/**
 ******************************************************************************
 * PROJECT:  HOB Encryption library
 *
 * This file provides the complete 'unicrypt'-library in one file only.
 *
 * Comment:
 * You can use the single 'hob*.c' sources needed, or you can use this single
 * file only. This file is built by running the Ruby-script 'xs-encr-1.rb'.
 * Even you are using this complete library file, you can control the compilation
 * by different defines. If you don't set any definitions the whole library is
 * compiled. If any other preprocessor definition are set, only these ares used.
 *
 * Required programs:
 * MS Visual Studio .NET 2005
 * MS Linker
 *
 * Copyright (C) HOB Germany 2005 - 2011
 *
 * @version 1.01
 * @author  Gerhard Oed, Juergen-Lorenz Lauenstein (script)
 * @date    Thu Oct 25 09:35:54 2012  (creation)
 *
 * Defines:
 * HL_ENCR_AES   AES is compiled
 * HL_ENCR_MD    MD2, MD4 and MD5 are compiled
 * HL_ENCR_SHA   SHA1 and SHA2 are compiled
 * HL_ENCR_DES   DES is compiled
 * HL_ENCR_RC    RC2 and RC4 are compiled
 * HL_ENCR_RSA   RSA is compiled
 * HL_ENCR_HMAC  HMAC is compiled
 * HL_ENCR_DSA   DSA is compiled
 * HL_ENCR_RAND  RAND is compiled
 * HL_ENCR_LNUM  LNUM is compiled
*/
#if !defined HL_ENCR_AES && !defined HL_ENCR_MD && !defined HL_ENCR_SHA && !defined HL_ENCR_DES && !defined HL_ENCR_RC && !defined HL_ENCR_RSA && !defined HL_ENCR_HMAC && !defined HL_ENCR_DSA && !defined HL_ENCR_RAND && !defined HL_ENCR_LNUM
 #define HL_ENCR_AES
 #define HL_ENCR_MD
 #define HL_ENCR_SHA
 #define HL_ENCR_DES
 #define HL_ENCR_RC
 #define HL_ENCR_RSA
 #define HL_ENCR_HMAC
 #define HL_ENCR_DSA
 #define HL_ENCR_RAND
 #define HL_ENCR_LNUM
 #endif

#if defined WIN32 || defined WIN64
 #include <windows.h>
#endif


#ifdef HL_ENCR_AES
// hobaes.c
//==========================================================
//
// The AES Encryption Algorithm (Rijndael)
// As used for TLS/SSL only CBC/ECB Mode is implemented
// -- improved C-Version for WIN32 --
//
//==========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>


//#define DEBUG


//-------------------------------------------------
// Macros
//-------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (int) *((int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (int) *((int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);
#endif


#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#define long2char(l,c,i) c[i]   = (unsigned char) (l       & 0x0FF);\
                         c[i+1] = (unsigned char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (unsigned char) ((l>>16) & 0x0FF);\
                         c[i+3] = (unsigned char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (unsigned char) (l       & 0x0FF);\
                          c[i+1] = (unsigned char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (unsigned char) ((l>>16) & 0x0FF);\
                          c[i+3] = (unsigned char) ((l>>24) & 0x0FF);
#endif



//===================================================================
// Macros for the AES Round Functions
//===================================================================
#define	AES_ENC_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
  U = TabEncT0[(unsigned char) A] ^ \
      TabEncT1[(unsigned char) (B >> 8)] ^ \
      TabEncT2[(unsigned char) (C >> 16)] ^ \
      TabEncT3[(unsigned char) (D >> 24)] ^ \
      KeyTab[4+(N*4)];\
  V = TabEncT0[(unsigned char) B] ^ \
      TabEncT1[(unsigned char) (C >> 8)] ^ \
      TabEncT2[(unsigned char) (D >> 16)] ^ \
      TabEncT3[(unsigned char) (A >> 24)] ^ \
      KeyTab[4+(N*4)+1];\
  W = TabEncT0[(unsigned char) C] ^ \
      TabEncT1[(unsigned char) (D >> 8)] ^ \
      TabEncT2[(unsigned char) (A >> 16)] ^ \
      TabEncT3[(unsigned char) (B >> 24)] ^ \
      KeyTab[4+(N*4)+2];\
  X = TabEncT0[(unsigned char) D] ^ \
      TabEncT1[(unsigned char) (A >> 8)] ^ \
      TabEncT2[(unsigned char) (B >> 16)] ^ \
      TabEncT3[(unsigned char) (C >> 24)] ^ \
      KeyTab[4+(N*4)+3];

#define	AES_ENC_LAST_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
  U = ((unsigned int) SBox[(unsigned char) A] | \
      ((unsigned int) SBox[(unsigned char) (B >> 8)]  <<  8) | \
      ((unsigned int) SBox[(unsigned char) (C >> 16)] << 16) | \
      ((unsigned int) SBox[(unsigned char) (D >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)]; \
  V = ((unsigned int) SBox[(unsigned char) B] | \
      ((unsigned int) SBox[(unsigned char) (C >> 8)]  <<  8) | \
      ((unsigned int) SBox[(unsigned char) (D >> 16)] << 16) | \
      ((unsigned int) SBox[(unsigned char) (A >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+1]; \
  W = ((unsigned int) SBox[(unsigned char) C] | \
      ((unsigned int) SBox[(unsigned char) (D >> 8)]  <<  8) | \
      ((unsigned int) SBox[(unsigned char) (A >> 16)] << 16) | \
      ((unsigned int) SBox[(unsigned char) (B >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+2]; \
  X = ((unsigned int) SBox[(unsigned char) D] | \
      ((unsigned int) SBox[(unsigned char) (A >> 8)]  <<  8) | \
      ((unsigned int) SBox[(unsigned char) (B >> 16)] << 16) | \
      ((unsigned int) SBox[(unsigned char) (C >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+3];

#define AES_DEC_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
  U = TabDecT0[(unsigned char) A] ^ \
      TabDecT1[(unsigned char) (D >> 8)] ^ \
      TabDecT2[(unsigned char) (C >> 16)] ^ \
      TabDecT3[(unsigned char) (B >> 24)] ^ \
      KeyTab[4+(N*4)]; \
  V = TabDecT0[(unsigned char) B] ^ \
      TabDecT1[(unsigned char) (A >> 8)] ^ \
      TabDecT2[(unsigned char) (D >> 16)] ^ \
      TabDecT3[(unsigned char) (C >> 24)] ^ \
      KeyTab[4+(N*4)+1]; \
  W = TabDecT0[(unsigned char) C] ^ \
      TabDecT1[(unsigned char) (B >> 8)] ^ \
      TabDecT2[(unsigned char) (A >> 16)] ^ \
      TabDecT3[(unsigned char) (D >> 24)] ^ \
      KeyTab[4+(N*4)+2];\
  X = TabDecT0[(unsigned char) D] ^ \
      TabDecT1[(unsigned char) (C >> 8)] ^ \
      TabDecT2[(unsigned char) (B >> 16)] ^ \
      TabDecT3[(unsigned char) (A >> 24)] ^ \
      KeyTab[4+(N*4)+3];

#define	AES_DEC_LAST_ROUND(U,V,W,X,A,B,C,D,KeyTab,N) \
  U = ((unsigned int) InvSBox[(unsigned char) A] | \
      ((unsigned int) InvSBox[(unsigned char) (D >>  8)] <<  8) | \
      ((unsigned int) InvSBox[(unsigned char) (C >> 16)] << 16) | \
      ((unsigned int) InvSBox[(unsigned char) (B >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)]; \
  V = ((unsigned int) InvSBox[(unsigned char) B] | \
      ((unsigned int) InvSBox[(unsigned char) (A >>  8)] <<  8) | \
      ((unsigned int) InvSBox[(unsigned char) (D >> 16)] << 16) | \
      ((unsigned int) InvSBox[(unsigned char) (C >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+1]; \
  W = ((unsigned int) InvSBox[(unsigned char) C] | \
      ((unsigned int) InvSBox[(unsigned char) (B >>  8)] <<  8) | \
      ((unsigned int) InvSBox[(unsigned char) (A >> 16)] << 16) | \
      ((unsigned int) InvSBox[(unsigned char) (D >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+2]; \
  X = ((unsigned int) InvSBox[(unsigned char) D] | \
      ((unsigned int) InvSBox[(unsigned char) (C >>  8)] <<  8) | \
      ((unsigned int) InvSBox[(unsigned char) (B >> 16)] << 16) | \
      ((unsigned int) InvSBox[(unsigned char) (A >> 24)] << 24)) ^ \
      KeyTab[4+(N*4)+3];

//--------------------------------------------------------------
// AES S-Box used for Encryption
//--------------------------------------------------------------
static unsigned char SBox[256] = {
  0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 	// 00-07
  0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 	// 08-0F
  0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 	// 10-17
  0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,	// 18-1F
  0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 	// 20-27
  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 	// 28-2F
  0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,  	// 30-37
  0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 	// 38-3F
  0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 	// 40-47
  0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 	// 48-4F
  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 	// 50-57
  0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 	// 58-5F
  0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 	// 60-67
  0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 	// 68-6F
  0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 	// 70-77
  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 	// 78-7F
  0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 	// 80-87
  0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 	// 88-8F
  0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 	// 90-97
  0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 	// 98-9F
  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 	// A0-A7
  0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 	// A8-AF
  0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 	// B0-B7
  0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 	// B8-BF
  0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 	// C0-C7
  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 	// C8-CF
  0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 	// D0-D7
  0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 	// D8-DF
  0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 	// E0-E7
  0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 	// E8-EF
  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 	// F0-F7
  0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, 	// F8-FF
};
//--------------------------------------------------------------
// AES S-Box used for Decryption
//--------------------------------------------------------------
static unsigned char InvSBox[256] = {
  0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,	// 00-07
  0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 	// 08-0F
  0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 	// 10-17
  0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 	// 18-1F
  0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 	// 20-27
  0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 	// 28-2F
  0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 	// 30-37
  0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 	// 38-3F
  0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 	// 40-47
  0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 	// 48-4F
  0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 	// 50-57
  0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 	// 58-5F
  0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 	// 60-67
  0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 	// 68-6F
  0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 	// 70-77
  0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 	// 78-7F
  0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 	// 80-87
  0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 	// 88-8F
  0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 	// 90-97
  0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 	// 98-9F
  0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 	// A0-A7
  0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 	// A8-AF
  0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 	// B0-B7
  0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 	// B8-BF
  0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 	// C0-C7
  0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 	// C8-CF
  0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 	// D0-D7
  0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 	// D8-DF
  0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 	// E0-E7
  0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 	// E8-EF
  0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 	// F0-F7
  0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, 	// F8-FF
};
//------------------------------------------------------
// Encryption Table T0
//------------------------------------------------------
unsigned int TabEncT0[256] = {
  0xA56363C6, 0x847C7CF8, 0x997777EE, 0x8D7B7BF6, 	// 00-03
  0x0DF2F2FF, 0xBD6B6BD6, 0xB16F6FDE, 0x54C5C591, 	// 04-07
  0x50303060, 0x03010102, 0xA96767CE, 0x7D2B2B56, 	// 08-0B
  0x19FEFEE7, 0x62D7D7B5, 0xE6ABAB4D, 0x9A7676EC, 	// 0C-0F

  0x45CACA8F, 0x9D82821F, 0x40C9C989, 0x877D7DFA, 	// 10-13
  0x15FAFAEF, 0xEB5959B2, 0xC947478E, 0x0BF0F0FB, 	// 14-17
  0xECADAD41, 0x67D4D4B3, 0xFDA2A25F, 0xEAAFAF45, 	// 18-1B
  0xBF9C9C23, 0xF7A4A453, 0x967272E4, 0x5BC0C09B, 	// 1C-1F

  0xC2B7B775, 0x1CFDFDE1, 0xAE93933D, 0x6A26264C, 	// 20-23
  0x5A36366C, 0x413F3F7E, 0x02F7F7F5, 0x4FCCCC83, 	// 24-27
  0x5C343468, 0xF4A5A551, 0x34E5E5D1, 0x08F1F1F9, 	// 28-2B
  0x937171E2, 0x73D8D8AB, 0x53313162, 0x3F15152A, 	// 2C-2F

  0x0C040408, 0x52C7C795, 0x65232346, 0x5EC3C39D, 	// 30-33
  0x28181830, 0xA1969637, 0x0F05050A, 0xB59A9A2F, 	// 34-37
  0x0907070E, 0x36121224, 0x9B80801B, 0x3DE2E2DF, 	// 38-3B
  0x26EBEBCD, 0x6927274E, 0xCDB2B27F, 0x9F7575EA, 	// 3C-3F

  0x1B090912, 0x9E83831D, 0x742C2C58, 0x2E1A1A34, 	// 40-43
  0x2D1B1B36, 0xB26E6EDC, 0xEE5A5AB4, 0xFBA0A05B, 	// 44-47
  0xF65252A4, 0x4D3B3B76, 0x61D6D6B7, 0xCEB3B37D, 	// 48-4B
  0x7B292952, 0x3EE3E3DD, 0x712F2F5E, 0x97848413, 	// 4C-4F

  0xF55353A6, 0x68D1D1B9, 0x00000000, 0x2CEDEDC1, 	// 50-53
  0x60202040, 0x1FFCFCE3, 0xC8B1B179, 0xED5B5BB6, 	// 54-57
  0xBE6A6AD4, 0x46CBCB8D, 0xD9BEBE67, 0x4B393972, 	// 58-5B
  0xDE4A4A94, 0xD44C4C98, 0xE85858B0, 0x4ACFCF85, 	// 5C-5F

  0x6BD0D0BB, 0x2AEFEFC5, 0xE5AAAA4F, 0x16FBFBED, 	// 60-63
  0xC5434386, 0xD74D4D9A, 0x55333366, 0x94858511, 	// 64-67
  0xCF45458A, 0x10F9F9E9, 0x06020204, 0x817F7FFE, 	// 68-6B
  0xF05050A0, 0x443C3C78, 0xBA9F9F25, 0xE3A8A84B, 	// 6C-6F

  0xF35151A2, 0xFEA3A35D, 0xC0404080, 0x8A8F8F05, 	// 70-73
  0xAD92923F, 0xBC9D9D21, 0x48383870, 0x04F5F5F1, 	// 74-77
  0xDFBCBC63, 0xC1B6B677, 0x75DADAAF, 0x63212142, 	// 78-7B
  0x30101020, 0x1AFFFFE5, 0x0EF3F3FD, 0x6DD2D2BF, 	// 7C-7F

  0x4CCDCD81, 0x140C0C18, 0x35131326, 0x2FECECC3, 	// 80-83
  0xE15F5FBE, 0xA2979735, 0xCC444488, 0x3917172E, 	// 84-87
  0x57C4C493, 0xF2A7A755, 0x827E7EFC, 0x473D3D7A, 	// 88-8B
  0xAC6464C8, 0xE75D5DBA, 0x2B191932, 0x957373E6, 	// 8C-8F

  0xA06060C0, 0x98818119, 0xD14F4F9E, 0x7FDCDCA3, 	// 90-93
  0x66222244, 0x7E2A2A54, 0xAB90903B, 0x8388880B, 	// 94-97
  0xCA46468C, 0x29EEEEC7, 0xD3B8B86B, 0x3C141428, 	// 98-9B
  0x79DEDEA7, 0xE25E5EBC, 0x1D0B0B16, 0x76DBDBAD, 	// 9C-9F

  0x3BE0E0DB, 0x56323264, 0x4E3A3A74, 0x1E0A0A14, 	// A0-A3
  0xDB494992, 0x0A06060C, 0x6C242448, 0xE45C5CB8, 	// A4-A7
  0x5DC2C29F, 0x6ED3D3BD, 0xEFACAC43, 0xA66262C4, 	// A8-AB
  0xA8919139, 0xA4959531, 0x37E4E4D3, 0x8B7979F2, 	// AC-AF

  0x32E7E7D5, 0x43C8C88B, 0x5937376E, 0xB76D6DDA, 	// B0-B3
  0x8C8D8D01, 0x64D5D5B1, 0xD24E4E9C, 0xE0A9A949, 	// B4-B7
  0xB46C6CD8, 0xFA5656AC, 0x07F4F4F3, 0x25EAEACF, 	// B8-BB
  0xAF6565CA, 0x8E7A7AF4, 0xE9AEAE47, 0x18080810, 	// BC-BF

  0xD5BABA6F, 0x887878F0, 0x6F25254A, 0x722E2E5C, 	// C0-C3
  0x241C1C38, 0xF1A6A657, 0xC7B4B473, 0x51C6C697, 	// C4-C7
  0x23E8E8CB, 0x7CDDDDA1, 0x9C7474E8, 0x211F1F3E, 	// C8-CB
  0xDD4B4B96, 0xDCBDBD61, 0x868B8B0D, 0x858A8A0F, 	// CC-CF

  0x907070E0, 0x423E3E7C, 0xC4B5B571, 0xAA6666CC, 	// D0-D3
  0xD8484890, 0x05030306, 0x01F6F6F7, 0x120E0E1C, 	// D4-D7
  0xA36161C2, 0x5F35356A, 0xF95757AE, 0xD0B9B969, 	// D8-DB
  0x91868617, 0x58C1C199, 0x271D1D3A, 0xB99E9E27, 	// DC-DF

  0x38E1E1D9, 0x13F8F8EB, 0xB398982B, 0x33111122, 	// E0-E3
  0xBB6969D2, 0x70D9D9A9, 0x898E8E07, 0xA7949433, 	// E4-E7
  0xB69B9B2D, 0x221E1E3C, 0x92878715, 0x20E9E9C9, 	// E8-EB
  0x49CECE87, 0xFF5555AA, 0x78282850, 0x7ADFDFA5, 	// EC-EF

  0x8F8C8C03, 0xF8A1A159, 0x80898909, 0x170D0D1A, 	// F0-F3
  0xDABFBF65, 0x31E6E6D7, 0xC6424284, 0xB86868D0, 	// F4-F7
  0xC3414182, 0xB0999929, 0x772D2D5A, 0x110F0F1E, 	// F8-FB
  0xCBB0B07B, 0xFC5454A8, 0xD6BBBB6D, 0x3A16162C, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T1
//------------------------------------------------------
unsigned int TabEncT1[256] = {
  0x6363C6A5, 0x7C7CF884, 0x7777EE99, 0x7B7BF68D, 	// 00-03
  0xF2F2FF0D, 0x6B6BD6BD, 0x6F6FDEB1, 0xC5C59154, 	// 04-07
  0x30306050, 0x01010203, 0x6767CEA9, 0x2B2B567D, 	// 08-0B
  0xFEFEE719, 0xD7D7B562, 0xABAB4DE6, 0x7676EC9A, 	// 0C-0F

  0xCACA8F45, 0x82821F9D, 0xC9C98940, 0x7D7DFA87, 	// 10-13
  0xFAFAEF15, 0x5959B2EB, 0x47478EC9, 0xF0F0FB0B, 	// 14-17
  0xADAD41EC, 0xD4D4B367, 0xA2A25FFD, 0xAFAF45EA, 	// 18-1B
  0x9C9C23BF, 0xA4A453F7, 0x7272E496, 0xC0C09B5B, 	// 1C-1F

  0xB7B775C2, 0xFDFDE11C, 0x93933DAE, 0x26264C6A, 	// 20-23
  0x36366C5A, 0x3F3F7E41, 0xF7F7F502, 0xCCCC834F, 	// 24-27
  0x3434685C, 0xA5A551F4, 0xE5E5D134, 0xF1F1F908, 	// 28-2B
  0x7171E293, 0xD8D8AB73, 0x31316253, 0x15152A3F, 	// 2C-2F

  0x0404080C, 0xC7C79552, 0x23234665, 0xC3C39D5E, 	// 30-33
  0x18183028, 0x969637A1, 0x05050A0F, 0x9A9A2FB5, 	// 34-37
  0x07070E09, 0x12122436, 0x80801B9B, 0xE2E2DF3D, 	// 38-3B
  0xEBEBCD26, 0x27274E69, 0xB2B27FCD, 0x7575EA9F, 	// 3C-3F

  0x0909121B, 0x83831D9E, 0x2C2C5874, 0x1A1A342E, 	// 40-43
  0x1B1B362D, 0x6E6EDCB2, 0x5A5AB4EE, 0xA0A05BFB, 	// 44-47
  0x5252A4F6, 0x3B3B764D, 0xD6D6B761, 0xB3B37DCE, 	// 48-4B
  0x2929527B, 0xE3E3DD3E, 0x2F2F5E71, 0x84841397, 	// 4C-4F

  0x5353A6F5, 0xD1D1B968, 0x00000000, 0xEDEDC12C, 	// 50-53
  0x20204060, 0xFCFCE31F, 0xB1B179C8, 0x5B5BB6ED, 	// 54-57
  0x6A6AD4BE, 0xCBCB8D46, 0xBEBE67D9, 0x3939724B, 	// 58-5B
  0x4A4A94DE, 0x4C4C98D4, 0x5858B0E8, 0xCFCF854A, 	// 5C-5F

  0xD0D0BB6B, 0xEFEFC52A, 0xAAAA4FE5, 0xFBFBED16, 	// 60-63
  0x434386C5, 0x4D4D9AD7, 0x33336655, 0x85851194, 	// 64-67
  0x45458ACF, 0xF9F9E910, 0x02020406, 0x7F7FFE81, 	// 68-6B
  0x5050A0F0, 0x3C3C7844, 0x9F9F25BA, 0xA8A84BE3, 	// 6C-6F

  0x5151A2F3, 0xA3A35DFE, 0x404080C0, 0x8F8F058A, 	// 70-73
  0x92923FAD, 0x9D9D21BC, 0x38387048, 0xF5F5F104, 	// 74-77
  0xBCBC63DF, 0xB6B677C1, 0xDADAAF75, 0x21214263, 	// 78-7B
  0x10102030, 0xFFFFE51A, 0xF3F3FD0E, 0xD2D2BF6D, 	// 7C-7F

  0xCDCD814C, 0x0C0C1814, 0x13132635, 0xECECC32F, 	// 80-83
  0x5F5FBEE1, 0x979735A2, 0x444488CC, 0x17172E39, 	// 84-87
  0xC4C49357, 0xA7A755F2, 0x7E7EFC82, 0x3D3D7A47, 	// 88-8B
  0x6464C8AC, 0x5D5DBAE7, 0x1919322B, 0x7373E695, 	// 8C-8F

  0x6060C0A0, 0x81811998, 0x4F4F9ED1, 0xDCDCA37F, 	// 90-93
  0x22224466, 0x2A2A547E, 0x90903BAB, 0x88880B83, 	// 94-97
  0x46468CCA, 0xEEEEC729, 0xB8B86BD3, 0x1414283C, 	// 98-9B
  0xDEDEA779, 0x5E5EBCE2, 0x0B0B161D, 0xDBDBAD76, 	// 9C-9F

  0xE0E0DB3B, 0x32326456, 0x3A3A744E, 0x0A0A141E, 	// A0-A3
  0x494992DB, 0x06060C0A, 0x2424486C, 0x5C5CB8E4, 	// A4-A7
  0xC2C29F5D, 0xD3D3BD6E, 0xACAC43EF, 0x6262C4A6, 	// A8-AB
  0x919139A8, 0x959531A4, 0xE4E4D337, 0x7979F28B, 	// AC-AF

  0xE7E7D532, 0xC8C88B43, 0x37376E59, 0x6D6DDAB7, 	// B0-B3
  0x8D8D018C, 0xD5D5B164, 0x4E4E9CD2, 0xA9A949E0, 	// B4-B7
  0x6C6CD8B4, 0x5656ACFA, 0xF4F4F307, 0xEAEACF25, 	// B8-BB
  0x6565CAAF, 0x7A7AF48E, 0xAEAE47E9, 0x08081018, 	// BC-BF

  0xBABA6FD5, 0x7878F088, 0x25254A6F, 0x2E2E5C72, 	// C0-C3
  0x1C1C3824, 0xA6A657F1, 0xB4B473C7, 0xC6C69751, 	// C4-C7
  0xE8E8CB23, 0xDDDDA17C, 0x7474E89C, 0x1F1F3E21, 	// C8-CB
  0x4B4B96DD, 0xBDBD61DC, 0x8B8B0D86, 0x8A8A0F85, 	// CC-CF

  0x7070E090, 0x3E3E7C42, 0xB5B571C4, 0x6666CCAA, 	// D0-D3
  0x484890D8, 0x03030605, 0xF6F6F701, 0x0E0E1C12, 	// D4-D7
  0x6161C2A3, 0x35356A5F, 0x5757AEF9, 0xB9B969D0, 	// D8-DB
  0x86861791, 0xC1C19958, 0x1D1D3A27, 0x9E9E27B9, 	// DC-DF

  0xE1E1D938, 0xF8F8EB13, 0x98982BB3, 0x11112233, 	// E0-E3
  0x6969D2BB, 0xD9D9A970, 0x8E8E0789, 0x949433A7, 	// E4-E7
  0x9B9B2DB6, 0x1E1E3C22, 0x87871592, 0xE9E9C920, 	// E8-EB
  0xCECE8749, 0x5555AAFF, 0x28285078, 0xDFDFA57A, 	// EC-EF

  0x8C8C038F, 0xA1A159F8, 0x89890980, 0x0D0D1A17, 	// F0-F3
  0xBFBF65DA, 0xE6E6D731, 0x424284C6, 0x6868D0B8, 	// F4-F7
  0x414182C3, 0x999929B0, 0x2D2D5A77, 0x0F0F1E11, 	// F8-FB
  0xB0B07BCB, 0x5454A8FC, 0xBBBB6DD6, 0x16162C3A, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T2
//------------------------------------------------------
unsigned int TabEncT2[256] = {
  0x63C6A563, 0x7CF8847C, 0x77EE9977, 0x7BF68D7B, 	// 00-03
  0xF2FF0DF2, 0x6BD6BD6B, 0x6FDEB16F, 0xC59154C5, 	// 04-07
  0x30605030, 0x01020301, 0x67CEA967, 0x2B567D2B, 	// 08-0B
  0xFEE719FE, 0xD7B562D7, 0xAB4DE6AB, 0x76EC9A76, 	// 0C-0F

  0xCA8F45CA, 0x821F9D82, 0xC98940C9, 0x7DFA877D, 	// 10-13
  0xFAEF15FA, 0x59B2EB59, 0x478EC947, 0xF0FB0BF0, 	// 14-17
  0xAD41ECAD, 0xD4B367D4, 0xA25FFDA2, 0xAF45EAAF, 	// 18-1B
  0x9C23BF9C, 0xA453F7A4, 0x72E49672, 0xC09B5BC0, 	// 1C-1F

  0xB775C2B7, 0xFDE11CFD, 0x933DAE93, 0x264C6A26, 	// 20-23
  0x366C5A36, 0x3F7E413F, 0xF7F502F7, 0xCC834FCC, 	// 24-27
  0x34685C34, 0xA551F4A5, 0xE5D134E5, 0xF1F908F1, 	// 28-2B
  0x71E29371, 0xD8AB73D8, 0x31625331, 0x152A3F15, 	// 2C-2F

  0x04080C04, 0xC79552C7, 0x23466523, 0xC39D5EC3, 	// 30-33
  0x18302818, 0x9637A196, 0x050A0F05, 0x9A2FB59A, 	// 34-37
  0x070E0907, 0x12243612, 0x801B9B80, 0xE2DF3DE2, 	// 38-3B
  0xEBCD26EB, 0x274E6927, 0xB27FCDB2, 0x75EA9F75, 	// 3C-3F

  0x09121B09, 0x831D9E83, 0x2C58742C, 0x1A342E1A, 	// 40-43
  0x1B362D1B, 0x6EDCB26E, 0x5AB4EE5A, 0xA05BFBA0, 	// 44-47
  0x52A4F652, 0x3B764D3B, 0xD6B761D6, 0xB37DCEB3, 	// 48-4B
  0x29527B29, 0xE3DD3EE3, 0x2F5E712F, 0x84139784, 	// 4C-4F

  0x53A6F553, 0xD1B968D1, 0x00000000, 0xEDC12CED, 	// 50-53
  0x20406020, 0xFCE31FFC, 0xB179C8B1, 0x5BB6ED5B, 	// 54-57
  0x6AD4BE6A, 0xCB8D46CB, 0xBE67D9BE, 0x39724B39, 	// 58-5B
  0x4A94DE4A, 0x4C98D44C, 0x58B0E858, 0xCF854ACF, 	// 5C-5F

  0xD0BB6BD0, 0xEFC52AEF, 0xAA4FE5AA, 0xFBED16FB, 	// 60-63
  0x4386C543, 0x4D9AD74D, 0x33665533, 0x85119485, 	// 64-67
  0x458ACF45, 0xF9E910F9, 0x02040602, 0x7FFE817F, 	// 68-6B
  0x50A0F050, 0x3C78443C, 0x9F25BA9F, 0xA84BE3A8, 	// 6C-6F

  0x51A2F351, 0xA35DFEA3, 0x4080C040, 0x8F058A8F, 	// 70-73
  0x923FAD92, 0x9D21BC9D, 0x38704838, 0xF5F104F5, 	// 74-77
  0xBC63DFBC, 0xB677C1B6, 0xDAAF75DA, 0x21426321, 	// 78-7B
  0x10203010, 0xFFE51AFF, 0xF3FD0EF3, 0xD2BF6DD2, 	// 7C-7F

  0xCD814CCD, 0x0C18140C, 0x13263513, 0xECC32FEC, 	// 80-83
  0x5FBEE15F, 0x9735A297, 0x4488CC44, 0x172E3917, 	// 84-87
  0xC49357C4, 0xA755F2A7, 0x7EFC827E, 0x3D7A473D, 	// 88-8B
  0x64C8AC64, 0x5DBAE75D, 0x19322B19, 0x73E69573, 	// 8C-8F

  0x60C0A060, 0x81199881, 0x4F9ED14F, 0xDCA37FDC, 	// 90-93
  0x22446622, 0x2A547E2A, 0x903BAB90, 0x880B8388, 	// 94-97
  0x468CCA46, 0xEEC729EE, 0xB86BD3B8, 0x14283C14, 	// 98-9B
  0xDEA779DE, 0x5EBCE25E, 0x0B161D0B, 0xDBAD76DB, 	// 9C-9F

  0xE0DB3BE0, 0x32645632, 0x3A744E3A, 0x0A141E0A, 	// A0-A3
  0x4992DB49, 0x060C0A06, 0x24486C24, 0x5CB8E45C, 	// A4-A7
  0xC29F5DC2, 0xD3BD6ED3, 0xAC43EFAC, 0x62C4A662, 	// A8-AB
  0x9139A891, 0x9531A495, 0xE4D337E4, 0x79F28B79, 	// AC-AF

  0xE7D532E7, 0xC88B43C8, 0x376E5937, 0x6DDAB76D, 	// B0-B3
  0x8D018C8D, 0xD5B164D5, 0x4E9CD24E, 0xA949E0A9, 	// B4-B7
  0x6CD8B46C, 0x56ACFA56, 0xF4F307F4, 0xEACF25EA, 	// B8-BB
  0x65CAAF65, 0x7AF48E7A, 0xAE47E9AE, 0x08101808, 	// BC-BF

  0xBA6FD5BA, 0x78F08878, 0x254A6F25, 0x2E5C722E, 	// C0-C3
  0x1C38241C, 0xA657F1A6, 0xB473C7B4, 0xC69751C6, 	// C4-C7
  0xE8CB23E8, 0xDDA17CDD, 0x74E89C74, 0x1F3E211F, 	// C8-CB
  0x4B96DD4B, 0xBD61DCBD, 0x8B0D868B, 0x8A0F858A, 	// CC-CF

  0x70E09070, 0x3E7C423E, 0xB571C4B5, 0x66CCAA66, 	// D0-D3
  0x4890D848, 0x03060503, 0xF6F701F6, 0x0E1C120E, 	// D4-D7
  0x61C2A361, 0x356A5F35, 0x57AEF957, 0xB969D0B9, 	// D8-DB
  0x86179186, 0xC19958C1, 0x1D3A271D, 0x9E27B99E, 	// DC-DF

  0xE1D938E1, 0xF8EB13F8, 0x982BB398, 0x11223311, 	// E0-E3
  0x69D2BB69, 0xD9A970D9, 0x8E07898E, 0x9433A794, 	// E4-E7
  0x9B2DB69B, 0x1E3C221E, 0x87159287, 0xE9C920E9, 	// E8-EB
  0xCE8749CE, 0x55AAFF55, 0x28507828, 0xDFA57ADF, 	// EC-EF

  0x8C038F8C, 0xA159F8A1, 0x89098089, 0x0D1A170D, 	// F0-F3
  0xBF65DABF, 0xE6D731E6, 0x4284C642, 0x68D0B868, 	// F4-F7
  0x4182C341, 0x9929B099, 0x2D5A772D, 0x0F1E110F, 	// F8-FB
  0xB07BCBB0, 0x54A8FC54, 0xBB6DD6BB, 0x162C3A16, 	// FC-FF
};
//------------------------------------------------------
// Encryption Table T3
//------------------------------------------------------
unsigned int TabEncT3[256] = {
  0xC6A56363, 0xF8847C7C, 0xEE997777, 0xF68D7B7B, 	// 00-03
  0xFF0DF2F2, 0xD6BD6B6B, 0xDEB16F6F, 0x9154C5C5, 	// 04-07
  0x60503030, 0x02030101, 0xCEA96767, 0x567D2B2B, 	// 08-0B
  0xE719FEFE, 0xB562D7D7, 0x4DE6ABAB, 0xEC9A7676, 	// 0C-0F

  0x8F45CACA, 0x1F9D8282, 0x8940C9C9, 0xFA877D7D, 	// 10-13
  0xEF15FAFA, 0xB2EB5959, 0x8EC94747, 0xFB0BF0F0, 	// 14-17
  0x41ECADAD, 0xB367D4D4, 0x5FFDA2A2, 0x45EAAFAF, 	// 18-1B
  0x23BF9C9C, 0x53F7A4A4, 0xE4967272, 0x9B5BC0C0, 	// 1C-1F

  0x75C2B7B7, 0xE11CFDFD, 0x3DAE9393, 0x4C6A2626, 	// 20-23
  0x6C5A3636, 0x7E413F3F, 0xF502F7F7, 0x834FCCCC, 	// 24-27
  0x685C3434, 0x51F4A5A5, 0xD134E5E5, 0xF908F1F1, 	// 28-2B
  0xE2937171, 0xAB73D8D8, 0x62533131, 0x2A3F1515, 	// 2C-2F

  0x080C0404, 0x9552C7C7, 0x46652323, 0x9D5EC3C3, 	// 30-33
  0x30281818, 0x37A19696, 0x0A0F0505, 0x2FB59A9A, 	// 34-37
  0x0E090707, 0x24361212, 0x1B9B8080, 0xDF3DE2E2, 	// 38-3B
  0xCD26EBEB, 0x4E692727, 0x7FCDB2B2, 0xEA9F7575, 	// 3C-3F

  0x121B0909, 0x1D9E8383, 0x58742C2C, 0x342E1A1A, 	// 40-43
  0x362D1B1B, 0xDCB26E6E, 0xB4EE5A5A, 0x5BFBA0A0, 	// 44-47
  0xA4F65252, 0x764D3B3B, 0xB761D6D6, 0x7DCEB3B3, 	// 48-4B
  0x527B2929, 0xDD3EE3E3, 0x5E712F2F, 0x13978484, 	// 4C-4F

  0xA6F55353, 0xB968D1D1, 0x00000000, 0xC12CEDED, 	// 50-53
  0x40602020, 0xE31FFCFC, 0x79C8B1B1, 0xB6ED5B5B, 	// 54-57
  0xD4BE6A6A, 0x8D46CBCB, 0x67D9BEBE, 0x724B3939, 	// 58-5B
  0x94DE4A4A, 0x98D44C4C, 0xB0E85858, 0x854ACFCF, 	// 5C-5F

  0xBB6BD0D0, 0xC52AEFEF, 0x4FE5AAAA, 0xED16FBFB, 	// 60-63
  0x86C54343, 0x9AD74D4D, 0x66553333, 0x11948585, 	// 64-67
  0x8ACF4545, 0xE910F9F9, 0x04060202, 0xFE817F7F, 	// 68-6B
  0xA0F05050, 0x78443C3C, 0x25BA9F9F, 0x4BE3A8A8, 	// 6C-6F

  0xA2F35151, 0x5DFEA3A3, 0x80C04040, 0x058A8F8F, 	// 70-73
  0x3FAD9292, 0x21BC9D9D, 0x70483838, 0xF104F5F5, 	// 74-77
  0x63DFBCBC, 0x77C1B6B6, 0xAF75DADA, 0x42632121, 	// 78-7B
  0x20301010, 0xE51AFFFF, 0xFD0EF3F3, 0xBF6DD2D2, 	// 7C-7F

  0x814CCDCD, 0x18140C0C, 0x26351313, 0xC32FECEC, 	// 80-83
  0xBEE15F5F, 0x35A29797, 0x88CC4444, 0x2E391717, 	// 84-87
  0x9357C4C4, 0x55F2A7A7, 0xFC827E7E, 0x7A473D3D, 	// 88-8B
  0xC8AC6464, 0xBAE75D5D, 0x322B1919, 0xE6957373, 	// 8C-8F

  0xC0A06060, 0x19988181, 0x9ED14F4F, 0xA37FDCDC, 	// 90-93
  0x44662222, 0x547E2A2A, 0x3BAB9090, 0x0B838888, 	// 94-97
  0x8CCA4646, 0xC729EEEE, 0x6BD3B8B8, 0x283C1414, 	// 98-9B
  0xA779DEDE, 0xBCE25E5E, 0x161D0B0B, 0xAD76DBDB, 	// 9C-9F

  0xDB3BE0E0, 0x64563232, 0x744E3A3A, 0x141E0A0A, 	// A0-A3
  0x92DB4949, 0x0C0A0606, 0x486C2424, 0xB8E45C5C, 	// A4-A7
  0x9F5DC2C2, 0xBD6ED3D3, 0x43EFACAC, 0xC4A66262, 	// A8-AB
  0x39A89191, 0x31A49595, 0xD337E4E4, 0xF28B7979, 	// AC-AF

  0xD532E7E7, 0x8B43C8C8, 0x6E593737, 0xDAB76D6D, 	// B0-B3
  0x018C8D8D, 0xB164D5D5, 0x9CD24E4E, 0x49E0A9A9, 	// B4-B7
  0xD8B46C6C, 0xACFA5656, 0xF307F4F4, 0xCF25EAEA, 	// B8-BB
  0xCAAF6565, 0xF48E7A7A, 0x47E9AEAE, 0x10180808, 	// BC-BF

  0x6FD5BABA, 0xF0887878, 0x4A6F2525, 0x5C722E2E, 	// C0-C3
  0x38241C1C, 0x57F1A6A6, 0x73C7B4B4, 0x9751C6C6, 	// C4-C7
  0xCB23E8E8, 0xA17CDDDD, 0xE89C7474, 0x3E211F1F, 	// C8-CB
  0x96DD4B4B, 0x61DCBDBD, 0x0D868B8B, 0x0F858A8A, 	// CC-CF

  0xE0907070, 0x7C423E3E, 0x71C4B5B5, 0xCCAA6666, 	// D0-D3
  0x90D84848, 0x06050303, 0xF701F6F6, 0x1C120E0E, 	// D4-D7
  0xC2A36161, 0x6A5F3535, 0xAEF95757, 0x69D0B9B9, 	// D8-DB
  0x17918686, 0x9958C1C1, 0x3A271D1D, 0x27B99E9E, 	// DC-DF

  0xD938E1E1, 0xEB13F8F8, 0x2BB39898, 0x22331111, 	// E0-E3
  0xD2BB6969, 0xA970D9D9, 0x07898E8E, 0x33A79494, 	// E4-E7
  0x2DB69B9B, 0x3C221E1E, 0x15928787, 0xC920E9E9, 	// E8-EB
  0x8749CECE, 0xAAFF5555, 0x50782828, 0xA57ADFDF, 	// EC-EF

  0x038F8C8C, 0x59F8A1A1, 0x09808989, 0x1A170D0D, 	// F0-F3
  0x65DABFBF, 0xD731E6E6, 0x84C64242, 0xD0B86868, 	// F4-F7
  0x82C34141, 0x29B09999, 0x5A772D2D, 0x1E110F0F, 	// F8-FB
  0x7BCBB0B0, 0xA8FC5454, 0x6DD6BBBB, 0x2C3A1616, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T0
//------------------------------------------------------
unsigned int TabDecT0[256] = {
  0x50A7F451, 0x5365417E, 0xC3A4171A, 0x965E273A, 	// 00-03
  0xCB6BAB3B, 0xF1459D1F, 0xAB58FAAC, 0x9303E34B, 	// 04-07
  0x55FA3020, 0xF66D76AD, 0x9176CC88, 0x254C02F5, 	// 08-0B
  0xFCD7E54F, 0xD7CB2AC5, 0x80443526, 0x8FA362B5, 	// 0C-0F

  0x495AB1DE, 0x671BBA25, 0x980EEA45, 0xE1C0FE5D, 	// 10-13
  0x02752FC3, 0x12F04C81, 0xA397468D, 0xC6F9D36B, 	// 14-17
  0xE75F8F03, 0x959C9215, 0xEB7A6DBF, 0xDA595295, 	// 18-1B
  0x2D83BED4, 0xD3217458, 0x2969E049, 0x44C8C98E, 	// 1C-1F

  0x6A89C275, 0x78798EF4, 0x6B3E5899, 0xDD71B927, 	// 20-23
  0xB64FE1BE, 0x17AD88F0, 0x66AC20C9, 0xB43ACE7D, 	// 24-27
  0x184ADF63, 0x82311AE5, 0x60335197, 0x457F5362, 	// 28-2B
  0xE07764B1, 0x84AE6BBB, 0x1CA081FE, 0x942B08F9, 	// 2C-2F

  0x58684870, 0x19FD458F, 0x876CDE94, 0xB7F87B52, 	// 30-33
  0x23D373AB, 0xE2024B72, 0x578F1FE3, 0x2AAB5566, 	// 34-37
  0x0728EBB2, 0x03C2B52F, 0x9A7BC586, 0xA50837D3, 	// 38-3B
  0xF2872830, 0xB2A5BF23, 0xBA6A0302, 0x5C8216ED, 	// 3C-3F

  0x2B1CCF8A, 0x92B479A7, 0xF0F207F3, 0xA1E2694E, 	// 40-43
  0xCDF4DA65, 0xD5BE0506, 0x1F6234D1, 0x8AFEA6C4, 	// 44-47
  0x9D532E34, 0xA055F3A2, 0x32E18A05, 0x75EBF6A4, 	// 48-4B
  0x39EC830B, 0xAAEF6040, 0x069F715E, 0x51106EBD, 	// 4C-4F

  0xF98A213E, 0x3D06DD96, 0xAE053EDD, 0x46BDE64D, 	// 50-53
  0xB58D5491, 0x055DC471, 0x6FD40604, 0xFF155060, 	// 54-57
  0x24FB9819, 0x97E9BDD6, 0xCC434089, 0x779ED967, 	// 58-5B
  0xBD42E8B0, 0x888B8907, 0x385B19E7, 0xDBEEC879, 	// 5C-5F

  0x470A7CA1, 0xE90F427C, 0xC91E84F8, 0x00000000, 	// 60-63
  0x83868009, 0x48ED2B32, 0xAC70111E, 0x4E725A6C, 	// 64-67
  0xFBFF0EFD, 0x5638850F, 0x1ED5AE3D, 0x27392D36, 	// 68-6B
  0x64D90F0A, 0x21A65C68, 0xD1545B9B, 0x3A2E3624, 	// 6C-6F

  0xB1670A0C, 0x0FE75793, 0xD296EEB4, 0x9E919B1B, 	// 70-73
  0x4FC5C080, 0xA220DC61, 0x694B775A, 0x161A121C, 	// 74-77
  0x0ABA93E2, 0xE52AA0C0, 0x43E0223C, 0x1D171B12, 	// 78-7B
  0x0B0D090E, 0xADC78BF2, 0xB9A8B62D, 0xC8A91E14, 	// 7C-7F

  0x8519F157, 0x4C0775AF, 0xBBDD99EE, 0xFD607FA3, 	// 80-83
  0x9F2601F7, 0xBCF5725C, 0xC53B6644, 0x347EFB5B, 	// 84-87
  0x7629438B, 0xDCC623CB, 0x68FCEDB6, 0x63F1E4B8, 	// 88-8B
  0xCADC31D7, 0x10856342, 0x40229713, 0x2011C684, 	// 8C-8F

  0x7D244A85, 0xF83DBBD2, 0x1132F9AE, 0x6DA129C7, 	// 90-93
  0x4B2F9E1D, 0xF330B2DC, 0xEC52860D, 0xD0E3C177, 	// 94-97
  0x6C16B32B, 0x99B970A9, 0xFA489411, 0x2264E947, 	// 98-9B
  0xC48CFCA8, 0x1A3FF0A0, 0xD82C7D56, 0xEF903322, 	// 9C-9F

  0xC74E4987, 0xC1D138D9, 0xFEA2CA8C, 0x360BD498, 	// A0-A3
  0xCF81F5A6, 0x28DE7AA5, 0x268EB7DA, 0xA4BFAD3F, 	// A4-A7
  0xE49D3A2C, 0x0D927850, 0x9BCC5F6A, 0x62467E54, 	// A8-AB
  0xC2138DF6, 0xE8B8D890, 0x5EF7392E, 0xF5AFC382, 	// AC-AF

  0xBE805D9F, 0x7C93D069, 0xA92DD56F, 0xB31225CF, 	// B0-B3
  0x3B99ACC8, 0xA77D1810, 0x6E639CE8, 0x7BBB3BDB, 	// B4-B7
  0x097826CD, 0xF418596E, 0x01B79AEC, 0xA89A4F83, 	// B8-BB
  0x656E95E6, 0x7EE6FFAA, 0x08CFBC21, 0xE6E815EF, 	// BC-BF

  0xD99BE7BA, 0xCE366F4A, 0xD4099FEA, 0xD67CB029, 	// C0-C3
  0xAFB2A431, 0x31233F2A, 0x3094A5C6, 0xC066A235, 	// C4-C7
  0x37BC4E74, 0xA6CA82FC, 0xB0D090E0, 0x15D8A733, 	// C8-CB
  0x4A9804F1, 0xF7DAEC41, 0x0E50CD7F, 0x2FF69117, 	// CC-CF

  0x8DD64D76, 0x4DB0EF43, 0x544DAACC, 0xDF0496E4, 	// D0-D3
  0xE3B5D19E, 0x1B886A4C, 0xB81F2CC1, 0x7F516546, 	// D4-D7
  0x04EA5E9D, 0x5D358C01, 0x737487FA, 0x2E410BFB, 	// D8-DB
  0x5A1D67B3, 0x52D2DB92, 0x335610E9, 0x1347D66D, 	// DC-DF

  0x8C61D79A, 0x7A0CA137, 0x8E14F859, 0x893C13EB, 	// E0-E3
  0xEE27A9CE, 0x35C961B7, 0xEDE51CE1, 0x3CB1477A, 	// E4-E7
  0x59DFD29C, 0x3F73F255, 0x79CE1418, 0xBF37C773, 	// E8-EB
  0xEACDF753, 0x5BAAFD5F, 0x146F3DDF, 0x86DB4478, 	// EC-EF

  0x81F3AFCA, 0x3EC468B9, 0x2C342438, 0x5F40A3C2, 	// F0-F3
  0x72C31D16, 0x0C25E2BC, 0x8B493C28, 0x41950DFF, 	// F4-F7
  0x7101A839, 0xDEB30C08, 0x9CE4B4D8, 0x90C15664, 	// F8-FB
  0x6184CB7B, 0x70B632D5, 0x745C6C48, 0x4257B8D0, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T1
//------------------------------------------------------
unsigned int TabDecT1[256] = {
  0xA7F45150, 0x65417E53, 0xA4171AC3, 0x5E273A96, 	// 00-03
  0x6BAB3BCB, 0x459D1FF1, 0x58FAACAB, 0x03E34B93, 	// 04-07
  0xFA302055, 0x6D76ADF6, 0x76CC8891, 0x4C02F525, 	// 08-0B
  0xD7E54FFC, 0xCB2AC5D7, 0x44352680, 0xA362B58F, 	// 0C-0F

  0x5AB1DE49, 0x1BBA2567, 0x0EEA4598, 0xC0FE5DE1, 	// 10-13
  0x752FC302, 0xF04C8112, 0x97468DA3, 0xF9D36BC6, 	// 14-17
  0x5F8F03E7, 0x9C921595, 0x7A6DBFEB, 0x595295DA, 	// 18-1B
  0x83BED42D, 0x217458D3, 0x69E04929, 0xC8C98E44, 	// 1C-1F

  0x89C2756A, 0x798EF478, 0x3E58996B, 0x71B927DD, 	// 20-23
  0x4FE1BEB6, 0xAD88F017, 0xAC20C966, 0x3ACE7DB4, 	// 24-27
  0x4ADF6318, 0x311AE582, 0x33519760, 0x7F536245, 	// 28-2B
  0x7764B1E0, 0xAE6BBB84, 0xA081FE1C, 0x2B08F994, 	// 2C-2F

  0x68487058, 0xFD458F19, 0x6CDE9487, 0xF87B52B7, 	// 30-33
  0xD373AB23, 0x024B72E2, 0x8F1FE357, 0xAB55662A, 	// 34-37
  0x28EBB207, 0xC2B52F03, 0x7BC5869A, 0x0837D3A5, 	// 38-3B
  0x872830F2, 0xA5BF23B2, 0x6A0302BA, 0x8216ED5C, 	// 3C-3F

  0x1CCF8A2B, 0xB479A792, 0xF207F3F0, 0xE2694EA1, 	// 40-43
  0xF4DA65CD, 0xBE0506D5, 0x6234D11F, 0xFEA6C48A, 	// 44-47
  0x532E349D, 0x55F3A2A0, 0xE18A0532, 0xEBF6A475, 	// 48-4B
  0xEC830B39, 0xEF6040AA, 0x9F715E06, 0x106EBD51, 	// 4C-4F

  0x8A213EF9, 0x06DD963D, 0x053EDDAE, 0xBDE64D46, 	// 50-53
  0x8D5491B5, 0x5DC47105, 0xD406046F, 0x155060FF, 	// 54-57
  0xFB981924, 0xE9BDD697, 0x434089CC, 0x9ED96777, 	// 58-5B
  0x42E8B0BD, 0x8B890788, 0x5B19E738, 0xEEC879DB, 	// 5C-5F

  0x0A7CA147, 0x0F427CE9, 0x1E84F8C9, 0x00000000, 	// 60-63
  0x86800983, 0xED2B3248, 0x70111EAC, 0x725A6C4E, 	// 64-67
  0xFF0EFDFB, 0x38850F56, 0xD5AE3D1E, 0x392D3627, 	// 68-6B
  0xD90F0A64, 0xA65C6821, 0x545B9BD1, 0x2E36243A, 	// 6C-6F

  0x670A0CB1, 0xE757930F, 0x96EEB4D2, 0x919B1B9E, 	// 70-73
  0xC5C0804F, 0x20DC61A2, 0x4B775A69, 0x1A121C16, 	// 74-77
  0xBA93E20A, 0x2AA0C0E5, 0xE0223C43, 0x171B121D, 	// 78-7B
  0x0D090E0B, 0xC78BF2AD, 0xA8B62DB9, 0xA91E14C8, 	// 7C-7F

  0x19F15785, 0x0775AF4C, 0xDD99EEBB, 0x607FA3FD, 	// 80-83
  0x2601F79F, 0xF5725CBC, 0x3B6644C5, 0x7EFB5B34, 	// 84-87
  0x29438B76, 0xC623CBDC, 0xFCEDB668, 0xF1E4B863, 	// 88-8B
  0xDC31D7CA, 0x85634210, 0x22971340, 0x11C68420, 	// 8C-8F

  0x244A857D, 0x3DBBD2F8, 0x32F9AE11, 0xA129C76D, 	// 90-93
  0x2F9E1D4B, 0x30B2DCF3, 0x52860DEC, 0xE3C177D0, 	// 94-97
  0x16B32B6C, 0xB970A999, 0x489411FA, 0x64E94722, 	// 98-9B
  0x8CFCA8C4, 0x3FF0A01A, 0x2C7D56D8, 0x903322EF, 	// 9C-9F

  0x4E4987C7, 0xD138D9C1, 0xA2CA8CFE, 0x0BD49836, 	// A0-A3
  0x81F5A6CF, 0xDE7AA528, 0x8EB7DA26, 0xBFAD3FA4, 	// A4-A7
  0x9D3A2CE4, 0x9278500D, 0xCC5F6A9B, 0x467E5462, 	// A8-AB
  0x138DF6C2, 0xB8D890E8, 0xF7392E5E, 0xAFC382F5, 	// AC-AF

  0x805D9FBE, 0x93D0697C, 0x2DD56FA9, 0x1225CFB3, 	// B0-B3
  0x99ACC83B, 0x7D1810A7, 0x639CE86E, 0xBB3BDB7B, 	// B4-B7
  0x7826CD09, 0x18596EF4, 0xB79AEC01, 0x9A4F83A8, 	// B8-BB
  0x6E95E665, 0xE6FFAA7E, 0xCFBC2108, 0xE815EFE6, 	// BC-BF

  0x9BE7BAD9, 0x366F4ACE, 0x099FEAD4, 0x7CB029D6, 	// C0-C3
  0xB2A431AF, 0x233F2A31, 0x94A5C630, 0x66A235C0, 	// C4-C7
  0xBC4E7437, 0xCA82FCA6, 0xD090E0B0, 0xD8A73315, 	// C8-CB
  0x9804F14A, 0xDAEC41F7, 0x50CD7F0E, 0xF691172F, 	// CC-CF

  0xD64D768D, 0xB0EF434D, 0x4DAACC54, 0x0496E4DF, 	// D0-D3
  0xB5D19EE3, 0x886A4C1B, 0x1F2CC1B8, 0x5165467F, 	// D4-D7
  0xEA5E9D04, 0x358C015D, 0x7487FA73, 0x410BFB2E, 	// D8-DB
  0x1D67B35A, 0xD2DB9252, 0x5610E933, 0x47D66D13, 	// DC-DF

  0x61D79A8C, 0x0CA1377A, 0x14F8598E, 0x3C13EB89, 	// E0-E3
  0x27A9CEEE, 0xC961B735, 0xE51CE1ED, 0xB1477A3C, 	// E4-E7
  0xDFD29C59, 0x73F2553F, 0xCE141879, 0x37C773BF, 	// E8-EB
  0xCDF753EA, 0xAAFD5F5B, 0x6F3DDF14, 0xDB447886, 	// EC-EF

  0xF3AFCA81, 0xC468B93E, 0x3424382C, 0x40A3C25F, 	// F0-F3
  0xC31D1672, 0x25E2BC0C, 0x493C288B, 0x950DFF41, 	// F4-F7
  0x01A83971, 0xB30C08DE, 0xE4B4D89C, 0xC1566490, 	// F8-FB
  0x84CB7B61, 0xB632D570, 0x5C6C4874, 0x57B8D042, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T2
//------------------------------------------------------
unsigned int TabDecT2[256] = {
  0xF45150A7, 0x417E5365, 0x171AC3A4, 0x273A965E, 	// 00-03
  0xAB3BCB6B, 0x9D1FF145, 0xFAACAB58, 0xE34B9303, 	// 04-07
  0x302055FA, 0x76ADF66D, 0xCC889176, 0x02F5254C, 	// 08-0B
  0xE54FFCD7, 0x2AC5D7CB, 0x35268044, 0x62B58FA3, 	// 0C-0F

  0xB1DE495A, 0xBA25671B, 0xEA45980E, 0xFE5DE1C0, 	// 10-13
  0x2FC30275, 0x4C8112F0, 0x468DA397, 0xD36BC6F9, 	// 14-17
  0x8F03E75F, 0x9215959C, 0x6DBFEB7A, 0x5295DA59, 	// 18-1B
  0xBED42D83, 0x7458D321, 0xE0492969, 0xC98E44C8, 	// 1C-1F

  0xC2756A89, 0x8EF47879, 0x58996B3E, 0xB927DD71, 	// 20-23
  0xE1BEB64F, 0x88F017AD, 0x20C966AC, 0xCE7DB43A, 	// 24-27
  0xDF63184A, 0x1AE58231, 0x51976033, 0x5362457F, 	// 28-2B
  0x64B1E077, 0x6BBB84AE, 0x81FE1CA0, 0x08F9942B, 	// 2C-2F

  0x48705868, 0x458F19FD, 0xDE94876C, 0x7B52B7F8, 	// 30-33
  0x73AB23D3, 0x4B72E202, 0x1FE3578F, 0x55662AAB, 	// 34-37
  0xEBB20728, 0xB52F03C2, 0xC5869A7B, 0x37D3A508, 	// 38-3B
  0x2830F287, 0xBF23B2A5, 0x0302BA6A, 0x16ED5C82, 	// 3C-3F

  0xCF8A2B1C, 0x79A792B4, 0x07F3F0F2, 0x694EA1E2, 	// 40-43
  0xDA65CDF4, 0x0506D5BE, 0x34D11F62, 0xA6C48AFE, 	// 44-47
  0x2E349D53, 0xF3A2A055, 0x8A0532E1, 0xF6A475EB, 	// 48-4B
  0x830B39EC, 0x6040AAEF, 0x715E069F, 0x6EBD5110, 	// 4C-4F

  0x213EF98A, 0xDD963D06, 0x3EDDAE05, 0xE64D46BD, 	// 50-53
  0x5491B58D, 0xC471055D, 0x06046FD4, 0x5060FF15, 	// 54-57
  0x981924FB, 0xBDD697E9, 0x4089CC43, 0xD967779E, 	// 58-5B
  0xE8B0BD42, 0x8907888B, 0x19E7385B, 0xC879DBEE, 	// 5C-5F

  0x7CA1470A, 0x427CE90F, 0x84F8C91E, 0x00000000, 	// 60-63
  0x80098386, 0x2B3248ED, 0x111EAC70, 0x5A6C4E72, 	// 64-67
  0x0EFDFBFF, 0x850F5638, 0xAE3D1ED5, 0x2D362739, 	// 68-6B
  0x0F0A64D9, 0x5C6821A6, 0x5B9BD154, 0x36243A2E, 	// 6C-6F

  0x0A0CB167, 0x57930FE7, 0xEEB4D296, 0x9B1B9E91, 	// 70-73
  0xC0804FC5, 0xDC61A220, 0x775A694B, 0x121C161A, 	// 74-77
  0x93E20ABA, 0xA0C0E52A, 0x223C43E0, 0x1B121D17, 	// 78-7B
  0x090E0B0D, 0x8BF2ADC7, 0xB62DB9A8, 0x1E14C8A9, 	// 7C-7F

  0xF1578519, 0x75AF4C07, 0x99EEBBDD, 0x7FA3FD60, 	// 80-83
  0x01F79F26, 0x725CBCF5, 0x6644C53B, 0xFB5B347E, 	// 84-87
  0x438B7629, 0x23CBDCC6, 0xEDB668FC, 0xE4B863F1, 	// 88-8B
  0x31D7CADC, 0x63421085, 0x97134022, 0xC6842011, 	// 8C-8F

  0x4A857D24, 0xBBD2F83D, 0xF9AE1132, 0x29C76DA1, 	// 90-93
  0x9E1D4B2F, 0xB2DCF330, 0x860DEC52, 0xC177D0E3, 	// 94-97
  0xB32B6C16, 0x70A999B9, 0x9411FA48, 0xE9472264, 	// 98-9B
  0xFCA8C48C, 0xF0A01A3F, 0x7D56D82C, 0x3322EF90, 	// 9C-9F

  0x4987C74E, 0x38D9C1D1, 0xCA8CFEA2, 0xD498360B, 	// A0-A3
  0xF5A6CF81, 0x7AA528DE, 0xB7DA268E, 0xAD3FA4BF, 	// A4-A7
  0x3A2CE49D, 0x78500D92, 0x5F6A9BCC, 0x7E546246, 	// A8-AB
  0x8DF6C213, 0xD890E8B8, 0x392E5EF7, 0xC382F5AF, 	// AC-AF

  0x5D9FBE80, 0xD0697C93, 0xD56FA92D, 0x25CFB312, 	// B0-B3
  0xACC83B99, 0x1810A77D, 0x9CE86E63, 0x3BDB7BBB, 	// B4-B7
  0x26CD0978, 0x596EF418, 0x9AEC01B7, 0x4F83A89A, 	// B8-BB
  0x95E6656E, 0xFFAA7EE6, 0xBC2108CF, 0x15EFE6E8, 	// BC-BF

  0xE7BAD99B, 0x6F4ACE36, 0x9FEAD409, 0xB029D67C, 	// C0-C3
  0xA431AFB2, 0x3F2A3123, 0xA5C63094, 0xA235C066, 	// C4-C7
  0x4E7437BC, 0x82FCA6CA, 0x90E0B0D0, 0xA73315D8, 	// C8-CB
  0x04F14A98, 0xEC41F7DA, 0xCD7F0E50, 0x91172FF6, 	// CC-CF

  0x4D768DD6, 0xEF434DB0, 0xAACC544D, 0x96E4DF04, 	// D0-D3
  0xD19EE3B5, 0x6A4C1B88, 0x2CC1B81F, 0x65467F51, 	// D4-D7
  0x5E9D04EA, 0x8C015D35, 0x87FA7374, 0x0BFB2E41, 	// D8-DB
  0x67B35A1D, 0xDB9252D2, 0x10E93356, 0xD66D1347, 	// DC-DF

  0xD79A8C61, 0xA1377A0C, 0xF8598E14, 0x13EB893C, 	// E0-E3
  0xA9CEEE27, 0x61B735C9, 0x1CE1EDE5, 0x477A3CB1, 	// E4-E7
  0xD29C59DF, 0xF2553F73, 0x141879CE, 0xC773BF37, 	// E8-EB
  0xF753EACD, 0xFD5F5BAA, 0x3DDF146F, 0x447886DB, 	// EC-EF

  0xAFCA81F3, 0x68B93EC4, 0x24382C34, 0xA3C25F40, 	// F0-F3
  0x1D1672C3, 0xE2BC0C25, 0x3C288B49, 0x0DFF4195, 	// F4-F7
  0xA8397101, 0x0C08DEB3, 0xB4D89CE4, 0x566490C1, 	// F8-FB
  0xCB7B6184, 0x32D570B6, 0x6C48745C, 0xB8D04257, 	// FC-FF
};
//------------------------------------------------------
// Decryption Table T3
//------------------------------------------------------
unsigned int TabDecT3[256] = {
  0x5150A7F4, 0x7E536541, 0x1AC3A417, 0x3A965E27, 	// 00-03
  0x3BCB6BAB, 0x1FF1459D, 0xACAB58FA, 0x4B9303E3, 	// 04-07
  0x2055FA30, 0xADF66D76, 0x889176CC, 0xF5254C02, 	// 08-0B
  0x4FFCD7E5, 0xC5D7CB2A, 0x26804435, 0xB58FA362, 	// 0C-0F

  0xDE495AB1, 0x25671BBA, 0x45980EEA, 0x5DE1C0FE, 	// 10-13
  0xC302752F, 0x8112F04C, 0x8DA39746, 0x6BC6F9D3, 	// 14-17
  0x03E75F8F, 0x15959C92, 0xBFEB7A6D, 0x95DA5952, 	// 18-1B
  0xD42D83BE, 0x58D32174, 0x492969E0, 0x8E44C8C9, 	// 1C-1F

  0x756A89C2, 0xF478798E, 0x996B3E58, 0x27DD71B9, 	// 20-23
  0xBEB64FE1, 0xF017AD88, 0xC966AC20, 0x7DB43ACE, 	// 24-27
  0x63184ADF, 0xE582311A, 0x97603351, 0x62457F53, 	// 28-2B
  0xB1E07764, 0xBB84AE6B, 0xFE1CA081, 0xF9942B08, 	// 2C-2F

  0x70586848, 0x8F19FD45, 0x94876CDE, 0x52B7F87B, 	// 30-33
  0xAB23D373, 0x72E2024B, 0xE3578F1F, 0x662AAB55, 	// 34-37
  0xB20728EB, 0x2F03C2B5, 0x869A7BC5, 0xD3A50837, 	// 38-3B
  0x30F28728, 0x23B2A5BF, 0x02BA6A03, 0xED5C8216, 	// 3C-3F

  0x8A2B1CCF, 0xA792B479, 0xF3F0F207, 0x4EA1E269, 	// 40-43
  0x65CDF4DA, 0x06D5BE05, 0xD11F6234, 0xC48AFEA6, 	// 44-47
  0x349D532E, 0xA2A055F3, 0x0532E18A, 0xA475EBF6, 	// 48-4B
  0x0B39EC83, 0x40AAEF60, 0x5E069F71, 0xBD51106E, 	// 4C-4F

  0x3EF98A21, 0x963D06DD, 0xDDAE053E, 0x4D46BDE6, 	// 50-53
  0x91B58D54, 0x71055DC4, 0x046FD406, 0x60FF1550, 	// 54-57
  0x1924FB98, 0xD697E9BD, 0x89CC4340, 0x67779ED9, 	// 58-5B
  0xB0BD42E8, 0x07888B89, 0xE7385B19, 0x79DBEEC8, 	// 5C-5F

  0xA1470A7C, 0x7CE90F42, 0xF8C91E84, 0x00000000, 	// 60-63
  0x09838680, 0x3248ED2B, 0x1EAC7011, 0x6C4E725A, 	// 64-67
  0xFDFBFF0E, 0x0F563885, 0x3D1ED5AE, 0x3627392D, 	// 68-6B
  0x0A64D90F, 0x6821A65C, 0x9BD1545B, 0x243A2E36, 	// 6C-6F

  0x0CB1670A, 0x930FE757, 0xB4D296EE, 0x1B9E919B, 	// 70-73
  0x804FC5C0, 0x61A220DC, 0x5A694B77, 0x1C161A12, 	// 74-77
  0xE20ABA93, 0xC0E52AA0, 0x3C43E022, 0x121D171B, 	// 78-7B
  0x0E0B0D09, 0xF2ADC78B, 0x2DB9A8B6, 0x14C8A91E, 	// 7C-7F

  0x578519F1, 0xAF4C0775, 0xEEBBDD99, 0xA3FD607F, 	// 80-83
  0xF79F2601, 0x5CBCF572, 0x44C53B66, 0x5B347EFB, 	// 84-87
  0x8B762943, 0xCBDCC623, 0xB668FCED, 0xB863F1E4, 	// 88-8B
  0xD7CADC31, 0x42108563, 0x13402297, 0x842011C6, 	// 8C-8F

  0x857D244A, 0xD2F83DBB, 0xAE1132F9, 0xC76DA129, 	// 90-93
  0x1D4B2F9E, 0xDCF330B2, 0x0DEC5286, 0x77D0E3C1, 	// 94-97
  0x2B6C16B3, 0xA999B970, 0x11FA4894, 0x472264E9, 	// 98-9B
  0xA8C48CFC, 0xA01A3FF0, 0x56D82C7D, 0x22EF9033, 	// 9C-9F

  0x87C74E49, 0xD9C1D138, 0x8CFEA2CA, 0x98360BD4, 	// A0-A3
  0xA6CF81F5, 0xA528DE7A, 0xDA268EB7, 0x3FA4BFAD, 	// A4-A7
  0x2CE49D3A, 0x500D9278, 0x6A9BCC5F, 0x5462467E, 	// A8-AB
  0xF6C2138D, 0x90E8B8D8, 0x2E5EF739, 0x82F5AFC3, 	// AC-AF

  0x9FBE805D, 0x697C93D0, 0x6FA92DD5, 0xCFB31225, 	// B0-B3
  0xC83B99AC, 0x10A77D18, 0xE86E639C, 0xDB7BBB3B, 	// B4-B7
  0xCD097826, 0x6EF41859, 0xEC01B79A, 0x83A89A4F, 	// B8-BB
  0xE6656E95, 0xAA7EE6FF, 0x2108CFBC, 0xEFE6E815, 	// BC-BF

  0xBAD99BE7, 0x4ACE366F, 0xEAD4099F, 0x29D67CB0, 	// C0-C3
  0x31AFB2A4, 0x2A31233F, 0xC63094A5, 0x35C066A2, 	// C4-C7
  0x7437BC4E, 0xFCA6CA82, 0xE0B0D090, 0x3315D8A7, 	// C8-CB
  0xF14A9804, 0x41F7DAEC, 0x7F0E50CD, 0x172FF691, 	// CC-CF

  0x768DD64D, 0x434DB0EF, 0xCC544DAA, 0xE4DF0496, 	// D0-D3
  0x9EE3B5D1, 0x4C1B886A, 0xC1B81F2C, 0x467F5165, 	// D4-D7
  0x9D04EA5E, 0x015D358C, 0xFA737487, 0xFB2E410B, 	// D8-DB
  0xB35A1D67, 0x9252D2DB, 0xE9335610, 0x6D1347D6, 	// DC-DF

  0x9A8C61D7, 0x377A0CA1, 0x598E14F8, 0xEB893C13, 	// E0-E3
  0xCEEE27A9, 0xB735C961, 0xE1EDE51C, 0x7A3CB147, 	// E4-E7
  0x9C59DFD2, 0x553F73F2, 0x1879CE14, 0x73BF37C7, 	// E8-EB
  0x53EACDF7, 0x5F5BAAFD, 0xDF146F3D, 0x7886DB44, 	// EC-EF

  0xCA81F3AF, 0xB93EC468, 0x382C3424, 0xC25F40A3, 	// F0-F3
  0x1672C31D, 0xBC0C25E2, 0x288B493C, 0xFF41950D, 	// F4-F7
  0x397101A8, 0x08DEB30C, 0xD89CE4B4, 0x6490C156, 	// F8-FB
  0x7B6184CB, 0xD570B632, 0x48745C6C, 0xD04257B8, 	// FC-FF
};


//***********************************************************
//
// Processing Routines with special 32 Bit Table support (9 kB),
// all tested
//
// VERY IMPORTANT NOTE:
// --------------------
// The Tables and associated processing routines are BYTE REVERSED
// compared to the original RIJNDAEL fast mode reference code.
// This reduces Byte to DWord/DWord to Byte conversion overhead on
// Little Endian machines [INTEL]
// For Big Endian machines [SUN etc.] all the tables and processing
// routines should be changed.... (to be done ?)
//
//***********************************************************

//===================================================================
// Generate the AES Round Encryption Keys from the given key bytes
//
// NOTE: Only 128, 192 and 256 Bit keys are supported,
// ----- Blocksize 128 Bits (nb = 4). Further: nr = nk + 6
//
//	Keylen	nk	nr	Subkey Array Size (nr+1) * nb * 4 Bytes
//	---------------------------------------------------------------
//	128	4	10	((10+1) * 4) * 4 = 44 * 4 = 176
//	192	6	12	((12+1) * 4) * 4 = 52 * 4 = 108
//	256	8	14	((14+1) * 4) * 4 = 60 * 4 = 240
//
// Input parameters:	char * AesKey[]	 Key Bytes Array
//			int    AesKeyLen Number of BIT32 to use (nk=4,6,8)
//			BIT32 EncKeyTab	Filled array of Round Keys
// Returns: int Status  - 0 o.k.
//			- else error (keylength Error)
//===================================================================
int m_gen_aes_encrypt_keys(unsigned char * AesKey, int AesKeyLen,
		           ds_aes_key * pEncKeyStruc)
{
  unsigned int * EncKeyTab = (unsigned int *) pEncKeyStruc->byr_key;

  int Index = AesKeyLen-1;
  unsigned char Remainder;
  int MaxRoundIndex = AesKeyLen*4 + 28 - 1;  // ((nk+6) + 1) * nb (-1)

  unsigned int Rcon = 0x01;
  unsigned int s;
  //---------------------------------------------------------
  // Copy the key data to the array
  //---------------------------------------------------------
  char2longn(AesKey,EncKeyTab[0],0);
  char2longn(AesKey,EncKeyTab[1],4);
  char2longn(AesKey,EncKeyTab[2],8);
  char2longn(AesKey,EncKeyTab[3],12);

  if(AesKeyLen == 4)
  {
//    Offset += 16;
  }
  else if(AesKeyLen == 6)
  {
    char2longn(AesKey,EncKeyTab[4],16);
    char2longn(AesKey,EncKeyTab[5],20);
//    Offset += 24;
  }
  else if(AesKeyLen == 8)
  {
    char2longn(AesKey,EncKeyTab[4],16);
    char2longn(AesKey,EncKeyTab[5],20);
    char2longn(AesKey,EncKeyTab[6],24);
    char2longn(AesKey,EncKeyTab[7],28);
//    Offset += 32;
  }
  else // wrong key length, should not happen
  {
    return(-1);
  }
  //--------------------------------------------------------
  // Expand the key for the number of rounds required
  //--------------------------------------------------------
  do
  {
    s = EncKeyTab[Index++];			// get last key, advance
    Remainder = (unsigned char) (Index % AesKeyLen); // get modulus remainder
    if(Remainder == 0)				// at a specific index
    {
      s = ((((int) SBox[s         & 0xFF] & 0xFF) << 24) |
           (((int) SBox[(s >> 24) & 0xFF] & 0xFF) << 16) |
           (((int) SBox[(s >> 16) & 0xFF] & 0xFF) << 8) |
           (((int) SBox[(s >>  8) & 0xFF] & 0xFF))) ^ Rcon;
      Rcon <<= 1;				// times 2
      if((Rcon & 0x100) != 0)			// was 1 00
        Rcon = 0x1B;				// reduce modulo 1 1B
    }
    else if((AesKeyLen == 8) && (Remainder == 4))
    {
      s = ((int)  SBox[s         & 0xFF] & 0xFF) |
          (((int) SBox[(s >>  8) & 0xFF] & 0xFF) <<  8) |
          (((int) SBox[(s >> 16) & 0xFF] & 0xFF) << 16) |
          (((int) SBox[(s >> 24) & 0xFF] & 0xFF) << 24);
    }
    EncKeyTab[Index] = EncKeyTab[Index - AesKeyLen] ^ s;
  }while(Index < MaxRoundIndex);
  return(0);
}

//===================================================================
// Generate the AES Round Decryption Keys from the given key bytes
// (Keys are pre-inverse mixed for Table accesses)
//
// NOTE: Only 128, 192 and 256 Bit keys are supported,
// ----- Blocksize 128 Bits (nb = 4). Further: nr = nk + 6
//
//	Keylen	nk	nr	Subkey Array Size (nr+1) * nb * 4 Bytes
//	---------------------------------------------------------------
//	128	4	10	((10+1) * 4) * 4 = 44 * 4 = 176
//	192	6	12	((12+1) * 4) * 4 = 52 * 4 = 108
//	256	8	14	((14+1) * 4= * 4 = 60 * 4 = 240
//
// Input parameters:	char * AesKey[]	Key Bytes Array
//			int   AesKeyLen	Number of BIT32 to use (nk=4,6,8)
//			BIT32 DecKeyTab	Filled array of Round Keys
// Returns: int Status  - 0 o.k.
//			- else error (keylength Error)
//===================================================================
int m_gen_aes_decrypt_keys(unsigned char * AesKey, int AesKeyLen,
		           ds_aes_key * pDecKeyStruc)
{
  unsigned int * DecKeyTab = (unsigned int *) pDecKeyStruc->byr_key;
  int Retcode;
  int SrcIndex;
  int DstIndex;
  int Rounds = AesKeyLen + 6 - 2;	// not for first/last
  unsigned int s0,s1,s2,s3;
  //---------------------------------------------------------------
  // 1. Expand the key same as for encryption mode
  //---------------------------------------------------------------
  Retcode = m_gen_aes_encrypt_keys(AesKey, AesKeyLen, pDecKeyStruc);
  if(Retcode != 0)
    return(Retcode);
  //---------------------------------------------------------------
  // 2. Change order of keys in Blocks of 4
  //---------------------------------------------------------------
  SrcIndex = 0;
  DstIndex = (AesKeyLen + 6) * 4;		// last quadruple
  do
  {
    s0 = DecKeyTab[DstIndex+0];
    s1 = DecKeyTab[DstIndex+1];
    s2 = DecKeyTab[DstIndex+2];
    s3 = DecKeyTab[DstIndex+3];

    DecKeyTab[DstIndex+0] = DecKeyTab[SrcIndex+0];
    DecKeyTab[DstIndex+1] = DecKeyTab[SrcIndex+1];
    DecKeyTab[DstIndex+2] = DecKeyTab[SrcIndex+2];
    DecKeyTab[DstIndex+3] = DecKeyTab[SrcIndex+3];

    DecKeyTab[SrcIndex+0] = s0;
    DecKeyTab[SrcIndex+1] = s1;
    DecKeyTab[SrcIndex+2] = s2;
    DecKeyTab[SrcIndex+3] = s3;

    SrcIndex += 4;
    DstIndex -= 4;
  }while(SrcIndex < DstIndex);
  //---------------------------------------------------------------
  // 2. Inverse Mix Columns for Element Indices 1 ... KeyLen-2
  //---------------------------------------------------------------
  Rounds = AesKeyLen + 6 - 1;	// not for first/last
  SrcIndex = 4;
  do
  {
    //-------------------------------------------------------------
    // fetch 4 contiguous keys, process through tables
    // NOTE: watch for the Indirect Index processing via S-Box !!!
    //-------------------------------------------------------------
    s0 = DecKeyTab[SrcIndex+0];
    s1 = DecKeyTab[SrcIndex+1];
    s2 = DecKeyTab[SrcIndex+2];
    s3 = DecKeyTab[SrcIndex+3];

    DecKeyTab[SrcIndex+0] =
      TabDecT0[SBox[ s0        & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s0 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s0 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s0 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+1] =
      TabDecT0[SBox[s1         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s1 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s1 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s1 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+2] =
      TabDecT0[SBox[s2         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s2 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s2 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s2 >> 24) & 0xFF] & 0xFF];

    DecKeyTab[SrcIndex+3] =
      TabDecT0[SBox[s3         & 0xFF] & 0xFF] ^
      TabDecT1[SBox[(s3 >>  8) & 0xFF] & 0xFF] ^
      TabDecT2[SBox[(s3 >> 16) & 0xFF] & 0xFF] ^
      TabDecT3[SBox[(s3 >> 24) & 0xFF] & 0xFF];

    SrcIndex += 4;
    Rounds--;
  }while(Rounds != 0);
  return(0);
}
//========================================================================
// CBC Encrypt an AES Block in FAST mode (unfolded loop, 32 Bits wide)
//
// Input Parameters:	BIT8PTR  input		Pointer to Input Data buffer
//			BIT8PTR  output		Pointer to Output Data buffer
//			BIT32PTR EncKeyTab	Pointer to precomputed
//						Encrypt AES Subkeys
//			BIT32 BlkCnt		Number of blocks times 16 byte
//			BIT8PTR IVector		Initialization Vector
//			int	 Rounds		Number of Rounds
// Returns: nothing
//======================================================================
#if !defined WIN_EM64T_ASSEMBLER

void FAST AES_Fast_cbc_encrypt(unsigned char * input,
		               unsigned char * output,
                               ds_aes_key * pEncKeyStruc,
                               int BlkCnt,
                               unsigned char * IVector,
		               int Rounds)
{
  unsigned int * EncKeyTab = (unsigned int *) pEncKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int Xor[4];
  unsigned int s[4];
  //-----------------------------------------------------------
  // load IV Vector
  //-----------------------------------------------------------
#if defined WIN32 && ! defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
  Xor[0] = * (unsigned int *) (IVector+0);
  Xor[1] = * (unsigned int *) (IVector+4);
  Xor[2] = * (unsigned int *) (IVector+8);
  Xor[3] = * (unsigned int *) (IVector+12);

#else // other OSs, JAVA
  char2longn(IVector,Xor[0],0);		// get bytes 0-3
  char2longn(IVector,Xor[1],4);		// get bytes 4-7
  char2longn(IVector,Xor[2],8);		// get bytes 8-11
  char2longn(IVector,Xor[3],12);	// get bytes 12-15
#endif
  //-----------------------------------------------------------
  // Encrypt Blocks, full unrolled loops
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    s[0] = * (unsigned int *) (input+0);
    s[1] = * (unsigned int *) (input+4);
    s[2] = * (unsigned int *) (input+8);
    s[3] = * (unsigned int *) (input+12);
#else // other OSs, JAVA
    char2longn(input,s[0],0);		// get bytes 0-3
    char2longn(input,s[1],4);		// get bytes 4-7
    char2longn(input,s[2],8);		// get bytes 8-11
    char2longn(input,s[3],12);		// get bytes 12-15
#endif

    s0 = s[0] ^ Xor[0] ^ EncKeyTab[0];
    s1 = s[1] ^ Xor[1] ^ EncKeyTab[1];
    s2 = s[2] ^ Xor[2] ^ EncKeyTab[2];
    s3 = s[3] ^ Xor[3] ^ EncKeyTab[3];
    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,0);	// Round 1
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,1);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,1);	// Round 2
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,2);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,2);	// Round 3
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,3);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,3);	// Round 4
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,4);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,4);	// Round 5
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,5);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,5);	// Round 6
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,6);

    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,6);	// Round 7
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,7);

    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,7);	// Round 8
//  SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,8);


    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,8);	// Round 9
//  SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,9);

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);  // Round 10
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,10);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10); // Round 11
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,11);

      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11); // Round 12
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,12);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,12); // Round 13
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,13);

      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,13);//Round 14
//    SR_STATES(t0,t1,t2,t3,xor[0],xor[1],xor[2],xor[3],14);

    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9); // Round 10
//    SR_STATES(t0,t1,t2,t3,s0,s1,s2,s3,10);

      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10);// Round 11
//    SR_STATES(s0,s1,s2,s3,t0,t1,t2,t3,11);

      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,11);//Round 12
//    SR_STATES(t0,t1,t2,t3,Xor[0],Xor[1],Xor[2],Xor[3],12);
    }
    else
    {
      AES_ENC_LAST_ROUND(Xor[0],Xor[1],Xor[2],Xor[3],t0,t1,t2,t3,EncKeyTab,9);// Round 10
//    SR_STATES(t0,t1,t2,t3,Xor[0],Xor[1],Xor[2],Xor[3],10);
    }

#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    *(unsigned int *) (output+0)  = Xor[0];
    *(unsigned int *) (output+4)  = Xor[1];
    *(unsigned int *) (output+8)  = Xor[2];
    *(unsigned int *) (output+12) = Xor[3];

#else // other OSs, JAVA
    long2charn(Xor[0],output,0);
    long2charn(Xor[1],output,4);
    long2charn(Xor[2],output,8);
    long2charn(Xor[3],output,12);
#endif

    input  += 16;
    output += 16;
  }
  //-----------------------------------------------------------
  // Store Back new IV
  //-----------------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
  *(unsigned int *) (IVector+ 0) = Xor[0];
  *(unsigned int *) (IVector+ 4) = Xor[1];
  *(unsigned int *) (IVector+ 8) = Xor[2];
  *(unsigned int *) (IVector+12) = Xor[3];

#else // other OSs, JAVA
  long2charn(Xor[0],IVector,0);
  long2charn(Xor[1],IVector,4);
  long2charn(Xor[2],IVector,8);
  long2charn(Xor[3],IVector,12);
#endif
}
#endif// !defined WIN_EM64T_ASSEMBLER
//========================================================================
// CBC Decrypt an AES Block in FAST mode (unfolded loop, 32 Bits wide)
// NOTE: For JAVA/CSHARP other calling is used (with offsets, aka. indices)
// -----
//
// Input Parameters:	BIT8PTR  input		Pointer to Input Data buffer
//			BIT8PTR  output		Pointer to Output Data buffer
//			BIT32PTR DecKeyTab[]	Pointer to precomputed
//						Decrypt AES Subkeys
//			BIT32 BlkCnt		Number of blocks times 16 byte
//			BIT8PTR IVector[]	Initialization Vector
//			int	 Rounds		Number of Rounds
// Returns: nothing
//======================================================================
#if !defined WIN_EM64T_ASSEMBLER

void FAST AES_Fast_cbc_decrypt(unsigned char * input,
		               unsigned char * output,
                               ds_aes_key * pDecKeyStruc,
                               int BlkCnt,
                               unsigned char * IVector,
		               int Rounds)
{
  unsigned int * DecKeyTab = (unsigned int *) pDecKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int Xor[4];
  unsigned int s[4];
  //-----------------------------------------------------------
  // load IV Vector, prepare input/output pointers
  //-----------------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
  Xor[0] = *(unsigned int *) (IVector+ 0);
  Xor[1] = *(unsigned int *) (IVector+ 4);
  Xor[2] = *(unsigned int *) (IVector+ 8);
  Xor[3] = *(unsigned int *) (IVector+12);

#else // other OSs, JAVA
  char2longn(IVector,Xor[0],0);			// get bytes 0-3
  char2longn(IVector,Xor[1],4);			// get bytes 4-7
  char2longn(IVector,Xor[2],8);			// get bytes 8-11
  char2longn(IVector,Xor[3],12);		// get bytes 12-15
#endif
  //-----------------------------------------------------------
  // Decrypt Blocks
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    s[0] = *(unsigned int *) (input+ 0);
    s[1] = *(unsigned int *) (input+ 4);
    s[2] = *(unsigned int *) (input+ 8);
    s[3] = *(unsigned int *) (input+12);

#else // other OSs, JAVA
    char2longn(input,s[0],0);
    char2longn(input,s[1],4);
    char2longn(input,s[2],8);
    char2longn(input,s[3],12);
#endif

    s0 = s[0] ^ DecKeyTab[0];
    s1 = s[1] ^ DecKeyTab[1];
    s2 = s[2] ^ DecKeyTab[2];
    s3 = s[3] ^ DecKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10 rounds
    //-------------------------------------------------
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,0);	// Round 1
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,1);	// Round 2
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,2);	// Round 3
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,3);	// Round 4
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,4);	// Round 5
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,5);	// Round 6
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,6);	// Round 7
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,7);	// Round 8
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,8);	// Round 9
    if(Rounds == 14)					// AES-256
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);  // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10); // Round 11
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11); // Round 12
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,12); // Round 13
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9); // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10);// Round 11
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11);//Round 12
    }
    else						// AES-128
    {
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);// Round 10
    }

    Xor[0] ^= s0;			// Xor with IV
    Xor[1] ^= s1;
    Xor[2] ^= s2;
    Xor[3] ^= s3;

#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    *(unsigned int *) (output+ 0) = Xor[0];
    *(unsigned int *) (output+ 4) = Xor[1];
    *(unsigned int *) (output+ 8) = Xor[2];
    *(unsigned int *) (output+12) = Xor[3];

    Xor[0] = s[0];
    Xor[1] = s[1];
    Xor[2] = s[2];
    Xor[3] = s[3];

#else // other OSs, JAVA
    long2charn(Xor[0],output,0);
    long2charn(Xor[1],output,4);
    long2charn(Xor[2],output,8);
    long2charn(Xor[3],output,12);
    memcpy(Xor,s,16);
#endif

    input  += 16;
    output += 16;
  }
  //-----------------------------------------------------------
  // Store Back new IV
  //-----------------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
  *(unsigned int *) (IVector+ 0) = Xor[0];
  *(unsigned int *) (IVector+ 4) = Xor[1];
  *(unsigned int *) (IVector+ 8) = Xor[2];
  *(unsigned int *) (IVector+12) = Xor[3];

#else // other OSs, JAVA
  long2charn(Xor[0],IVector,0);
  long2charn(Xor[1],IVector,4);
  long2charn(Xor[2],IVector,8);
  long2charn(Xor[3],IVector,12);
#endif
}
#endif// !defined WIN_EM64T_ASSEMBLER


//========================================================================
// ECB Encrypt an AES Block in FAST mode (unfolded loop, 32 Bits wide)
//
// Input Parameters:	BIT8PTR  input		Pointer to Input Data buffer
//			BIT8PTR  output		Pointer to Output Data buffer
//			BIT32PTR EncKeyTab	Pointer to precomputed
//						Encrypt AES Subkeys
//			BIT32 BlkCnt		Number of blocks times 16 byte
//			int	 Rounds		Number of Rounds
// Returns: nothing
//======================================================================
void FAST AES_Fast_ecb_encrypt(unsigned char * input,
		               unsigned char * output,
                               ds_aes_key * pEncKeyStruc,
                               int BlkCnt, int Rounds)
{
  unsigned int * EncKeyTab = (unsigned int *) pEncKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int s[4];
  //-----------------------------------------------------------
  // Encrypt Blocks, full unrolled loops
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    s[0] = * (unsigned int *) (input+0);
    s[1] = * (unsigned int *) (input+4);
    s[2] = * (unsigned int *) (input+8);
    s[3] = * (unsigned int *) (input+12);
#else // other OSs, JAVA
    char2longn(input,s[0],0);		// get bytes 0-3
    char2longn(input,s[1],4);		// get bytes 4-7
    char2longn(input,s[2],8);		// get bytes 8-11
    char2longn(input,s[3],12);		// get bytes 12-15
#endif

    s0 = s[0] ^ EncKeyTab[0];
    s1 = s[1] ^ EncKeyTab[1];
    s2 = s[2] ^ EncKeyTab[2];
    s3 = s[3] ^ EncKeyTab[3];
    //-------------------------------------------------
    // Perform Table processing for all 10/12/14 rounds
    //-------------------------------------------------
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,0);	// Round 1
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,1);	// Round 2
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,2);	// Round 3
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,3);	// Round 4
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,4);	// Round 5
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,5);	// Round 6
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,6);	// Round 7
    AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,7);	// Round 8
    AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,8);	// Round 9

    if(Rounds == 14)					// AES-256
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);  // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10); // Round 11
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11); // Round 12
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,12); // Round 13
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_ENC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9); // Round 10
      AES_ENC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,EncKeyTab,10);// Round 11
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,11);//Round 12
    }
    else
    {
      AES_ENC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,EncKeyTab,9);// Round 10
    }

#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    *(unsigned int *) (output+0)  = s0;
    *(unsigned int *) (output+4)  = s1;
    *(unsigned int *) (output+8)  = s2;
    *(unsigned int *) (output+12) = s3;

#else // other OSs, JAVA
    long2charn(s0,output,0);
    long2charn(s1,output,4);
    long2charn(s2,output,8);
    long2charn(s3,output,12);
#endif

    input  += 16;
    output += 16;
  }
}
//========================================================================
// ECB Decrypt an AES Block in FAST mode (unfolded loop, 32 Bits wide)
// NOTE: For JAVA/CSHARP other calling is used (with offsets, aka. indices)
// -----
//
// Input Parameters:	unsigned char * input	Pointer to Input Data buffer
//			unsigned char * output	Pointer to Output Data buffer
//			ds_aes_key * pDecKeyStruc Pointer to precomputed
//						  Decrypt AES Subkeys
//			int      BlkCnt		Number of blocks times 16 byte
//			int	 Rounds		Number of Rounds
// Returns: nothing
//======================================================================
void FAST AES_Fast_ecb_decrypt(unsigned char * input,
		               unsigned char * output,
                               ds_aes_key * pDecKeyStruc,
                               int BlkCnt,
		               int Rounds)
{
  unsigned int * DecKeyTab = (unsigned int *) pDecKeyStruc->byr_key;

  unsigned int s0,s1,s2,s3;
  unsigned int t0,t1,t2,t3;
  unsigned int s[4];
  //-----------------------------------------------------------
  // Decrypt Blocks
  //-----------------------------------------------------------
  for(;BlkCnt > 0;BlkCnt--)
  {
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    s[0] = *(unsigned int *) (input+ 0);
    s[1] = *(unsigned int *) (input+ 4);
    s[2] = *(unsigned int *) (input+ 8);
    s[3] = *(unsigned int *) (input+12);

#else // other OSs, JAVA
    char2longn(input,s[0],0);
    char2longn(input,s[1],4);
    char2longn(input,s[2],8);
    char2longn(input,s[3],12);
#endif

    s0 = s[0] ^ DecKeyTab[0];
    s1 = s[1] ^ DecKeyTab[1];
    s2 = s[2] ^ DecKeyTab[2];
    s3 = s[3] ^ DecKeyTab[3];

    //-------------------------------------------------
    // Perform Table processing for all 10 rounds
    //-------------------------------------------------
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,0);	// Round 1
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,1);	// Round 2
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,2);	// Round 3
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,3);	// Round 4
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,4);	// Round 5
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,5);	// Round 6
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,6);	// Round 7
    AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,7);	// Round 8
    AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,8);	// Round 9
    if(Rounds == 14)					// AES-256
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);  // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10); // Round 11
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11); // Round 12
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,12); // Round 13
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,13);//Round 14
    }
    else if(Rounds == 12)				// AES-192
    {
      AES_DEC_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9); // Round 10
      AES_DEC_ROUND(t0,t1,t2,t3,s0,s1,s2,s3,DecKeyTab,10);// Round 11
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,11);//Round 12
    }
    else						// AES-128
    {
      AES_DEC_LAST_ROUND(s0,s1,s2,s3,t0,t1,t2,t3,DecKeyTab,9);// Round 10
    }
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
    *(unsigned int *) (output+ 0) = s0;
    *(unsigned int *) (output+ 4) = s1;
    *(unsigned int *) (output+ 8) = s2;
    *(unsigned int *) (output+12) = s3;

#else // other OSs, JAVA
    long2charn(s0,output,0);
    long2charn(s1,output,4);
    long2charn(s2,output,8);
    long2charn(s3,output,12);
#endif

    input  += 16;
    output += 16;
  }
}


//================================================================
//
// CPU-AES Wrapper functions
//
//================================================================
#if defined HAVE_AES_CPU
void m_aes_set_encrypt_key(unsigned char * abyp_userkey,
			   int imp_dwords,
			   ds_aes_key * adsp_keytab)
{
  if(((adsp_keytab->im_flags & CHECK_CPU_AES_FLAG) != 0) &&
     (m_check_cpu_support_aes() != 0))
  {
    adsp_keytab->im_flags |= 1;
    m_aes_cpu_set_encrypt_key(abyp_userkey,imp_dwords, adsp_keytab);
  }
  else						// no CPU support
  {
    adsp_keytab->im_flags &= ~1;
#if !defined WIN_EM64T_ASSEMBLER
    m_gen_aes_encrypt_keys(abyp_userkey,imp_dwords,adsp_keytab);
#else
    GenAESEncryptKeys(abyp_userkey,0,imp_dwords,(unsigned int *) adsp_keytab);
#endif
  }
}
#endif


#if defined HAVE_AES_CPU
void m_aes_set_decrypt_key(unsigned char * abyp_userkey,
			   int imp_dwords,
			   ds_aes_key * adsp_keytab)
{
  if(((adsp_keytab->im_flags & CHECK_CPU_AES_FLAG) != 0) &&
     (m_check_cpu_support_aes() != 0))
  {
    adsp_keytab->im_flags |= 1;
    m_aes_cpu_set_decrypt_key(abyp_userkey,imp_dwords,adsp_keytab);
  }
  else						// no CPU support
  {
    adsp_keytab->im_flags &= ~1;
#if !defined WIN_EM64T_ASSEMBLER
    m_gen_aes_decrypt_keys(abyp_userkey,imp_dwords,adsp_keytab);
#else
    GenAESDecryptKeys(abyp_userkey,0,imp_dwords,(unsigned int *) adsp_keytab);
#endif
  }
}
#endif


#if defined HAVE_AES_CPU
void m_aes_cbc_encrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_blkcount,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{
  if((adsp_key->im_flags & 0x01) == 0)	// no CPU support
  {
#if defined DEBUG
    printf("USING C AES!\n");
#endif
    AES_Fast_cbc_encrypt(abyp_input,abyp_output,
                         adsp_key,ump_blkcount,
		         abyp_iv,imp_rounds);
  }
  else						// has CPU support
  {
#if defined DEBUG
    printf("USING CPU AES!\n");
#endif
    m_aes_cbc_cpu_encrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          ump_blkcount,
			  abyp_iv,
		          imp_rounds);
  }
}
#endif



#if defined HAVE_AES_CPU
void m_aes_cbc_decrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_blkcount,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{
  if((adsp_key->im_flags & 0x01) == 0)		// no CPU support
  {
    AES_Fast_cbc_decrypt(abyp_input,abyp_output,adsp_key,
                         ump_blkcount,abyp_iv,imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_cbc_cpu_decrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          ump_blkcount,abyp_iv,
		          imp_rounds);
  }
}
#endif

#if defined HAVE_AES_CPU
void m_aes_ecb_encrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_blkcount,
		       int imp_rounds)
{
  if((adsp_key->im_flags & 0x01) == 0)		// no CPU support
  {
    AES_Fast_ecb_encrypt(abyp_input,abyp_output,
                         adsp_key,ump_blkcount,
		         imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_ecb_cpu_encrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          ump_blkcount,
		          imp_rounds);
  }
}
#endif

#if defined HAVE_AES_CPU
void m_aes_ecb_decrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_blkcount,
		       int imp_rounds)
{
  if((adsp_key->im_flags & 0x01) == 0)		// no CPU support
  {
    AES_Fast_ecb_decrypt(abyp_input,abyp_output,
                         adsp_key,ump_blkcount,
		         imp_rounds);
  }
  else						// has CPU support
  {
    m_aes_ecb_cpu_decrypt(abyp_input,abyp_output,
		          (unsigned char *) adsp_key,
		          ump_blkcount,
		          imp_rounds);
  }
}
#endif


/**
* Encrypts a data block with AES in CFB8 mode of operation.
*
* The data may be of arbitrary length. The output buffer must be at least
* as long, as the data.
*
*  @param abyp_input Pointer to input data buffer
*  @param abyp_output Pointer to output data buffer
*  @param adsp_key Pointer to precomputed
*               AES encrypt subkey structure
*  @param ump_byte_count Number of 16 byte AES blocks
*  @param abyp_iv Initialization vector
*  @param imp_rounds Number of rounds
*/
void m_aes_cfb8_encrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_byte_count,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned char aucl_temp_in_block[AES_BLOCK_SIZE];     //Input for actual AES calls
   unsigned int uml_bytes_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   memcpy(aucl_temp_in_block,abyp_iv,AES_BLOCK_SIZE);
   for(;uml_bytes_written < ump_byte_count; uml_bytes_written++){ //Encrypt byte by byte
      m_aes_ecb_encrypt(aucl_temp_in_block, aucl_temp_cipher_block, adsp_key, 1, imp_rounds);
      abyp_output[uml_bytes_written] = aucl_temp_cipher_block[0]^abyp_input[uml_bytes_written];
      // Shift the input and fill with encrypted (meaning OUT) byte
      memmove(aucl_temp_in_block,aucl_temp_in_block+1, AES_BLOCK_SIZE-1);
      aucl_temp_in_block[AES_BLOCK_SIZE-1] = abyp_output[uml_bytes_written];
   }
}


/**
* Decrypts a data block with AES in CFB8 mode of operation.
*
* The data may be of arbitrary length. The output buffer must be at least
* as long, as the data.
*
* The key is the same as for encryption, meaining it must be generated using
* m_gen_aes_encrypt_keys, NOT m_gen_aes_decrypt_keys.
*
*  @param abyp_input Pointer to input data buffer
*  @param abyp_output Pointer to output data buffer
*  @param adsp_key Pointer to precomputed
*               AES encrypt subkey structure
*  @param ump_byte_count Number of 16 byte AES blocks
*  @param abyp_iv Initialization vector
*  @param imp_rounds Number of rounds
*/
void m_aes_cfb8_decrypt(unsigned char * abyp_input,
		       unsigned char * abyp_output,
		       ds_aes_key * adsp_key,
		       unsigned int ump_byte_count,
		       unsigned char * abyp_iv,
		       int imp_rounds)
{
   unsigned char aucl_temp_cipher_block[AES_BLOCK_SIZE]; //Output from actual AES calls
   unsigned char aucl_temp_in_block[AES_BLOCK_SIZE];     //Input for actual AES calls
   unsigned int uml_bytes_written = 0;                   //Number of bytes encrypted so far
   // Start with IV
   memcpy(aucl_temp_in_block,abyp_iv,AES_BLOCK_SIZE);
   for(;uml_bytes_written < ump_byte_count; uml_bytes_written++){ //Decrypt byte by byte
      m_aes_ecb_encrypt(aucl_temp_in_block, aucl_temp_cipher_block, adsp_key, 1, imp_rounds);
      abyp_output[uml_bytes_written] = aucl_temp_cipher_block[0]^abyp_input[uml_bytes_written];
      // Shift the input and fill with encrypted (meaning IN) byte
      memmove(aucl_temp_in_block,aucl_temp_in_block+1, AES_BLOCK_SIZE-1);
      aucl_temp_in_block[AES_BLOCK_SIZE-1] = abyp_input[uml_bytes_written];
   }
}

//========================================================
//
// AES CPU functions
//
//========================================================
#if defined HAVE_AES_CPU

//#include <wmmintrin.h>
//#include <smmintrin.h>


#if (defined WIN32 || defined WIN64) && !defined _M_IA64 && !defined WINCE
#include <intrin.h>

// For Microsoft Compiler only!
int m_check_cpu_support_aes()
{
  int imlr_info[4];
  __cpuid(imlr_info,1);
  return(imlr_info[2] & 0x2000000);
}
#elif defined (__GNUC__) && (defined LINUX_X86CPU || defined LINUX_X64CPU || defined SOLARIS_X64CPU)
#if 0 // does NOT work with gcc -fPIC option needed for xxx.so !!!!!
#define cpuid(func,ax,bx,cx,dx)\
         __asm__ __volatile__ ("cpuid":\
         "=a" (ax), "=b" (bx), "=c" (cx), "=d" (dx) : "a" (func));

int m_check_cpu_support_aes()
{
  unsigned int a,b,c,d;
  cpuid(1, a,b,c,d);
  return(c & 0x2000000);
}
#endif // 0
#else // all others

int m_check_cpu_support_aes()
{
  return(0);
}
#endif



#if !defined HAVE_AES_CPU_ASSEMBLER

void m_aes_cbc_cpu_encrypt(const unsigned char * abyp_in,
		           unsigned char * abyp_out,
		           unsigned char * abyp_key,
		           unsigned int ump_blkcount,
		           unsigned char * abyp_ivec,
		           int imp_number_of_rounds)
{
  __m128i uhl_feedback,uhl_data;
  int iml_1,iml_2;

  uhl_feedback = _mm_loadu_si128((__m128i*) abyp_ivec);
  for(iml_1=0;iml_1<(int) ump_blkcount;iml_1++)
  {
    uhl_data = _mm_loadu_si128(&((__m128i*) abyp_in)[iml_1]);
    uhl_feedback = _mm_xor_si128(uhl_data,uhl_feedback);
    uhl_feedback = _mm_xor_si128(uhl_feedback,((__m128i*)abyp_key)[0]);

    for(iml_2=1;iml_2<imp_number_of_rounds;iml_2++)
      uhl_feedback = _mm_aesenc_si128(uhl_feedback,
                                      ((__m128i*)abyp_key)[iml_2]);

    uhl_feedback = _mm_aesenclast_si128(uhl_feedback,
				        ((__m128i*)abyp_key)[iml_2]);

    _mm_storeu_si128(&((__m128i*)abyp_out)[iml_1],uhl_feedback);
  }
  _mm_storeu_si128((__m128i*)abyp_ivec, uhl_feedback);
}

void m_aes_cbc_cpu_decrypt(const unsigned char * abyp_in,
		           unsigned char * abyp_out,
		           unsigned char * abyp_key,
		           unsigned int ump_blkcount,
		           unsigned char * abyp_ivec,
		           int imp_number_of_rounds)
{
  __m128i uhl_data,uhl_feedback,uhl_last_in;
  int iml_1,iml_2;

  uhl_feedback = _mm_loadu_si128((__m128i*)abyp_ivec);

  for(iml_1=0;iml_1<(int) ump_blkcount;iml_1++)
  {
    uhl_last_in = _mm_loadu_si128(&((__m128i*)abyp_in)[iml_1]);
    uhl_data = _mm_xor_si128(uhl_last_in,((__m128i*)abyp_key)[0]);

    for(iml_2=1;iml_2<imp_number_of_rounds;iml_2++)
      uhl_data = _mm_aesdec_si128(uhl_data,((__m128i*)abyp_key)[iml_2]);

    uhl_data = _mm_aesdeclast_si128(uhl_data,((__m128i*)abyp_key)[iml_2]);
    uhl_data = _mm_xor_si128(uhl_data,uhl_feedback);
    _mm_storeu_si128(&((__m128i*)abyp_out)[iml_1],uhl_data);
    uhl_feedback = uhl_last_in;
  }
  _mm_storeu_si128((__m128i*)abyp_ivec,uhl_feedback);
}

void m_aes_ecb_cpu_encrypt(const unsigned char * abyp_in,
		           unsigned char * abyp_out,
		           unsigned char * abyp_key,
		           unsigned int ump_blkcount,
		           int imp_number_of_rounds)
{
  __m128i uhl_tmp;
  int iml_1,iml_2;

  for(iml_1=0;iml_1<(int) ump_blkcount;iml_1++)
  {
    uhl_tmp = _mm_loadu_si128(&((__m128i*) abyp_in)[iml_1]);
    uhl_tmp = _mm_xor_si128(uhl_tmp,((__m128i*)abyp_key)[0]);

    for(iml_2=1;iml_2<imp_number_of_rounds;iml_2++)
      uhl_tmp = _mm_aesenc_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);

    uhl_tmp = _mm_aesenclast_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);

    _mm_storeu_si128(&((__m128i*)abyp_out)[iml_1],uhl_tmp);
  }
}


void m_aes_ecb_cpu_decrypt(const unsigned char * abyp_in,
		           unsigned char * abyp_out,
		           unsigned char * abyp_key,
		           unsigned int ump_blkcount,
		           int imp_number_of_rounds)
{
  __m128i uhl_tmp;
  int iml_1,iml_2;

  for(iml_1=0;iml_1<(int) ump_blkcount;iml_1++)
  {
    uhl_tmp = _mm_loadu_si128(&((__m128i*)abyp_in)[iml_1]);
    uhl_tmp = _mm_xor_si128(uhl_tmp,((__m128i*)abyp_key)[0]);

    for(iml_2=1;iml_2<imp_number_of_rounds;iml_2++)
      uhl_tmp = _mm_aesdec_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);

    uhl_tmp = _mm_aesdeclast_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);
    _mm_storeu_si128(&((__m128i*)abyp_out)[iml_1],uhl_tmp);
  }
}

void m_aes_ctr_cpu_encrypt(const unsigned char * abyp_in,
		           unsigned char * abyp_out,
		           const unsigned char * abyp_ivec,
		           const unsigned char * abyp_nonce,
		           unsigned int ump_blockcnt,
		           const unsigned char * abyp_key,
		           int imp_number_of_rounds)
{
  __m128i uhl_ctr_block, uhl_tmp, uhl_one, uhl_bswap_epi64;
  int iml_1,iml_2;

  uhl_one = _mm_set_epi32(0,1,0,0);
  uhl_bswap_epi64 = _mm_setr_epi8(7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8);

//  uhl_ctr_block = _mm_insert_epi64(uhl_ctr_block,*((long long *)abyp_ivec),1);
  uhl_ctr_block = _mm_insert_epi32(uhl_ctr_block,*(&((long *)abyp_ivec)[0]),2);
  uhl_ctr_block = _mm_insert_epi32(uhl_ctr_block,*(&((long *)abyp_ivec)[1]),3);


  uhl_ctr_block = _mm_insert_epi32(uhl_ctr_block,*(long*)abyp_nonce,1);
  uhl_ctr_block = _mm_srli_si128(uhl_ctr_block,4);
  uhl_ctr_block = _mm_shuffle_epi8(uhl_ctr_block,uhl_bswap_epi64);
  uhl_ctr_block = _mm_add_epi64(uhl_ctr_block,uhl_one);

  for(iml_1=0;iml_1<(int) ump_blockcnt;iml_1++)
  {
    uhl_tmp = _mm_shuffle_epi8(uhl_ctr_block,uhl_bswap_epi64);
    uhl_ctr_block = _mm_add_epi64(uhl_ctr_block,uhl_one);
    uhl_tmp = _mm_xor_si128(uhl_tmp,((__m128i*)abyp_key)[0]);
    for(iml_2=1;iml_2<imp_number_of_rounds;iml_2++)
      uhl_tmp = _mm_aesenc_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);
    uhl_tmp = _mm_aesenclast_si128(uhl_tmp,((__m128i*)abyp_key)[iml_2]);
    uhl_tmp = _mm_xor_si128(uhl_tmp,
			    _mm_loadu_si128(&((__m128i*)abyp_in)[iml_1]));
    _mm_storeu_si128(&((__m128i*)abyp_out)[iml_1],uhl_tmp);
  }
}
#endif // !defined HAVE_AES_CPU_ASSEMBLER


#if 0
//#if !defined HAVE_AES_CPU_ASSEMBLER

inline __m128i m_aes_128_assist(__m128i uhp_temp1, __m128i uhp_temp2)
{
  __m128i uhl_temp3;

  uhp_temp2 = _mm_shuffle_epi32(uhp_temp2,0xFF);
  uhl_temp3 = _mm_slli_si128(uhp_temp1,0x04);
  uhp_temp1 = _mm_xor_si128(uhp_temp1,uhl_temp3);
  uhl_temp3 = _mm_slli_si128(uhl_temp3,0x04);
  uhp_temp1 = _mm_xor_si128(uhp_temp1,uhl_temp3);
  uhl_temp3 = _mm_slli_si128(uhl_temp3,0x04);
  uhp_temp1 = _mm_xor_si128(uhp_temp1,uhl_temp3);
  uhp_temp1 = _mm_xor_si128(uhp_temp1,uhp_temp2);
  return(uhp_temp1);
}


void m_aes_128_cpu_key_expansion(const unsigned char * abyp_userkey,
			         unsigned char * abyp_key)
{
  __m128i uhl_temp1,uhl_temp2;
  __m128i * auhl_key_schedule = (__m128i *) abyp_key;

  uhl_temp1 = _mm_loadu_si128((__m128i *)abyp_userkey);
  auhl_key_schedule[0] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x01);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[1] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x02);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[2] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x04);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[3] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x08);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[4] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x10);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[5] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x20);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[6] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x40);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[7] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x80);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[8] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x1B);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[9] = uhl_temp1;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp1,0x36);
  uhl_temp1 = m_aes_128_assist(uhl_temp1,uhl_temp2);
  auhl_key_schedule[10] = uhl_temp1;
}

inline void m_key_192_assist(__m128i * auhp_temp1, __m128i * auhp_temp2,
		             __m128i * auhp_temp3)
{
  __m128i uhl_temp4;
  *auhp_temp2 = _mm_shuffle_epi32(*auhp_temp2,0x55);
  uhl_temp4   = _mm_slli_si128(*auhp_temp1,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp4);
  uhl_temp4   = _mm_slli_si128(uhl_temp4,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp4);
  uhl_temp4   = _mm_slli_si128(uhl_temp4,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp4);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,*auhp_temp2);
  *auhp_temp2 = _mm_shuffle_epi32(*auhp_temp1,0xFF);
  uhl_temp4   = _mm_slli_si128(*auhp_temp3,0x04);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,uhl_temp4);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,*auhp_temp2);
}


void m_aes_192_cpu_key_expansion(const unsigned char * abyp_userkey,
			         unsigned char * abyp_key)
{
  __m128i uhl_temp1,uhl_temp2,uhl_temp3;
  __m128i * auhl_key_schedule = (__m128i *) abyp_key;
  __m128d uhl_dtemp;

  uhl_temp1 = _mm_loadu_si128((__m128i *) abyp_userkey);
  uhl_temp3 = _mm_loadu_si128((__m128i *)(abyp_userkey+16));

  auhl_key_schedule[0] = uhl_temp1;
  auhl_key_schedule[1] = uhl_temp3;

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x01);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&auhl_key_schedule[1]),
			     *((__m128d*)&uhl_temp1),0);
  auhl_key_schedule[1] = *((__m128i*)&uhl_dtemp);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&uhl_temp1),
                             *((__m128d*)&uhl_temp3),1);
  auhl_key_schedule[2] = *((__m128i*)&uhl_dtemp);

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x02);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  auhl_key_schedule[3] = uhl_temp1;
  auhl_key_schedule[4] = uhl_temp3;

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x04);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&auhl_key_schedule[4]),
			     *((__m128d*)&uhl_temp1),0);
  auhl_key_schedule[4] = *((__m128i*)&uhl_dtemp);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&uhl_temp1),
                             *((__m128d*)&uhl_temp3),1);
  auhl_key_schedule[5] = *((__m128i*)&uhl_dtemp);

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x08);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  auhl_key_schedule[6] = uhl_temp1;
  auhl_key_schedule[7] = uhl_temp3;

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x10);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&auhl_key_schedule[7]),
			     *((__m128d*)&uhl_temp1),0);
  auhl_key_schedule[7] = *((__m128i*) &uhl_dtemp);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&uhl_temp1),
                             *((__m128d*)&uhl_temp3),1);
  auhl_key_schedule[8] = *((__m128i*) &uhl_dtemp);

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x20);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  auhl_key_schedule[9]  = uhl_temp1;
  auhl_key_schedule[10] = uhl_temp3;

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x40);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&auhl_key_schedule[10]),
 			     *((__m128d*)&uhl_temp1),0);
  auhl_key_schedule[10] = *((__m128i*) &uhl_dtemp);
  uhl_dtemp = _mm_shuffle_pd(*((__m128d*)&uhl_temp1),
                             *((__m128d*)&uhl_temp3),1);
  auhl_key_schedule[11] = *((__m128i*)&uhl_dtemp);

  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x80);
  m_key_192_assist(&uhl_temp1,&uhl_temp2,&uhl_temp3);
  auhl_key_schedule[12] = uhl_temp1;
  auhl_key_schedule[13] = uhl_temp3;
}

inline void m_key_256_assist_1(__m128i * auhp_temp1, __m128i * auhp_temp2)
{
  __m128i uhl_temp3;
  *auhp_temp2 = _mm_shuffle_epi32(*auhp_temp2,0xFF);
  uhl_temp3   = _mm_slli_si128(*auhp_temp1,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp3);
  uhl_temp3   = _mm_slli_si128(uhl_temp3,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp3);
  uhl_temp3   = _mm_slli_si128(uhl_temp3,0x04);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,uhl_temp3);
  *auhp_temp1 = _mm_xor_si128(*auhp_temp1,*auhp_temp2);
}

inline void m_key_256_assist_2(__m128i * auhp_temp1, __m128i * auhp_temp3)
{
  __m128i uhl_temp2,uhl_temp4;
  uhl_temp4   = _mm_aeskeygenassist_si128(*auhp_temp1,0x00);
  uhl_temp2   = _mm_shuffle_epi32(uhl_temp4,0xAA);
  uhl_temp4   = _mm_slli_si128(*auhp_temp3,0x04);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,uhl_temp4);
  uhl_temp4   = _mm_slli_si128(uhl_temp4,0x04);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,uhl_temp4);
  uhl_temp4   = _mm_slli_si128(uhl_temp4,0x04);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,uhl_temp4);
  *auhp_temp3 = _mm_xor_si128(*auhp_temp3,uhl_temp2);
}


void m_aes_256_cpu_key_expansion(const unsigned char * abyp_userkey,
			         unsigned char * abyp_key)
{
  __m128i uhl_temp1,uhl_temp2,uhl_temp3;
  __m128i * auhl_key_schedule = (__m128i *) abyp_key;

  uhl_temp1 = _mm_loadu_si128((__m128i *) abyp_userkey);
  uhl_temp3 = _mm_loadu_si128((__m128i *)(abyp_userkey+16));
  auhl_key_schedule[0] = uhl_temp1;
  auhl_key_schedule[1] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x01);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[2] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[3] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x02);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[4] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[5] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x04);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[6] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[7] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x08);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[8] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[9] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x10);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[10] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[11] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x20);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[12] = uhl_temp1;
  m_key_256_assist_2(&uhl_temp1,&uhl_temp3);
  auhl_key_schedule[13] = uhl_temp3;
  uhl_temp2 = _mm_aeskeygenassist_si128(uhl_temp3,0x40);
  m_key_256_assist_1(&uhl_temp1,&uhl_temp2);
  auhl_key_schedule[14] = uhl_temp1;
}
#endif // !defined HAVE_AES_CPU_ASSEMBLER

//==============================================================

void m_aes_cpu_set_encrypt_key(const unsigned char * abyp_userkey,
	 		       const int imp_dwords,
			       ds_aes_key * adsp_key)
{
  if(imp_dwords == 4)
    m_aes_128_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
  else if(imp_dwords == 6)
    m_aes_192_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
  else
    m_aes_256_cpu_key_expansion(abyp_userkey,(unsigned char *) adsp_key);
}


void m_aes_cpu_set_decrypt_key(const unsigned char * abyp_userkey,
			       const int imp_dwords,
			       ds_aes_key * adsp_key)
{
  int iml_nr;
  ds_aes_key dsl_temp_key;

#if !defined HAVE_AES_CPU_ASSEMBLER
  __m128i * auhl_key_schedule = (__m128i*)adsp_key->byr_key;
  __m128i * auhl_temp_key_schedule = (__m128i*) dsl_temp_key.byr_key;
#endif


  m_aes_cpu_set_encrypt_key(abyp_userkey,imp_dwords,&dsl_temp_key);

  iml_nr = imp_dwords + 6;	// number of rounds



#if !defined HAVE_AES_CPU_ASSEMBLER
  auhl_key_schedule[iml_nr]   = auhl_temp_key_schedule[0];
  auhl_key_schedule[iml_nr-1] = _mm_aesimc_si128(auhl_temp_key_schedule[1]);
  auhl_key_schedule[iml_nr-2] = _mm_aesimc_si128(auhl_temp_key_schedule[2]);
  auhl_key_schedule[iml_nr-3] = _mm_aesimc_si128(auhl_temp_key_schedule[3]);
  auhl_key_schedule[iml_nr-4] = _mm_aesimc_si128(auhl_temp_key_schedule[4]);
  auhl_key_schedule[iml_nr-5] = _mm_aesimc_si128(auhl_temp_key_schedule[5]);
  auhl_key_schedule[iml_nr-6] = _mm_aesimc_si128(auhl_temp_key_schedule[6]);
  auhl_key_schedule[iml_nr-7] = _mm_aesimc_si128(auhl_temp_key_schedule[7]);
  auhl_key_schedule[iml_nr-8] = _mm_aesimc_si128(auhl_temp_key_schedule[8]);
  auhl_key_schedule[iml_nr-9] = _mm_aesimc_si128(auhl_temp_key_schedule[9]);
  if(iml_nr > 10)
  {
    auhl_key_schedule[iml_nr-10] = _mm_aesimc_si128(auhl_temp_key_schedule[10]);
    auhl_key_schedule[iml_nr-11] = _mm_aesimc_si128(auhl_temp_key_schedule[11]);
  }
  if(iml_nr > 12)
  {
    auhl_key_schedule[iml_nr-12] = _mm_aesimc_si128(auhl_temp_key_schedule[12]);
    auhl_key_schedule[iml_nr-13] = _mm_aesimc_si128(auhl_temp_key_schedule[13]);
  }
  auhl_key_schedule[0]   = auhl_temp_key_schedule[iml_nr];
#else
  m_aes_cpu_revert_key((unsigned char *) &dsl_temp_key,
	                   (unsigned char *) adsp_key,iml_nr);
#endif
}

#endif //defined HAVE_AES_CPU


#undef char2long
#undef char2longn
#undef long2char
#undef long2charn
#undef AES_ENC_ROUND
#undef AES_ENC_LAST_ROUND
#undef AES_DEC_ROUND
#undef AES_DEC_LAST_ROUND
#endif // HL_ENCR_AES
// end of 'hobaes.c'


#ifdef HL_ENCR_DES
// hobdes.c
//===========================================================
//
// This file implements the basic DES cipher algorithm and
// some derived cipher modes e.g. DES-CBC, 3DES-EDE_CBC.
//
// See US Standards FIPS PUB 46 (-1, -2) [DES] and FIPS PUB 81
// [Modes of Operation] for further description.
//
// See also DESSWAP.TXT, KEYSHIFT.TXT, SROUND.TXT and DESSBOX.TXT
// for specific implementation.
//
//===========================================================


//-------------------------------------------------------------
// Constants
//-------------------------------------------------------------

#define SP_BOX_LEN	64			// 64 longs a 32 Bit
#define	DES_ENCRYPT	0			// do DES encryption
#define	DES_DECRYPT	1			// do DES decryption
#define	DES_KEY_BYTES	8			// number of Key Bytes
#define	DES_SUBKEY_ARRAY_SIZE	32		// 32 longs a 32 Bit
#define	DES_BLOCK_SIZE	8			// 8 bytes

//-------------------------------------------------------------
// Macros
//-------------------------------------------------------------
#define LROT1(l) ((( l << 1) | ((l >> 31) &   1)) & 0xFFFFFFFF)

#define LROT2(l) ((( l << 2) | ((l >> 30) &    3)) & 0xFFFFFFFF)
#define LROT3(l) ((( l << 3) | ((l >> 29) &    7)) & 0xFFFFFFFF)
#define LROT4(l) ((( l << 4) | ((l >> 28) & 0x0F)) & 0xFFFFFFFF)
#define LROT5(l) ((( l << 5) | ((l >> 27) & 0x1F)) & 0xFFFFFFFF)
#define LROT6(l) ((( l << 6) | ((l >> 26) & 0x3F)) & 0xFFFFFFFF)


#define RROT1(l) ((((l >> 1) & 0x7FFFFFFF) | ((l & 1) << 31)) & 0xFFFFFFFF)
#define RROT2(l) ((((l >> 2) & 0x3FFFFFFF) | ((l & 3) << 30)) & 0xFFFFFFFF)
#define RROT3(l) ((((l >> 3) & 0x1FFFFFFF) | ((l & 7) << 29)) & 0xFFFFFFFF)
#define	RROT4(l) ((((l >> 4) & 0x0FFFFFFF) | ((l & 0x0F)<< 28)) & 0xFFFFFFFF)
#define	RROT5(l) ((((l >> 5) & 0x07FFFFFF) | ((l & 0x1F)<< 27)) & 0xFFFFFFFF)

#define RROT1MOD28BIT(l)\
        ((((l >> 1) & 0x07FFFFFF) | ((l & 1) << 27)) & 0x0FFFFFFF)
#define RROT2MOD28BIT(l)\
        ((((l >> 2) & 0x03FFFFFF) | ((l & 3) << 26)) & 0x0FFFFFFF)




#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (unsigned int) *((unsigned int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (unsigned int) *((unsigned int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#if defined WIN64

#define char2long(c,l,i)\
       l  = (((unsigned int) c[i+3] & 0x0FF) << 24) |\
            (((unsigned int) c[i+2] & 0x0FF) << 16) |\
            (((unsigned int) c[i+1] & 0x0FF) << 8)  |\
            ((unsigned int)  c[i  ] & 0x0FF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((unsigned int) c[i+3] & 0x0FF) << 24) |\
            (((unsigned int) c[i+2] & 0x0FF) << 16) |\
            (((unsigned int) c[i+1] & 0x0FF) << 8)  |\
            ((unsigned int)  c[i  ] & 0x0FF);

#else // JAVA, Solaris etc

#define char2long(c,l,i)\
       l  = (((unsigned int) c[i+3] & 0x0FF) << 24) |\
            (((unsigned int) c[i+2] & 0x0FF) << 16) |\
            (((unsigned int) c[i+1] & 0x0FF) << 8)  |\
            ((unsigned int)  c[i  ] & 0x0FF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((unsigned int) c[i+3] & 0x0FF) << 24) |\
            (((unsigned int) c[i+2] & 0x0FF) << 16) |\
            (((unsigned int) c[i+1] & 0x0FF) << 8)  |\
            ((unsigned int)  c[i  ] & 0x0FF);
#endif
#endif


#if defined WIN32 && !defined _M_IA64 && !defined WINCE
#define	long2char(l,c,i) (*((unsigned int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((unsigned int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#if defined WIN64

#define long2char(l,c,i) c[i]   = (unsigned char) (l);\
                         c[i+1] = (unsigned char) (l>> 8);\
                         c[i+2] = (unsigned char) (l>>16);\
                         c[i+3] = (unsigned char) (l>>24);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (unsigned char) (l);\
                          c[i+1] = (unsigned char) (l>> 8);\
                          c[i+2] = (unsigned char) (l>>16);\
                          c[i+3] = (unsigned char) (l>>24);

#else // JAVA, SOLARIS etc


#define long2char(l,c,i) c[i]   = (unsigned char) (l       & 0x0FF);\
                         c[i+1] = (unsigned char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (unsigned char) ((l>>16) & 0x0FF);\
                         c[i+3] = (unsigned char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (unsigned char) (l       & 0x0FF);\
                          c[i+1] = (unsigned char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (unsigned char) ((l>>16) & 0x0FF);\
                          c[i+3] = (unsigned char) ((l>>24) & 0x0FF);
#endif
#endif


#if 0
/*--------------------------------------------------------------*/
/* Permutation functions (taken from EAY)			*/
/*--------------------------------------------------------------*/
// Bit-Permutation between 2 long words, see documentation
// DESSWAP.TXT for specification of operation
#endif // 0

#define PERMUTE2(x,y,tmp,bitcnt,bitmask) {\
	 tmp = ((x >> bitcnt) ^ y) & bitmask;\
         x ^= (tmp << bitcnt);\
         y ^= tmp;}

#if 0
// Bit-Permutation within 1 long words, works similar
// as Bit-Permutation between 2 long words, but does not work
// for bitcnt <= 0 !!!
// (due to sign extension problem when using right shift !!!)
#endif // 0

#define PERMUTE1(x,tmp,bitcnt,bitmask) { \
         tmp = (x ^ (x >> (16+bitcnt))) & bitmask;\
         x = x ^ tmp ^ (tmp << (16+bitcnt));}

#if 0
/*--------------------------------------------------------------*/
/* DES functions (adapted from EAY)				*/
/*--------------------------------------------------------------*/
//
// DES Encryption/Decryption Round Function
//
//
// NOTE: the primary l,r rotate that is needed to generate correct
//       Bit order for the S-Box inputs (Expansion Permutation) has
//	 been changed so that the bit order for l and r is now:
//       31,20,29,......,1,32 in FIPS order (was before:
//       29,28,27,......,1,32,31,30).
//	 This eases and unifies access via a single Index into SP-Tables.
//       Therefore the SP-Boxes had to be modified (changed Output
//       Permutation) see SBOXGEN1.C. Further the Subkey-Generation
//	 routine is modified for reduced left rotate by 2 Bits.
//
// Operations:
// XOR with S1,S3,S5,S7 Subkey i   (C'')
// XOR with S2,S4,S6,S8 Subkey i+1 (D'')
// align for S-Box Access (E-Box Function helper function RROT4)
// XOR with S1 Output,
// XOR with S3 Output,
// XOR with S5 Output,
// XOR with S7 Output,
// XOR with S2 Output,
// XOR with S4 Output,
// XOR with S6 Output,
// XOR with S8 Output
#endif // 0

#define DES_ROUND(L,R,K,SK_TAB) { \
	u=R^SK_TAB[K  ]; \
	v=R^SK_TAB[K+1]; \
	v=RROT4(v); \
	L^= \
        pSPBox[u & 0x3F]^\
        pSPBox[2*SP_BOX_LEN + ((u>> 8) & 0x3F)]^\
        pSPBox[4*SP_BOX_LEN + ((u>>16) & 0x3F)]^\
        pSPBox[6*SP_BOX_LEN + ((u>>24) & 0x3F)]^\
        pSPBox[1*SP_BOX_LEN + (v & 0x3F)]^\
        pSPBox[3*SP_BOX_LEN + ((v>> 8) & 0x3F)]^\
        pSPBox[5*SP_BOX_LEN + ((v>>16) & 0x3F)]^\
        pSPBox[7*SP_BOX_LEN + ((v>>24) & 0x3F)];}

#if 0
//----------------------------------------------------------------------
// DES Initial permutation (IP)
//
// Note: the Output is in reversed bit-Order with l and r values
// ----- exchanged !!
//
// Description of Operation:
//	 exch. low/high nibbles
//	 exch. low/high 16 Bit Words
//	 exch. low/high 2 bits/nib.
//	 exch. low/high bytes
//	 exch. even/odd bits
//
#endif // 0

#define IP(l,r) { \
	unsigned int IP_TMP; \
	PERMUTE2(r,l,IP_TMP, 4,0x0F0F0F0F) \
	PERMUTE2(l,r,IP_TMP,16,0x0000FFFF) \
	PERMUTE2(r,l,IP_TMP, 2,0x33333333) \
	PERMUTE2(l,r,IP_TMP, 8,0x00FF00FF) \
	PERMUTE2(r,l,IP_TMP, 1,0x55555555)}

#if 0
//----------------------------------------------------------------------
// DES Final permutation (FP)
//
// Note: the Input is in reversed bit-Order with l and r values
// ----- exchanged !!
//
// Description of Operation:
//	 exch. odd/even bits
//	 exch. low/high bytes
//	 exch. low/high 2 bits/nib.
//	 exch. low/high 16 Bit Words
//	 exch. low/high nibbles
//
#endif // 0

#define FP(l,r) { \
	unsigned int IP_TMP; \
	PERMUTE2(l,r,IP_TMP, 1,0x55555555) \
	PERMUTE2(r,l,IP_TMP, 8,0x00FF00FF) \
	PERMUTE2(l,r,IP_TMP, 2,0x33333333) \
	PERMUTE2(r,l,IP_TMP,16,0x0000FFFF) \
	PERMUTE2(l,r,IP_TMP, 4,0x0F0F0F0F)}

#if 0
//----------------------------------------------------------------------
// DES Initial Key permutation (PC-1)
//
// Note: the Output is in reversed bit-Order !
// ----
//
// Description of Operation:
//	 exch. low/high Nibbles
//	 exch. low/high upmost bits C
//	 dto.			    D
//	 exch. odd/even bits
//	 exch. low/high bytes
//	 exch. odd/even bits
//	 assemble D-Bits, note c is used for upmost bits !!
//	 remove D-Bits from C
#endif // 0

#define PC1(d,c) { \
        unsigned int PC1_TMP; \
	PERMUTE2(d,c,PC1_TMP, 4,0x0F0F0F0F)\
	PERMUTE1(c,PC1_TMP,2,0x00003333)\
	PERMUTE1(d,PC1_TMP,2,0x00003333)\
	PERMUTE2(d,c,PC1_TMP, 1,0x55555555)\
	PERMUTE2(c,d,PC1_TMP, 8,0x00FF00FF)\
	PERMUTE2(d,c,PC1_TMP, 1,0x55555555)\
	d= (((d & 0x000000FF) << 16) |\
             (d & 0x0000FF00) | \
            ((d & 0x00FF0000) >> 16) |\
            ((c & 0xF0000000) >>  4));\
	c &= 0x0FFFFFFF;}



//----------------------------------------------------
// constant values
//----------------------------------------------------
const unsigned int DES_KPBox[8][64]=
{
// CP-Box 1 :
{
0x00000000,0x00000010,0x20000000,0x20000010,
0x00010000,0x00010010,0x20010000,0x20010010,
0x00000800,0x00000810,0x20000800,0x20000810,
0x00010800,0x00010810,0x20010800,0x20010810,
0x00000020,0x00000030,0x20000020,0x20000030,
0x00010020,0x00010030,0x20010020,0x20010030,
0x00000820,0x00000830,0x20000820,0x20000830,
0x00010820,0x00010830,0x20010820,0x20010830,
0x00080000,0x00080010,0x20080000,0x20080010,
0x00090000,0x00090010,0x20090000,0x20090010,
0x00080800,0x00080810,0x20080800,0x20080810,
0x00090800,0x00090810,0x20090800,0x20090810,
0x00080020,0x00080030,0x20080020,0x20080030,
0x00090020,0x00090030,0x20090020,0x20090030,
0x00080820,0x00080830,0x20080820,0x20080830,
0x00090820,0x00090830,0x20090820,0x20090830,
},

// CP-Box 2 :
{
0x00000000,0x02000000,0x00002000,0x02002000,
0x00200000,0x02200000,0x00202000,0x02202000,
0x00000004,0x02000004,0x00002004,0x02002004,
0x00200004,0x02200004,0x00202004,0x02202004,
0x00000400,0x02000400,0x00002400,0x02002400,
0x00200400,0x02200400,0x00202400,0x02202400,
0x00000404,0x02000404,0x00002404,0x02002404,
0x00200404,0x02200404,0x00202404,0x02202404,
0x10000000,0x12000000,0x10002000,0x12002000,
0x10200000,0x12200000,0x10202000,0x12202000,
0x10000004,0x12000004,0x10002004,0x12002004,
0x10200004,0x12200004,0x10202004,0x12202004,
0x10000400,0x12000400,0x10002400,0x12002400,
0x10200400,0x12200400,0x10202400,0x12202400,
0x10000404,0x12000404,0x10002404,0x12002404,
0x10200404,0x12200404,0x10202404,0x12202404,
},

// CP-Box 3 :
{
0x00000000,0x00000001,0x00040000,0x00040001,
0x01000000,0x01000001,0x01040000,0x01040001,
0x00000002,0x00000003,0x00040002,0x00040003,
0x01000002,0x01000003,0x01040002,0x01040003,
0x00000200,0x00000201,0x00040200,0x00040201,
0x01000200,0x01000201,0x01040200,0x01040201,
0x00000202,0x00000203,0x00040202,0x00040203,
0x01000202,0x01000203,0x01040202,0x01040203,
0x08000000,0x08000001,0x08040000,0x08040001,
0x09000000,0x09000001,0x09040000,0x09040001,
0x08000002,0x08000003,0x08040002,0x08040003,
0x09000002,0x09000003,0x09040002,0x09040003,
0x08000200,0x08000201,0x08040200,0x08040201,
0x09000200,0x09000201,0x09040200,0x09040201,
0x08000202,0x08000203,0x08040202,0x08040203,
0x09000202,0x09000203,0x09040202,0x09040203,
},

// CP-Box 4 :
{
0x00000000,0x00100000,0x00000100,0x00100100,
0x00000008,0x00100008,0x00000108,0x00100108,
0x00001000,0x00101000,0x00001100,0x00101100,
0x00001008,0x00101008,0x00001108,0x00101108,
0x04000000,0x04100000,0x04000100,0x04100100,
0x04000008,0x04100008,0x04000108,0x04100108,
0x04001000,0x04101000,0x04001100,0x04101100,
0x04001008,0x04101008,0x04001108,0x04101108,
0x00020000,0x00120000,0x00020100,0x00120100,
0x00020008,0x00120008,0x00020108,0x00120108,
0x00021000,0x00121000,0x00021100,0x00121100,
0x00021008,0x00121008,0x00021108,0x00121108,
0x04020000,0x04120000,0x04020100,0x04120100,
0x04020008,0x04120008,0x04020108,0x04120108,
0x04021000,0x04121000,0x04021100,0x04121100,
0x04021008,0x04121008,0x04021108,0x04121108,
},

// DP-Box 1 :
{
0x00000000,0x10000000,0x00010000,0x10010000,
0x00000004,0x10000004,0x00010004,0x10010004,
0x20000000,0x30000000,0x20010000,0x30010000,
0x20000004,0x30000004,0x20010004,0x30010004,
0x00100000,0x10100000,0x00110000,0x10110000,
0x00100004,0x10100004,0x00110004,0x10110004,
0x20100000,0x30100000,0x20110000,0x30110000,
0x20100004,0x30100004,0x20110004,0x30110004,
0x00001000,0x10001000,0x00011000,0x10011000,
0x00001004,0x10001004,0x00011004,0x10011004,
0x20001000,0x30001000,0x20011000,0x30011000,
0x20001004,0x30001004,0x20011004,0x30011004,
0x00101000,0x10101000,0x00111000,0x10111000,
0x00101004,0x10101004,0x00111004,0x10111004,
0x20101000,0x30101000,0x20111000,0x30111000,
0x20101004,0x30101004,0x20111004,0x30111004,
},

// DP-Box 2 :
{
0x00000000,0x08000000,0x00000008,0x08000008,
0x00000400,0x08000400,0x00000408,0x08000408,
0x00020000,0x08020000,0x00020008,0x08020008,
0x00020400,0x08020400,0x00020408,0x08020408,
0x00000001,0x08000001,0x00000009,0x08000009,
0x00000401,0x08000401,0x00000409,0x08000409,
0x00020001,0x08020001,0x00020009,0x08020009,
0x00020401,0x08020401,0x00020409,0x08020409,
0x02000000,0x0a000000,0x02000008,0x0a000008,
0x02000400,0x0a000400,0x02000408,0x0a000408,
0x02020000,0x0a020000,0x02020008,0x0a020008,
0x02020400,0x0a020400,0x02020408,0x0a020408,
0x02000001,0x0a000001,0x02000009,0x0a000009,
0x02000401,0x0a000401,0x02000409,0x0a000409,
0x02020001,0x0a020001,0x02020009,0x0a020009,
0x02020401,0x0a020401,0x02020409,0x0a020409,
},

// DP-Box 3 :
{
0x00000000,0x00000100,0x00080000,0x00080100,
0x01000000,0x01000100,0x01080000,0x01080100,
0x00000010,0x00000110,0x00080010,0x00080110,
0x01000010,0x01000110,0x01080010,0x01080110,
0x00200000,0x00200100,0x00280000,0x00280100,
0x01200000,0x01200100,0x01280000,0x01280100,
0x00200010,0x00200110,0x00280010,0x00280110,
0x01200010,0x01200110,0x01280010,0x01280110,
0x00000200,0x00000300,0x00080200,0x00080300,
0x01000200,0x01000300,0x01080200,0x01080300,
0x00000210,0x00000310,0x00080210,0x00080310,
0x01000210,0x01000310,0x01080210,0x01080310,
0x00200200,0x00200300,0x00280200,0x00280300,
0x01200200,0x01200300,0x01280200,0x01280300,
0x00200210,0x00200310,0x00280210,0x00280310,
0x01200210,0x01200310,0x01280210,0x01280310,
},

// DP-Box 4 :
{
0x00000000,0x04000000,0x00040000,0x04040000,
0x00000002,0x04000002,0x00040002,0x04040002,
0x00002000,0x04002000,0x00042000,0x04042000,
0x00002002,0x04002002,0x00042002,0x04042002,
0x00000020,0x04000020,0x00040020,0x04040020,
0x00000022,0x04000022,0x00040022,0x04040022,
0x00002020,0x04002020,0x00042020,0x04042020,
0x00002022,0x04002022,0x00042022,0x04042022,
0x00000800,0x04000800,0x00040800,0x04040800,
0x00000802,0x04000802,0x00040802,0x04040802,
0x00002800,0x04002800,0x00042800,0x04042800,
0x00002802,0x04002802,0x00042802,0x04042802,
0x00000820,0x04000820,0x00040820,0x04040820,
0x00000822,0x04000822,0x00040822,0x04040822,
0x00002820,0x04002820,0x00042820,0x04042820,
0x00002822,0x04002822,0x00042822,0x04042822,
},
};


const unsigned int DesSPBox[8*64]=
{

// SP-Box 1 :
0x00820200, 0x00020000, 0x80800000, 0x80820200,
0x00800000, 0x80020200, 0x80020000, 0x80800000,
0x80020200, 0x00820200, 0x00820000, 0x80000200,
0x80800200, 0x00800000, 0x00000000, 0x80020000,
0x00020000, 0x80000000, 0x00800200, 0x00020200,
0x80820200, 0x00820000, 0x80000200, 0x00800200,
0x80000000, 0x00000200, 0x00020200, 0x80820000,
0x00000200, 0x80800200, 0x80820000, 0x00000000,
0x00000000, 0x80820200, 0x00800200, 0x80020000,
0x00820200, 0x00020000, 0x80000200, 0x00800200,
0x80820000, 0x00000200, 0x00020200, 0x80800000,
0x80020200, 0x80000000, 0x80800000, 0x00820000,
0x80820200, 0x00020200, 0x00820000, 0x80800200,
0x00800000, 0x80000200, 0x80020000, 0x00000000,
0x00020000, 0x00800000, 0x80800200, 0x00820200,
0x80000000, 0x80820000, 0x00000200, 0x80020200,


// SP-Box 2 :
0x10042004, 0x00000000, 0x00042000, 0x10040000,
0x10000004, 0x00002004, 0x10002000, 0x00042000,
0x00002000, 0x10040004, 0x00000004, 0x10002000,
0x00040004, 0x10042000, 0x10040000, 0x00000004,
0x00040000, 0x10002004, 0x10040004, 0x00002000,
0x00042004, 0x10000000, 0x00000000, 0x00040004,
0x10002004, 0x00042004, 0x10042000, 0x10000004,
0x10000000, 0x00040000, 0x00002004, 0x10042004,
0x00040004, 0x10042000, 0x10002000, 0x00042004,
0x10042004, 0x00040004, 0x10000004, 0x00000000,
0x10000000, 0x00002004, 0x00040000, 0x10040004,
0x00002000, 0x10000000, 0x00042004, 0x10002004,
0x10042000, 0x00002000, 0x00000000, 0x10000004,
0x00000004, 0x10042004, 0x00042000, 0x10040000,
0x10040004, 0x00040000, 0x00002004, 0x10002000,
0x10002004, 0x00000004, 0x10040000, 0x00042000,


// SP-Box 3 :
0x41000000, 0x01010040, 0x00000040, 0x41000040,
0x40010000, 0x01000000, 0x41000040, 0x00010040,
0x01000040, 0x00010000, 0x01010000, 0x40000000,
0x41010040, 0x40000040, 0x40000000, 0x41010000,
0x00000000, 0x40010000, 0x01010040, 0x00000040,
0x40000040, 0x41010040, 0x00010000, 0x41000000,
0x41010000, 0x01000040, 0x40010040, 0x01010000,
0x00010040, 0x00000000, 0x01000000, 0x40010040,
0x01010040, 0x00000040, 0x40000000, 0x00010000,
0x40000040, 0x40010000, 0x01010000, 0x41000040,
0x00000000, 0x01010040, 0x00010040, 0x41010000,
0x40010000, 0x01000000, 0x41010040, 0x40000000,
0x40010040, 0x41000000, 0x01000000, 0x41010040,
0x00010000, 0x01000040, 0x41000040, 0x00010040,
0x01000040, 0x00000000, 0x41010000, 0x40000040,
0x41000000, 0x40010040, 0x00000040, 0x01010000,


// SP-Box 4 :
0x00100402, 0x04000400, 0x00000002, 0x04100402,
0x00000000, 0x04100000, 0x04000402, 0x00100002,
0x04100400, 0x04000002, 0x04000000, 0x00000402,
0x04000002, 0x00100402, 0x00100000, 0x04000000,
0x04100002, 0x00100400, 0x00000400, 0x00000002,
0x00100400, 0x04000402, 0x04100000, 0x00000400,
0x00000402, 0x00000000, 0x00100002, 0x04100400,
0x04000400, 0x04100002, 0x04100402, 0x00100000,
0x04100002, 0x00000402, 0x00100000, 0x04000002,
0x00100400, 0x04000400, 0x00000002, 0x04100000,
0x04000402, 0x00000000, 0x00000400, 0x00100002,
0x00000000, 0x04100002, 0x04100400, 0x00000400,
0x04000000, 0x04100402, 0x00100402, 0x00100000,
0x04100402, 0x00000002, 0x04000400, 0x00100402,
0x00100002, 0x00100400, 0x04100000, 0x04000402,
0x00000402, 0x04000000, 0x04000002, 0x04100400,


// SP-Box 5 :
0x02000000, 0x00004000, 0x00000100, 0x02004108,
0x02004008, 0x02000100, 0x00004108, 0x02004000,
0x00004000, 0x00000008, 0x02000008, 0x00004100,
0x02000108, 0x02004008, 0x02004100, 0x00000000,
0x00004100, 0x02000000, 0x00004008, 0x00000108,
0x02000100, 0x00004108, 0x00000000, 0x02000008,
0x00000008, 0x02000108, 0x02004108, 0x00004008,
0x02004000, 0x00000100, 0x00000108, 0x02004100,
0x02004100, 0x02000108, 0x00004008, 0x02004000,
0x00004000, 0x00000008, 0x02000008, 0x02000100,
0x02000000, 0x00004100, 0x02004108, 0x00000000,
0x00004108, 0x02000000, 0x00000100, 0x00004008,
0x02000108, 0x00000100, 0x00000000, 0x02004108,
0x02004008, 0x02004100, 0x00000108, 0x00004000,
0x00004100, 0x02004008, 0x02000100, 0x00000108,
0x00000008, 0x00004108, 0x02004000, 0x02000008,


// SP-Box 6 :
0x20000010, 0x00080010, 0x00000000, 0x20080800,
0x00080010, 0x00000800, 0x20000810, 0x00080000,
0x00000810, 0x20080810, 0x00080800, 0x20000000,
0x20000800, 0x20000010, 0x20080000, 0x00080810,
0x00080000, 0x20000810, 0x20080010, 0x00000000,
0x00000800, 0x00000010, 0x20080800, 0x20080010,
0x20080810, 0x20080000, 0x20000000, 0x00000810,
0x00000010, 0x00080800, 0x00080810, 0x20000800,
0x00000810, 0x20000000, 0x20000800, 0x00080810,
0x20080800, 0x00080010, 0x00000000, 0x20000800,
0x20000000, 0x00000800, 0x20080010, 0x00080000,
0x00080010, 0x20080810, 0x00080800, 0x00000010,
0x20080810, 0x00080800, 0x00080000, 0x20000810,
0x20000010, 0x20080000, 0x00080810, 0x00000000,
0x00000800, 0x20000010, 0x20000810, 0x20080800,
0x20080000, 0x00000810, 0x00000010, 0x20080010,


// SP-Box 7 :
0x00001000, 0x00000080, 0x00400080, 0x00400001,
0x00401081, 0x00001001, 0x00001080, 0x00000000,
0x00400000, 0x00400081, 0x00000081, 0x00401000,
0x00000001, 0x00401080, 0x00401000, 0x00000081,
0x00400081, 0x00001000, 0x00001001, 0x00401081,
0x00000000, 0x00400080, 0x00400001, 0x00001080,
0x00401001, 0x00001081, 0x00401080, 0x00000001,
0x00001081, 0x00401001, 0x00000080, 0x00400000,
0x00001081, 0x00401000, 0x00401001, 0x00000081,
0x00001000, 0x00000080, 0x00400000, 0x00401001,
0x00400081, 0x00001081, 0x00001080, 0x00000000,
0x00000080, 0x00400001, 0x00000001, 0x00400080,
0x00000000, 0x00400081, 0x00400080, 0x00001080,
0x00000081, 0x00001000, 0x00401081, 0x00400000,
0x00401080, 0x00000001, 0x00001001, 0x00401081,
0x00400001, 0x00401080, 0x00401000, 0x00001001,


// SP-Box 8 :
0x08200020, 0x08208000, 0x00008020, 0x00000000,
0x08008000, 0x00200020, 0x08200000, 0x08208020,
0x00000020, 0x08000000, 0x00208000, 0x00008020,
0x00208020, 0x08008020, 0x08000020, 0x08200000,
0x00008000, 0x00208020, 0x00200020, 0x08008000,
0x08208020, 0x08000020, 0x00000000, 0x00208000,
0x08000000, 0x00200000, 0x08008020, 0x08200020,
0x00200000, 0x00008000, 0x08208000, 0x00000020,
0x00200000, 0x00008000, 0x08000020, 0x08208020,
0x00008020, 0x08000000, 0x00000000, 0x00208000,
0x08200020, 0x08008020, 0x08008000, 0x00200020,
0x08208000, 0x00000020, 0x00200020, 0x08008000,
0x08208020, 0x00200000, 0x08200000, 0x08000020,
0x00208000, 0x00008020, 0x08008020, 0x08200000,
0x00000020, 0x08208000, 0x00208020, 0x00000000,
0x08000000, 0x08200020, 0x00008000, 0x00208020,
};


#define pSPBox	DesSPBox


//======================================================================
// UP DES_encrypt_decrypt,
// performs Des encryption/Decryption
//
// Input Parameters:	int * data		Pointer to Input Data
//						(2 Bit32 values)
//			int * SubKeyTab		Pointer to precomputed
//						DES Subkeys
//			int  mode		Encrypt (0) or
//						Decrypt (<>0) mode
// Output Parameters:	None
//======================================================================
void DES_encrypt_decrypt(unsigned int * data,
			 unsigned int * SubKeyTab,
			 int mode)
{
  int i;
  unsigned int l,r,u,v;

  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do Encryption
  //------------------------------------------------------------
  if(mode == DES_ENCRYPT)			// encryption mode selected
  {
    i=0;
    do
    {
      DES_ROUND(l,r,i,SubKeyTab);		// use subkey 1/5/ 9/13, C'',D''
      DES_ROUND(r,l,i+2,SubKeyTab);		// use subkey 2/6/10/14, C'',D''
      i += 4;
    } while(i<32);
  }
  //------------------------------------------------------------
  // Do Decryption
  //------------------------------------------------------------
  else
  {
    i=30;
    do
    {
      DES_ROUND(l,r,i,SubKeyTab);		// use subkey 16/12/8/4, C'',D''
      DES_ROUND(r,l,i-2,SubKeyTab);		// use subkey 15/11/7/3, C'',D''
      i -= 4;
    } while(i>0);

  }
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}
//======================================================================
// UP DES_encrypt3,
// performs 3 Des encryptions in EDE mode, based on 3 different keys
//
// Input Parameters:	int * data		Pointer to Input Data
//						(2 Bit32 values)
//			int * SubKeyTab1	Pointer to precomputed
//						DES Subkeys from key 1
//			int * SubKeyTab2	Pointer to precomputed
//						DES Subkeys from key 2
//			int * SubKeyTab3	Pointer to precomputed
//						DES Subkeys from key 3
// Output Parameters:	None
//======================================================================
void DES_encrypt3(unsigned int * data,
	          unsigned int * SubKeyTab1,
		  unsigned int * SubKeyTab2,
                  unsigned int * SubKeyTab3)
{
  int i;
  unsigned int  l,r,u,v;

  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do 1st Encryption
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab1);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(r,l,i+2,SubKeyTab1);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // Do 2nd Encryption (is a DECRYPTION!!)
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(r,l,i,SubKeyTab2);	// use subkey 16/12/8/4, C'',D''
    DES_ROUND(l,r,i-2,SubKeyTab2);	// use subkey 15/11/7/3, C'',D''
    i -= 4;
  } while(i>0);
  //------------------------------------------------------------
  // Do 3rd Encryption
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab3);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(r,l,i+2,SubKeyTab3);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}
//======================================================================
// UP DES_decrypt3,
// performs 3 Des decryptions, based on 3 different keys
//
// Input Parameters:	int * data		Pointer to Input Data
//						(2 Bit32 values)
//			int * SubKeyTab1	Pointer to precomputed
//						DES Subkeys from key 1
//			int * SubKeyTab2	Pointer to precomputed
//						DES Subkeys from key 2
//			int * SubKeyTab3	Pointer to precomputed
//						DES Subkeys from key 3
// Output Parameters:	None
//======================================================================
void DES_decrypt3(unsigned int * data,
	          unsigned int * SubKeyTab1,
		  unsigned int * SubKeyTab2,
		  unsigned int * SubKeyTab3)
{
  int i;
  unsigned int l,r,u,v;
  r=data[0];					// get DATA low
  l=data[1];					// get DATA high
  //------------------------------------------------------------
  // Do initial permutation and prepare for E-Box Access
  //------------------------------------------------------------
  IP(r,l);					// do Initial Permutation
  r=LROT1(r);					// prepare for S-Box access
  l=LROT1(l);					// dto.
  //------------------------------------------------------------
  // Do 1st Decryption
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab3);		// use subkey 16/12/8/4, C'',D''
    DES_ROUND(r,l,i-2,SubKeyTab3);		// use subkey 15/11/7/3, C'',D''
    i -= 4;
  }while(i>0);
  //------------------------------------------------------------
  // Do 2nd Decryption (is an Encryption)
  //------------------------------------------------------------
  i=0;
  do
  {
    DES_ROUND(r,l,i,SubKeyTab2);	// use subkey 1/5/ 9/13, C'',D''
    DES_ROUND(l,r,i+2,SubKeyTab2);	// use subkey 2/6/10/14, C'',D''
    i += 4;
  }while(i<32);
  //------------------------------------------------------------
  // Do 3rd Decryption
  //------------------------------------------------------------
  i=30;
  do
  {
    DES_ROUND(l,r,i,SubKeyTab1);		// use subkey 16/12/8/4, C'',D''
    DES_ROUND(r,l,i-2,SubKeyTab1);		// use subkey 15/11/7/3, C'',D''
    i -= 4;
  }while(i>0);
  //------------------------------------------------------------
  // rearrange bits before final permutation, do final permutation
  //------------------------------------------------------------
  l = RROT1(l);				// convert back to original bit order
  r = RROT1(r);				// dto.

  FP(r,l);				// Do Final Permutation
  //------------------------------------------------------------
  //Store new data words, clear used temporary variables (safety)
  //------------------------------------------------------------
  data[0]=l;				// save new low
  data[1]=r;				// save new high
  l=r=u=v=0;				// clear temporary vars.
}
//======================================================================
// UP SplitDESKey
// Splits a given DES into 'Registers' C and D doing initial
// key permutation (PC1)
//
// Input Params  :	char * DesKey	   64 Bit (8*8 Byte) DES Key
// 					   in FIPS46 Bit Order
//			int * CDRegs	   C/D-Registers (Bit-Reversed!!)
//					   Element 0: C-Register
//					   Element 1: D-Register
// Output Params :	none
//======================================================================
static void SplitDESKey(unsigned char * DesKey, int * CDRegs)
{
  unsigned int c,d;
  //
  // 1. Pre-Load DES Key Registers C,D
  //
    char2longn(DesKey,c,0);
    char2longn(DesKey,d,4);
  //
  // 2. Perform Initial Permutation on C,D Registers (PC-1)
  //    this leaves C and D loaded with the appropriate
  //	starting Subkeys in Bitreversed order !!
  //
    PC1(d,c)				// do Key Permutation
  //
  // 3. Store DES Key Registers C,D
  //
  CDRegs[0] = c;
  CDRegs[1] = d;
}
//======================================================================
// UP GenDESSubkeys
// Generates 16 * 2 Subkeys C''/ D'' required for Encryption/Decryption
// from a given DES Key
//
// Input Params  :	char * DesKey	   64 Bit (8*8 Byte) DES Key
// 					   in FIPS46 Bit Order
//			int * SubKeyTab    Subkey Table for storing
//					   16 * 2 * 4 Byte C''/D''
//					   SubKeys
// Output Params :	none
//======================================================================
void GenDESSubKeys(unsigned char * DesKey, unsigned int * SubKeyTab)
{
  unsigned int c,d,s,t;
  unsigned int CDRegs[2];
  int i,j;

#define	pDES_KPBox	DES_KPBox

  //
  // Get DES C,D Registers
  //
    SplitDESKey(DesKey,(int *) CDRegs);
    c = CDRegs[0];
    d = CDRegs[1];
  //
  // 3. Generate Subkeys for direct Exoring to the data before
  //    entering the S-Box Permutation
  //
    i = j = 0;
    do
    {
      //
      // 3.1 rotate C,D registers 1 or 2 bit right (note the mentioned
      // reversed bit order in C and D !!)
      //
      if((i != 0) && (i != 1) && (i != 8) && (i != 15))
      {
        c=RROT2MOD28BIT(c);			// 2 Bits to the right
        d=RROT2MOD28BIT(d);			// dto.
      }
      else
      {
        c=RROT1MOD28BIT(c);			// 1 Bit to the right
        d=RROT1MOD28BIT(d);				// dto.
      }
      //
      // 3.2 Perform Key Compression Permutation PC-2 and
      // reorder output bits / bytes to be suited for XOR
      //
      s= pDES_KPBox[0][  c     & 0x3F                ]| // Bit 1,2,3,4,5,6
         pDES_KPBox[1][((c>> 7)& 0x3C)|((c>> 6)&0x03)]| // Bit 7,8,10,11,12,13
	 pDES_KPBox[2][((c>>14)& 0x30)|((c>>13)&0x0F)]|// Bit14,15,16,17,19,20
         pDES_KPBox[3][((c>>22)& 0x38)|((c>>21)&0x06)| // Bit21,23,24,26,27,28
                       ((c>>20)& 0x01)];

      t= pDES_KPBox[4][  d     &0x3F                 ]|// Bit29,30,31,32,33,34
         pDES_KPBox[5][((d>> 8)& 0x3C)|((d>> 7)&0x03)]|// Bit36,37,39,40,41,42
         pDES_KPBox[6][((d>>15)& 0x3F)               ]|// Bit44,45,46,47,48,49
         pDES_KPBox[7][((d>>22)& 0x30)|((d>>21)&0x0F)];// Bit50,51,53,54,55,56

         SubKeyTab[j] = 				// generate,save C''
            ((t<<16) | (s & 0xFFFF)) & 0xFFFFFFFF;

         t = ((t & 0xFFFF0000)|((s>>16) & 0xFFFF)) &	// generate D''
               0xFFFFFFFF;
      SubKeyTab[j+1] = LROT4(t);			// do pre-rotate, save

       j +=2;
       i ++;
    } while(i < 16);
}
//======================================================================
// UP DES_cbc_encrypt_decrypt,
// performs DES CBC encryption/Decryption with IV store back
//
// Input Parameters:	char * input		Pointer to Input Data buffer
//			char * output		Pointer to Output Data buffer
//			int *  SubKeyTab	Pointer to precomputed
//						DES Subkeys
//			int    BlkCnt		Number of blocks times 8 byte
//						be a multiple of 8 !!!!
//			char * IVector		Initialization Vector
//			int    mode		Encrypt (0) or
//						Decrypt (<>0) mode
// Output Parameters:	none
//======================================================================
void DES_cbc_encrypt_decrypt(unsigned char * input,
			     unsigned char * output,
                             unsigned int * DES_SubkeyTab,
                             int BlkCnt,
                             unsigned char * IVector,
                             int mode)
{
  unsigned int tin0,tin1;
  unsigned int tout0,tout1,xor0,xor1;

  unsigned int tin[2];
  int l=BlkCnt;
  int i,j;


  if(mode == DES_ENCRYPT)
  {
    char2longn(IVector,tout0,0);	// get low portion of IV
    char2longn(IVector,tout1,4);	// dto. high

    i = 0;
    j = 0;
    do
    {
      char2long(input,tin0,i);		// get low  4 data bytes
      char2long(input,tin1,i);		// get high 4 data bytes
      tin[0]=tin0^tout0;
      tin[1]=tin1^tout1;

      DES_encrypt_decrypt(tin,DES_SubkeyTab,DES_ENCRYPT);
      tout0=tin[0];
      long2char(tout0,output,j);
      tout1=tin[1];
      long2char(tout1,output,j);
      l --;
    } while(l != 0);
    long2charn(tout0,IVector,0);
    long2charn(tout1,IVector,4);
  }
  else					// Decrypt
  {
    char2longn(IVector,xor0,0);
    char2longn(IVector,xor1,4);
    i=0;
    j=0;
    do
    {
      char2long(input,tin0,i);
      tin[0]=tin0;
      char2long(input,tin1,i);
      tin[1]=tin1;

      DES_encrypt_decrypt(tin,DES_SubkeyTab,DES_DECRYPT);
      tout0=tin[0]^xor0;
      tout1=tin[1]^xor1;
      long2char(tout0,output,j);
      long2char(tout1,output,j);
      xor0=tin0;
      xor1=tin1;
      l --;
    } while(l != 0);
    long2charn(xor0,IVector,0);
    long2charn(xor1,IVector,4);
  }
  tin0=tin1=tout0=tout1=xor0=xor1=0;
  tin[0]=tin[1]=0;
}
//======================================================================
// UP DES3_ede_cbc_encrypt_decrypt,
// performs triple DES EDE CBC encryption/Decryption with IV store back
//
// Input Parameters:	char * input		Pointer to Input Data buffer
//			char * output		Pointer to Output Data buffer
//			int *  SubKeyTab1	Pointer to Subkey1 Table
//			int *  SubKeyTab2	Pointer to Subkey2 Table
//			int *  SubKeyTab3	Pointer to Subkey3 Table
//			int    BlkCnt		Number of blocks times 8 byte
//			char * IVector		Initialization Vector
//			int    mode		Encrypt (0) or
//						Decrypt (<>0) mode
// Output Parameters:	none
//======================================================================
void DES3_ede_cbc_encrypt_decrypt(unsigned char * input,
			          unsigned char * output,
                                  unsigned int * DES_SubkeyTab1,
                                  unsigned int * DES_SubkeyTab2,
                                  unsigned int * DES_SubkeyTab3,
                                  int BlkCnt,
                                  unsigned char * IVector,
                                  int mode)
{
  unsigned int tin0,tin1;
  unsigned int tout0,tout1,xor0,xor1;

  unsigned int tin[2];
  int l=BlkCnt;
  int i,j;


  if(mode == DES_ENCRYPT)
  {
    char2longn(IVector,tout0,0);	// get low portion of IV
    char2longn(IVector,tout1,4);	// dto. high

    i=0;
    j=0;
    do
    {
      char2long(input,tin0,i);		// get low  4 data bytes
      char2long(input,tin1,i);		// get high 4 data bytes
      tin[0]=tin0^tout0;
      tin[1]=tin1^tout1;

      DES_encrypt3(tin,DES_SubkeyTab1,DES_SubkeyTab2,DES_SubkeyTab3);
      tout0=tin[0];
      long2char(tout0,output,j);
      tout1=tin[1];
      long2char(tout1,output,j);
      l --;
    } while(l != 0);
    long2charn(tout0,IVector,0);
    long2charn(tout1,IVector,4);
  }
  else					// Decrypt
  {
    char2longn(IVector,xor0,0);
    char2longn(IVector,xor1,4);
    i=0;
    j=0;
    do
    {
      char2long(input,tin0,i);
      tin[0]=tin0;
      char2long(input,tin1,i);
      tin[1]=tin1;

      DES_decrypt3(tin,DES_SubkeyTab1,DES_SubkeyTab2,DES_SubkeyTab3);
      tout0=tin[0]^xor0;
      long2char(tout0,output,j);
      tout1=tin[1]^xor1;
      long2char(tout1,output,j);
      xor0=tin0;
      xor1=tin1;
      l --;
    } while(l != 0);
    long2charn(xor0,IVector,0);
    long2charn(xor1,IVector,4);
  }
  tin0=tin1=tout0=tout1=xor0=xor1=0;
  tin[0]=tin[1]=0;
}
//======================================================================
// UP DES_ecb_encrypt_decrypt,
// performs DES ECB encryption/Decryption
//
// Input Parameters:	char * input		Pointer to Input Data buffer
//			char * output		Pointer to Output Data buffer
//			int *  SubKeyTab	Pointer to precomputed
//						DES Subkeys
//			int    BlkCnt		Number of blocks times 8 byte
//			int    mode		Encrypt (0) or
//						Decrypt (<>0) mode
// Output Parameters:	none
//======================================================================
void DES_ecb_encrypt_decrypt(unsigned char * input,
			     unsigned char * output,
                             unsigned int * DES_SubkeyTab,
                             int BlkCnt, int mode)
{
  int i,j;
  unsigned int tin[2];


  i=0;
  j=0;
  while(BlkCnt > 0)
  {
    char2long(input,tin[0],i);		// get low  4 data bytes
    char2long(input,tin[1],i);		// get high 4 data bytes

    DES_encrypt_decrypt(tin,DES_SubkeyTab, mode);

    long2char(tin[0],output,j);
    long2char(tin[1],output,j);
    BlkCnt--;
  }
  tin[0]=tin[1]=0;
}

#undef LROT1
#undef LROT2
#undef LROT3
#undef LROT4
#undef LROT5
#undef LROT6

#undef RROT1
#undef RROT2
#undef RROT3
#undef RROT4
#undef RROT5

#undef RROT1MOD28BIT
#undef RROT2MOD28BIT

#undef char2long
#undef char2longn
#undef long2char
#undef long2charn

#undef PERMUTE2
#undef PERMUTE1
#undef DES_ROUND
#undef IP
#undef FP
#undef PC1
#endif // HL_ENCR_DES
// end of 'hobdes.c'


#ifdef HL_ENCR_DSA
// hobdsadh.c
//===========================================================
//
// This file implements the DSA signature algorithm, the
// DH X9.42 Key exchange algorithm and
// (combined) DSA/DH parameter generation routines.
//
// See US Standards FIPS PUB 186(-1) for description of DSA algorithm
// and DSA parameter generation.
// See RSA PKCS-3 for description of DH algorithm.
// See draft-ietf-smime-X942-076.txt for DH parameter generation.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>


//#define __DEBUG__


//------------------------------------------------
// Defines
//------------------------------------------------
#define MIN_DH_DSA_Q_BITS	160
#define SMALL_PRIME_CNT		1000	// small numbers < 2000, suggested
#define PRIME_CHECK_CNT		20

#define DSA_GEN_TYPE		0	// generate DSA parameters
#define DH_GEN_TYPE		1	// generate DH  parameters

//================================================
// Global Returncodes
//================================================
#define DSA_OP_OK			 0
#define DH_OP_OK			 0
#define DSA_DH_OP_OK			 0	// same as LNUM_OP_OK

#define	DSA_DH_NULL_PTR			-1
#define	DSA_DH_ALLOC_ERR		-3

//================================================
// Specific Returncodes, range is -800 ... -899
//================================================
//------------------------------------------------------------------
// DSA/DH Key-/Parameter generation/check Returncodes, internal only
//------------------------------------------------------------------
#define DSA_DH_GEN_INV_BITSIZE  	-800

#define DSA_DH_CHK_INV_BITSIZE		-805
#define DSA_DH_CHK_INVALID_PUBVAL	-806

#define DSA_DH_KEY_SIZE_ERR		-810
#define DSA_DH_KEY_PRIV_GEN_ERR		-811
#define DSA_DH_KEY_PUBL_GEN_ERR		-812

//------------------------------------------------
// DSA Key generate Returncodes
//------------------------------------------------
#define DSA_GEN_NULL_PTR_ERR		-820
#define DSA_GEN_INV_BITSIZE_ERR		-821
#define DSA_GEN_ALLOC_ERR		-822

//------------------------------------------------
// DSA Signature generate/verify Returncodes
//------------------------------------------------
#define DSA_SIGN_R_DATA_TOO_LARGE	-830
#define DSA_SIGN_S_DATA_TOO_LARGE	-831
#define DSA_SIGN_DATA_TOO_LARGE		-832
#define DSA_SIGN_LNUM_ERR		-833
#define	DSA_SIGN_BUFFER_TOO_SMALL	-834
#define DSA_SIGN_INVALID_HASH_LEN	-835
#define	DSA_SIGN_R_S_ZERO		-836


#define DSA_VERIFY_SIGNAT_TOO_SMALL	-840
#define DSA_VERIFY_ALLOC_ERR		-841
#define	DSA_VERIFY_INVALID_SIGNAT_DATA	-842
#define DSA_VERIFY_NO_R_VALUE		-843
#define DSA_VERIFY_NO_S_VALUE		-844
#define	DSA_VERIFY_INVALID_SIGNAT	-845
#define DSA_VERIFY_LNUM_ERR		-846
#define DSA_VERIFY_INVALID_HASH_LEN	-847

//------------------------------------------------
// DH Params/Secret generate Returncodes
//------------------------------------------------
#define DH_GEN_NULL_PTR_ERR		-850
#define DH_GEN_INV_BITSIZE		-851
#define DH_GEN_ALLOC_ERR		-852

#define DH_COMPUTE_KEY_INV_DATA		-860
#define DH_COMPUTE_KEY_ALLOC_ERR	-861
#define DH_COMPUTE_KEY_EXPMOD_ERR	-862
#define DH_COMPUTE_KEY_LNUM_TO_BIN_ERR	-863


//-------------------------------------------------
// Macros
//-------------------------------------------------
#define BIGchar2wordn(c,w,i) \
  {\
    w = ((int) (((int) c[i] & 0xFF)  << 8)) | \
        ((int) c[i+1] & 0xFF);\
  }

//=================================================================

#if defined __DEBUG__
static void ShowWElement(int WElement, int ZeroSupress)
{
  char c;
  int i = 8;

  while(i != 0)
  {
    c = (char) ((WElement >> 28) & 0x0F);	// get nibble
    WElement <<= 4;				// to next
    if(ZeroSupress != 0)			// Zero supression *IS* active
    {
      if(c != 0)				// is not a zero !
      {
        ZeroSupress = 0;				// deactivate
        c = (char) (c + 0x30);			// to ascii
        if(c > 0x39)
          c = (char) (c + 7);
        printf("%c",c);
      }
    }
    else
    {
      c = (char) (c + 0x30);			// to ascii
      if(c > 0x39)
        c = (char) (c + 7);
      printf("%c",c);
    }
    i--;
  }
  if(ZeroSupress != 0)				// all zeroes
    printf("0");
}


//================================================================
// Show a large number contents in HEX notation
//
// Input Parameters: WLARGENUM * pwLnum
// Returns: Nothing
//
//================================================================
static void FAST ShowLnum(WLARGENUM * pWLnum)
{
  int i;
  int * pEl;

  i = pWLnum->UsedSize;
  if(i == 0)
  {
    printf("0");
    return;
  }

  i--;
  pEl = WLNUM_lpEl(pWLnum);
  ShowWElement(pEl[i], 1);
  while(i != 0)
  {
    printf(" ");
    i--;
    ShowWElement(pEl[i], 0);
  }
  printf("\n");
}
//==============================================================
// Show all DSA structure Components
//
// Input parameters: DSA_STRUC * pDsaStruc
// Returns: nothing
//==============================================================
static void FAST ShowDsaStruc(DSA_STRUC * pDsaStruc)
{
  WLARGENUM * pLnum;

  if(pDsaStruc == NULL)
  {
    printf("No DSA structure available!\n");
    return;
  }

  printf("\nPrime P: ");
  pLnum = pDsaStruc->p;
  if(pLnum == NULL)
  {
    printf("Not Present\n");
  }
  else
  {
    printf("\n");
    ShowLnum(pLnum);
  }

  printf("\nPrime Q: ");
  pLnum = pDsaStruc->q;
  if(pLnum == NULL)
  {
    printf("Not Present\n");
  }
  else
  {
    printf("\n");
    ShowLnum(pLnum);
  }

  printf("\nGenerator G: ");
  pLnum = pDsaStruc->g;
  if(pLnum == NULL)
  {
    printf("Not Present\n");
  }
  else
  {
    printf("\n");
    ShowLnum(pLnum);
  }

  printf("\nPublic value Y: ");
  pLnum = pDsaStruc->y;
  if(pLnum == NULL)
  {
    printf("Not Present\n");
  }
  else
  {
    printf("\n");
    ShowLnum(pLnum);
  }

  printf("\nPrivate value X: ");
  pLnum = pDsaStruc->x;
  if(pLnum == NULL)
  {
    printf("Not Present\n");
  }
  else
  {
    printf("\n");
    ShowLnum(pLnum);
  }
}


#endif // __DEBUG__


//==============================================================
// Get bitsize of a large number
//
// Input Parameters:	WLARGENUM * pNum	Number to query
// Returns: int size in bits, if 0 no bits set / NULL pointer
//==============================================================
static int FAST WLnum_BitSize(WLNUM * pNum)
{
  int UsedSize;
  int * lpEl;

  if(pNum == NULL)				// Null pointer
    return(0);

  UsedSize = pNum->UsedSize;
  if(UsedSize == 0)				// value is 0
    return(0);

  lpEl = pNum->lpEl;			// get pointer
  return(HardGetBitCntWLnumElem(lpEl[UsedSize-1]) +
	 ((UsedSize-1) * 32));
}

//================================================================
//==============================================================
// Subroutine GetAsn1_DER_LenfieldSize calculates required
// number of bytes for ASN.1 DER encoded length field for a
// given data length ( < 32k)
//
// Input params:	int  DataLen		length of data
// Returns:	int LenBytes		<> 0 number of length field bytes
//					== 0 error occured (length too large)
//=============================================================
static int FAST GetAsn1_DER_LenfieldSize(int DataLen)
{
  int i = (DataLen >> 8) & 0xFF;	// get MSB

  if(i > 0x80) return(0);		// too big
  if(DataLen < 0x80) return(1);		// 1 Byte needed
  if(i == 0) return(2);			// 2 bytes needed
  return(3);				// 3 bytes needed
}
//==============================================================
// Subroutine SetAsn1_DER_Lenfield generates ASN.1 encoded
// length field from a given length value (must be < 32K)
// Note: buffer size and length value are not checked!
// -----
//
// Input params:	char * dstbuf		Array base
//			int  dstOffset		Start of data
//			int  dstLen		length of data
//
// Returns: nothing
//=============================================================
static void FAST SetAsn1_DER_Lenfield(char * dstbuf,
				      int dstOffset, int dstLen)
{
  int Index = dstOffset;

  if(dstLen < 0x80)
  {
    dstbuf[Index] = (char) dstLen;
    return;
  }
  if(dstLen < 0x100)
  {
    dstbuf[Index++] = (char) ((unsigned char) 0x81);
    dstbuf[Index] = (char) dstLen;
    return;
  }
  dstbuf[Index++] = (char) ((unsigned char) 0x82);
  dstbuf[Index++] = (char) (dstLen >> 8);
  dstbuf[Index] = (char) dstLen;
}
//==============================================================
// Subroutine GetAsn1_DER_DataLen decodes length of ASN1 DER encoded
// length (no indefinite length, minimal byte values) length < 32 k)
//
// Input params:	char * inpBuf		array base
//			int  inpOffset		Start of data
//			int  inpLen		Data length
//			int * DatLen		length of Data
// Returns:	int LenBytes		<> 0 number of length field bytes (1/2)
//					== 0 error occured (length too large)
//=============================================================
static int FAST GetAsn1_DER_DataLen(char * inpBuf, int inpOffset,
				    int inpLen, int * pDatLen)
{
  int Index=inpOffset;
  int i;

  if(inpLen ==  0) return(0);			// error !!
  i = (int) inpBuf[Index++] & 0xFF;		// get number of bytes
  if((i & 0x80) == 0)				// 1 byte only
  {
    pDatLen[0] = i;
    return(1);
  }
  inpLen--;
  i &= 0x7F;					// get byte count
  if((i == 0) || (i > 2) || (i > inpLen))	// error occured
    return(0);
  pDatLen[0] = (int) inpBuf[Index++] & 0xFF;
  i--;
  if(i == 0) return(2);				// 1 additional byte !
  if((pDatLen[0] & 0x80) != 0)			// overflow !!
    return(0);

  pDatLen[0] <<= 8;				// shift up 1 byte
  pDatLen[0] |=  ((int) inpBuf[Index] & 0xFF);	// insert 2nd byte
  return(3);
}
//==============================================================
// Subroutine DSA_Free, frees an allocated DSA structure,
// including all Large numbers
//
// Input params : DSA_STRUC *	r	Pointer to structure
// Returns:	  Nothing
//==============================================================
void FAST DSA_Free(HMEM_CTX_DEF DSA_STRUC * r)
{
  if(r == NULL) return;
  ClearFreeWLnum(HMEM_CTX_REF1 r->p);
  ClearFreeWLnum(HMEM_CTX_REF1 r->q);
  ClearFreeWLnum(HMEM_CTX_REF1 r->g);
  ClearFreeWLnum(HMEM_CTX_REF1 r->y);
  ClearFreeWLnum(HMEM_CTX_REF1 r->x);
  FREE_CARRAY(HMEM_CTX_REF,r);
}
//==============================================================
// Subroutine DSA_New, allocates a new DSA structure and
// all required Large number structures
//
// Input params :	int pElementcnt		Size of prime p
//			int qElementcnt		Size of factor q
//			int gElementcnt		Size of generator g
//			int yElementcnt		Size of public value  y
//			int xElementcnt		Size of private value x
// Returns:  DSA_STRUC *	<> 0: Pointer to structure
//				== 0: Allocation Error occured
//==============================================================
DSA_STRUC * FAST DSA_New(HMEM_CTX_DEF int pElementcnt,
			          int qElementcnt,
			          int gElementcnt,
			          int yElementcnt,
				  int xElementcnt)
{
  DSA_STRUC * ret;

  ret = (DSA_STRUC *)
          ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(DSA_STRUC)));
  if(ret == NULL) return(NULL);

  ret->p = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt);
  ret->q = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->g = AllocNewWLnum(HMEM_CTX_REF1 gElementcnt);
  ret->y = AllocNewWLnum(HMEM_CTX_REF1 yElementcnt);
  ret->x = AllocNewWLnum(HMEM_CTX_REF1 xElementcnt);

  if((ret->x == NULL) || (ret->y == NULL) ||
     (ret->p == NULL) || (ret->q == NULL) ||
     (ret->g == NULL))
  {
    DSA_Free(HMEM_CTX_REF1 ret);
    return(NULL);
  }
  return(ret);
}
//==============================================================
// Subroutine DSA_BitSize gets the size of DSA Modulus in Bits
//
// Input Parameters:	DSA_STRUC * dsa	Start of structure
// Return: 	int	> 0: length of prime p in Bits
//			== 0 : no prime/no structure
//==============================================================
int FAST DSA_BitSize(DSA_STRUC * dsa)
{
  if((dsa == NULL) || (dsa->p == NULL)) return(0);
  return(WLnum_BitSize(dsa->p));
}
//==============================================================
// Subroutine DSA_MaxLen calculates required maximal buffer size for
// DSA signature for given DSA parameters.
//
// ASN.1 DSA-Signature: SEQUENCE { INTEGER r, INTEGER s}
//
// Input params : DSA_STRUC * dsa	Pointer to structure
// Returns:  int size			<> 0: required size
//					== 0: error occured
//==============================================================
int DSA_SignatMaxLen(DSA_STRUC * dsa)
{
  int i,len,qsize;

  if((dsa == NULL) || (dsa->q == NULL))  return(0);	// no structure/q-value
  qsize = GetByteCntWLnum(dsa->q);			// get byte-count of q
  if(qsize == 0) return(0);				// invalid value !
  qsize++;						// incl. leading zero
  //-------------------------------------------------------
  // get required ASN.1 length field for Integers r,s
  //-------------------------------------------------------
  i=GetAsn1_DER_LenfieldSize(qsize);
  if(i == 0) return(0);					// invalid
  len = (qsize + i + 1) * 2;				// length incl.INTEGER
  //-------------------------------------------------------
  // get required ASN.1 length field for sequence
  //-------------------------------------------------------
  i=GetAsn1_DER_LenfieldSize(len);
  if(i == 0) return(0);					// invalid
  return(len + i + 1);
}
//==============================================================
// Subroutine DH_Free clears/frees an allocated Diffie-Hellman
// parameter structure and its elements.
//
// Input Parameters:	DH_STRUC * r	Start of structure
// Return: nothing
//==============================================================
void FAST DH_Free(HMEM_CTX_DEF DH_STRUC * r)
{
  if(r == NULL) return;
  ClearFreeWLnum(HMEM_CTX_REF1 r->p);
  ClearFreeWLnum(HMEM_CTX_REF1 r->q);
  ClearFreeWLnum(HMEM_CTX_REF1 r->g);
  ClearFreeWLnum(HMEM_CTX_REF1 r->j);
  ClearFreeWLnum(HMEM_CTX_REF1 r->PubKey);

  ClearFreeWLnum(HMEM_CTX_REF1 r->PrivKey);
  FreeWLnum(HMEM_CTX_REF1 r->Seed);
  FREE_CARRAY(HMEM_CTX_REF,r);
}
//==============================================================
// Subroutine DH_New, allocates a new DH structure and
// all required Large number structures
//
// Input params :	int pElementcnt		Size of prime p
// 			int qElementcnt		Size of prime q
//			int gElementcnt		Size of generator g
//			int yElementcnt		Size of public value  y
//			int xElementcnt		Size of private value x
// Return: DH_STRUC *		<> 0 o.k.
//				== 0 allocation error occured
//==============================================================
DH_STRUC * FAST DH_New(HMEM_CTX_DEF int pElementcnt,
				int qElementcnt,
				int gElementcnt,
				int yElementcnt,
				int xElementcnt)
{
  int i;
  DH_STRUC * ret;

  ret = (DH_STRUC *)
          ((void *) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,sizeof(DH_STRUC)));
  if (ret == NULL) return(NULL);

  i = pElementcnt - qElementcnt;
  if(i < 0) i = -i;
  ret->p = AllocNewWLnum(HMEM_CTX_REF1 pElementcnt);
  ret->q = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->g = AllocNewWLnum(HMEM_CTX_REF1 gElementcnt);
  ret->j = AllocNewWLnum(HMEM_CTX_REF1 i);
  ret->PubKey  = AllocNewWLnum(HMEM_CTX_REF1 yElementcnt);
  ret->PrivKey = AllocNewWLnum(HMEM_CTX_REF1 xElementcnt);
  ret->Seed    = AllocNewWLnum(HMEM_CTX_REF1 qElementcnt);
  ret->PrivLen = 0;
  ret->PgenCount = 0;

  if((ret->p == NULL) || (ret->q == NULL) ||
     (ret->g == NULL) || (ret->j == NULL) ||
     (ret->PubKey == NULL) || (ret->PrivKey == NULL) ||
     (ret->Seed == NULL))
  {
    DH_Free(HMEM_CTX_REF1 ret);
    return(NULL);
  }
  return(ret);
}	
//==============================================================
// Subroutine DH_size gets the size of a Diffie-Hellman
// parameter structure's prime p length in bytes.
//
// Input Parameters:	DH_STRUC * dh	Start of structure
// Return: 	int	> 0: length of prime p
//			== 0 : no prime/no structure
//==============================================================
int FAST DH_Size(DH_STRUC * dh)
{
  if((dh == NULL) || (dh->p == NULL)) return(0);
  return(GetByteCntWLnum(dh->p));
}
//==============================================================
// Subroutine DH_BitSize gets the size of DH Modulus in Bits
//
// Input Parameters:	DH_STRUC * dh	Start of structure
// Return: 	int	> 0: length of prime p in Bits
//			== 0 : no prime/no structure
//==============================================================
int FAST DH_BitSize(DH_STRUC * dh)
{
  if((dh == NULL) || (dh->p == NULL)) return(0);
  return(WLnum_BitSize(dh->p));
}
//==============================================================
// Subroutine DH_ParamCompare compares two DH structures for
// same Dh-Parameters p, q and g, which must all be of length <> 0
//
// Input Parameters:	DH_STRUC * Dh1	Start of structure 1
//			DH_STRUC * Dh2	Start of structure 2
//
// Return: 	int	!= 0 : not same / Zero pointer/values
//			== 0 : same, valid p,q, g params
//==============================================================
int FAST DH_ParamCompare(DH_STRUC * Dh1, DH_STRUC * Dh2)
{

  if((Dh1 == NULL) || (Dh2 == NULL))	// one or both absent
    return(1);
  //----------------------------------------------------------
  // Check if all 3 parameters are loaded and have length <> 0
  //----------------------------------------------------------
  if((Dh1->p == NULL) || (Dh2->p == NULL))
    return(1);

  if((Dh1->p->UsedSize == 0) || (Dh2->p->UsedSize == 0))
    return(1);

  if((Dh1->g == NULL) || (Dh2->g == NULL))
    return(1);

  if((Dh1->g->UsedSize == 0) || (Dh2->g->UsedSize == 0))
    return(1);
  //----------------------------------------------------------
  // All Parameters present, compare
  //----------------------------------------------------------
  if(UcompWLnum(Dh1->p,Dh2->p) != WLNUM_1ST_EQ_2ND)
    return(1);

  if(UcompWLnum(Dh1->g,Dh2->g) != WLNUM_1ST_EQ_2ND)
    return(1);

  return(0);
}
//==============================================================
// Subroutine DSA_Sign, generates DSA signature from given message
// using SHA1 message digest or plain input (already hashed).
//
// Input params :	char * msgbuf		Message buffer array base
//			int  msgOffset		Start index of message
//			int  msgLen		length of message
//			char * sig		Signature buffer array base
//			int  sigOffset		Start index of signature
//			int * psigLen		length of signature buffer
//			DSA_STRUC * dsa		DSA structure base
//			WLARGENUM * kTest	if <> 0, replaces random
//						number for test purposes
//			int  Mode		== 0 do SHA1 hash of input
//						!= 0 use input as SHA1 hash
//
// Returns:  Status				== DSA_OP_OK - o.k.
//						else: Error occured
//==============================================================
int FAST DSA_Sign(HMEM_CTX_DEF
			char * msgBuf, int msgOffset, int msgLen,
			char * sigBuf, int sigOffset, int * psigLen,
			DSA_STRUC * dsa, WLNUM * kTest,int Mode)
{

  int i,j,l,SeqLen,NumLen,rLen,sLen;

  int ret=DSA_OP_OK;
  int reason=LNUM_OP_OK;

  int DgstOffset = 0;

  char * pDgst;

  char dgst[SHA_DIGEST_LEN];
  int sha[SHA_ARRAY_SIZE];
  int tmpLen;

  WLNUM * m = NULL;
  WLNUM * k = NULL;
  WLNUM * kinv = NULL;
  WLNUM * r = NULL;
  WLNUM * s = NULL;

  for(;;)				// outer processing loop
  {
    if(Mode == 0)			// must hash
    {
      pDgst = dgst;			// use local buffer later
      //---------------------------------------------------
      // generate SHA1 Hash
      //---------------------------------------------------
      SHA1_Init(sha);					// initialize
      SHA1_Update(sha,msgBuf,msgOffset,msgLen);		// generate
      SHA1_Final(sha,dgst,0);				// store
    }
    else				// no hashing required
    {
      pDgst      = msgBuf;
      DgstOffset = msgOffset;
    }
    //---------------------------------------------------
    // allocate required large numbers
    //---------------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    m = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    r = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    s = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    k = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    kinv = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if(m == NULL || r == NULL || s == NULL || k == NULL || kinv == NULL)
    {
      reason = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-----------------------------------------------------
    // convert digest from binary to large number for calc,
    // get 160 Bit Random, compute s and r params
    //-----------------------------------------------------
							// to large number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			m,pDgst,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    if(kTest != NULL)
      reason = CopyWLnum(HMEM_CTX_REF1 k,kTest);	// use given value
    else
      reason = WLnumRand(HMEM_CTX_REF1 k,160,1,0);	// get 160 Bit random

    if(reason != LNUM_OP_OK)
      break;

    // Compute r = (g^k mod p) mod q

							// s = g^k mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		    s,dsa->g,k,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;

							// r = s mod q
    if((reason = DivWLnum(HMEM_CTX_REF1
			   NULL, r,s,dsa->q,NULL)) != LNUM_OP_OK)
      break;


    // Compute  s = inv(k) (m + xr) mod q

							// s = x * r
    if((reason = MulWLnum(HMEM_CTX_REF1
			   s,dsa->x,r)) != LNUM_OP_OK)
      break;
							// s = x * r + m
    if((reason = AddWLnum(HMEM_CTX_REF1
			   s,s,m)) != LNUM_OP_OK)
      break;
							 // kinv = k^-1 mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1
			       kinv,k,dsa->q,NULL)) != LNUM_OP_OK)
      break;
							// s = (s * kinv) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       s, s, kinv,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------
    // assure that nor s neither t are 0 (is invalid!)
    //------------------------------------------------------
    if((IsZeroWLnum(r) != 0) || (IsZeroWLnum(s) != 0))
    {
      reason = DSA_SIGN_R_S_ZERO;
      break;
    }

    //------------------------------------------------------
    // get length for r and s byte strings
    // NOTE: Obey leading zero for ASN.1 integer coding
    //------------------------------------------------------
    rLen = GetByteCntWLnum(r);			// get length in byte
    i = r->UsedSize;				// get element count
    j = HardGetByteCntWLnumElem(r->lpEl[i-1]);// number of bytes in highest

    if((r->lpEl[i-1] & ((int) 0x80 << ((j-1)*8))) != 0) //MSB bit set
      rLen++;

    sLen = GetByteCntWLnum(s);			// get length in byte
    i = s->UsedSize;				// get element count
    j = HardGetByteCntWLnumElem(s->lpEl[i-1]);// number of bytes in highest

    if((s->lpEl[i-1] & ((int) 0x80 << ((j-1)*8))) != 0) //MSB bit set
      sLen++;

    i = GetAsn1_DER_LenfieldSize(rLen);			// get length bytes
    if(i == 0)
    {
      ret = DSA_SIGN_R_DATA_TOO_LARGE;
      break;
    }
    j = GetAsn1_DER_LenfieldSize(sLen);			// get length bytes
    if(j == 0)
    {
      ret = DSA_SIGN_S_DATA_TOO_LARGE;
      break;
    }
    l = rLen + sLen + i + j + 2;			// length of r,s
    NumLen = GetAsn1_DER_LenfieldSize(l);		// seq. length
    if(NumLen == 0)
    {
      ret = DSA_SIGN_DATA_TOO_LARGE;
      break;
    }
    SeqLen = NumLen + l;				// total size
    if((SeqLen+1) > psigLen[0])
    {
      ret = DSA_SIGN_DATA_TOO_LARGE;
      break;
    }
    psigLen[0] = SeqLen + 1;
    //------------------------------------------------------
    // generate ASN.1 sequence
    //------------------------------------------------------
    sigBuf[sigOffset++] = (char) 0x30;			// set sequence
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,l);		// set length field
    sigOffset += NumLen;
    //------------------------------------------------------
    // generate ASN.1 integer r
    //------------------------------------------------------
    sigBuf[sigOffset++] = 0x02;				// set integer
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,rLen);	// set length field
    sigOffset += i;
    tmpLen = rLen;
							//to string
    if((reason = WLnum_wlnum2bin(sigBuf,sigOffset,&tmpLen,r,1)) != LNUM_OP_OK)
      break;

    sigOffset += rLen;
    //------------------------------------------------------
    // generate ASN.1 integer s
    //------------------------------------------------------
    sigBuf[sigOffset++] = 0x02;				// set integer
    SetAsn1_DER_Lenfield(sigBuf,sigOffset,sLen);	// set length field
    sigOffset += j;
    tmpLen = sLen;
							//to string
    reason = WLnum_wlnum2bin(sigBuf,sigOffset,&tmpLen,s,1);
    break;
  } // for

#if defined __DEBUG__
  if(reason != 0)
  {
    ShowDsaStruc(dsa);
    printf("Random value k: ");
    if(k == NULL)
    {
      printf("Not present!\n");
    }
    else
      ShowLnum(k);
  }
#endif


  FreeWLnum(HMEM_CTX_REF1 m);
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 s);
  FreeWLnum(HMEM_CTX_REF1 k);
  FreeWLnum(HMEM_CTX_REF1 kinv);
  if(reason != LNUM_OP_OK)
    return(DSA_SIGN_LNUM_ERR);
  return(ret);
}
//==============================================================
// Subroutine DSA_Verify, verifies given DSA signature for a
// given message using SHA1 message digest or plain input
//
// Input params :	char * msgbuf		Message buffer array base
//			int  msgOffset		Start index of message
//			int  msglen		length of message
//			char * sigbuf		Signature buffer array base
//			int  SigOffset		Start index of signature
//			int  siglen		length of signature buffer
//			DSA_STRUC * dsa		DSA structure base
//			int  Mode		== 0 do SHA1 hash of input
//						!= 0 use input as SHA1 hash
//
// Returns:  Status				== 1 - o.k.
//						<  1 Error occured
//==============================================================
int FAST DSA_Verify(HMEM_CTX_DEF
			char * msgBuf, int msgOffset, int msgLen,
			char * sigBuf, int sigOffset, int sigLen,
		        DSA_STRUC * dsa, int Mode)
{
  int i,NumLen,SeqLen;
  int ret = DSA_OP_OK;
  int reason = LNUM_OP_OK;

  int DgstOffset=0;
  char * pDgst;

  int DataLen;

  char dgst[SHA_DIGEST_LEN];
  int sha[SHA_ARRAY_SIZE];

  WLNUM * r  = NULL;
  WLNUM * t1 = NULL;
  WLNUM * t2 = NULL;
  WLNUM * u1 = NULL;
  WLNUM * u2 = NULL;

  if(sigLen < 8) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
  //-----------------------------------------------
  // FOR-Loop for easier error handling
  //-----------------------------------------------
  for(;;)
  {
    if(Mode == 0)				// must hash first
    {
      pDgst = dgst;
      //---------------------------------------------------
      // generate SHA1 Hash
      //---------------------------------------------------
      SHA1_Init(sha);				// initialize
      SHA1_Update(sha,msgBuf,msgOffset,msgLen);	// generate
      SHA1_Final(sha,dgst,0);			// store
    }
    else					// use as direct input
    {
      pDgst      = msgBuf;
      DgstOffset = msgOffset;
    }
    //---------------------------------------------
    // Allocate temporary large numbers
    //---------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    r  = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if((r==NULL) || (u1==NULL) || (u2==NULL) || (t1==NULL) || (t2 == NULL))
    {
      ret = DSA_VERIFY_ALLOC_ERR;
      break;
    }
    //---------------------------------------------
    // Decode the ASN.1 sequence from the signature buffer:
    // 1. Get/Check length of Sequence
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x30)		// must be a sequence
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;					// reduce length

    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,&DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    SeqLen = DataLen;
    sigOffset += i;				// skip bytes
    sigLen -= i;				// reduce length
    if(sigLen < SeqLen) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    SeqLen -= 2;				// reduce INT prefixes
    //---------------------------------------------
    // 2. Get/Check length of number r
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x02)		// must be an integer
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;
    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,&DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    sigOffset += i;				// skip bytes
    sigLen -= i;				// reduce count
    SeqLen -= i;				// dto.
    NumLen = DataLen;				// get length
    if(NumLen >= SeqLen) return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    //---------------------------------------------
    // 3. load number r into LNUM structure
    //---------------------------------------------

    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
				 r,sigBuf,sigOffset,NumLen)) != LNUM_OP_OK)
      break;
    SeqLen -= NumLen;
    sigOffset += NumLen;
    sigLen -= NumLen;
    if(sigLen < 2)
      return(DSA_VERIFY_SIGNAT_TOO_SMALL);
    //---------------------------------------------
    // 4. Get/Check length of number s
    //---------------------------------------------
    if(sigBuf[sigOffset++] != 0x02)		// must be an integer
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    sigLen--;					// reduce count
    i = GetAsn1_DER_DataLen(sigBuf,sigOffset,sigLen,&DataLen);
    if(i == 0)
    {
      reason = DSA_VERIFY_INVALID_SIGNAT_DATA;
      break;
    }
    sigOffset += i;				// skip bytes
    SeqLen -= i;				// dto.
    NumLen = DataLen;
    if(NumLen != SeqLen)
      return(DSA_VERIFY_INVALID_SIGNAT_DATA);
    //---------------------------------------------
    // 5. load number s into LNUM structure
    //---------------------------------------------
						// convert s to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			u1,sigBuf,sigOffset,NumLen)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate w = (S^-1) mod q
    //-----------------------------------------------------------
						// w = u2 = (s^-1) mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1
			       u2,u1,dsa->q,NULL)) != LNUM_OP_OK)
      break;
						 // convert M to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			u1,pDgst,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u1 = (M' * w) mod q
    //-----------------------------------------------------------
						// u1 = (M'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       u1,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u2 = (r' * w) mod q
    //-----------------------------------------------------------
						 // u2 = (r'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       u2,r,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate v = (((g^u1) * (y^u2)) mod p) mod q =
    //                (((g^u1) mod p) * ((y^u2) mod p) mod p) mod q
    //-----------------------------------------------------------
							// t1 = (g^u1) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		   t1,dsa->g,u1,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// t2 = (y^u2) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		   t2,dsa->y,u2,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;

							//u2 = (t1 * t2) mod p
    if((reason = MulModWLnum(HMEM_CTX_REF1
			u2,t1,t2,dsa->p,NULL)) != LNUM_OP_OK)
      break;

							 // u1 = u2 mod q
    if((reason = DivWLnum(HMEM_CTX_REF1
			   NULL,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // V is now in u1.  If the signature is correct, it will be
    // equal to R.
    //-----------------------------------------------------------
    i = UcompWLnum(u1,r);				// compare
    if(i != WLNUM_1ST_EQ_2ND)
      ret = DSA_VERIFY_INVALID_SIGNAT;
    break;
  } // Error FOR loop
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 t1);
  FreeWLnum(HMEM_CTX_REF1 t2);
  FreeWLnum(HMEM_CTX_REF1 u1);
  FreeWLnum(HMEM_CTX_REF1 u2);
  if(reason != LNUM_OP_OK)
    return(DSA_VERIFY_LNUM_ERR);
  return(ret);
}
//===========================================================
//
// Routines for DSA/DH Parameter generation
//
//===========================================================

//-----------------------------------------------------------
// Subroutine AddByteToBufMod2n adds a byte value to a number
// in BIG ENDIAN order in a byte buffer and does modulo reduction
// to 2^n (i.e. discard all bits that would be larger 2^n) according
// to the given bitmask for the topmost element.
//
// Input Parameters:	char *	Buf	Buffer containing number (BIG ENDIAN)
//			int	Offset	Start of Data
//			int	Len	Number of Bytes in buffer	
//			unsigned char AddVal	Value to Add
//			char	BitMask	Mask for topmost (MSB) bits [Modulo]
//
// Returns: nothing
//-----------------------------------------------------------
static void AddByteToBufMod2n(char * Buf, int Offset, int Len,
			      unsigned char AddVal, char BitMask)
{
  int Index = Offset+Len-1;		// Start of LSB byte
  int Sum = AddVal & 0xFF;

  if(Len == 0) return;			// nothing to do

  do
  {
    Sum += ((int) Buf[Index] & 0xFF);	// Add up
    Buf[Index--] = (unsigned char) Sum;
    Sum = (Sum >> 8) & 0xFF;
    Len--;
  }while(Len != 0);
  Buf[Index+1] &= BitMask;		// do modulo reduction
}
//--------------------------------------------------------------------
// Subroutine GenDsaDhParams generates DSA/DH parameters
// p, q, g, j and the associated verification values Seed and Counter
//
// Input parameters:	int L		Bitsize prime p
//			int m		Bitsize prime q, >= 160
//			int ncheck	Miller Rabin check count
//			int Type	== 0 -> DSA /  <> 0 -> DH
//			WLARGENUM * p	generated prime p
//			WLARGENUM * q	generated prime q
//			WLARGENUM * g	generated group parameter g
//			WLARGENUM * j	subgroup factor / NULL
//			WLARGENUM * Seed used seed / NULL
//			int * Counter	counter for p / NULL
//			void * callback(int) Callback Function
//
// Returns: int Status		LNUM_OP_OK o.k.
//				else error occured
//
//--------------------------------------------------------------------
int GenDsaDhParams(HMEM_CTX_DEF  int L, int m, int ncheck,
				 int Type,
				 WLNUM * p, WLNUM * q, WLNUM * g, WLNUM * j,
				 WLNUM * Seed, int * pCounter,
				 void callback(int))
{
  int Retcode = LNUM_OP_OK;

  char * pSeed	    = NULL;
  char * pSeedCalc1 = NULL;
  char * pSeedCalc2 = NULL;

  char * pNumberU   = NULL;
  char * pNumberW   = NULL;

  char Sha1Dgst1[SHA_DIGEST_LEN];
  char Sha1Dgst2[SHA_DIGEST_LEN];

  int sha[SHA_ARRAY_SIZE];

  unsigned char bMask;
  unsigned char dMask;

  int	i,k,l;
  int   b,n,t,d;
  int	bCnt,dCnt;
  int	VLen,SLen;
  int	Index;
  int	PgenCnt = 0;
  int	StopFlag = 0;

  int TmpInt;

  WLNUM * lp2q  = NULL;
  WLNUM * lpX   = NULL;
  WLNUM * lpTmp = NULL;

  short * primarray=NULL;			// prime number array
  //----------------------------------------------
  // Check Parameters
  //----------------------------------------------
  if((p == NULL) || (q == NULL) || (g == NULL))
    return(LNUM_OP_NULL_PTR);

  if(m < MIN_DH_DSA_Q_BITS)
    return(DSA_DH_GEN_INV_BITSIZE);

  if(Type == 0)					// DSA
  {
    if((m != MIN_DH_DSA_Q_BITS) || (L < 512) || (L > 1024) ||
       (((L - 512) & 0x1F) != 0))
    return(DSA_DH_GEN_INV_BITSIZE);
  }
  else
  {
    if(L <= m+1)
      return(DSA_DH_GEN_INV_BITSIZE);
  }
  //----------------------------------------------
  // Calculate constants
  //----------------------------------------------
  n = (L-1) / MIN_DH_DSA_Q_BITS;		// full digests V count
  b = (L-1) - n*MIN_DH_DSA_Q_BITS;		// remaining bits
  bCnt = (b + 7) / 8;				// number of bytes
  VLen = n * SHA_DIGEST_LEN + bCnt;		// total bytes
  b &= 0x07;					// remaining bits
  bMask = (unsigned char) 0xFF;			// do not mask bits
  if(b != 0) bMask =(unsigned char) ~(bMask << b); // generate bitmask

  t = m / MIN_DH_DSA_Q_BITS;			// full digests S count
  d = m - t * MIN_DH_DSA_Q_BITS;		// remaining bits
  dCnt = (d + 7) / 8;				// number of bytes
  SLen = t * SHA_DIGEST_LEN + dCnt;		// total Bytes
  d &= 0x07;					// remaining bits
  dMask = (unsigned char) 0xFF;			// do not mask bits
  if(d != 0) dMask = (unsigned char) ~(dMask << d); // generate bitmask
  //----------------------------------------------
  // Allocate required buffers and prime array
  //----------------------------------------------
  pSeed      = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // m bit long Seed
  pSeedCalc1 = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // same for S generation
  pSeedCalc2 = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // dto.
  pNumberW   = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,VLen+1); // L bit long number
  pNumberU   = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,SLen); // m bit long number
  primarray  = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,SMALL_PRIME_CNT); // number array
  if((pSeed == NULL) || (pSeedCalc1 == NULL) ||
     (pSeedCalc2 == NULL) || (pNumberU == NULL) ||
     (pNumberW == NULL) || (primarray == NULL))
  {
    FREE_ARRAY(HMEM_CTX_REF,pSeed);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
    FREE_ARRAY(HMEM_CTX_REF,pNumberU);
    FREE_ARRAY(HMEM_CTX_REF,pNumberW);
    FREE_ARRAY(HMEM_CTX_REF,primarray);
    return(LNUM_OP_ALLOC_ERR);
  }
  //----------------------------------------------
  // Get required large numbers.....
  //----------------------------------------------
  lp2q  = AllocNewWLnum(HMEM_CTX_REF1 (SLen + 4 - 1)/4); // 2 times m size
  lpX   = AllocNewWLnum(HMEM_CTX_REF1 (VLen + 4 - 1) / 4); // size L
  lpTmp = AllocNewWLnum(HMEM_CTX_REF1 (VLen + 4 - 1) / 4);
  if((lpX == NULL) || (lp2q == NULL) || (lpTmp == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 lp2q);
    FreeWLnum(HMEM_CTX_REF1 lpX);
    FreeWLnum(HMEM_CTX_REF1 lpTmp);
    FREE_ARRAY(HMEM_CTX_REF,pSeed);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
    FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
    FREE_ARRAY(HMEM_CTX_REF,primarray);
    FREE_ARRAY(HMEM_CTX_REF,pNumberW);
    FREE_ARRAY(HMEM_CTX_REF,pNumberU);
    return(LNUM_OP_ALLOC_ERR);
  }
  //----------------------------------------------
  // Generate small prime Array
  //----------------------------------------------
  DoEratosthenesWSieve(HMEM_CTX_REF1 primarray,SMALL_PRIME_CNT);

  //----------------------------------------------
  // Generate prime q,p and group params g
  //----------------------------------------------
  for(;;)				// Error FOR
  {
    if(callback != NULL)
    {
      callback(0);
    }
    //----------------------------------------------
    // A. Generate prime q
    //----------------------------------------------
    for(;;)				// q Generate FOR
    {
      //----------------------------------------------------------
      // 1. Get the Seed of length m bit, prepare calculation
      //----------------------------------------------------------
      Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSeed,0,SLen);
      if(Retcode != 0)
        break;


      pSeed[0] &= dMask;				// ignore masked bits
      if(d == 0)
        pSeed[0] |= 0x80;				// set top bit
      else
      {
        pSeed[0] = (char)
          (pSeed[0] | (0x01 << (d-1)));			// dto.
      }
      memcpy(pSeedCalc1,pSeed,SLen);		  // copy for calculation
      memcpy(pSeedCalc2,pSeed,SLen);		  // copy for calculation

      AddByteToBufMod2n(pSeedCalc2,0,SLen,	// add t
	  	        (unsigned char) t,dMask);
      //----------------------------------------------------------
      // 2. Format Number U resp. p from S(0) ... S(t-1)
      //----------------------------------------------------------
      Index = SLen;					// past last byte
      i = 0;
      for(;;)
      {
        //--------------------------------------------------
        // Get Hashes for current i, XOR them together
        //--------------------------------------------------
        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc1,0,SLen);	// generate hash 1
        SHA1_Final(sha,Sha1Dgst1,0);

        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc2,0,SLen);	// generate hash 2
        SHA1_Final(sha,Sha1Dgst2,0);
        k = SHA_DIGEST_LEN;				// Counter and Index
        do
        {
          k--;						// pre-decrement
          Sha1Dgst1[k] ^= Sha1Dgst2[k];			// XOR
        }while(k != 0);
        //--------------------------------------------------
        // put the full / partial  hashes to number U
        //--------------------------------------------------
        if(i < t)					// full hash to copy
        {
          Index -= SHA_DIGEST_LEN;
          memcpy(pNumberU+Index,Sha1Dgst1,SHA_DIGEST_LEN);

          AddByteToBufMod2n(pSeedCalc1,0,SLen,(char) 1,dMask);	// add 1
          AddByteToBufMod2n(pSeedCalc2,0,SLen,(char) 1,dMask);	// add 1
        }
        else						// not a full hash
        {
          Index -= dCnt;
          if(dCnt != 0)					// bytes to copy
          {
            memcpy(pNumberU+Index,Sha1Dgst1+SHA_DIGEST_LEN-1-dCnt,dCnt);
            pNumberU[Index] &= dMask;			// ignore bits
          }
          pNumberU[SLen-1] |= 0x01;			// make odd
          if(d == 0)					// full bytes
            pNumberU[Index] |= 0x80;			// set top most
          else
          {
            pNumberU[Index] = (char)
              (pNumberU[Index] | (0x01 << (d-1)));	// set bit m
          }
          break;
        }
        i++;
      } // U-Generate for
      //----------------------------------------------------------
      // 3. Convert number to internal format, weed out small primes
      //----------------------------------------------------------
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
				    q,pNumberU,0,SLen)) != LNUM_OP_OK)
        break;

      i = 0;
      do
      {
        if(ModWordWLnum(q,primarray[i]) == 0)	// get p mod (prime)
          break;				// not prime
        i++;
      }while(i < SMALL_PRIME_CNT);
      if(i == SMALL_PRIME_CNT)			// all test passed
      {

#if 0
        printf("Prime Candidate: ");
        ShowLnum(q);
#endif

        if(callback != NULL)
        {
          callback(1);
        }

        Retcode = WLnumMillerRabin(HMEM_CTX_REF1
				   q,ncheck,&TmpInt,NULL,callback);
        if(Retcode != LNUM_OP_OK)
          break;
        if(TmpInt == 0)				// found a prime q !!
          break;
        if(callback != NULL)
        {
          callback(2);
        }
      }
//      printf("d");
    } // q generate FOR
    if(Retcode != LNUM_OP_OK) break;		// error occured
//    printf("\nFound q\n");
    if(callback != NULL)
    {
      callback(4);
    }
    //----------------------------------------------
    // B. Generate prime p from seed and q
    //----------------------------------------------
    PgenCnt = 0;
    memcpy(pSeedCalc1,pSeed,SLen);		// copy for calculation
    AddByteToBufMod2n(pSeedCalc1,0,SLen,(char) 2,dMask);// add offset 2

							// 2*q
    if((Retcode = Lshift1WLnum(HMEM_CTX_REF1 lp2q,q)) != LNUM_OP_OK)
      break;

    if(callback != NULL)
    {
      callback(0);
    }

    do
    {
      memcpy(pSeedCalc2,pSeedCalc1,SLen);		// copy for calculation
      Index = VLen+1;					// past LSB of Number
      i = 0;
      //----------------------------------------------------
      // generate number W resp. X from V(0),...,V(n)
      //----------------------------------------------------
      for(;;)	// V-Number generate for
      {
        //--------------------------------------------------
        // Get Hash for current i
        //--------------------------------------------------
        SHA1_Init(sha);
        SHA1_Update(sha,pSeedCalc2,0,SLen);	// generate hash
        SHA1_Final(sha,Sha1Dgst1,0);
        //--------------------------------------------------
        // put the full / partial  hash to number V
        //--------------------------------------------------
        if(i < n)   					// full hash to set
        {
          Index -= SHA_DIGEST_LEN;			// to Start
          memcpy(pNumberW+Index,Sha1Dgst1,SHA_DIGEST_LEN);

          AddByteToBufMod2n(pSeedCalc2,0,SLen,(char) 1,bMask);// increment
        }
        else
        {
          Index -= bCnt;
          if(bCnt != 0)
          {
            memcpy(pNumberW+Index,Sha1Dgst1+SHA_DIGEST_LEN-bCnt,bCnt);

            pNumberW[Index] &= bMask;			// ignore bits
          }
          pNumberW[0] = 0;				// clear top
          if(b == 0)					// one more byte !
            pNumberW[0] = 0x01;				// set top bit
          else
          {
            pNumberW[1] = (char)
              (pNumberW[1] | (0x01 << b));		// topmost
          }
          break;
        }
        i++;
      } // W-Generate for
      //----------------------------------------------------
      // convert X to internal, calculate p
      //----------------------------------------------------
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
			lpX,pNumberW,0,VLen+1)) != LNUM_OP_OK)
        break;
							// X mod 2*q
      if((Retcode = ModWLnum(HMEM_CTX_REF1
			lpTmp,lpX,lp2q,NULL)) != LNUM_OP_OK)
        break;
							// X + 1
      if((Retcode = AddElementWLnum(HMEM_CTX_REF1
			lpX, (int) 1)) != LNUM_OP_OK)
        break;
							// p = X - c + 1;
      if((Retcode = SubWLnum(HMEM_CTX_REF1
			p,lpX,lpTmp)) != LNUM_OP_OK)
        break;
      //----------------------------------------------------
      // check if p has size L, if so check prime
      //----------------------------------------------------
      i = p->UsedSize;				// get count
      k = HardGetBitCntWLnumElem(p->lpEl[i-1]); // get topmost
      l = 0;					// signaling flag
      if(((i-1)*32 + k) >= L)			// has correct size
      {
        i = 0;
        do
        {
          if(ModWordWLnum(p,primarray[i]) == 0) // get p mod (prime)
            break;				// not a prime
          i++;
        }while(i < SMALL_PRIME_CNT);
        if(i == SMALL_PRIME_CNT)		// all test passed
        {
	  l = 1;
          //----------------------------------------------------------
          // do Miller-Rabin
          //----------------------------------------------------------
          if(callback != NULL)
          {
            callback(1);
          }

          Retcode = WLnumMillerRabin(HMEM_CTX_REF1
				     p,ncheck,&TmpInt,NULL,callback);
          if(Retcode != LNUM_OP_OK) break;
          if(TmpInt == 0)
          {
            StopFlag = 1;				// found prime p !!
  	    break;
          }
        }
      }
      //----------------------------------------------------
      // size too small, not prime, to next counter / offset
      //----------------------------------------------------
      if((callback != NULL) && (l != 0))
      {
        callback(2);
      }
      PgenCnt ++;
      AddByteToBufMod2n(pSeedCalc1,0,SLen,(char) (n+1),// increment by n+1
			bMask);
    }while(PgenCnt < 4096);
    if(Retcode != LNUM_OP_OK) break;		// error occured
    if(StopFlag == 0) continue;			// no Error, not yet found
    if(callback != NULL)
    {
      callback(5);
    }
    //----------------------------------------------
    // C. Generate group parameter g from p,q and j
    //----------------------------------------------
								// get p
    if((Retcode = CopyWLnum(HMEM_CTX_REF1 lpX,p)) != LNUM_OP_OK)
      break;
								// p-1
    if((Retcode = SubElementWLnum(lpX,(int) 1)) != LNUM_OP_OK)
      break;
								// j = (p-1)/q
    if((Retcode = QuotWLnum(HMEM_CTX_REF1
			     lpTmp,lpX,q,NULL)) != LNUM_OP_OK)
      break;
    //-------------------------------------------------
    // Get Mask for Random Size generation
    //-------------------------------------------------
    b = 0x8000;					// preload mask
    i = 16;					// shift-Counter
    do
    {
      if((L & b) != 0) break;			// found top bit
      b = (b >> 1) | 0x8000;			// shift down 1 bit
      i--;
    }while(i != 0);
    b = ~(b << 1);				// generate AND mask

    for(;;)
    {
      //-------------------------------------------------
      // Generate random number h of length 2 .. L-1 bits
      //-------------------------------------------------
      if((Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pSeedCalc1,0,2)) != 0)
        break;

      BIGchar2wordn(pSeedCalc1,i,0);		// to number
      i &= b;					// isolate relevant bits
      if(i <= 1) i = 2;				// at least 2 bits
      if(i >= L) i = L-1;			// at most L-1 bits
						// get random
      if((Retcode = WLnumRand(HMEM_CTX_REF1 lp2q,i,1,0)) != LNUM_OP_OK)
        break;
      //-------------------------------------------
      // Calculate g = (h ** j) mod p
      //-------------------------------------------
						//(h ** j) mod p
      if((Retcode = ExpModWLnum(HMEM_CTX_REF1
			lpX,lp2q,lpTmp,p,NULL,NULL)) != LNUM_OP_OK)
        break;

      if(IsOneWLnum(lpX) == 0)			// found g
      {
        Retcode = CopyWLnum(HMEM_CTX_REF1 g,lpX);
	break;
      }
      if(callback != NULL)
      {
        callback(6);
      }
    } // g generate for
    break;
  } // Error / Generate for

  if(Retcode == LNUM_OP_OK)
  {
    if(pCounter != NULL)
      pCounter[0] = PgenCnt;			// set Counter

    if(Seed != NULL)
    {
      Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1 Seed,pSeed,0,SLen);
    }

    if((j != NULL) && (Retcode == LNUM_OP_OK))
    {
      Retcode = CopyWLnum(HMEM_CTX_REF1 j,lpTmp);
    }
  }

  FreeWLnum(HMEM_CTX_REF1 lp2q);
  FreeWLnum(HMEM_CTX_REF1 lpX);
  FreeWLnum(HMEM_CTX_REF1 lpTmp);
  FREE_ARRAY(HMEM_CTX_REF,pSeed);
  FREE_ARRAY(HMEM_CTX_REF,pSeedCalc1);
  FREE_ARRAY(HMEM_CTX_REF,pSeedCalc2);
  FREE_ARRAY(HMEM_CTX_REF,primarray);
  FREE_ARRAY(HMEM_CTX_REF,pNumberW);
  FREE_ARRAY(HMEM_CTX_REF,pNumberU);
  return(Retcode);
}

//====================================================================
// Transform a given large number x using modulo and addition
// operation into a given interval ]Low,High[.
// This is used for DSA/DH private value generation
// NOTE: No parameters checked. Is MUST be assured that High - Low >= 2 !

//
// Input parameters: WLARGENUM * x	Large number to modify
//		     WLARGENUM * LowVal	Interval lower limit
//		     WLARGENUM * HighVal Interval higher limit
// Returns: int Status - 0 o.k., else error occured
//====================================================================
static int FAST TransformLnumToInterval(HMEM_CTX_DEF
	WLNUM * x, WLNUM * LowVal, WLNUM * HighVal)
{
  int Retcode;

  WLNUM * Result = NULL;
  WLNUM * Remainder = NULL;

  //---------------------------------------------------------
  // Allocate helper large numbers
  //---------------------------------------------------------
  Result = AllocNewWLnum(HMEM_CTX_REF1 HighVal->AllocSize);
  Remainder = AllocNewWLnum(HMEM_CTX_REF1 HighVal->AllocSize);

  if((Result == NULL) || (Remainder == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 Result);
    FreeWLnum(HMEM_CTX_REF1 Remainder);
    return(LNUM_OP_ALLOC_ERR);
  }

  for(;;)
  {
    //---------------------------------------------------------
    // Calculate k = interval size - 1  for Modulo reduction
    //---------------------------------------------------------
    if((Retcode = SubWLnum(HMEM_CTX_REF1
			   Result,HighVal,LowVal)) != LNUM_OP_OK)
      break;

    if((Retcode = SubElementWLnum(Result,(int) 1)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------------
    // Limit x to interval [0,k-1]: y = x mod k
    //---------------------------------------------------------
    if((Retcode = ModWLnum(HMEM_CTX_REF1
			Remainder,x,Result,NULL)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------------------
    // Add low limit to y:  z = y + Low to bring in range
    // NOTE: we direct store z to the x input number (no longer used)
    //---------------------------------------------------------------
    Retcode = AddWLnum(HMEM_CTX_REF1 x,Remainder,LowVal);
    break;
  }
  FreeWLnum(HMEM_CTX_REF1 Result);
  FreeWLnum(HMEM_CTX_REF1 Remainder);
  return(Retcode);
}

//====================================================================
// Subroutine GenDsaDhKey generates DSA/DH public / private values
// x, y of appropriate length
//
// Private key value requirements:
// DSA-Mode: 0 < x < q is required, 2**159 < q < 2**160
// DH-Mode: Two different modes:
//	    a) Classic mode (from PKCS3):
//	       - no Private key size l given then
//		 0 < x < p-1 shall be satisfied
//	       - Private key size l given (limiting) then
//		 2**(l-1) < x < 2**l
//	    b) Enhanced mode (from RFC 2631)
//	       1 < x < q-1 shall be satisfied
//	
//
// Input parameters:	int PrivKeyLen	Desired Length of private Key,
//					if 0 calculate from length of p
//			int KeyType	0 - DSA, else DH
//			int Mode	0 - classic, else enhanced
//			WLARGENUM * p	prime p
//			WLARGENUM * q	prime q / NULL (DH for SSH)
//			WLARGENUM * g	group parameter g
//			WLARGENUM * y	generated public value
//			WLARGENUM * x	generated private value
//		     void CallBack(int) Callback procedure
//
//
// Returns: int Status		LNUM_OP_OK o.k.
//				else error occured
//
//====================================================================
int GenDsaDhKey(HMEM_CTX_DEF  int PrivKeyLen, int KeyType, int Mode,
			      WLNUM * p, WLNUM * q, WLNUM * g,
			      WLNUM * y, WLNUM * x,
			      void callback(int))
{
  int i;
  int Retcode;
  int TopFlag = 0;
  int BitCnt;
  int NumLen;
  int LowCmp,HighCmp;
//  int RetryCount = 4096;
  int RetryCount = 20;				// no more should be needed...
  WLNUM * pLowLimit  = NULL;
  WLNUM * pHighLimit = NULL;
  char TmpBuf[1];

#if defined __DEBUG__
  WLNUM * Last_x = NULL;
#endif

  //-----------------------------------------------------------------
  // Check parameters
  //-----------------------------------------------------------------
  if((p == NULL) || (g == NULL) || (y == NULL) || (x == NULL) ||
    (p->UsedSize == 0) || (g->UsedSize == 0))
    return(LNUM_OP_NULL_PTR);

  Retcode = LNUM_OP_OK;
  for(;;)				// Error FOR
  {
    //-----------------------------------------------
    // set up bitsizes and comparison values needed
    //-----------------------------------------------
    if(KeyType == 0)					// DSA key to generate
    {
      //------------------------------------------------------------
      // Private key x for DSA is required, assure that q is present
      // and has correct length, set low and high compare limit
      //------------------------------------------------------------
      if(q == NULL)
        return(LNUM_OP_NULL_PTR);
      BitCnt = WLnum_BitSize(q);
      if(BitCnt != MIN_DH_DSA_Q_BITS)		// size is fixed !!
        return(DSA_DH_KEY_SIZE_ERR);


      NumLen = BitCnt / 32;
      pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);// need 1 element only
      pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);	// elements needed
      if((pLowLimit == NULL) || (pHighLimit == NULL))
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }

      TmpBuf[0] = (char) 0x00;			// > 0, lower limit
      if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
				    pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
        break;
      if((Retcode = CopyWLnum(HMEM_CTX_REF1 pHighLimit,q)) != LNUM_OP_OK)
        break;
    }
    else
    {
      //----------------------------------------------------
      // DH Key to generate, check which mode to use
      //----------------------------------------------------
      if(Mode == 0)					// classic mode
      {
//      printf("DH Generate Key Classic Mode\n");
        BitCnt = WLnum_BitSize(p);			// maximum size
        //--------------------------------------------------
        // Preprocess key length in case of SSH access
        //--------------------------------------------------
        if(PrivKeyLen != 0)				// given size limit
        {
          if(PrivKeyLen > BitCnt)
            return(DSA_DH_KEY_SIZE_ERR);

          BitCnt = PrivKeyLen;
          if((q != NULL) && (q->AllocSize == 0))	// from SSH !!
            PrivKeyLen = 0;				// use 'default'
        }

        if(PrivKeyLen != 0)				// given size, classic
        {
	  TopFlag = 1;					// assure bit size
          //------------------------------------------------
          // Allocate large numbers for comparison,
          // 2**(l-1) < x < 2**l
          //------------------------------------------------
          NumLen = BitCnt / 32;				// size needed
          pLowLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen); // elements needed
          pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen);// elements needed
          if((pLowLimit == NULL) || (pHighLimit == NULL))
          {
            Retcode = LNUM_OP_ALLOC_ERR;
            break;
          }
          //------------------------------------------------
          // generate lower limit 2**(l-1) (l = bitsize)
          //------------------------------------------------
          TmpBuf[0] = (char) 0x01;			// set LSB bit
          if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
					pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
            break;

          if((Retcode = LshiftWLnum(HMEM_CTX_REF1
			  pLowLimit, pLowLimit, BitCnt)) != LNUM_OP_OK)
            break;
          //------------------------------------------------
          // generate upper limit 2**l (l = bitsize)
          //------------------------------------------------
          if((Retcode = CopyWLnum(HMEM_CTX_REF1
				  pHighLimit, pLowLimit)) != LNUM_OP_OK)
            break;
          if((Retcode = Lshift1WLnum(HMEM_CTX_REF1
				pHighLimit, pHighLimit)) != LNUM_OP_OK)
            break;
        }
        else					// no private key length
        {
          //------------------------------------------------
          // Allocate large numbers for comparison,
          // 1 < x < p-1	(Original: 0 < x < p-1)
          //------------------------------------------------
          NumLen = BitCnt / 32;			// size needed
          pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);	// only 1 element needed
          pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen); // elements needed
          if((pHighLimit == NULL) || (pLowLimit == NULL))
          {
            Retcode = LNUM_OP_ALLOC_ERR;
            break;
          }
          //------------------------------------------------
          // generate lower limit 1 and upper limit p-1
          //------------------------------------------------
          TmpBuf[0] = (char) 0x01;			// set Low limit
          if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
				pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
            break;

          if((Retcode = CopyWLnum(HMEM_CTX_REF1
				  pHighLimit,p)) != LNUM_OP_OK)
            break;

          if((Retcode = SubElementWLnum(
				pHighLimit,(int) 1)) != LNUM_OP_OK)
            break;
        }
      }
      else
      {
        //----------------------------------------------------------
        // Extended DH mode to use, check if q is present, get size
        //----------------------------------------------------------
        if(q == NULL)
          return(LNUM_OP_NULL_PTR);
        BitCnt = WLnum_BitSize(q);
        if(BitCnt <= 0)
          return(DSA_DH_KEY_SIZE_ERR);
        //------------------------------------------------
        // Allocate large numbers for comparison,
        // 1 < x < q-1	(Original: 0 < x < q-1)
        //------------------------------------------------
        NumLen = BitCnt / 32;				// size needed
        pLowLimit  = AllocNewWLnum(HMEM_CTX_REF1 1);// only 1 element needed
        pHighLimit = AllocNewWLnum(HMEM_CTX_REF1 NumLen); // elements needed
        if((pHighLimit == NULL) || (pLowLimit == NULL))
        {
          Retcode = LNUM_OP_ALLOC_ERR;
          break;
        }
        //------------------------------------------------
        // generate lower limit 1 and upper limit q-1
        //------------------------------------------------
        TmpBuf[0] = (char) 0x01;			// set Low limit
        if((Retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
			pLowLimit,TmpBuf,0,1)) != LNUM_OP_OK)
          break;

        if((Retcode = CopyWLnum(HMEM_CTX_REF1
				 pHighLimit,q)) != LNUM_OP_OK)
          break;

        if((Retcode = SubElementWLnum(
				pHighLimit,(int) 1)) != LNUM_OP_OK)
          break;
      } // classic / enhanced DH
    } // DSA/DH
    break;
  } // Error FOR

  if(Retcode != LNUM_OP_OK)
  {
    FreeWLnum(HMEM_CTX_REF1 pHighLimit);
    FreeWLnum(HMEM_CTX_REF1 pLowLimit);
    return(Retcode);
  }




  //-----------------------------------------------------------------
  // All precalculations done, get the private value x
  //-----------------------------------------------------------------
//  printf("Start generating x value now...\n");

#if defined __DEBUG__
  Last_x = AllocNewWLnum(HMEM_CTX_REF1 NumLen);	// elements needed
  if(Last_x == NULL)
  {
    printf("DSA/DH Privgen: Failed to allocate Helper Lnum!\n");
    FreeWLnum(HMEM_CTX_REF1 pLowLimit);
    FreeWLnum(HMEM_CTX_REF1 pHighLimit);
    return(LNUM_OP_ALLOC_ERR);
  }
#endif // __DEBUG__



  if(callback != NULL)
  {
    callback(0);
  }

  do
  {

#if defined __DEBUG__
    if(CopyWLnum(HMEM_CTX_REF1 Last_x,x) != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pLowLimit);
      FreeWLnum(HMEM_CTX_REF1 pHighLimit);
      FreeWLnum(HMEM_CTX_REF1 Last_x);
      printf("Failed to save current PRNG value!\n");
      return(DSA_DH_KEY_PRIV_GEN_ERR);
    }
#endif


    i = WLnumRand(HMEM_CTX_REF1 x,BitCnt,TopFlag,0); // get random
    if(i != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pLowLimit);
      FreeWLnum(HMEM_CTX_REF1 pHighLimit);
//      printf("PRNG Err\n");
      return(DSA_DH_KEY_PRIV_GEN_ERR);
    }
    //------------------------------------------------------
    // Check if LowLimit < x < HighLimit
    //------------------------------------------------------
    LowCmp  = UcompWLnum(x,pLowLimit);
    HighCmp = UcompWLnum(x,pHighLimit);
    if((LowCmp == WLNUM_1ST_GT_2ND) &&			// x above low limit
       (HighCmp == WLNUM_1ST_LT_2ND))			// x below high limit
      break;
    //------------------------------------------------------
    // x is outside interval ]LowLimit,HighLimit[ put inside
    //------------------------------------------------------
    if((Retcode = TransformLnumToInterval(HMEM_CTX_REF1
			x,pLowLimit,pHighLimit)) != LNUM_OP_OK)
    {
      FreeWLnum(HMEM_CTX_REF1 pLowLimit);
      FreeWLnum(HMEM_CTX_REF1 pHighLimit);
//      printf("PRNG Err\n");
      return(DSA_DH_KEY_PRIV_GEN_ERR);
    }
    LowCmp  = UcompWLnum(x,pLowLimit);
    HighCmp = UcompWLnum(x,pHighLimit);
    if((LowCmp == WLNUM_1ST_GT_2ND) &&			// x above low limit
       (HighCmp == WLNUM_1ST_LT_2ND))			// x below high limit
      break;

//    printf(";");
    RetryCount--;
    if(callback != NULL)
    {
      callback(2);
    }
  }while(RetryCount != 0);

#if defined __DEBUG__
  if(RetryCount == 0)
  {
    printf("DSA/DH Private value generate failed, too many retries!\n");
    printf("\nLower compare limit was:\n");
    ShowLnum(pLowLimit);
    printf("\nUpper compare limit was:\n");
    ShowLnum(pHighLimit);
    printf("\nRecent Random used was:\n");
    ShowLnum(x);
    printf("\nLast Random used was:\n");
    ShowLnum(Last_x);
  }
#endif // __DEBUG__

  FreeWLnum(HMEM_CTX_REF1 pLowLimit);
  FreeWLnum(HMEM_CTX_REF1 pHighLimit);
#if defined __DEBUG__
  FreeWLnum(HMEM_CTX_REF1 Last_x);
#endif

  if(RetryCount == 0)
  {
//    printf("Too many retries\n");
    return(DSA_DH_KEY_PRIV_GEN_ERR);
  }
  //-----------------------------------------------------------------
  // Calculate public value: pub_key y = (g ** priv_key x) mod prime p
  //-----------------------------------------------------------------
  i = ExpModWLnum(HMEM_CTX_REF1 y, g, x, p, NULL ,callback);

  if(i != LNUM_OP_OK)
    return(DSA_DH_KEY_PUBL_GEN_ERR);

  if(callback != NULL)
  {
    callback(3);
  }
  return(DSA_DH_OP_OK);
}
//--------------------------------------------------------------------
// Subroutine CheckDsaDhPubValue verifies correct generation of
// DSS/DH public according to given primes p and q.
//
// Input parameters:	WLARGENUM * p	prime p
//			WLARGENUM * q	prime q
//			WLARGENUM * y	public value y
//
// Returns: int Status		LNUM_OP_OK o.k.
//				else error occured
//
//--------------------------------------------------------------------
int CheckDsaDhPubValue(HMEM_CTX_DEF WLNUM * p, WLNUM * q, WLNUM * y)
{
  int Retcode;

  int i;
  int pLen,yLen;
  WLNUM * lpTmp = NULL;

  int CmpResult;
  //-----------------------------------------------------
  // Check for NULL pointers or invalid length of p,y
  //-----------------------------------------------------
  if((p == NULL) || (q == NULL) || (y == NULL))
    return(LNUM_OP_NULL_PTR);
  pLen = p->UsedSize;
  yLen = y->UsedSize;
  if((pLen == 0) || (yLen == 0))
    return(LNUM_OP_INVALID_PRIME);
  //-----------------------------------------------------
  // 1. Check if y is in the interval [2,...p-1]
  //-----------------------------------------------------
  if((yLen == 1) && ((y->lpEl[0] == 1) || (y->lpEl[0] == 0)))
    return(DSA_DH_CHK_INVALID_PUBVAL);		// invalid size

  i = UcompWLnum(y,p);				// compare
  if((i == WLNUM_1ST_GT_2ND) || (i == WLNUM_1ST_EQ_2ND))
    return(DSA_DH_CHK_INVALID_PUBVAL);		// invalid size
  //-----------------------------------------------------
  // 2. Check if (y ** q) mod p === 1
  //-----------------------------------------------------
  if((lpTmp = AllocNewWLnum(HMEM_CTX_REF1 pLen)) == NULL)
    return(LNUM_OP_ALLOC_ERR);

  if((Retcode = ExpModWLnum(HMEM_CTX_REF1
			      lpTmp,y,q,p, NULL, NULL)) != LNUM_OP_OK)
  {
    FreeWLnum(HMEM_CTX_REF1 lpTmp);
    return(Retcode);
  }
  CmpResult = IsOneWLnum(lpTmp);		// check result === 1
  FreeWLnum(HMEM_CTX_REF1 lpTmp);

  if(CmpResult == 0)
    return(DSA_DH_CHK_INVALID_PUBVAL);
  return(DSA_DH_OP_OK);
}
//================================================================
// Subroutine DSA_GenKey generates DSA public/private value
//
// 1.) Generate Random private value x (of desired length)
// 2.) Calculate public value y = (g ** x) mod p
//
// Input Parameters:	DSA_STRUC * dsa		Base of parameter structure
// Return: int	Status	DSA_DH_OP_OK		success
//			else error occured
//================================================================
int FAST DSA_GenKey(HMEM_CTX_DEF DSA_STRUC * dsa)
{
  //-------------------------------------------------------
  // Generate public/private values
  //-------------------------------------------------------
  return(GenDsaDhKey(HMEM_CTX_REF1
		MIN_DH_DSA_Q_BITS,0,0,
		dsa->p,dsa->q,dsa->g,dsa->y,dsa->x,NULL));
}
//================================================================
// Subroutine DSA_GenParams Allocates DSA Parameter structure and
// generates DSA parameters p,q,g,y and x
//
// Input Parameters: int pBits		Bitcount prime p
//		     DSA_STRUC ** pdsa	returned parameter structure
//		     void CallBack(int) Callback procedure
//
// Return: int	Status	DSA_DH_OP_OK		success
//			else error occured
//================================================================
int FAST DSA_GenParams(HMEM_CTX_DEF int pBits, DSA_STRUC ** pdsa,
				    void CallBack(int))
{
  int Retcode;
  int pLen,qLen;

  DSA_STRUC * dsa;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if(pdsa == NULL) return(DSA_GEN_NULL_PTR_ERR);
  if(pBits < (MIN_DH_DSA_Q_BITS+2)) return(DSA_GEN_INV_BITSIZE_ERR);
  pdsa[0] = NULL;
  //-------------------------------------------------------
  // 1. Allocate DSA Structure
  //-------------------------------------------------------
  pLen = ((((pBits + 7)/8) + 1) + (4-1))/4;
  qLen = (((MIN_DH_DSA_Q_BITS+7)/8+1) + (4-1))/4;

  dsa = DSA_New(HMEM_CTX_REF1 pLen, qLen, pLen, pLen, pLen);
  if(dsa == NULL) return(DSA_GEN_ALLOC_ERR);

  //-------------------------------------------------------
  // 2. Generate parameters p,q,g
  //-------------------------------------------------------
  Retcode = GenDsaDhParams(HMEM_CTX_REF1
			   pBits,MIN_DH_DSA_Q_BITS,PRIME_CHECK_CNT,
			   DSA_GEN_TYPE,dsa->p,dsa->q,
			   dsa->g,NULL,NULL,NULL,CallBack);
  if(Retcode == DSA_DH_OP_OK)
  {
    //-------------------------------------------------------
    // 3. Generate public/private key y,x
    //-------------------------------------------------------
    Retcode = DSA_GenKey(HMEM_CTX_REF1 dsa);
  }
  if(Retcode != DSA_DH_OP_OK)
    DSA_Free(HMEM_CTX_REF1 dsa);
  else
    pdsa[0] = dsa;
  return(Retcode);
}
//================================================================
// Subroutine DH_GenParams Allocates DH Parameter structure and
// generates DH parameters p,q,g,j,Seed and PgenCnt
//
// NOTE: the public/private params elements are allocated but
// ----- not filled. This  M U S T be done separately.
//
// Input Parameters: int pBits		Bitcount prime p
//		     int qBits		Bitcount prime q (the critical value!)
//		     DH_STRUC ** pdh	returned parameter structure
//		     void CallBack(int) Callback procedure
//
// Return: int	Status	DSA_DH_OP_OK		success
//			else error occured
//================================================================
int FAST DH_GenParams(HMEM_CTX_DEF int pBits, int qBits, DH_STRUC ** pdh,
				   void CallBack(int))
{
  int Retcode;
  int pLen;
  int qLen;

  int pTmpInt;

  DH_STRUC * dh;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if(pdh == NULL) return(DH_GEN_NULL_PTR_ERR);
  if((qBits < MIN_DH_DSA_Q_BITS) ||(pBits < qBits))
    return(DH_GEN_INV_BITSIZE);
  pdh[0] = NULL;
  //-------------------------------------------------------
  // 1. Allocate DH Structure
  //-------------------------------------------------------
  pLen = ((((pBits + 7)/8) + 1) + 4-1)/4;
  qLen = ((((qBits + 7)/8) + 1) + 4-1)/4;

  dh = DH_New(HMEM_CTX_REF1 pLen,qLen,pLen,pLen,pLen);
  if(dh == NULL) return(DH_GEN_ALLOC_ERR);
  //-------------------------------------------------------
  // 2. Generate parameters p,q,g,j,Seed and PgenCount
  //-------------------------------------------------------
  Retcode = GenDsaDhParams(HMEM_CTX_REF1
			   pBits,qBits,PRIME_CHECK_CNT,DH_GEN_TYPE,
			   dh->p,dh->q,dh->g,dh->j,dh->Seed,&pTmpInt,
			   CallBack);
  if(Retcode != DSA_DH_OP_OK)
    DH_Free(HMEM_CTX_REF1 dh);
  else
  {
    dh->PgenCount = pTmpInt;
    pdh[0] = dh;
  }
  return(Retcode);
}
//================================================================
// Subroutine DH_GenKey processes phase I of Diffie-Hellman
// key agreement:
//
// 1.) Generate Random private value x (of desired length)
// 2.) Calculate public value y = (g ** x) mod p
//
// The public value must be sent to the other peer,
// the private value will be used in phase II to
// generate the agreed secret key z.
//
// Input Parameters:	DH_STRUC * dh		Base of parameter structure
// Return: int	Status	DSA_DH_OP_OK		success
//			else error occured
//================================================================
int FAST DH_GenKey(HMEM_CTX_DEF DH_STRUC * dh, void callback(int))
{
  int DhMode = 0;
  int PrivLen;
  //-------------------------------------------------------
  // assure that we get the correct length for private key
  //-------------------------------------------------------
  PrivLen = dh->PrivLen;		// get preset value
  if(PrivLen > 0)			// one is selected, classic mode
  {
    DhMode = 0;
//    printf("Set DH Classic Mode");
  }
  else					// none selected, assume enhanced mode
  {
    PrivLen = 0;			// we use the defaults
    DhMode  = 1;
//    printf("Assume DH Enhanced Mode");
    if((dh->q == NULL) || (dh->q->UsedSize <= 0))
    {
      DhMode = 0;			// back to classic mode
//      printf("Back to DH Classic Mode");
    }
  }
  //-------------------------------------------------------
  // Generate public/private values
  //-------------------------------------------------------
  return(GenDsaDhKey(HMEM_CTX_REF1
		     PrivLen,1,DhMode,dh->p,dh->q,
		     dh->g,dh->PubKey,dh->PrivKey,callback));
}
//================================================================
// Subroutine DH_GenSecret processes phase II of Diffie-Hellman
// key agreement:
//
// 1.) Calculate secret key z = (y'** x) mod p
// 2.) Convert secret key to byte string without leading zero
//
// NOTE: a 'mixed format' DH-Structure is used:
//	 1.) p, g, Ys, Xc   loaded for the client side
//	 2.) p, g, Yc, Xs   loaded for the server side
//
//
// Input Parameters:	char ** pDstBuf		Allocated secret buffer
//			int *	pDstLen		length of data
//			DH_STRUC * dh		Base of parameter structure
//
// Return: int	Retcode	DH_OP_OK			success
//			DH_COMPUTE_KEY_INV_DATA_ERR	missing data
//			DH_COMPUTE_KEY_ALLOC_ERR	alloc failure
//			DH_COMPUTE_KEY_EXPMOD_ERR	error computing value
//			DH_COMPUTE_KEY_LNUM_TO_BIN_ERR	error computing value
//----------------------------------------------------------------------
int FAST DH_GenSecret(HMEM_CTX_DEF
		      char ** ppDstBuf, int * pDstLen, DH_STRUC * dh)
{
  int i;
  int pLen;
  int Retcode = DH_OP_OK;

  char * pBuf = NULL;

  WLNUM * lptmplnum = NULL;
  //----------------------------------------------------------
  // check if prime p, Base g, private value x and public value
  // y are present and valid
  //----------------------------------------------------------
  if((dh == NULL) || (dh->p == NULL) ||
     (dh->PrivKey == NULL) || (dh->PubKey == NULL) ||
     (ppDstBuf == NULL) || (pDstLen == NULL) ||
     ((pLen = dh->p->UsedSize) == 0) ||
     (dh->g->UsedSize == 0) ||
     (dh->PubKey->UsedSize == 0) ||
     (dh->PrivKey->UsedSize == 0))
    return(DH_COMPUTE_KEY_INV_DATA);
  ppDstBuf[0] = NULL;
  pDstLen[0] = 0;
  //--------------------------------------------------------------
  // Allocate large numbers for calculation and destination buffer
  //--------------------------------------------------------------
  lptmplnum = AllocNewWLnum(HMEM_CTX_REF1 pLen);	// get pointer
  pLen = GetByteCntWLnum(dh->p);
  pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,pLen+1);		// get buffer
  if((lptmplnum == NULL) || (pBuf == NULL))
  {
    FreeWLnum(HMEM_CTX_REF1 lptmplnum);
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
    return(DH_COMPUTE_KEY_ALLOC_ERR);
  }
  ppDstBuf[0] = pBuf;
  pDstLen[0] = pLen+1;
  //----------------------------------------------------------
  // Calculate secret Z
  //----------------------------------------------------------
  i = ExpModWLnum(HMEM_CTX_REF1
		lptmplnum,dh->PubKey,dh->PrivKey,dh->p, NULL, NULL);
  if(i != LNUM_OP_OK)
  {
//      printf("\nExpMod");printf("%d",i);printf("\n");	// TEST TEST TEST
    Retcode = DH_COMPUTE_KEY_EXPMOD_ERR;
  }
  else
  {
							// convert back	
    if((i = WLnum_wlnum2bin(pBuf, 0, pDstLen, lptmplnum, 0)) != LNUM_OP_OK)
    {
      Retcode = DH_COMPUTE_KEY_LNUM_TO_BIN_ERR;
//      printf("\nLNUM_Conv");printf("%d",i);printf("\n");// TEST TEST TEST
    }
  }

  FreeWLnum(HMEM_CTX_REF1 lptmplnum);
  if(Retcode != DH_OP_OK)
  {
    ppDstBuf[0] = NULL;
    pDstLen[0] = 0;
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }
  return(Retcode);
}


//**************************************************************
//
// DSA Raw Signing / Verification Module
//
//**************************************************************

#define	DSARAW_NULL_PTR			-1
#define	DSARAW_INVALID_PARAMETER	-2
#define	DSARAW_BUFFER_TOO_SMALL		-3	// redefine ?


//==============================================================
// Subroutine DSA_SignRaw, generates DSA signature from given message
// using SHA1 message digest (already hashed).
// NOTE: Output is NOT ASN.1 formatted
//
// Input params :	char * pDgstBuf		Digest buffer base
//			int  DgstOffset		Start of Digest
//			int  DgstLen		length of Digest
//			char * sig		Signature buffer array base
//			int  sigOffset		Start index of signature
//			int * psigLen		length of signature buffer
//			DSA_STRUC * dsa		DSA structure base
//			WLARGENUM * kTest	if <> 0, replaces random
//						number for test purposes
//
// Returns:  Status				== DSA_OP_OK - o.k.
//						else: Error occured
//==============================================================
int FAST DSA_SignRaw(HMEM_CTX_DEF
		char * pDgstBuf, int DgstOffset,
		int DgstLen, char * pSigBuf, int SigOffset, int * pSigLen,
		DSA_STRUC * dsa, WLNUM * kTest)
{
  int NumLen,rLen,sLen;

  int ret=DSA_OP_OK;
  int reason=LNUM_OP_OK;

  int pTmpLen;

  WLNUM * m = NULL;
  WLNUM * k = NULL;
  WLNUM * kinv = NULL;
  WLNUM * r = NULL;
  WLNUM * s = NULL;
  //------------------------------------------------------------
  // Check Parameters ahead
  //------------------------------------------------------------
  if((pDgstBuf == NULL) || (pSigBuf == NULL) || (dsa == NULL) ||
     (pSigLen == NULL))
    return(DSA_DH_NULL_PTR);

  if(pSigLen[0] < (2*SHA_DIGEST_LEN))
    return(DSA_SIGN_BUFFER_TOO_SMALL);

  if(DgstLen != SHA_DIGEST_LEN)
    return(DSA_SIGN_INVALID_HASH_LEN);
  //------------------------------------------------------------
  // Clear signing buffer
  //------------------------------------------------------------
//  pSigLen[0] = 0;
  memset(pSigBuf+SigOffset,0,(2*SHA_DIGEST_LEN));

  for(;;)				// outer processing loop
  {
    //---------------------------------------------------
    // allocate required large numbers
    //---------------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    m = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    r = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    s = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    k = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    kinv = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if(m == NULL || r == NULL || s == NULL || k == NULL || kinv == NULL)
    {
      reason = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-----------------------------------------------------
    // convert digest from binary to large number for calc,
    // get 160 Bit Random, compute s and r params
    //-----------------------------------------------------
						// to large number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			m,pDgstBuf,DgstOffset, SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    if(kTest != NULL)
      reason = CopyWLnum(HMEM_CTX_REF1 k,kTest); // use given value
    else
      reason = WLnumRand(HMEM_CTX_REF1 k,160,1,0);// get 160 Bit random
    if(reason != LNUM_OP_OK)
      break;

    // Compute r = (g^k mod p) mod q

							// s = g^k mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		    s,dsa->g,k,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// r = s mod q
    if((reason = DivWLnum(HMEM_CTX_REF1
			   NULL, r,s,dsa->q,NULL)) != LNUM_OP_OK)
      break;

    // Compute  s = inv(k) (m + xr) mod q
							// s = x * r
    if((reason = MulWLnum(HMEM_CTX_REF1
			   s,dsa->x,r)) != LNUM_OP_OK)
      break;
							// s = x * r + m
    if((reason = AddWLnum(HMEM_CTX_REF1
			   s,s,m)) != LNUM_OP_OK)
      break;
							// kinv = k^-1 mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1
			       kinv,k,dsa->q,NULL)) != LNUM_OP_OK)
      break;
							// s = (s * kinv) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       s, s, kinv,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------
    // get length for r store large number
    //------------------------------------------------------
    rLen = GetByteCntWLnum(r);
    pTmpLen = rLen;

    if((reason = WLnum_wlnum2bin(pSigBuf,SigOffset+SHA_DIGEST_LEN-rLen,
		                 &pTmpLen,r,0)) != LNUM_OP_OK)
      break;

    SigOffset += SHA_DIGEST_LEN;

    sLen = GetByteCntWLnum(s);
    pTmpLen = sLen;

    reason = WLnum_wlnum2bin(pSigBuf,SigOffset+SHA_DIGEST_LEN-sLen,
		             &pTmpLen,s,0);
    break;
  } // for
  FreeWLnum(HMEM_CTX_REF1 m);
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 s);
  FreeWLnum(HMEM_CTX_REF1 k);
  FreeWLnum(HMEM_CTX_REF1 kinv);
  if(reason != LNUM_OP_OK)
    return(DSA_SIGN_LNUM_ERR);
  return(ret);
}
//==============================================================
// Subroutine DSA_VerifyRaw, verifies given DSA signature for a
// given message digest
// NOTE: Signature is NOT ASN1 formatted
//
// Input params :	char * pDgstBuf		Digest buffer base
//			int  DgstOffset		Start of Digest
//			int  DgstLen		length of message
//			char * pSigbuf		Signature buffer array base
//			int  SigOffset		Start index of signature
//			int  SigLen		length of signature buffer
//			DSA_STRUC * dsa		DSA structure base
//
// Returns:  Status				== 0 - o.k.
//						<  0 Error occured
//==============================================================
int FAST DSA_VerifyRaw(HMEM_CTX_DEF
		char * pDgstBuf, int DgstOffset, int DgstLen,
		char * pSigBuf, int SigOffset, int SigLen,
		DSA_STRUC * dsa)
{
  int i,NumLen;
  int ret = DSA_OP_OK;
  int reason = LNUM_OP_OK;

  WLNUM * r  = NULL;
  WLNUM * t1 = NULL;
  WLNUM * t2 = NULL;
  WLNUM * u1 = NULL;
  WLNUM * u2 = NULL;
  //------------------------------------------------------------
  // Check Parameters ahead
  //------------------------------------------------------------
  if((pDgstBuf == NULL) || (pSigBuf == NULL) || (dsa == NULL))
    return(DSA_DH_NULL_PTR);

  if(SigLen < (2 * SHA_DIGEST_LEN))
    return(DSA_VERIFY_SIGNAT_TOO_SMALL);

  if(DgstLen != SHA_DIGEST_LEN)
    return(DSA_VERIFY_INVALID_HASH_LEN);
  //-----------------------------------------------
  // FOR-Loop for easier error handling
  //-----------------------------------------------
  for(;;)
  {
    //---------------------------------------------
    // Allocate temporary large numbers
    //---------------------------------------------
    if(dsa->q->UsedSize > dsa->p->UsedSize)
      NumLen = dsa->q->UsedSize;
    else
      NumLen = dsa->p->UsedSize;

    r  = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    u2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t1 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    t2 = AllocNewWLnum(HMEM_CTX_REF1 NumLen);
    if((r==NULL) || (u1==NULL) || (u2==NULL) || (t1==NULL) || (t2 == NULL))
    {
      ret = DSA_VERIFY_ALLOC_ERR;
      break;
    }
    //---------------------------------------------
    // 1. load number r into LNUM structure
    //---------------------------------------------
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			r,pSigBuf,SigOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;

    SigOffset += SHA_DIGEST_LEN;
    //---------------------------------------------
    // 2. load number s into LNUM structure
    //---------------------------------------------
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			u1,pSigBuf,SigOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate w = (S^-1) mod q
    //-----------------------------------------------------------
							//w = u2 = (s^-1) mod q
    if((reason = InvModWLnum(HMEM_CTX_REF1
			       u2,u1,dsa->q,NULL)) != LNUM_OP_OK)
      break;
						 // convert M to long number
    if((reason = WLnum_bin2wlnum(HMEM_CTX_REF1
			u1,pDgstBuf,DgstOffset,SHA_DIGEST_LEN)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u1 = (M' * w) mod q
    //-----------------------------------------------------------
							//u1 = (M'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       u1,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate u2 = (r' * w) mod q
    //-----------------------------------------------------------
							// u2 = (r'* w) mod q
    if((reason = MulModWLnum(HMEM_CTX_REF1
			       u2,r,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // Calculate v = (((g^u1) * (y^u2)) mod p) mod q =
    //                (((g^u1) mod p) * ((y^u2) mod p) mod p) mod q
    //-----------------------------------------------------------
							// t1 = (g^u1) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		   t1,dsa->g,u1,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// t2 = (y^u2) mod p
    if((reason = ExpModWLnum(HMEM_CTX_REF1
		   t2,dsa->y,u2,dsa->p,NULL,NULL)) != LNUM_OP_OK)
      break;
							// u2 = (t1 * t2) mod p
    if((reason = MulModWLnum(HMEM_CTX_REF1
			u2,t1,t2,dsa->p,NULL)) != LNUM_OP_OK)
      break;
							// u1 = u2 mod q
    if((reason = DivWLnum(HMEM_CTX_REF1
			   NULL,u1,u2,dsa->q,NULL)) != LNUM_OP_OK)
      break;
    //-----------------------------------------------------------
    // V is now in u1.  If the signature is correct, it will be
    // equal to R.
    //-----------------------------------------------------------
    i = UcompWLnum(u1,r);				// compare
    if(i != WLNUM_1ST_EQ_2ND)
      ret = DSA_VERIFY_INVALID_SIGNAT;
    break;
  } // Error FOR loop
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 t1);
  FreeWLnum(HMEM_CTX_REF1 t2);
  FreeWLnum(HMEM_CTX_REF1 u1);
  FreeWLnum(HMEM_CTX_REF1 u2);
  if(reason != LNUM_OP_OK)
    return(DSA_VERIFY_LNUM_ERR);
  return(ret);
}

#undef BIGchar2wordn
#endif // HL_ENCR_DSA
// end of 'hobdsadh.c'


#ifdef HL_ENCR_HMAC
// hobhmac.c
//*******************************************************************
//
// HMAC Implementation according to RFC2104, MD5 and SHA1
//
//*******************************************************************
#include <hob-encry-1.h>
#include <stdlib.h>
#include <memory.h>




#define	HMAC_IPAD	0x36
#define	HMAC_OPAD	0x5C

//-------------------------------------------------------
// Error codes
//-------------------------------------------------------

#define	HMAC_OP_OK	0
#define	HMAC_NULL_PTR	-1
#define	HMAC_ALLOC_ERR	-2
#define	HMAC_PARAM_ERR	-3
#define	HMAC_DST_BUFFER_TOO_SMALL -4





//=======================================================================
// Helper Routine XorBit8Array Xors Array contents with given value
//
// Input parameters: char * pBuf	Array Base
//		     int  BufOff	Start of Data
//		     int  BufLen	Size of Data
//		     int  Value		Value for XOR (Low Byte)
// Returns: Nothing
//=======================================================================
static void FAST XorBit8Array(char * pBuf, int BufOff, int BufLen,
				      int Value)
{
  if((pBuf != NULL) && (BufLen > 0))
  {
    while(BufLen != 0)
    {
      pBuf[BufOff++] ^= (unsigned char) Value;
      BufLen--;
    }
  }
}
//===============================================================
// Generate HMAC using MD5 or SHA-1 hash from given data and key
//
// Input parameters:	char * pKeyData		Base of data
//			int  KeyDataOff		Start of data
//			int  KeyDataLen		Size of key
//			char * pHashData	base of data to hash
//			int  HashDataOff	Start of Data
//			int  HashDataLen	Size of data to hash
//			int  HashType		Hash to Use
//			char * pDstBuf		Buffer for Output
//			int  DstOff		Start of Data
//			int  * pDstLen		IN: Buffersize, OUT: Hashsize
// Returns: int Status - 0 o.k., else error occured
//===============================================================
int FAST GenHMAC(char * pKeyData, int KeyDataOff,
	int KeyDataLen, char * pHashData, int HashDataOff, int HashDataLen,
	int HashType, char * pDstBuf, int DstOff, int * pDstLen)
{
  int DstBufLen;
  int HashLen, KeyLen;

  char KeyBuffer[HMAC_BLOCK_LEN];
  char DigestBuffer[HMAC_MAX_DIGEST_LEN];
  int HashArray[HMAC_MAX_HASH_ARRAY_SIZE];

  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pKeyData == NULL) || (pHashData == NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(HMAC_NULL_PTR);

  if((KeyDataLen <= 0) || (HashDataLen <= 0) ||
     ((DstBufLen = pDstLen[0]) <= 0))
    return(HMAC_PARAM_ERR);

  switch(HashType){
     case HMAC_MD5_ID:
        HashLen = MD5_DIGEST_LEN;
        break;
     case HMAC_SHA1_ID:
        HashLen = SHA_DIGEST_LEN;
        break;
     case HMAC_RMD160_ID:
        HashLen = RMD160_DIGEST_LEN;
        break;
     case HMAC_SHA256_ID:
        HashLen = SHA256_DIGEST_LEN;
        break;
     default:
        return(HMAC_PARAM_ERR);
  }

  if(DstBufLen < HashLen)
    return(HMAC_DST_BUFFER_TOO_SMALL);

  //-------------------------------------------------------
  // Generate the Key buffer from Key
  //-------------------------------------------------------
  if(KeyDataLen > HMAC_BLOCK_LEN)
  {
    //-----------------------------------------------------
    // Must shrink the Key down, use the appropriate hash
    //-----------------------------------------------------
    switch(HashType){
      case HMAC_MD5_ID:
         MD5_Init(HashArray);
         MD5_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
         MD5_Final(HashArray,KeyBuffer,0);
         break;
      case HMAC_SHA1_ID:
         SHA1_Init(HashArray);
         SHA1_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
         SHA1_Final(HashArray,KeyBuffer,0);
         break;
      case HMAC_RMD160_ID:
         RMD160_Init(HashArray);
         RMD160_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
         RMD160_Final(HashArray,KeyBuffer,0);
         break;
      case HMAC_SHA256_ID:
         SHA256_Init(HashArray);
         SHA256_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
         SHA256_Final(HashArray,KeyBuffer,0);
         break;
    }
    KeyLen = HashLen;
  }
  else
  {
    memcpy(KeyBuffer,pKeyData+KeyDataOff,KeyDataLen);
    KeyLen = KeyDataLen;
  }
  //--------------------------------------------------------
  // Pad the Key with 0x00 till Blocksize is reached
  //--------------------------------------------------------
  memset(KeyBuffer+KeyLen,0,HMAC_BLOCK_LEN - KeyLen);

  //--------------------------------------------------------
  // XOR the Key buffer with IPAD (0x36)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, HMAC_BLOCK_LEN, HMAC_IPAD);

  //--------------------------------------------------------
  // Build hash from concatenation of Xored Key and Data
  //--------------------------------------------------------
  switch(HashType){
     case HMAC_MD5_ID:
        MD5_Init(HashArray);
        MD5_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        MD5_Update(HashArray,pHashData,HashDataOff,HashDataLen);
        MD5_Final(HashArray,DigestBuffer,0);
        break;
     case HMAC_SHA1_ID:
        SHA1_Init(HashArray);
        SHA1_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        SHA1_Update(HashArray,pHashData,HashDataOff,HashDataLen);
        SHA1_Final(HashArray,DigestBuffer,0);
        break;
     case HMAC_RMD160_ID:
        RMD160_Init(HashArray);
        RMD160_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        RMD160_Update(HashArray,pHashData,HashDataOff,HashDataLen);
        RMD160_Final(HashArray,DigestBuffer,0);
        break;
     case HMAC_SHA256_ID:
        SHA256_Init(HashArray);
        SHA256_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        SHA256_Update(HashArray,pHashData,HashDataOff,HashDataLen);
        SHA256_Final(HashArray,DigestBuffer,0);
        break;
  }
  //--------------------------------------------------------
  // XOR the Key buffer with OPAD (0x5C)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, HMAC_BLOCK_LEN, HMAC_IPAD ^ HMAC_OPAD);

  //-----------------------------------------------------------
  // Build hash from concatenation of padded key and Inner Hash
  //-----------------------------------------------------------
  switch(HashType){
     case HMAC_MD5_ID:
        MD5_Init(HashArray);
        MD5_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        MD5_Update(HashArray,DigestBuffer,0,MD5_DIGEST_LEN);
        MD5_Final(HashArray,pDstBuf,DstOff);
        break;
     case HMAC_SHA1_ID:
        SHA1_Init(HashArray);
        SHA1_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        SHA1_Update(HashArray,DigestBuffer,0,SHA_DIGEST_LEN);
        SHA1_Final(HashArray,pDstBuf,DstOff);
        break;
     case HMAC_RMD160_ID:
        RMD160_Init(HashArray);
        RMD160_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        RMD160_Update(HashArray,DigestBuffer,0,RMD160_DIGEST_LEN);
        RMD160_Final(HashArray,pDstBuf,DstOff);
        break;
     case HMAC_SHA256_ID:
        SHA256_Init(HashArray);
        SHA256_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
        SHA256_Update(HashArray,DigestBuffer,0,SHA256_DIGEST_LEN);
        SHA256_Final(HashArray,pDstBuf,DstOff);
        break;
  }

  memset(KeyBuffer,0,HMAC_BLOCK_LEN);
  memset(DigestBuffer,0,HMAC_MAX_DIGEST_LEN);
  memset(HashArray,0,HMAC_MAX_HASH_ARRAY_SIZE*4);

  pDstLen[0] = HashLen;
  return(HMAC_OP_OK);
}

//===============================================================
// Generate HMAC using MD5 or SHA-1 hash from given gather data and key
//
// Input parameters:	char * 		pKeyData	Base of data
//			int             KeyDataOff	Start of data
//			int             KeyDataLen	Size of key
//			dsd_gather_i_1* ads_data        base of gather data to hash
//			int             HashType	Hash to Use
//			char *          pDstBuf		Buffer for Output
//			int             DstOff		Start of Data
//			int *           pDstLen		IN: Buffersize, OUT: Hashsize
// Returns: int Status - 0 o.k., else error occured
//===============================================================
int FAST GenHMACGath(char * pKeyData, int KeyDataOff, int KeyDataLen,
	   struct dsd_gather_i_1* ads_gath, int HashType, char * pDstBuf,
	   int DstOff, int * pDstLen)
{
  int DstBufLen;
  int HashLen, KeyLen;
  struct dsd_gather_i_1* ads_curr = ads_gath;

  char KeyBuffer[HMAC_BLOCK_LEN];
  char DigestBuffer[HMAC_MAX_DIGEST_LEN];
  int HashArray[HMAC_MAX_HASH_ARRAY_SIZE];

  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((pKeyData == NULL) || (ads_gath== NULL) ||
     (pDstBuf == NULL) || (pDstLen == NULL))
    return(HMAC_NULL_PTR);

  if((KeyDataLen <= 0) ||
     ((DstBufLen = pDstLen[0]) <= 0) ||
     ((HashType != HMAC_MD5_ID) &&
      (HashType != HMAC_SHA1_ID)))
    return(HMAC_PARAM_ERR);

  // Ensure proper input was given
  while(ads_curr)
  {
      if (ads_curr->achc_ginp_end < ads_curr->achc_ginp_cur)
          return(HMAC_PARAM_ERR);
      ads_curr = ads_curr->adsc_next;
  }
  ads_curr = ads_gath;

  if(HashType == HMAC_MD5_ID)
    HashLen = MD5_DIGEST_LEN;
  else // if(HashType == HMAC_SHA1_ID)
    HashLen = SHA_DIGEST_LEN;

  if(DstBufLen < HashLen)
    return(HMAC_DST_BUFFER_TOO_SMALL);

  //-------------------------------------------------------
  // Generate the Key buffer from Key
  //-------------------------------------------------------
  if(KeyDataLen > HMAC_BLOCK_LEN)
  {
    //-----------------------------------------------------
    // Must shrink the Key down, use the appropriate hash
    //-----------------------------------------------------
    if(HashType == HMAC_MD5_ID)
    {
      MD5_Init(HashArray);
      MD5_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
      MD5_Final(HashArray,KeyBuffer,0);
    }
    else if(HashType == HMAC_SHA1_ID)
    {
      SHA1_Init(HashArray);
      SHA1_Update(HashArray,pKeyData,KeyDataOff,KeyDataLen);
      SHA1_Final(HashArray,KeyBuffer,0);
    }
    KeyLen = HashLen;
  }
  else
  {
    memcpy(KeyBuffer,pKeyData+KeyDataOff,KeyDataLen);
    KeyLen = KeyDataLen;
  }
  //--------------------------------------------------------
  // Pad the Key with 0x00 till Blocksize is reached
  //--------------------------------------------------------
  memset(KeyBuffer+KeyLen,0,HMAC_BLOCK_LEN - KeyLen);
  //--------------------------------------------------------
  // XOR the Key buffer with IPAD (0x36)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, HMAC_BLOCK_LEN, HMAC_IPAD);

  //--------------------------------------------------------
  // Build hash from concatenation of Xored Key and Data
  //--------------------------------------------------------
  if(HashType == HMAC_MD5_ID)
  {
    MD5_Init(HashArray);
    MD5_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);

    while (ads_curr)
    {
        MD5_Update(HashArray,ads_curr->achc_ginp_cur,0,
            (int)(ads_curr->achc_ginp_end - ads_curr->achc_ginp_cur));
        ads_curr = ads_curr->adsc_next;
    }

    MD5_Final(HashArray,DigestBuffer,0);
  }
  else // if(HashType == HMAC_SHA1_ID)
  {
    SHA1_Init(HashArray);
    SHA1_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);

    while (ads_curr)
    {
        SHA1_Update(HashArray,ads_curr->achc_ginp_cur,0,
            (int)(ads_curr->achc_ginp_end - ads_curr->achc_ginp_cur));
        ads_curr = ads_curr->adsc_next;
    }

    SHA1_Final(HashArray,DigestBuffer,0);
  }

  //--------------------------------------------------------
  // XOR the Key buffer with OPAD (0x5C)
  //--------------------------------------------------------
  XorBit8Array(KeyBuffer, 0, HMAC_BLOCK_LEN, HMAC_IPAD ^ HMAC_OPAD);

  //-----------------------------------------------------------
  // Build hash from concatenation of padded key and Inner Hash
  //-----------------------------------------------------------
  if(HashType == HMAC_MD5_ID)
  {
    MD5_Init(HashArray);
    MD5_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
    MD5_Update(HashArray,DigestBuffer,0,MD5_DIGEST_LEN);
    MD5_Final(HashArray,pDstBuf,DstOff);
  }
  else // if(HashType == HMAC_SHA1_ID)
  {
    SHA1_Init(HashArray);
    SHA1_Update(HashArray,KeyBuffer,0,HMAC_BLOCK_LEN);
    SHA1_Update(HashArray,DigestBuffer,0,SHA_DIGEST_LEN);
    SHA1_Final(HashArray,pDstBuf,DstOff);
  }

  memset(KeyBuffer,0,HMAC_BLOCK_LEN);
  memset(DigestBuffer,0,HMAC_MAX_DIGEST_LEN);
  memset(HashArray,0,HMAC_MAX_HASH_ARRAY_SIZE*4);

  pDstLen[0] = HashLen;
  return(HMAC_OP_OK);
}
#endif // HL_ENCR_HMAC
// end of 'hobhmac.c'


#ifdef HL_ENCR_LNUM
// hoblnum32.c
//*********************************************************************
//
// New 32 Bit Large Number system library using either
// Target 64 Bit mode or 64 Bit Emulation mode (if no INT64 available)
//
// NOTE: 1. All Elements for calculation are defined as SIGNED types
// -----   but will be used to produce unsigned results anyway !
//	   THIS NEEDS PROPER CASTING IN ANY CASE !!!
//	 2. Two's complement arithmetic is needed for proper operation!
//
//*********************************************************************
#include <hob-encry-1.h>
#include <stdlib.h>
#include <memory.h>


#if defined WIN32 || defined HL_SOLARIS
#define LNUM32_USE_INT64
#endif



//#define __DEBUG_EXPMOD__
//#define __DEBUG_DIVIDE__
//#define __DEBUG_ESTIMATE__

#if defined __DEBUG_EXPMOD__
#define __DEBUG__
#define	EXP_PRINT(a)			printf(a)
#define	EXP_PRINT_INT_NL(a)		printf("%d",a)
#define	EXP_PRINT_HEX_BIT32(a)		printf("%08X",a)
#define	EXP_PRINT_HEX_BIT32_NL(a)	printf("%08X\n",a)
#define	EXP_SHOWLNUM(a)			ShowLnum(a)
#else
#define	EXP_PRINT(a)
#define	EXP_PRINT_INT_NL(a)
#define	EXP_PRINT_HEX_BIT32(a)
#define	EXP_PRINT_HEX_BIT32_NL(a)
#define	EXP_SHOWLNUM(a)
#endif


#if defined __DEBUG_DIVIDE__
#define	DIV_PRINT(a)			printf(a)
#define	DIV_PRINT_NL(a)			{printf(a);printf("\n");}
#define	DIV_PRINT_HEX_BIT32(a)		printf("%08X",a)
#define	DIV_PRINT_HEX_BIT32_NL(a) 	printf("%08X\n",a)
#define	DIV_PRINT_HEX_BIT64(a,b)	printf("%08X%08X",a,b)
#define	DIV_PRINT_HEX_BIT64_NL(a,b)	printf("%08X%08X\n",a,b)
#define	DIV_SHOWLNUM(a)			ShowLnum(a)
#else
#define	DIV_PRINT(a)
#define	DIV_PRINT_NL(a)
#define	DIV_PRINT_HEX_BIT32(a)
#define	DIV_PRINT_HEX_BIT32_NL(a)
#define	EST_PRINT_HEX_BIT64(a,b)
#define	EST_PRINT_HEX_BIT64_NL(a,b)
#define	DIV_SHOWLNUM(a)
#endif

#if defined __DEBUG_ESTIMATE__
#define	EST_PRINT(a)			printf(a)
#define	EST_PRINT_NL(a)			{printf(a);printf("\n");}
#define	EST_PRINT_HEX_BIT32(a)		printf("%08X",a)
#define	EST_PRINT_HEX_BIT32_NL(a) 	printf("%08X\n",a)
#define	EST_PRINT_HEX_BIT64(a,b)	printf("%08X%08X",a,b)
#define	EST_PRINT_HEX_BIT64_NL(a,b)	printf("%08X%08X\n",a,b)
#else
#define	EST_PRINT(a)
#define	EST_PRINT_NL(a)
#define	EST_PRINT_HEX_BIT32(a)
#define	EST_PRINT_HEX_BIT32_NL(a)
#define	EST_PRINT_HEX_BIT64(a,b)
#define	EST_PRINT_HEX_BIT64_NL(a,b)
#endif

//-----------------------------------------------------
// long long constants
//-----------------------------------------------------

#if defined WIN32 || defined WIN64
#define	B64_01			0x01L
#define	B64_0FFFF		0x0FFFFL
#define	B64_07FFFFFFF		0x07FFFFFFFL
#define	B64_0FFFFFFFF		0x0FFFFFFFFL
#define	B64_0FFFFFFFF00000000	0x0FFFFFFFF00000000L
#define	B64_07FFFFFFFFFFFFFFF	0x07FFFFFFFFFFFFFFFL
#endif

#if defined HL_SOLARIS
#define	B64_01			0x01LL
#define	B64_0FFFF		0x0FFFFLL
#define	B64_07FFFFFFF		0x07FFFFFFFLL
#define	B64_0FFFFFFFF		0x0FFFFFFFFLL
#define	B64_0FFFFFFFF00000000	0x0FFFFFFFF00000000LL
#define	B64_07FFFFFFFFFFFFFFF	0x07FFFFFFFFFFFFFFFLL
#endif

//------------------------------------------------------
// Forward declarations
//------------------------------------------------------
int FAST ExpModWLnum(HMEM_CTX_DEF
		     WLNUM * pRem, WLNUM * pU, WLNUM * pV,
		     WLNUM * pMod, WLNUM_CTX * pCtx,
		     void callback(int));


//=====================================================================

static int UsedBitTab[16] = { // fast conversion table for bit-counts
//       0          1          2          3	   Nibble value
        0x00,      0x01,      0x02,      0x02,	// Top Most Bit Number
//       4          5          6          7	   Nibble value
        0x03,      0x03,      0x03,      0x03,	// Top Most Bit Number
//       8          9          A          B	   Nibble value
        0x04,      0x04,      0x04,      0x04,	// Top Most Bit Number
//       C          D          E          F	   Nibble value
        0x04,      0x04,      0x04,      0x04,	// Top Most Bit Number
};


#if defined __DEBUG__
STATIC void ShowWElement(int WElement, int ZeroSupress)
{
  char c;
  int i = 8;

  while(i != 0)
  {
    c = (char) ((WElement >> 28) & 0x0F);	// get nibble
    WElement <<= 4;				// to next
    if(ZeroSupress != 0)			// Zero supression *IS* active
    {
      if(c != 0)				// is not a zero !
      {
        ZeroSupress = 0;				// deactivate
        c = (char) (c + 0x30);			// to ascii
        if(c > 0x39)
          c = (char) (c + 7);
        PRINT_CHAR(c);
      }
    }
    else
    {
      c = (char) (c + 0x30);			// to ascii
      if(c > 0x39)
        c = (char) (c + 7);
      PRINT_CHAR(c);
    }
    i--;
  }
  if(ZeroSupress != 0)				// all zeroes
    PRINT("0");
}
//================================================================
// Show a large number contents in HEX notation
//
// Input Parameters: WLNUM * pwLnum
// Returns: Nothing
//
//================================================================
PRIVATE STATIC void FAST ShowLnum(WLNUM * pWLnum)
{
  int i;
  int * pEl;

  i = pWLnum->UsedSize;
  if(i == 0)
  {
    printf("0");
    return;
  }

  i--;
  pEl = pWLnum->lpEl;
  ShowWElement(pEl[i], 1);
  while(i != 0)
  {
    printf(" ");
    i--;
    ShowWElement(pEl[i], 0);
  }
  printf("\n");
}
#endif // __DEBUG__


//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// General Helper routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if 0
//================================================================
// Clear a BIT8 Array
//
// Input parameters:	char * pArr	 Buffer base
//			int  Offset	 Start of Data
//			int  Size	 number of Elements
// Returns: nothing
//================================================================
static void FAST ClearBit8Array(char * pArr, int Offset, int Size)
{
  if(Size > 0)
    memset(pArr + Offset, 0, Size * sizeof(char));
}
#endif // 0

#if 0
//================================================================
// Clear a BIT32 Array
//
// Input parameters:	int * pArr	 Buffer base
//			int   Offset	 Start of Data
//			int   Size	 number of Elements
// Returns: nothing
//================================================================
static void FAST ClearBit32Array(int * pArr, int Offset, int Size)
{
  if(Size > 0)
    memset(pArr + Offset, 0, Size * sizeof(int));
}
#endif
//==============================================================
// UP HardGetByteCntWLnumElem calculates the number of 'used'
// byte positions within an BIT32 Element. Used for conversion
// routines.
// Example: If no bits set 				-> 0
//	    If top most bit set (and propably others)	-> 4
//
// Input:	int WElement		Number Element
// Returns:	int ByteCount		number of used bytes
/*==============================================================*/
int FAST HardGetByteCntWLnumElem(int WElement)
{
  int ByteCnt = 4;

  if(WElement == 0)				// special case, none set
    return(0);
  //--------------------------------------------------
  // find topmost byte that is not zero
  //--------------------------------------------------
  for(;;)
  {
    if((WElement & 0xFF000000) != 0)		// found a byte with bits set
      return(ByteCnt);
    WElement <<= 8;				// shift up next
    ByteCnt--;					// reduce available bytes
  }
}

//==============================================================
// UP HardGetBitCntWLnumElem calculates the number of 'used'
// bit positions within an BIT32 Element. Used for normalization
// purposes and shifting routines.
// Example: If no bits set 				-> 0
//	    If top most bit set (and propably others)	-> 32
//
// Input:	int WElement		Number Element
// Returns:	int BitCount		number of used bits
/*==============================================================*/
int FAST HardGetBitCntWLnumElem(int WElement)
{
  int NibbleCnt = 7;

  if(WElement == 0)				// special case, none set
    return(0);
  //--------------------------------------------------
  // find topmost Nibble that is not zero
  //--------------------------------------------------
  for(;;)
  {
    if((WElement & 0xF0000000) != 0)		// found a nibble with bits
      return(UsedBitTab[(WElement >> 28) & 0x0F] + (NibbleCnt*4));
    WElement <<= 4;				// shift up next
    NibbleCnt--;				// reduce available nibbles
  }
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// WLarge Number/Context Allocation, Access and Freeing routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//==============================================================
// UP AllocNewWLnum allocates control structure and buffer
// (if requested) for a new WLarge Number.
//
// Input parameters:	int Size	required element count
// Returns: WLNUM *	== 0 -> allocation Error
//			<> 0 -> pointer to new created structure
//
//===============================================================
WLNUM * FAST AllocNewWLnum(HMEM_CTX_DEF int Size)
{
  WLNUM * pWLnum;
  int * pBuf;
  //-------------------------------------------------------------
  // Allocate, initialize structure
  //-------------------------------------------------------------
  pWLnum = (WLNUM *)
             ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1, sizeof(WLNUM)));
  if(pWLnum == NULL)
    return(NULL);
  //-------------------------------------------------------------
  // Allocate Number buffer if requested
  //-------------------------------------------------------------
  if(Size > 0)
  {
    if((pBuf = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,Size)) == NULL)
    {
      FREE_CARRAY(HMEM_CTX_REF,pWLnum);
      return(NULL);
    }
    pWLnum->AllocSize = Size;
    pWLnum->lpEl      = pBuf;
  }
  return(pWLnum);
}
//==============================================================
// UP FreeWLnum frees buffer and control structure for a
// WLarge Number. If a Null pointer is passed no action is
// performed.
//
// Input parameters:	WLNUM * pWLnum Structure pointer
// Returns: nothing
//==============================================================
void FAST FreeWLnum(HMEM_CTX_DEF WLNUM * pWLnum)
{
  if(pWLnum != NULL)
  {
    FREE_ARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    FREE_ARRAY(HMEM_CTX_REF,pWLnum);
  }
}
//==============================================================
// ClearFreeWLnum frees buffer and control structure for a
// WLarge Number, clears the buffer before releasing it (to
// prevent leaving security relevant data in memory)
//
// Input parameters:	WLNUM * pWLnum	Structure pointer
// Returns: nothing
//==============================================================
void FAST ClearFreeWLnum(HMEM_CTX_DEF WLNUM * pWLnum)
{
  int * pBuf;

  if(pWLnum != NULL)
  {
    if((pBuf = pWLnum->lpEl) != NULL)
    {
//      ClearBit32Array(pBuf, 0, pWLnum->AllocSize);
      memset(pBuf,0,pWLnum->AllocSize*4);
      FREE_CARRAY(HMEM_CTX_REF,pBuf);
    }
    FREE_CARRAY(HMEM_CTX_REF,pWLnum);
  }
}
//==============================================================
// ClearWLnumElements clears WLarge Number buffer,
// sets used size = 0
//
// Input parameters:	WLNUM * pWLnum Structure
// Returns: Nothing
//==============================================================
void FAST ClearWLnumElements(WLNUM * pWLnum)
{
  int * pBuf;

  if((pWLnum != NULL) && (pWLnum->AllocSize != 0) &&
     ((pBuf = pWLnum->lpEl) != NULL))
  {
//    ClearBit32Array(pBuf, 0, pWLnum->AllocSize);
    memset(pBuf,0,pWLnum->AllocSize*4);
    pWLnum->UsedSize = 0;
  }
}
//==============================================================
// AllocWLnumElements allocates/reallocates the Elementbuffer
// of a given WLarge Number control structure
// NOTE: No parameters checked !!!
// -----
//
// NOTE: the contents of an already allocated buffer is
// ----- maintained up to min(requested,allocated) Elements
//
// Input parameters:	WLNUM * pWLnum Structure
//			int NewSize	 New requested size
// Returns: int Status - 0 o.k., else Error occured
//==============================================================
int FAST AllocWLnumElements(HMEM_CTX_DEF WLNUM * pWLnum, int NewSize)
{
  int AllocedSize;
#if defined XH_INTERFACE
  int CopyCnt;
  int * pOldBuf;
#endif // XH_INTERFACE
  int * pNewBuf = NULL;
  //----------------------------------------------------------------
  // check if we have already allocated memory, and if so, check size
  //----------------------------------------------------------------
  AllocedSize = pWLnum->AllocSize;		// get element count
  if(AllocedSize > 0)				// allocated element(s) present
  {
    if(NewSize > 0)				// Element present, resize
    {
//      PRINT("\nREALLOC ");
      //------------------------------------------------------------
      // we must re-allocate memory, different for JAVA / C
      // NOTE: now same routine for C as for JAVA when external
      // ----- interface is to be used !!!!!
      //------------------------------------------------------------
#if !defined XH_INTERFACE
      if((pNewBuf = (int *) realloc(pWLnum->lpEl,
                            NewSize * sizeof(int))) == NULL)
      {
        pWLnum->UsedSize = 0;
        return(LNUM_OP_ALLOC_ERR);
      }
      pWLnum->lpEl      = pNewBuf;	// set new buffer
      pWLnum->AllocSize = NewSize;	// set new size
      //------------------------------------------------------------
      // Clear the new allocated portion if larger than before
      //------------------------------------------------------------
      if(NewSize > AllocedSize)
//        ClearBit32Array(pNewBuf,AllocedSize,NewSize - AllocedSize);
        memset(pNewBuf+AllocedSize,0,(NewSize - AllocedSize)*4);
      //------------------------------------------------------------------
      // Correct used size if buffer shrinked ??? -> should not happen !!!
      // CHECK if we should *REALLY* renormalize !!!!
      //------------------------------------------------------------------
//    if(NewSize < WLNUM_UsedSize(pWLnum))
//      WLNUM_UsedSize(pWLnum) = NewSize;
      return(LNUM_OP_OK);

#else // XH_INTERFACE mode
      if((pNewBuf = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,NewSize)) == NULL)
      {
        pWLnum->UsedSize = 0;
        return(LNUM_OP_ALLOC_ERR);
      }
      pOldBuf = pWLnum->lpEl;
      pWLnum->lpEl      = pNewBuf;	// set new buffer
      pWLnum->AllocSize = NewSize;	// set new size
      //-----------------------------------------------------------------------
      // copy data to new buffer if any, clear the rest if larger (not needed!)
      //-----------------------------------------------------------------------
      CopyCnt = AllocedSize;			// assume all to copy
      if(NewSize < AllocedSize)			// new is smaller (but NOT 0)
        CopyCnt = NewSize;
      memcpy(pNewBuf,pOldBuf,CopyCnt*4);
      FREE_CARRAY(HMEM_CTX_REF,pOldBuf);
      //------------------------------------------------------------------
      // Correct used size if buffer shrinked ??? -> should not happen !!!
      // CHECK if we should *REALLY* renormalize !!!!
      //------------------------------------------------------------------
//    if(NewSize < pWLnum->UsedSize)
//      pWLnum->UsedSize = NewSize;
      return(LNUM_OP_OK);
#endif
    } // NewSize > 0
    else
    {
      //----------------------------------------------------------
      // Buffer release option, New Size <= 0, AllocedSize was > 0
      //----------------------------------------------------------
      FREE_ARRAY(HMEM_CTX_REF,pWLnum->lpEl); // also sets NULL !
      pWLnum->AllocSize = 0;			// nothing allocated
      pWLnum->UsedSize  = 0;			// nothing used
      return(LNUM_OP_OK);				// o.k.
    } // Element present
  }
  //--------------------------------------------------------------
  // no elements have been allocated yet, allocate elements now,
  // check for trivial case of NewSize <= 0 also !
  //--------------------------------------------------------------
  if(NewSize > 0)				// new buffer requested
  {
    pNewBuf = (int *)
	        ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
					    NewSize * sizeof(int)));
    if(pNewBuf == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pWLnum->lpEl      = pNewBuf;
    pWLnum->AllocSize = NewSize;
    pWLnum->UsedSize  = 0;
  }
  return(LNUM_OP_OK);
}
//===================================================================
// Free a WLarge number work context and its WLnum Structures and
// their Elements
//
// Input parameters: WLNUM_CTX * pCtx	Context
// Returns: Nothing
//===================================================================
void FAST FreeWLnumContext(HMEM_CTX_DEF WLNUM_CTX * pCtx)
{
  int Index;
  WLNUM ** pNumArr;

  if(pCtx == NULL)
    return;
  Index = pCtx->AllocedNumCnt;
  pNumArr = pCtx->pWLnumArr;
  while(Index != 0)
  {
    Index--;
    FreeWLnum(HMEM_CTX_REF1 pNumArr[Index]);
  }
  FREE_ARRAY(HMEM_CTX_REF,pNumArr);
  FREE_ARRAY(HMEM_CTX_REF,pCtx);
}

//===================================================================
// Allocate a WLarge number work context of given size and
// Allocated Element buffers if requested
//
// Input parameters: int NumCnt		Number structures to allocate
//		     int ElementSize	Size of Elements to allocate
// Returns: WLNUM_CTX * / NULL if alloc failed
//===================================================================
WLNUM_CTX * FAST AllocWLnumContext(HMEM_CTX_DEF
				   int NumCnt, int ElementSize)
{
  int Index = 0;
  WLNUM ** pNumArr;
  WLNUM_CTX * pCtx;

  if((NumCnt <= 0) || (ElementSize < 0))	// should not happen
    return(NULL);
  //------------------------------------------------------
  // Allocate the Structure and the Pointer array
  //------------------------------------------------------
  pCtx    = (WLNUM_CTX *)
	      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				          sizeof(WLNUM_CTX)));
  pNumArr = (WLNUM **)
	      ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
				          sizeof(WLNUM *) * NumCnt));
  if(pCtx == NULL)
    return(NULL);
  if(pNumArr == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pCtx);
    return(NULL);
  }
  pCtx->AllocedNumCnt = NumCnt;
  pCtx->pWLnumArr     = pNumArr;
  //----------------------------------------------------------
  // Allocate the WLNUM Structures and Elements
  //----------------------------------------------------------
  do
  {
    if((pNumArr[Index] = AllocNewWLnum(HMEM_CTX_REF1
				       ElementSize)) == NULL)
      break;
    Index++;
  }while(Index < NumCnt);
  if(Index != NumCnt)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pCtx);
    pCtx = NULL;
  }
  return(pCtx);
}

//===================================================================
// Get a WLarge number structure of required size from a work context
// Re-Allocate Element buffer if needed, initialize the WLnum
//
// Input parameters: WLNUM_CTX *  pCtx	 	Context
//		     int ElementSize		Size of Element needed
//		     WLNUM ** ppWLnum		Element returned
// Returns: int Status - 0 o.k., else error occured
//===================================================================
int FAST GetWLnumFromContext(HMEM_CTX_DEF
		             WLNUM_CTX * pCtx, int ElementSize,
			     WLNUM ** ppWLnum)
{
  int Index;
  int * pEl;
  WLNUM * pWLnum;
  //------------------------------------------------------
  // Check parameters, remove later !!
  //------------------------------------------------------
  if((pCtx == NULL) || (ppWLnum == NULL))
    return(LNUM_OP_NULL_PTR);
  if(ElementSize < 0)
    return(LNUM_OP_PARAM_ERR);
  //------------------------------------------------------
  // Check if still elements available in Context
  //------------------------------------------------------
  if((Index = pCtx->NextFreeIndex) >= pCtx->AllocedNumCnt)
    return(LNUM_OP_CTX_FULL);
  pWLnum = pCtx->pWLnumArr[Index];
  //------------------------------------------------------
  // Check Size, reallocate if needed
  //------------------------------------------------------
  if(pWLnum->AllocSize < ElementSize)
  {
    if((pEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,ElementSize)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    FREE_CARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    pWLnum->lpEl      = pEl;
    pWLnum->AllocSize = ElementSize;
  }
  pWLnum->UsedSize = 0;
  pCtx->NextFreeIndex = Index + 1;
  ppWLnum[0] = pWLnum;
  return(LNUM_OP_OK);
}
//===================================================================
// Get a WLarge number structure of required size from a work context
// Re-Allocate Element buffer if needed, initialize the WLnum
//
// Input parameters: WLNUM_CTX * pCtx	 	Context
//		     int ElementSize		Size of Element needed
// Returns: WLNUM * pWLnum / NULL if Error
//===================================================================
WLNUM * FAST GetWLnumPtrFromContext(HMEM_CTX_DEF
		                    WLNUM_CTX * pCtx, int ElementSize)
{
  int Index;
  int * pEl;
  WLNUM * pWLnum;
  //------------------------------------------------------
  // Check parameters, remove later !!
  //------------------------------------------------------
  if((pCtx == NULL) | (ElementSize < 0))
    return(NULL);
  //------------------------------------------------------
  // Check if still elements available in Context
  //------------------------------------------------------
  if((Index = pCtx->NextFreeIndex) >= pCtx->AllocedNumCnt)
    return(NULL);
  pWLnum = pCtx->pWLnumArr[Index];
  //------------------------------------------------------
  // Check Size, reallocate if needed
  //------------------------------------------------------
  if(pWLnum->AllocSize < ElementSize)
  {
    if((pEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,ElementSize)) == NULL)
      return(NULL);
    FREE_CARRAY(HMEM_CTX_REF,pWLnum->lpEl);
    pWLnum->lpEl      = pEl;
    pWLnum->AllocSize = ElementSize;
  }
  pWLnum->UsedSize = 0;
  pCtx->NextFreeIndex = Index + 1;
  return(pWLnum);
}
//===================================================================
// Release n WLarge numbers from work context, do NOT free !
//
// Input parameters: WLNUM_CTX * pCtx	Context
//		     int WLnumCnt	Number of Elements to release
// Returns: Nothing
//===================================================================
void FAST ReleaseWLnumsFromContext(WLNUM_CTX * pCtx, int WLnumCnt)
{
  if(pCtx != NULL)
  {
    if((pCtx->NextFreeIndex -= WLnumCnt) < 0)
      pCtx->NextFreeIndex = 0;
  }
  return;
}
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//()								()
//() Large Number package CORE routines, are trimmed for speed.	()
//() BE EXTREMLY CAREFUL WHEN CHANGING ANY OF THESE ROUTINES !!!()
//()								()
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//***************************************************************
//*								*
//* 64 Bit Emulation Mode routines				*
//*								*
//* Assumptions:						*
//* - No unsigned types available				*
//* - Largest internal type is a (signed) BIT32			*
//* - No Carry out available from 32Bit Addition/Subtraction	*
//* - No High Word (32Bits) available from 32Bit multiplication	*
//* - No 64Bit by 32Bit Division available			*
//***************************************************************
#if !defined LNUM32_USE_INT64

//==============================================================
// 32Bit Emulation Routine
// Multiply 32 by 32 using Emulation mode used for machines without
// int64 types.
//
//
// Input parameters:	int	Mult1	Multiplicand
//			int	Mult2	Multiplicator
//			int *	pProdL	Prod. Least significant 32 Bits
// Returns: int ProdH Product Most significant 32 Bits
//==============================================================
static int FAST Mul32By32Emul32(int Mult1, int Mult2, int * pProdL)
{
  int A, B, C, D;
  int AC,BD,AD,BC;

  //---------------------------------------------------------------------
  // format of numbers is: Mult1 = a * 2**16 + b, Mult2 = c * 2**16 + d
  // calculate products BD = b * d, AD = a * d, BC = b * c and AC = a * c
  //---------------------------------------------------------------------
  A = (Mult1 >> 16) & 0x0FFFF;
  B = (Mult1 & 0x0FFFF);
  C = (Mult2 >> 16) & 0x0FFFF;
  D = (Mult2 & 0x0FFFF);

  BD = B * D;
  AD = A * D;
  BC = B * C;
  AC = A * C;
  //-------------------------------------------------------------------------
  // Result is now calculated from: AC * 2**32 + AD * 2**16 + BC * 2**16 + BD
  // Written in positional format:
  //		AC
  //	      +  AD
  //	      +  BC
  //          +   BD
  //	      ------
  //	        HHLL		Product
  // NOTE: There cannot be a carry out beyond bit 64.
  // ----- so we do the following:
  //	   - add High Word of AD and BC to AC
  //	   - clear High Word of AD, BC
  //	   - Add AD and BC and High Word of BD
  //	   - Low Word of Result replaces BD High Word
  //	   - High Word of result must be added as Carry to AC
  //-------------------------------------------------------------------------
  AC += ((AD >> 16) & 0xFFFF) + ((BC >> 16) & 0xFFFF);
  AD &= 0xFFFF;
  BC &= 0xFFFF;
  AD += BC + ((BD >> 16) & 0xFFFF);
  AC += ((AD >> 16) & 0xFFFF);
  BD = (BD & 0xFFFF) | ((AD & 0xFFFF) << 16);
  pProdL[0] = BD;
  return(AC);
}
//================================================================
// 32Bit Emulation Routine
// Divide 32 Bit Dividend by 16 Bit Divisor. Used for Word Remainder
// Calculation.
// NOTE: Divisor must be normalized, i.e. Divisor is >= B16/2
// -----
//
// Input parameters: int u		Dividend
//		     int v		Divisor (only lower 16 Bits used)
//		     int * pQ		Quotient/NULL
// Returns: BIT32 Remainder
//=================================================================
static int FAST NormDiv32By16Emul32(int u, int v, int * pQ)
{
  int qhat, rhat2, A31, X15;

  //---------------------------------------------------------------------
  // We assume that Dividend and Divisor are represented as follows
  // Dividend = A31*2 + B1
  // Divisor  = X15*2 + Y1
  // First we calculate estimate qhat, rhat.
  // NOTE: if Y1 == 0 qhat will be the desired result for q (max 17 bits)
  // ----- if Y1 == 1 qhat must be checked for reduce (up to 4 times)
  //---------------------------------------------------------------------
  A31 = (u >> 1) & 0x7FFFFFFF;
  X15 = (v >> 1) & 0x7FFF;

  qhat  = A31 / X15;				// 0 <= qhat <= 2**17 - 1
  rhat2 = ((A31 % X15) << 1) +	(u & 0x01); 	// 0 <= rhat2 < X15*2 + 1

#if 0
  PRINT("u = ");
  PRINT_HEX_BIT32(u);
  PRINT(" v = ");
  PRINT_HEX_BIT32_NL(v);

  PRINT("A31 = ");
  PRINT_HEX_BIT32(A31);
  PRINT(" X15 = ");
  PRINT_HEX_BIT32_NL(X15);

  PRINT("B32:16 qhat = ");
  PRINT_HEX_BIT32(qhat);
  PRINT(", rhat2 = ");
  PRINT_HEX_BIT32_NL(rhat2);
#endif

  //--------------------------------------------------------------------
  // Check special reduce case (Y1 == 1)
  //--------------------------------------------------------------------
  if((v & 0x01) != 0)				// Y1 == 1
  {
    //---------------------------------------------------------------------
    // Y1 is *NOT* 0, must subtract qhat to get remainder
    // NOTE: we use the fact that we have to add V in total as
    // ----- X15*2 + 1 (for qhat reduction correction) == v for Y1 == 1 !!
    //---------------------------------------------------------------------
    rhat2 -= qhat;				// r = rhat*2 + B1 - qhat
//  PRINT("w = ");
//  PRINT_HEX_BIT32(v);

#if 0
    PRINT(" rem = ");
    PRINT_HEX_BIT32_NL(rhat2);
#endif

    while(rhat2 < 0)				// reduction loop
    {
      qhat--;					// reduce estimate
      rhat2 += v;				// r = r + 2*X15 + 1
#if 0
      PRINT("Reduce, ");
      PRINT(" rem = ");
      PRINT_HEX_BIT32_NL(rhat2);
#endif
    }
  }
  if(pQ != NULL)
    pQ[0] = qhat;				// set quotient
  return(rhat2);
}

//================================================================
// 32Bit Emulation Routine
// Divide 64 Bit Dividend by 32 Bit Divisor. Used for Division algorithms.
// NOTE: Divisor must be B32 normalized, i.e. Divisor is >= B32/2
// -----
//
// Input parameters: int uH		Dividend High Part
//		     int uL		Dividend Low  Part
//		     int v		Divisor
//		     int * pQH		Quotient High Part
//		     int * pQL		Quotient Low  Part
// Returns: int Remainder
//
// Testpattern :
// ---------------------------------------------------------
// 1. qhat1 full reduce (max. 4 times):
//    Dividend: FFFF 8000 0000 0000
//    Divisor:  8000 FFFF
//
// 2. qhat2 full reduce (max. 2 times):
//    Dividend: 0000 7FFF 8000 0000
//    Divisor:  8000 FFFF
//=================================================================
static int FAST NormDiv64By32Emul32(int uH, int uL, int v,
		                    int * pQH, int * pQL)
{
  int X16, Y16, qhat1, qhat2, rhat, z, SumL;
  int ProdH, ProdL, rH, rL;
  int pTmpQ[1];

  qhat2 = 0;
  //---------------------------------------------------------------------
  // 1. Stage, calculate qhat1 and rhat1
  //
  // We assume that Dividend and Divisor are represented as follows
  // Dividend = A32 * 2**32 + B32
  // Divisor  = X16 * 2**16 + Y16
  //---------------------------------------------------------------------
  X16  = (v >> 16) & (int) 0x0FFFF;
  Y16  = v & (int) 0x0FFFF;
  z    = Y16 << 16;				// Y16 * 2**16

  rhat  = NormDiv32By16Emul32(uH, X16, pTmpQ);
  qhat1 = pTmpQ[0];

#if 0
  PRINT("qhat1: ");
  PRINT_HEX_BIT32(qhat1);
  PRINT(" rhat1: ");
  PRINT_HEX_BIT32_NL(rhat);
#endif

  //------------------------------------------------------------------
  // Calculate P = qhat1 * Y16 * 2**16 as 64 Bit value
  //------------------------------------------------------------------
  ProdH = 0;
  ProdL = (qhat1 & (int) 0x0FFFF) * Y16;	// Product low
  if((qhat1 & 0x10000) != 0)			// high part to add
  {
    SumL  = ProdL;
    ProdL = SumL + z;				// add Y16 * 2**16, gen. carry
    ProdH =					// subtract neg. carry
      -(((SumL & z) | ((~ProdL) & (SumL | z))) >> 31);
  }
  ProdH = (ProdH << 16) | ((ProdL >> 16) & (int) 0x0FFFF); // * 2**16
  ProdL = ProdL << 16;				// dto.

//  PRINT("Product P: ");
//  PRINT_HEX_BIT64_NL(ProdH, ProdL);
  //------------------------------------------------------------------
  // Set up remainder r = B32 + rhat * 2**32, Calculate r = r - P
  //------------------------------------------------------------------
  rL = uL - ProdL;				// B32 - Product low
  SumL = (((~uL) & ProdL) | (rL & (~(uL ^ ProdL)))) >> 31; // neg. borrow
  rH = rhat - ProdH + SumL;			// rhat * 2**32 - Product high

//  PRINT("Calculation Remainder r: ");
//  PRINT_HEX_BIT64_NL(rH, rL);
  //------------------------------------------------------------------
  // Reduce qhat1 as long as r < 0, max. 4 times needed
  //------------------------------------------------------------------
  while(rH < 0)					// r is < 0
  {
    qhat1--;

//    PRINT_NL("Reduce1");
//    PRINT("Add to low, z= Y16 * 2**16: ");
//    PRINT_HEX_BIT32_NL(z);
//    PRINT("Add to high, X16 * 2**16: ");
//    PRINT_HEX_BIT32_NL(X16);

    SumL = rL + z;				// add Y16 * 2**16
    rL   = ((rL & z) | ((~SumL) & (rL | z))) >> 31; // generate neg. carry
    rH   = rH + X16 - rL;			// add X16 * 2**16 + carry
    rL   = SumL;
#if 0
    PRINT(" qhat1 now: ");
    PRINT_HEX_BIT32(qhat1);
    PRINT(", Remainder r now: ");
    PRINT_HEX_BIT64_NL(rH, rL);
#endif
  }
#if 0
  PRINT("qhat1 past reduce1: ");
  PRINT_HEX_BIT32_NL(qhat1);
  PRINT("Reduced Remainder r: ");
  PRINT_HEX_BIT64_NL(rH, rL);
#endif
  //------------------------------------------------------------------
  // Check early out condition, i.e. if r < v
  //------------------------------------------------------------------
  SumL = rL - v;				// Subtract
  SumL = (((~rL) & v) | (SumL & (~(rL ^ v)))) >> 31; // gen. neg. Borrow

  if((rH != 0) |				// shure > v, no early out
     (SumL == 0))				// no borrow, r > v)
  {
#if 0
    PRINT("NO EARLY OUT, Remainder: ");
    PRINT_HEX_BIT64_NL(rH, rL);
#endif
    //----------------------------------------------------------------
    // no early out, Step 2 is required, we set u = r now
    // We assume that the new Dividend is represented as follows
    // Dividend u = r = C32*2**16 + D16
    // Calculate qhat2 and rhat
    //----------------------------------------------------------------
//  uH = rH;
//  uL = rL;
    ProdL = (rH << 16) | ((rL >> 16) & (int) 0x0FFFF); // Generate C32

    rhat  = NormDiv32By16Emul32(ProdL, X16, pTmpQ);
    qhat2 = pTmpQ[0];

#if 0
    PRINT("\nqhat2: ");
    PRINT_HEX_BIT32(qhat2);
    PRINT(" rhat2: ");
    PRINT_HEX_BIT32_NL(rhat);
#endif
    //------------------------------------------------------------------
    // Calculate P = qhat2 * Y16 as 64 Bit value
    //------------------------------------------------------------------
    ProdH = 0;
    ProdL = (qhat2 & (int) 0x0FFFF) * Y16;		// Product low
    if((qhat2 & 0x10000) != 0)			// high part to add
    {
      SumL  = ProdL;
      ProdL = SumL + z;				// add, Y16 << 16, gen. carry
      ProdH =					// subtract neg. carry
       -(((SumL & z) | ((~ProdL) & (SumL | z))) >> 31);
    }
#if 0
    PRINT("Y16 = ");
    PRINT_HEX_BIT32_NL(Y16);
    PRINT("Product P2 = qhat2 * Y16: ");
    PRINT_HEX_BIT64_NL(ProdH, ProdL);
#endif
    //------------------------------------------------------------------
    // Set up remainder r = D16 + rhat * 2**16,
    // Calculate r = r - P
    //------------------------------------------------------------------
    z  = (rL & (int) 0x0FFFF) | (rhat << 16);		// D16 + rhat * 2**16
#if 0
    PRINT("z: ");
    PRINT_HEX_BIT32_NL(z);
#endif

//  rH = 0;
    rL = z - ProdL;				// D16 + rhat*2**16 - Prod. low
    SumL = (((~z) & ProdL) | (rL & (~(z ^ ProdL)))) >> 31; // neg. borrow
    rH = - ProdH + SumL;			// - Product high - borrow

#if 0
    PRINT("r = r - P2: ");
    PRINT_HEX_BIT64_NL(rH,rL);
#endif
    //------------------------------------------------------------------
    // Reduce qhat1 as long as r < 0, in theory max. 4 times needed,
    // but in praxi max. 2 times only
    //------------------------------------------------------------------
    while(rH < 0)				// r is < 0
    {
      qhat2--;
//      PRINT_NL("Reduce2 ");
      SumL = rL + v;				// add V direct
      rL   = ((rL & v) | ((~SumL) & (rL | v))) >> 31; // generate neg. carry
      rH   = rH - rL;				// add neg. carry
      rL   = SumL;
    }
#if 0
    PRINT("qhat2 after reduce: ");
    PRINT_HEX_BIT32_NL(qhat2);
    PRINT("rem after reduce: ");
    PRINT_HEX_BIT64_NL(rH,rL);
#endif
    //---------------------------------------------------------------------
    // Add possible 17th bit of qhat2 to lowest position of qhat1, clear it
    //---------------------------------------------------------------------
    qhat1 = qhat1 + (qhat2 >> 16);
    qhat2 = qhat2 & (int) 0x0FFFF;
  }
  //--------------------------------------------------------------
  // Calculate final quotient qH, qL
  //--------------------------------------------------------------
  pQH[0] = (qhat1 >> 16);			// set top most bit
  pQL[0] = (qhat1 << 16) | qhat2;		// set low part
  return(rL);
}
//================================================================
// 32Bit Emulation Routine
// Add two WLarge Numbers.The Destination may be one of the
// sources.
// Note: If numbers of different sizes are subtracted, the first
// ----- number must be that with the longer size !
//
// Input parameters: int   uvMinLen	size of smaller number
//		     int * pR[]		Result buffer
//		     int * pU[]		Summand1 buffer
//		     int * pV[]		Summand2 buffer
//		     int   uvDifLen	Size difference of numbers
//
// Returns:	int Carry		== 0 if no Carry out
//					== 1 if Carry out
//=================================================================
static int FAST HardAddWLnumEmul32(int uvMinLen, int * pR,
		                        int * pU, int * pV, int uvDifLen)
{
  int Index = 0;

  int SumL;
  int SumH = 0;				// used as Carry

  do
  {
    SumL = pU[Index] + pV[Index] - SumH;	// u + v + Carry [neg. Carry]
    SumH = ((pU[Index] & pV[Index]) |
            ((~SumL) & (pU[Index] | pV[Index]))) >> 31; // generate carry
    pR[Index++] = SumL;				// save value
    uvMinLen--;
  }while(uvMinLen != 0);
  //-------------------------------------------------------
  // propagate the carry if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    SumL = pU[Index] -SumH;			// "add" neg. Carry
    SumH = (pU[Index] & (~SumL)) >> 31;		// generate neg. Carry
    pR[Index++] = SumL;				// store result
    uvDifLen--;
  }
  return((int) (-SumH));			// -1 > 1
}
//================================================================
// 32Bit Emulation Routine
// Subtract two WLarge Numbers.The Destination may be one of the
// sources.
// Note: If numbers of different sizes are subtracted, the first
// ----- number (Minuend) must be that with the longer size !
//
// Input parameters: int   vLen		size of Subtrahend
//		     int * pR[]		Result buffer
//		     int * pU[]		Minuend (1st) buffer
//		     int * pV[]		Subtrahend (2nd) buffer
//		     int   uvDifLen	Size difference of
//					Minuend and Subtrahend
//
// Returns:	int Borrow		== 0 if no Borrow out
//					== 1 if Borrow out
/*==============================================================*/
static int FAST HardSubWLnumEmul32(int vLen, int * pR,
		                   int * pU, int * pV, int uvDifLen)
{
  int Index = 0;

  int DifL;
  int DifH = 0;				// used as Carry

  do
  {
    DifL = pU[Index] - pV[Index] + DifH;	// u - v - Borrow [neg. Borrow]
    DifH = (((~pU[Index]) & pV[Index]) |
            (DifL & (~(pU[Index]^pV[Index])))) >> 31; // generate borrow
    pR[Index++] = DifL;				// save value
    vLen--;
  }while(vLen != 0);
  //-------------------------------------------------------
  // propagate the borrow if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    DifL = pU[Index] + DifH;			// "subtract" neg. Borrow
    DifH = ((~pU[Index]) & DifL) >> 31;		// generate neg. Borrow
    pR[Index++] = DifL;				// store result
    uvDifLen--;
  }
  return((int) (-DifH));			// -1 > 1
}
//==============================================================
// 32Bit emulation Routine
// UP MulWLnumEmul32 does multiply two Wnumbers u and v
// NOTE: Result  m u s t  be different from input params
// -----
//
// Input parameters: WLNUM * pProd	pointer to result
// 		     WLNUM * pU		pointer to Multiplicand
// 		     WLNUM * pV		pointer to Multiplier v
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST MulWLnumEmul32(HMEM_CTX_DEF
			       WLNUM * pProd, WLNUM * pU, WLNUM * pV)
{
  int  Retcode,i,j,k, uSize, vSize, MaxSize;

  int Mul, ProdH, ProdL, SumL;		// multiplier

  int * pTmpEl2;
  int * pTmpEl1;
  int * pTmpEl0;
  int pTmp[1];

//  if((pProd == NULL) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  //------------------------------------------------
  // Check if one (or both) factor is zero
  //------------------------------------------------
  i = pU->UsedSize;
  j = pV->UsedSize;
  if((i<=0) || (j <= 0))
  {
    if((i == 0) || (j == 0) ||
    ((i == 1) && (pU->lpEl[0] == 0)) ||
    ((j == 1) && (pV->lpEl[0] == 0)))
    {
      pProd->UsedSize = 0;			// set Zero
      return(LNUM_OP_OK);
    }
  }
  //-------------------------------------------------
  // check which number is longer...
  //-------------------------------------------------
  MaxSize = i + j;			// get required length
  if(i >= j)
  {
    pTmpEl1 = pU->lpEl;
    pTmpEl0 = pV->lpEl;
    uSize = i;
    vSize = j;
  }
  else
  {
    pTmpEl1 = pV->lpEl;
    pTmpEl0 = pU->lpEl;
    uSize    = j;
    vSize    = i;
  }

  if(pProd->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pProd, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //------------------------------------------------------------
  // multiply loop 1 (without add)
  //------------------------------------------------------------
  pTmpEl2 = pProd->lpEl;			// Result pointer

  Mul = pTmpEl0[0];				// get multiplier
  i = uSize;					// multiplier Count
  j = 0;
  ProdL = 0;
  do
  {
    ProdH = Mul32By32Emul32(pTmpEl1[j], Mul, pTmp); // get new high part
    SumL  = ProdL + pTmp[0];			  // add low parts
    ProdH -= (((ProdL & pTmp[0]) | (~SumL & (ProdL | pTmp[0]))) >> 31);
    pTmpEl2[j++] = SumL;			// store low Element
    ProdL = ProdH;				// save High Element
  }while((--i) != 0);
  pTmpEl2[j] = ProdL;			// store saved low element
  //------------------------------------------------------------
  // multiply loop 2 (with add)
  //------------------------------------------------------------
  while((++i) < vSize)
  {
    Mul = pTmpEl0[i];				// get multiplier
    j = 0;
    k = i;

    ProdL = 0;
    do
    {
      ProdH = Mul32By32Emul32(pTmpEl1[j], Mul, pTmp); // get new high part
      SumL  = ProdL + pTmp[0];			  // add low parts
      ProdH -= (((ProdL & pTmp[0]) | (~SumL & (ProdL | pTmp[0]))) >> 31);
      ProdL = SumL + pTmpEl2[k];		// add 2nd summand
      ProdH -= (((SumL & pTmpEl2[k]) | (~ProdL & (SumL | pTmpEl2[k]))) >> 31);

      pTmpEl2[k++] = ProdL;			// store low Element
      ProdL = ProdH;				// save high Element
    }while((++j) < uSize);
    pTmpEl2[k] = ProdL;				// store saved Element
  }
  if(ProdL == 0)				// check if top element is 0
    MaxSize--;
  pProd->UsedSize = MaxSize;			// set max. size
  return(LNUM_OP_OK);
}
//======================================================================
// BIT32 Emulation Routine
// Subtract and Multiply Routine used for Division algorithm
// to calculate  u - q*v. If Result in too small, backadds v
// and signals that (See also LNUM.C)
//
// Input parameters:	int   vLen		Size of Divisor V
//			int * pU[] 		Dividend U
//			int   uIndex		Start Index for U
//			int * pV[]		Divisor V
//			int   Q			Multiplier Q
// Returns: int BorrowStatus == 0 no backadd occured
//			     != 0 a backadd was performed, reduce Q by 1
//======================================================================
static int FAST HardMulSubWLnumEmul32(int vLen, int * pU, int uIndex,
		                      int * pV, int Q)
{
  int vLenSave = vLen;
  int uIndexSave = uIndex;
  int vIndex = 0;
  int ProdH, ProdL, DifL;
  int ProdSave = 0;
  int DifH = 0;			// used as Borrow / Carry
  int pTmpLong[1];

  //---------------------------------------------------------------
  // perform multiply and subtract
  //---------------------------------------------------------------
  do
  {
    //--------------------------------------------------------------
    // Calculate new 64 Bit product add saved 32 High Bits from Last
    //--------------------------------------------------------------
    ProdH = Mul32By32Emul32(pV[vIndex++], Q, pTmpLong);
    ProdL = pTmpLong[0] + ProdSave;
    ProdH -= ((pTmpLong[0] & ProdSave) |
              ((~ProdL) & (pTmpLong[0] | ProdSave))) >> 31; // 'ADD' Carry
    ProdSave = ProdH;
    //--------------------------------------------------------------
    // Calculate Difference u - q*v with borrow
    //--------------------------------------------------------------
    DifL  = pU[uIndex] - ProdL + DifH;		// note: negative borrow!
    DifH  = ((~pU[uIndex] & ProdL) |
             (DifL & (~(pU[uIndex]^ProdL)))) >> 31; // generate Borrow
    pU[uIndex++] = DifL;
    vLen--;
  }while(vLen != 0);
  //----------------------------------------------------------------
  // Calculate topmost U element from remaining Product
  //----------------------------------------------------------------
  DifL  = pU[uIndex] - ProdH + DifH;		// note: negative borrow !
  DifH  = ((~pU[uIndex] & ProdH) |
           (DifL & (~(pU[uIndex]^ProdH)))) >> 31; // generate borrow
  pU[uIndex] = DifL;
  //----------------------------------------------------------------
  // Check if borrow out is set
  //----------------------------------------------------------------
  if(DifH == 0)					// no borrow, o.k.
    return(0);
  //---------------------------------------------------------------
  // perform backadd of V to U
  //---------------------------------------------------------------
  DifH = 0;
  vIndex = 0;
  uIndex = uIndexSave;
  do
  {
    //-------------------------------------------------------------
    // Calculate U + V with Carry
    //-------------------------------------------------------------
    DifL = pU[uIndex] + pV[vIndex] -DifH;	// NOTE: neg. Carry!
    DifH = ((pU[uIndex] & pV[vIndex]) |
            ((~DifL) & (pU[uIndex] | pV[vIndex]))) >> 31; // gen. Carry
    pU[uIndex++] = DifL;
    vIndex++;
    vLenSave--;
  }while(vLenSave != 0);
  //----------------------------------------------------------
  // Backadd the last Carry Bit
  //----------------------------------------------------------
  DifL = pU[uIndex] - DifH;			// NOTE: neg. Carry!
  pU[uIndex] = DifL;				// set the original value
  return(1);					// signal backadd
}
//==============================================================
// 32Bit Emulation routine
// Subroutine AddElementWLnumEmul32 calculates the sum of a Wlarge
// number and a given number element.
// The Destination is also the source.
//
// Input parameters: WLNUM *    pWnumU   Large Number Struc.
//		     int	Summand  given summand
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST AddElementWLnumEmul32(HMEM_CTX_DEF WLNUM * pWnumU, int Summand)
{
  int i,UsedSize;
  int SumL, Sum, Carry;
  int * pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;			// get used size
  if((UsedSize == 0) && (Summand == 0))
    return(LNUM_OP_OK);

  if(pWnumU->AllocSize <= UsedSize)
  {
    if((i = AllocWLnumElements(HMEM_CTX_REF1
			pWnumU, UsedSize+1)) != LNUM_OP_OK)
      return(i);
  }

  pElu = pWnumU->lpEl;				// get base
  if(UsedSize == 0)				// Number is zero
  {
    pElu[0] = 0;
    UsedSize++;
    pWnumU->UsedSize = UsedSize;
  }
  //----------------------------------------------------------
  // add up
  // CAN BE SPEEDED UP !!!
  // !!!!! CHANGE THAT !!!!!!
  //----------------------------------------------------------
  i = 0;					// startindex
  Carry = 0;
  SumL = Summand;				// set Number to add
  do
  {
    Sum = SumL + pElu[i] - Carry;		// add values [neg. carry]
    Carry = ((SumL & pElu[i]) | ((~Sum) & (SumL | pElu[i]))) >> 31;
    pElu[i++] = Sum;				// store back
    SumL  = 0;
    UsedSize--;					// reduce count
  }while(UsedSize != 0);
  //----------------------------------------------------------
  // check for Carry out
  //----------------------------------------------------------
  if(Carry != 0)				// had a carry out
  {
    pElu[i] = 1;				// save carry
    pWnumU->UsedSize++;				// increment valid size
  }
  return(LNUM_OP_OK);
}
//==============================================================
// 32Bit Emulation routine
// Subroutine SubElementWLnumEmul32 calculates the difference of a
// Wlarge number - a given number element.
// The Destination is also the source.
// Note: It is assumed that the large number is positive and
// ----- its value is larger/same than the subtrahend!!
//
// Input parameters: WLNUM *   pWlnumU      Large Number Struc.
//		     int       Subtrahend   given subtrahend
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST SubElementWLnumEmul32(WLNUM * pWnumU, int Subtrahend)
{
  int i,j, UsedSize;
  int Dif, Borrow;
  int * pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;			// get used size
  if(UsedSize == 0)				// cannot subtract
    return(LNUM_OP_ZERO_SIZE);
  pElu = pWnumU->lpEl;				// get base
  //----------------------------------------------------------
  // subtract lowest Element, is the only full subtraction (!)
  //----------------------------------------------------------
  i = 0;					// startindex
  Dif = pElu[0] - Subtrahend;			// generate start value
  Borrow = ((((~pElu[0]) & Subtrahend) |
            (Dif & (~(pElu[0]^Subtrahend)))) >> 31) & 0x01;
  pElu[0] = Dif;
  UsedSize--;					// reduce count
  j = UsedSize;					// save
  //---------------------------------------------------------
  // propagate Borrow if still set and elements present
  //---------------------------------------------------------
  for(;UsedSize > 0;UsedSize--)
  {
    if(Borrow == 0)				// no more borrow, ended
      break;
    i++;					// to next Minuend element

    Dif = pElu[i] - Borrow;			// propagate the borrow
    Borrow = (((~pElu[i]) & Dif) >> 31) & 0x01;
    pElu[i] = Dif;
  }
  //----------------------------------------------------------
  // check for topmost Element Zero
  //----------------------------------------------------------
  if(pElu[j] == 0)				// top Element zero
    pWnumU->UsedSize--;
  return(LNUM_OP_OK);
}
//==============================================================
// 32Bit emulation routine
// UP SquareWLnumEmul32 does square a number u using binomial
// formula:
// Let a = (an-1*b**n-1 + an-2*b**n-2+.....+a0) then, after
// reordering of the square summands of a**2 we get:
//
// a**2 = SUM(i=0,n-1)of[a(i)*a(i) * b**(2i)] + 2*(
//        a0*SUM(i=1,n-1)of[ai*b**i] +
//        a1*b*SUM(i=2,n-1)of[ai*b**i] + .... +
//        an-3*b**(n-3)*SUM(i=n-2,n)of[ai*b**i] +
//	  an-2*b**(n-2)*SUM(i=n-1,n-1)of[ai*b**i])
//
// Note: The first sum has the advantage that it can directly
//       be stored from the figure products as the distance
//       is always b**2i.
//       The remaining partial sums must be added at a distance
//       of b**2 ( 2 figures) to the previous one.
//       Further on,the first partial sum starts at b (figure2)
// NOTE: Destination and source  m u s t  be different !
// -----
//
// Input parameters: WLNUM * pProd	pointer to product
// 		     WLNUM * pU		pointer to number u
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST SquareWLnumEmul32(HMEM_CTX_DEF WLNUM * pProd, WLNUM * pU)
{
  int Retcode,i,j;
  int uSize,ProdSize;

  int ind0,ind1,ind2,ind3;

  int Mul, ProdH, ProdL, ProdSave, Carry, pH, pL, qH, qL;

  int * pElProd;
  int * pElu;
  int Tmp[1];

// if((pProd == NULL) || (pU == NULL)) return(LNUM_OP_NULL_PTR);

  //------------------------------------------------------------
  // check range of product, clear it
  //------------------------------------------------------------
  uSize = pU->UsedSize;			// get length
  pElu=pU->lpEl;			// get pointer
  ProdSize = uSize * 2;			// needed size
  if(pProd->AllocSize < ProdSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pProd, ProdSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pProd->UsedSize = ProdSize;		// set length count
  if(uSize == 0)			// nothing to do !!
    return(LNUM_OP_OK);

  pElProd = pProd->lpEl;		// get pointer
  pElProd[0] = 0;			// clear starting Element
  pElProd[ProdSize-1] = 0;		// clear topmost  Element
  //------------------------------------------------------------
  // calculate 1st partial sum
  //------------------------------------------------------------
  i = uSize - 1;			// figure count - 1
  if(i != 0)				// at least 2 figures
  {
#if 0
     PRINT("PSUM1: ");
     ShowLnum(pU);
#endif

    j = i;				// set for multiply
    ind0 = 1;				// start Source/Destination index

    Carry = 0;				// clear Carry
    ProdSave = 0;			// clear saver
    Mul = pElu[0];			// get multiplier
    do
    {
      //--------------------------------------------------
      // Multiply a0 * SUM
      //--------------------------------------------------
      ProdH = Mul32By32Emul32(pElu[ind0], Mul, Tmp);
      ProdL = Tmp[0];
      pL    = ProdL + ProdSave - Carry;		// Last + Carry
      Carry = ((ProdL & ProdSave) | ((~pL) & (ProdL | ProdSave))) >> 31;
      pElProd[ind0++] = pL;
      ProdSave = ProdH;
    }while((--j) != 0);
    ProdL = ProdSave - Carry;
    Carry = - (((~ProdL) & ProdSave) >> 31);

    pElProd[ind0++] = ProdL;
    pElProd[ind0]   = Carry;
    i--;				// reduce figure count
#if 0
    PRINT("A0 SUM: ");
    ShowLnum(pProd);
#endif
    //----------------------------------------------------------
    // calculate remaining partial sums
    //----------------------------------------------------------
    if(i != 0)				// at least 2 figures
    {
      ind3 = 1+2;			// destination index to 3rd elem.
      ind0 = 1;				// start Source index
      do
      {
        Mul = pElu[ind0++];		// get multiplier, increment index

        ind1 = ind0;			// assign Source index
        ind2 = ind3;			// assign Destination index
	ind3 += 2;

        j = i;				// set for multiply
        Carry = 0;			// clear Carry
        ProdSave = 0;
        do
        {
          ProdH = Mul32By32Emul32(pElu[ind1++], Mul, Tmp);
          ProdL = Tmp[0];

          qL    = ProdSave + ProdL - Carry;	// add low/low part1
          qH    = -(((ProdSave & ProdL) | ((~qL) & (ProdSave | ProdL))) >> 31);

          pL    = qL + pElProd[ind2];		// add low/low part2
          Carry = ((qL & pElProd[ind2]) | ((~pL) & (qL|pElProd[ind2]))) >> 31;
          pH    = qH - Carry;

          qL    = ProdH + pH;
          Carry = ((ProdH & pH) | ((~qL) & (ProdH | pH))) >> 31;

          pElProd[ind2++] = pL;
          ProdSave = qL;
        }while((--j) != 0);

        ProdL = ProdSave - Carry;
        ProdH = -((ProdSave & (~ProdL)) >> 31);

        pL    = pElProd[ind2];
        qL    = ProdL + pL;
        ProdH -=
              ((ProdL & pL) | ((~qL) & (ProdL | pL))) >> 31;

        pElProd[ind2++] = qL;
        pElProd[ind2]   = ProdH;
      }while((--i) != 0);
    }

#if 0
    PRINT("PSUMS2: ");
    ShowLnum(pProd);
#endif

    //----------------------------------------------------------
    // multiply actual partial sum times 2 (shift left 1 Bit)
    //----------------------------------------------------------
    i = ProdSize-1;			// number of figures to shift
    Carry = 0;
    ind0 = 1;
    do
    {
      ProdL = pElProd[ind0];
      ProdSave = ProdL + ProdL + Carry;
      pElProd[ind0++] = ProdSave;
      Carry = (ProdL >> 31) & 0x01;
    } while((--i) != 0);

#if 0
    PRINT("PSUMS2 * 2: ");
    ShowLnum(pProd);
#endif

  }
  //------------------------------------------------------------
  // add up figure squares
  //------------------------------------------------------------
  ProdSave = 0;
  ind0 = 0;
  ind1 = 0;
  do
  {
#if 0
    PRINT("MulIn *MulIN: ");
    PRINT_HEX_BIT64_NL(pElu[ind0], pElu[ind0]);
#endif
    //-----------------------------------------------------------
    // NOTE: Visual-C6 Compiler has a problem with auto-increment
    // in Funcion calls when same variable is also used !!!!!
    // --> Same for GNU Compiler !!!
    //-----------------------------------------------------------
#if 0
    ProdH = Mul32By32Emul32(pElu[ind0], pElu[ind0++], Tmp); // square figure
    ProdL = Tmp[0];
#else // VC6 Auto-Increment fault !!
    ProdH = Mul32By32Emul32(pElu[ind0], pElu[ind0], Tmp); // square figure
    ProdL = Tmp[0];
    ind0++;
#endif

#if 0
    PRINT("Mul*Mul: ");
    PRINT_HEX_BIT64_NL(ProdH, ProdL);
#endif

    pL    = ProdL + pElProd[ind1];
    pH    =
       - (((ProdL & pElProd[ind1]) | ((~pL) & (ProdL | pElProd[ind1]))) >> 31);

    ProdL = pL + ProdSave;
    pH    -=
         (((pL & ProdSave) | ((~ProdL) & (pL | ProdSave))) >> 31);

//    PRINT(" pElProd: ");
//    PRINT_HEX_BIT32_NL(pElProd[ind1]);

    pElProd[ind1++] = ProdL;

#if 0
    PRINT(" Prod1: ");
    PRINT_HEX_BIT32_NL(ProdL);
    PRINT(" pElProd: ");
    PRINT_HEX_BIT32(pElProd[ind1]);
#endif

    pL    = pH + pElProd[ind1];
    pH    =
         - (((pH & pElProd[ind1]) | ((~pL) & (pH | pElProd[ind1]))) >> 31);

    ProdL = pL + ProdH;
    pH    -=
           (((pL & ProdH) | ((~ProdL) & (pL | ProdH))) >> 31);

    ProdSave = pH;

    pElProd[ind1++] = ProdL;

#if 0
    PRINT(", Prod2: ");
    PRINT_HEX_BIT32(ProdL);
    PRINT(", ProdSave: ");
    PRINT_HEX_BIT32_NL(ProdSave);
#endif

  }while((--uSize) != 0);

#if 0
  PRINT("PRES: ");
  ShowLnum(pProd);
#endif

  //------------------------------------------------------------
  // check result topmost figure for zero
  //------------------------------------------------------------
  if(pElProd[ind1-1] == 0)
    pProd->UsedSize--;
  return(LNUM_OP_OK);
}
//==============================================================
// UP GetQ32EstimateEmul32 calculates qhat from given
// values u[n+m], u[n+m-1], u[n+m-2], v[n-1], v[n-2].
// This is the trial divisor calculation for Division
// NOTE: Normalized Dividend/Divisor is assumed !
// -----
// Input parameters: int * pU[]		current dividend
//		     int   uIndex	Index to topmost element n+m
//		     int   vnM1		v[n-1]
//		     int   vnM2		v[n-2]
// Returns: int qhat
//==============================================================
static int FAST GetQ32EstimateEmul32(int * pU, int uIndex,
		                     int vnM1, int vnM2)
{
  int TmpH[1];
  int TmpL[1];

  int qhatL, rhat, unM2, DifH, DifL, Sum, Tmp;

  //--------------------------------------------------------
  // calculate: qhat = (u[n+m] || u[n+m-1]) / v[n-1] and
  //            rhat = (u[n+m] || u[n+m-1]) % v[n-1]
  // NOTE: qhat <= 2**32 + 1, rhat < 2**32
  //--------------------------------------------------------
#if 0
  if((vnM1 & 0x80000000) == 0)
  {
    PRINT("GetQ32Estimate Divisor NOT normalized: ");
    PRINT_HEX_BIT64_NL(vnM1, vnM2);
  }
#endif

  rhat = NormDiv64By32Emul32(pU[uIndex], pU[uIndex-1], vnM1, TmpH, TmpL);
  qhatL = TmpL[0];

  EST_PRINT("U: ");
  EST_PRINT_HEX_BIT64(pU[uIndex],pU[uIndex-1]);
  EST_PRINT(", VNM1: ");
  EST_PRINT_HEX_BIT32_NL(vnM1);

  EST_PRINT("EMUL32 Estimate qhat: ");
  EST_PRINT_HEX_BIT64(TmpH[0],qhatL);
  EST_PRINT(", Estimate rhat: ");
  EST_PRINT_HEX_BIT32_NL(rhat);
  //--------------------------------------------------------------------
  // Check case, where qhat is either SURE too large, i.e. qhat == 2**32+1
  // or qhat might be too large by one only, i.e qhat == 2**32
  //--------------------------------------------------------------------
  if(TmpH[0] != 0)
  {
    qhatL--;					// reduce by one
    //----------------------------------------------------------------
    // Check special, trivial case: qhat == 2**32+1 ahead.
    // In that case we can always set q == 2**31-1 for the following:
    // 1. q <= 2**32 - 1 MUST hold and
    // 2. qhat - 2 <= q <= qhat
    //----------------------------------------------------------------
    if(qhatL == 0)				// qhat == 2**31+1
    {
      DIV_PRINT_NL("BIT32 Reduce 1a");
      qhatL--;					// use q = 2*+31-1 always
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32, reduce by one and check further
    // NOTE: when reducing qhat, rhat must be increased by v[n-1].
    // ----- if now rhat >= b, no further checking is needed
    //----------------------------------------------------------------
    Sum = rhat + vnM1;			// correct for qhat--, t high
    if((((rhat & vnM1) | ((~Sum) & (rhat | vnM1))) & 0x80000000) != 0)
    {
      DIV_PRINT_NL("BIT32 Reduce 1b");
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32 and rhat' = rhat + vnM1 < b, must
    // check if s = qhat * v[n-2]  >  t = b * rhat' + u[n-m-2]
    //----------------------------------------------------------------
    rhat = Sum;
    Sum  = Mul32By32Emul32(qhatL,vnM2,TmpL);	// calculate s, low high
    unM2 = pU[uIndex-2];				// get t low

    DifL  = unM2 - TmpL[0];			// t low - s low
    DifH  = rhat - Sum +
         ((((~unM2) & TmpL[0]) | (DifL & (~(unM2^TmpL[0])))) >> 31);

    if(((((~rhat) & Sum) | (DifH & (~(rhat^Sum)))) & 0x80000000) != 0)
    {
      qhatL--;
      DIV_PRINT_NL("BIT32 Reduce 1c");
    }
    return(qhatL);
  }
  //----------------------------------------------------------------
  // In the following cases qhat < 2**32 so may be 1 or 2 too large
  // Calculate: s = qhat * v[n-2] and: t = rhat*2**32 + u[n+m-2],
  // check if s > t.
  // NOTE: 1. s > t is equivalent to calculate t - s and check for borrow
  //----------------------------------------------------------------
#if 0
  DIV_PRINT("qhatL: ");
  DIV_PRINT_HEX_BIT32(qhatL);
  DIV_PRINT(", vnM2: ");
  DIV_PRINT_HEX_BIT32_NL(vnM2);
#endif


  Sum  = Mul32By32Emul32(qhatL,vnM2,TmpL);	// calculate s, low high
  unM2 = pU[uIndex-2];				// get t low

#if 0
  DIV_PRINT("s: ");
  DIV_PRINT_HEX_BIT64_NL(Sum,TmpL[0]);
#endif


  DifL  = unM2 - TmpL[0];			// t low - s low
  DifH  = rhat - Sum +
         ((((~unM2) & TmpL[0]) | (DifL & (~(unM2^TmpL[0])))) >> 31);

  if(((((~rhat) & Sum) | (DifH & (~(rhat^Sum)))) & 0x80000000) != 0)
  {
    DIV_PRINT_NL("BIT32 Reduce 2a");
#if 0
    DIV_PRINT("Before Next Check: qhatL is': ");
    DIV_PRINT_HEX_BIT32(qhatL);
    DIV_PRINT(", rhat: ");
    DIV_PRINT_HEX_BIT32(rhat);
    DIV_PRINT(", vnM1: ");
    DIV_PRINT_HEX_BIT32_NL(vnM1);
#endif
    qhatL--;
    Tmp = rhat + vnM1;			// adjust rhat, check if rhat < b
    if((((rhat & vnM1) | ((~Tmp) & (rhat | vnM1))) & 0x80000000) == 0)
    {
      rhat = Tmp;
//    PRINT_NL("BIT32 Check 2");
#if 0
      DIV_PRINT("reduced qhatL: ");
      DIV_PRINT_HEX_BIT32(qhatL);
      DIV_PRINT("increased rhat: ");
      DIV_PRINT_HEX_BIT32_NL(rhat);
#endif

      //-------------------------------------------------------------
      // q might be still too large, have to check:
      // s' = s - v[n-2]  >  t' = t + b*v[n-1] (or t'high = rhat' * b )
      // aka. calculate t' - s' and check for borrow
      //-------------------------------------------------------------
      DifH = TmpL[0] - vnM2;		// correct for qhat reduce
      Sum  += (((~TmpL[0]) & vnM2) | (DifH & (~(TmpL[0] ^ vnM2)))) >> 31;

#if 0
      EST_PRINT("s': ");
      EST_PRINT_HEX_BIT64(Sum,DifH);
      EST_PRINT("t': ");
      EST_PRINT_HEX_BIT64_NL(Tmp,unM2);
#endif

      DifL = unM2 - DifH;		// t' low - s' low
      DifH = Tmp - Sum +
             ((((~unM2) & DifH) | (DifL & (~(unM2^DifH)))) >> 31);

      EST_PRINT("Dif: ");
      EST_PRINT_HEX_BIT64_NL(DifH,DifL);

      if(((((~Tmp) & Sum) | (DifH & (~(Tmp^Sum)))) & 0x80000000) != 0)
      {
        qhatL --;
        DIV_PRINT_NL("BIT32 Reduce 2b");
      }
    }
  }
  return(qhatL);
}
//======================================================================
// 32 BIT Emulation Routine
// Add and Multiply Routine used for Montgomery algorithm
// to calculate  c = u + q*v for i=0 to sLen-1,
// and division of c by 2**(w*sLen)
// NOTE: As a final Carry may be generated size of number c must be
// ----- at least (2*sLen + 1) !!!!
//	 The following modulo reduction will shrink down size of c
//	 to 2*sLen anyway.
//
// Input parameters:	int   aLen		Size of number to convert
//			int * pA		Input number to convert
//			int   sLen		Size of Multiplicand V
//			int * pC 		Result C, size is 2*sLen+1 !!
//			int * pN		Multiplicand N (modulus)
//			int   Ni0		Multiplier Ni0 = - n[0]**(-1)
// Returns: int NumSize - size of number
//======================================================================
static int FAST HardMulAddMontEmul32(int aLen, int * pA,
				     int sLen, int * pC, int * pN, int Ni0)
{
  int cLen,nLen,cIndex,nIndex;
  int Q;
  int ProdH,ProdL,ProdHSave,ProdCY;
  int SumH,SumL;
  int sIndex = 0;
  int Tmp32[1];
  //----------------------------------------------------------------
  // copy input number to destination, clear not used elements
  //----------------------------------------------------------------
//  BIT32_ARRAY_COPY(pA,0,pC,0,aLen);
  memcpy(pC,pA,aLen*4);
//  ClearBit32Array(pC,aLen,(2*sLen+1)-aLen);
  memset(pC+aLen,0,((2*sLen+1)-aLen)*4);
  //----------------------------------------------------------------
  // outer loop over sLen (size of modulus)
  //----------------------------------------------------------------
  while(sIndex < sLen)
  {
    nLen   = sLen;
    nIndex = 0;
    cLen   = sLen * 2;
    cIndex = sIndex;
    ProdHSave = 0;
    SumH  = 0;
    Q     = pC[cIndex] * Ni0;			// Note: only 32 bits used!
    //---------------------------------------------------------------
    // inner loop, perform multiply and add
    //---------------------------------------------------------------
    do
    {
      //--------------------------------------------------------------
      // Calculate new 64 Bit product add saved 32 High Bits from Last
      // Note: no carry out possible (from high) !!
      //--------------------------------------------------------------
      ProdH = Mul32By32Emul32(pN[nIndex], Q, Tmp32);

      ProdL  = Tmp32[0] + ProdHSave;		// PL + PHsave
      ProdCY = ((Tmp32[0] & ProdHSave) |
               ((~ProdL) & (Tmp32[0] | ProdHSave))) >> 31; // gen. carry(neg!)
      ProdH  = ProdH - ProdCY;			// no CY out possible...
      ProdHSave = ProdH;			// save PH

      nIndex++;
      //--------------------------------------------------------------
      // Calculate Sum c + q*n with carry
      //--------------------------------------------------------------
      SumL = pC[cIndex] + ProdL - SumH;		// u + v + Carry [neg. Carry]

      SumH = ((pC[cIndex] & ProdL) |
            ((~SumL) & (pC[cIndex] | ProdL))) >> 31; // generate carry
      pC[cIndex++] = SumL;
      nLen--;
    }while(nLen != 0);
    //----------------------------------------------------------------
    // Calculate topmost C element from remaining Product saver
    //----------------------------------------------------------------
    SumL = pC[cIndex] + ProdHSave - SumH;		// u + v + Carry [neg. Carry]

    SumH = ((pC[cIndex] & ProdHSave) |
            ((~SumL) & (pC[cIndex] | ProdHSave))) >> 31; // generate carry
    pC[cIndex++] = SumL;
    //----------------------------------------------------------------
    // Check if carry out is set
    //----------------------------------------------------------------
    if(SumH != 0)				// carry, occured...
    {
      //---------------------------------------------------------------
      // add the carry to remaining elements of U
      //---------------------------------------------------------------
      do
      {
        //-------------------------------------------------------------
        // Calculate C + Carry
        //-------------------------------------------------------------
        SumL = pC[cIndex] - SumH;		// u + Carry [neg. Carry]
        SumH = ((pC[cIndex] & 0) |
            ((~SumL) & (pC[cIndex] | 0))) >> 31; // generate carry
        pC[cIndex++] = SumL;
        if(SumH == 0)				// no more carry...
          break;				// exit carry loop
      }while(cIndex < cLen);
    }
    sIndex++;
  }
  //-----------------------------------------------------------
  // Get size of calculated number, i.e. skip leading zeroes
  //-----------------------------------------------------------
  sIndex = 2 * sLen;				// set top element index
  while(sIndex >= 0)
  {
    if(pC[sIndex] != 0)				// found non zero element
      break;
    sIndex--;
  }
  //-----------------------------------------------------------
  // Shift right calculated number by sLen Elements (if appropriate!)
  // NOTE: 1. Start shift at the least significant word of pU to avoid
  // -----    overwrite !!!!
  //	   2. remaining (non zero) elements can be ignored
  //-----------------------------------------------------------
  sIndex = sIndex-sLen+1;			// resulting used size
  cIndex = 0;					// destination index
  while(cIndex < sIndex)
  {
    pC[cIndex] = pC[cIndex+sLen];		// shift right sLen elements
    cIndex++;
  }
  return(sIndex);				// report used size
}
#endif // !defined LNUM32_USE_INT64

//***************************************************************
//*								*
//* 64 Bit routines						*
//*								*
//* Assumptions:						*
//* - No unsigned types available				*
//* - Largest internal type is a (signed) BIT64			*
//* - No Carry out available from 64Bit Addition/Subtraction	*
//* - No High Word (64Bits) available from 64Bit multiplication	*
//* - No 64Bit by 32Bit Division available			*
//***************************************************************

#if defined LNUM32_USE_INT64


//================================================================
// Divide 64 Bit Dividend by 32 Bit Divisor. Used for Division algorithms.
// NOTE: Divisor must be B32 normalized, i.e. Divisor is >= B32/2
// -----
//
// Input parameters: BIT32 uH		Dividend High Part
//		     BIT32 uL		Dividend Low  Part
//		     BIT32 v		Divisor
//		     BIT32 pQH[]	Quotient High Part
//		     BIT32 pQL[]	Quotient Low  Part
// Returns: BIT32 Remainder
//
// Testpattern for full reduction cycles, i.e. qhat = 4 * q:
// ---------------------------------------------------------
// Dividend: FFFFFFFF 80000000
// Divisor:  80000001
//
//=================================================================
static int FAST NormDiv64By32Bit64(int uH, int uL, int v,
		                   int * pQH, int * pQL)
{
  long long A63, X31, qhat, rhat2, w;
  //---------------------------------------------------------------------
  // We assume that Dividend and Divisor are represented as follows
  // Dividend = A63*2 + B1
  // Divisor  = X31*2 + Y1
  // First we calculate estimate qhat, rhat.
  // NOTE: if Y1 == 0 qhat will be the desired result for q (max 33 bits)
  // ----- if Y1 == 1 qhat must be checked for reduce (up to 4 times)
  //---------------------------------------------------------------------

  A63 = ((((long long) uH << 32) | ((long long) uL & B64_0FFFFFFFF)) >> 1) &
        B64_07FFFFFFFFFFFFFFF;
  w   = (long long) v & B64_0FFFFFFFF;

  X31 = (w >> 1) & B64_07FFFFFFF;

  qhat  = A63 / X31;				// 0 <= qhat <= 2**33 - 1
  rhat2 = ((A63 - (qhat * X31)) << 1) + 	// 0 <= rhat2 < X31*2 + 1
          ((long long) uL & B64_01);

//  PRINT("qhat = ");
//  PRINT_HEX_BIT64((BIT32) (qhat >> 32), (BIT32) qhat);
//  PRINT(" rhat2 = ");
//  PRINT_HEX_BIT32_NL((BIT32) rhat2);

  //--------------------------------------------------------------------
  // Check special reduce case (Y1 == 1)
  //--------------------------------------------------------------------
  if((v & 0x01) != 0)				// Y1 == 1
  {
    //---------------------------------------------------------------------
    // Y1 is *NOT* 0, must subtract qhat to get remainder
    // NOTE: we use the fact that we have to add V in total as
    // ----- X31*2 + 1 (for qhat reduction correction) == v for Y1 == 1 !!
    //---------------------------------------------------------------------
    rhat2 -= qhat;				// r = rhat*2 + B1 - qhat
//  PRINT("w = ");
//  PRINT_HEX_BIT64((int) (w >> 32), (int) w);

//  PRINT(" rem = ");
//  PRINT_HEX_BIT64_NL((int) (rem >> 32), (int) rem);

    while(rhat2 < 0)				// reduction loop
    {
//    PRINT("Reduce, ");
      qhat--;					// reduce estimate
      rhat2 += w;				// r = r + 2*X31 - 1
//    PRINT(" rem = ");
//    PRINT_HEX_BIT64_NL((int) (rem >> 32), (int) rem);
    }
  }
  pQH[0] = (int) ((qhat >> 32) & 0x01);		// set MSW
  pQL[0] = (int) qhat;				// set LSW
  return((int) rhat2);
}
//================================================================
// Divide 32 Bit Dividend by 16 Bit Divisor. Used for Word Remainder
// Calculation.
// NOTE: Dividend and Divisor must be normalized, i.e. Divisor is >= B16/2
// -----
//
// Input parameters: int u		Dividend
//		     int v		Divisor (only lower 16 Bits used)
//		     int * pQ		Quotient/NULL
// Returns: int Remainder
//=================================================================
static int FAST NormDiv32By16Bit64(int u, int v, int * pQ)
{
  long long Quot, Rem;
  //---------------------------------------------------------------------
  // Divide direct
  //---------------------------------------------------------------------
  if(pQ != NULL)
  {
    Quot = ((long long) u & B64_0FFFFFFFF) /
            ((long long) v & B64_0FFFF);
    pQ[0] = (int) Quot;
  }
  Rem  = ((long long) u & B64_0FFFFFFFF) %
         ((long long) v & B64_0FFFF);
  return((int) Rem);
}
//================================================================
// Add two WLarge Numbers. The Destination may be one of the
// sources.
// Note: If numbers of different sizes are subtracted, the first
// ----- number must be that with the longer size !
//
// Input parameters: int   uvMinLen	size of smaller number
//		     int * pR		Result buffer
//		     int * pU		Summand1 buffer
//		     int * pV		Summand2 buffer
//		     int   uvDifLen	Size difference of numbers
//
// Returns:	int Carry		== 0 if no Carry out
//					== 1 if Carry out
//=================================================================
static int FAST HardAddWLnumBit64(int uvMinLen, int * pR,
	                          int * pU, int * pV, int uvDifLen)
{
  int Index = 0;
  long long Sum = 0;

  do
  {
    Sum = ((long long) pU[Index] & B64_0FFFFFFFF) +
          ((long long) pV[Index] & B64_0FFFFFFFF) +
	  ((Sum >> 32) & B64_0FFFFFFFF);	// u + v + Carry
    pR[Index++] = (int) Sum;			// save value
    uvMinLen--;
  }while(uvMinLen != 0);
  //-------------------------------------------------------
  // propagate the carry if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    Sum = ((long long) pU[Index] & B64_0FFFFFFFF) +
	  ((Sum >> 32) & B64_0FFFFFFFF);// add Carry
    pR[Index++] = (int) Sum;			// store result
    uvDifLen--;
  }
  return((int) (Sum >> 32));			// -1 > 1
}
//================================================================
// Subtract two WLarge Numbers.The Destination may be one of the
// sources.
// Note: If numbers of different sizes are subtracted, the first
// ----- number (Minuend) must be that with the longer size !
//
// Input parameters: int   vLen		size of Subtrahend
//		     int * pR		Result buffer
//		     int * pU		Minuend (1st) buffer
//		     int * pV		Subtrahend (2nd) buffer
//		     int   uvDifLen	Size difference of
//					Minuend and Subtrahend
//
// Returns:	int Borrow		== 0 if no Borrow out
//					== 1 if Borrow out
//==============================================================
static int FAST HardSubWLnumBit64(int vLen, int * pR,
		                  int * pU, int * pV, int uvDifLen)
{
  int Index = 0;
  long long Dif = 0;

  do
  {
    Dif = ((long long) pU[Index] & B64_0FFFFFFFF) -
          ((long long) pV[Index] & B64_0FFFFFFFF) +
	  (Dif >> 32);				// u - v - Borrow [neg. Borrow]
    pR[Index++] = (int) Dif;			// save value
    vLen--;
  }while(vLen != 0);
  //-------------------------------------------------------
  // propagate the borrow if one set or not if needed
  // Note: it is more effective to streamline the code by
  // ----- avoiding decision steps (!)
  //-------------------------------------------------------
  while(uvDifLen != 0)
  {
    Dif = ((long long) pU[Index] & B64_0FFFFFFFF) +
	  (Dif >> 32);				// "subtract" neg. Borrow
    pR[Index++] = (int) Dif;			// store result
    uvDifLen--;
  }
  return((int) (-Dif));				// -1 > 1
}
//==============================================================
// UP MulWLnumBit64 does multiply two Wnumbers u and v
// NOTE: Result  m u s t  be different from input params
// -----
//
// Input parameters: WLNUM * pProd	pointer to result
// 		     WLNUM * pU		pointer to Multiplicand
// 		     WLNUM * pV		pointer to Multiplier v
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST MulWLnumBit64(HMEM_CTX_DEF
			      WLNUM * pProd, WLNUM * pU, WLNUM * pV)
{
  int  i,j, Retcode, uSize, vSize, MaxSize;

  int k;
  long long Prod, Mul;

  int * pTmpEl2;
  int * pTmpEl1;
  int * pTmpEl0;

//  if((pProd == NULL) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  //------------------------------------------------
  // Check if one (or both) factor is zero
  //------------------------------------------------
  i = pU->UsedSize;
  j = pV->UsedSize;
  if((i<=0) || (j <= 0))
  {
    if((i == 0) || (j == 0) ||
    ((i == 1) && (pU->lpEl[0] == 0)) ||
    ((j == 1) && (pV->lpEl[0] == 0)))
    {
      pProd->UsedSize = 0;			// set Zero
      return(LNUM_OP_OK);
    }
  }
  //-------------------------------------------------
  // check which number is longer...
  //-------------------------------------------------
  MaxSize = i + j;			// get required length
  if(i >= j)
  {
    pTmpEl1 = pU->lpEl;
    pTmpEl0 = pV->lpEl;
    uSize = i;
    vSize = j;
  }
  else
  {
    pTmpEl1 = pV->lpEl;
    pTmpEl0 = pU->lpEl;
    uSize    = j;
    vSize    = i;
  }

  if(pProd->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
				pProd, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //------------------------------------------------------------
  // multiply loop 1 (without add)
  //------------------------------------------------------------
  pTmpEl2 = pProd->lpEl;			// Result pointer

  Mul = (long long) pTmpEl0[0] & B64_0FFFFFFFF; // get multiplier
  i = uSize;					// multiplier Count
  j = 0;
  Prod = 0;
  do
  {
    Prod += (((long long) pTmpEl1[j] & B64_0FFFFFFFF) * Mul);
    pTmpEl2[j++] = (int) Prod;		// store low Element
    Prod = (Prod >> 32) & B64_0FFFFFFFF;// save high part
  }while((--i) != 0);
  pTmpEl2[j] = (int) Prod;			// store saved low element
  //------------------------------------------------------------
  // multiply loop 2 (with add)
  //------------------------------------------------------------
  i = 0;
  while((++i) < vSize)
  {
    Mul = (long long) pTmpEl0[i] & B64_0FFFFFFFF;	// get multiplier
    j = 0;
    k = i;

    Prod = 0;
    do
    {
      Prod = Prod +
             (((long long) pTmpEl1[j] & B64_0FFFFFFFF) * Mul) +
             ((long long) pTmpEl2[k] & B64_0FFFFFFFF);
      pTmpEl2[k++] = (int) Prod;			// store low Element
      Prod = (Prod >> 32) & B64_0FFFFFFFF;	// save high part
    }while((++j) < uSize);
    pTmpEl2[k] = (int) Prod;			// store saved Element
  }
  if((Prod & B64_0FFFFFFFF) == 0)	// check if top element is 0
    MaxSize--;

  pProd->UsedSize = MaxSize;		// set max. size
  return(LNUM_OP_OK);
}
//======================================================================
// BIT64 Routine
// Add and Multiply Routine used for Montgomery algorithm
// to calculate  c = u + q*v for i=0 to sLen-1,
// and division of c by 2**(w*sLen)
// NOTE: As a final Carry may be generated size of number c must be
// ----- at least (2*sLen + 1) !!!!
//	 The following modulo reduction will shrink down size of c
//	 to 2*sLen anyway.
//
// Input parameters:	int   aLen		Size of number to convert
//			int * pA		Input number to convert
//			int   sLen		Size of Multiplicand V
//			int * pC 		Result C, size is 2*sLen+1 !!
//			int * pN		Multiplicand N (modulus)
//			int   Ni0		Multiplier Ni0 = - n[0]**(-1)
// Returns: int NumSize - size of number
//======================================================================
static int FAST HardMulAddMontBit64(int aLen, int * pA,
		                    int sLen, int * pC, int * pN, int Ni0)
{
  int cLen,nLen,cIndex,nIndex;
  long long QLong;
  long long Prod, Sum;
  int sIndex = 0;
  //----------------------------------------------------------------
  // copy input number to destination, clear not used elements
  //----------------------------------------------------------------
  memcpy(pC,pA,aLen * 4);
//  ClearBit32Array(pC,aLen,(2*sLen+1)-aLen);
  memset(pC+aLen,0,((2*sLen+1)-aLen)*4);
  //----------------------------------------------------------------
  // outer loop over sLen (size of modulus)
  //----------------------------------------------------------------
  while(sIndex < sLen)
  {
    nLen   = sLen;
    nIndex = 0;
    cLen   = sLen * 2;
    cIndex = sIndex;
    Prod  = 0;
    Sum   = 0;
    QLong = (long long) ((pC[cIndex] * Ni0) & B64_0FFFFFFFF);

    //---------------------------------------------------------------
    // inner loop, perform multiply and add
    //---------------------------------------------------------------
    do
    {
      //--------------------------------------------------------------
      // Calculate new 64 Bit product add saved 32 High Bits from Last
      // Note: no carry out possible !!
      //--------------------------------------------------------------
      Prod = (((long long) pN[nIndex++] & B64_0FFFFFFFF) * QLong) +
	      ((Prod >> 32) & B64_0FFFFFFFF);
      //--------------------------------------------------------------
      // Calculate Sum c + q*n with carry
      //--------------------------------------------------------------
      Sum = ((long long) pC[cIndex] & B64_0FFFFFFFF) +
             (Prod & B64_0FFFFFFFF) +
             (Sum >> 32);
      pC[cIndex++] = (int) Sum;
      nLen--;
    }while(nLen != 0);
    //----------------------------------------------------------------
    // Calculate topmost C element from remaining Product
    //----------------------------------------------------------------
    Sum = ((long long) pC[cIndex] & B64_0FFFFFFFF) +
          ((Prod >> 32) & B64_0FFFFFFFF) +
          (Sum >> 32);
    pC[cIndex++] = (int) Sum;
    Sum >>= 32;
    //----------------------------------------------------------------
    // Check if carry out is set
    //----------------------------------------------------------------
    if(Sum != 0)				// carry, occured...
    {
      //---------------------------------------------------------------
      // add the carry to remaining elements of U
      //---------------------------------------------------------------
      do
      {
        //-------------------------------------------------------------
        // Calculate C + Carry
        //-------------------------------------------------------------
        Sum = ((long long) pC[cIndex] & B64_0FFFFFFFF) + Sum;
        pC[cIndex++] = (int) Sum;
        Sum >>= 32;
        if(Sum == 0)				// no more carry...
          break;				// exit carry loop
      }while(cIndex < cLen);
    }
    sIndex++;
  }
  //-----------------------------------------------------------
  // Get size of calculated number, i.e. skip leading zeroes
  //-----------------------------------------------------------
  sIndex = 2 * sLen;				// set top element index
  while(sIndex >= 0)
  {
    if(pC[sIndex] != 0)				// found non zero element
      break;
    sIndex--;
  }
  //-----------------------------------------------------------
  // Shift right calculated number by sLen Elements (if appropriate!)
  // NOTE: 1. Start shift at the least significant word of pU to avoid
  // -----    overwrite !!!!
  //	   2. remaining (non zero) elements can be ignored
  //-----------------------------------------------------------
  sIndex = sIndex-sLen+1;			// resulting used size
  cIndex = 0;					// destination index
  while(cIndex < sIndex)
  {
    pC[cIndex] = pC[cIndex+sLen];		// shift right sLen elements
    cIndex++;
  }
  return(sIndex);				// report used size
}
//======================================================================
// BIT64 Routine
// Subtract and Multiply Routine used for Division algorithm
// to calculate  u - q*v. If Result in too small, backadds v
// and signals that (See also LNUM.C)
//
// Input parameters:	int   vLen		Size of Divisor V
//			int * pU 		Dividend U
//			int   uIndex		Start Index for U
//			int * pV		Divisor V
//			int   Q			Multiplier Q
// Returns: int BorrowStatus == 0 no backadd occured
//			     != 0 a backadd was performed, reduce Q by 1
//======================================================================
static int FAST HardMulSubWLnumBit64(int vLen, int * pU, int uIndex,
				     int * pV, int Q)
{

  int vLenSave = vLen;
  int uIndexSave = uIndex;
  int vIndex = 0;
  long long QLong = (long long) Q & B64_0FFFFFFFF;
  long long Prod = 0;
  long long Dif  = 0;
  //---------------------------------------------------------------
  // perform multiply and subtract
  //---------------------------------------------------------------
  do
  {
    //--------------------------------------------------------------
    // Calculate new 64 Bit product add saved 32 High Bits from Last
    // Note: no carry out possible !!
    //--------------------------------------------------------------
    Prod = (((long long) pV[vIndex++] & B64_0FFFFFFFF) * QLong) +
	    ((Prod >> 32) & B64_0FFFFFFFF);
    //--------------------------------------------------------------
    // Calculate Difference u - q*v with borrow
    //--------------------------------------------------------------
    Dif  = ((long long) pU[uIndex] & B64_0FFFFFFFF) -
           (Prod & B64_0FFFFFFFF) +
           (Dif >> 32);
    pU[uIndex++] = (int) Dif;
    vLen--;
  }while(vLen != 0);
  //----------------------------------------------------------------
  // Calculate topmost U element from remaining Product
  //----------------------------------------------------------------
  Dif = ((long long) pU[uIndex] & B64_0FFFFFFFF) -
        ((Prod >> 32) & B64_0FFFFFFFF) +
        (Dif >> 32);
  pU[uIndex] = (int) Dif;
  Dif >>= 32;
  //----------------------------------------------------------------
  // Check if borrow out is set
  //----------------------------------------------------------------
  if(Dif == 0)					// no borrow, o.k.
    return(0);
  //---------------------------------------------------------------
  // perform backadd of V to U
  //---------------------------------------------------------------
//  PRINT_NL("Before Backadd");

  Dif = 0;
  vIndex = 0;
  uIndex = uIndexSave;
  do
  {
    //-------------------------------------------------------------
    // Calculate U + V with Carry
    //-------------------------------------------------------------
#if 0
    PRINT(" U: ");
    PRINT_HEX_BIT32(pU[uIndex]);
    PRINT(" V: ");
    PRINT_HEX_BIT32(pV[vIndex]);
#endif

    Dif = ((long long) pU[uIndex] & B64_0FFFFFFFF) +
          ((long long) pV[vIndex++] & B64_0FFFFFFFF) +
          (Dif >> 32);				// positive Carry!
    pU[uIndex++] = (int) Dif;

//    PRINT(" U': ");
//    PRINT_HEX_BIT32(pU[uIndex-1]);

    vLenSave--;
  }while(vLenSave != 0);
  //----------------------------------------------------------
  // Backadd the last Carry Bit to original
  //----------------------------------------------------------
  Dif = pU[uIndex] + (Dif >> 32);
  pU[uIndex] = (int) Dif;
  return(1);					// signal backadd
}
//==============================================================
// Subroutine AddElementWLnumBit64 calculates the sum of a Wlarge
// number and a given number element.
// The Destination is also the source.
//
// Input parameters: WLNUM *    pWnumU   Large Number Struc.
//		     int	Summand  given summand
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST AddElementWLnumBit64(HMEM_CTX_DEF WLNUM * pWnumU, int Summand)
{
  int i,UsedSize;
  long long Sum;
  int * pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;			// get used size
  if((UsedSize == 0) && (Summand == 0))
    return(LNUM_OP_OK);

  if(pWnumU->AllocSize <= UsedSize)
  {
    if((i = AllocWLnumElements(HMEM_CTX_REF1
			pWnumU, UsedSize+1)) != LNUM_OP_OK)
      return(i);
  }
  pElu = pWnumU->lpEl;				// get base
  if(UsedSize == 0)
  {
    pElu[0] = 0;
    UsedSize++;
    pWnumU->UsedSize = UsedSize;
  }
  //----------------------------------------------------------
  // add up
  //----------------------------------------------------------
  i = 0;					// startindex
  Sum = ((long long) Summand & B64_0FFFFFFFF); // set Number to add
  do
  {
    Sum = Sum + ((long long) pElu[i] & B64_0FFFFFFFF);// add values
    pElu[i++] = (int) Sum;			// store back
    Sum = Sum >> 32;
    UsedSize--;					// reduce count
  }while(UsedSize != 0);
  //----------------------------------------------------------
  // check for Carry out
  //----------------------------------------------------------
  if(Sum != 0)					// had a carry out
  {
    pElu[i] = 1;				// save carry
    pWnumU->UsedSize++;				// increment valid size
  }
  return(LNUM_OP_OK);
}
//==============================================================
// Subroutine SubElementWLnumBit64 calculates the difference of a
// Wlarge number - a given number element.
// The Destination is also the source.
// Note: It is assumed that the large number is positive and
// ----- its value is larger/same than the subtrahend!!
//
// Input parameters: WLNUM *   pWlnumU      Large Number Struc.
//		     int       Subtrahend   given subtrahend
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST SubElementWLnumBit64(WLNUM * pWnumU, int Subtrahend)
{
  int i,j, UsedSize;
  long long Dif;
  int * pElu;

  if(pWnumU == NULL)
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------
  // check if necessary size allocated, if not, allocate
  //----------------------------------------------------------
  UsedSize = pWnumU->UsedSize;			// get used size
  if(UsedSize == 0)				// cannot subtract
    return(LNUM_OP_ZERO_SIZE);
  pElu = pWnumU->lpEl;				// get base
  //----------------------------------------------------------
  // subtract lowest Element, is the only full subtraction (!)
  //----------------------------------------------------------
  i = 0;					// startindex
  Dif = ((long long) pElu[0] & B64_0FFFFFFFF) -	// generate start value
        ((long long) Subtrahend & B64_0FFFFFFFF);
  pElu[0] = (int) Dif;
  Dif = Dif >> 32;				// get borrow
  UsedSize--;					// reduce count
  j = UsedSize;					// save
  //---------------------------------------------------------
  // propagate Borrow if still set and elements present
  //---------------------------------------------------------
  for(;UsedSize > 0;UsedSize--)
  {
    if(Dif == 0)				// no more borrow, ended
      break;
    i++;					// to next Minuend element

    Dif = ((long long) pElu[i] & B64_0FFFFFFFF) + Dif;	// propagate the borrow
    pElu[i] = (int) Dif;
    Dif = Dif >> 32;				// get borrow
  }
  //----------------------------------------------------------
  // check for topmost Element Zero
  //----------------------------------------------------------
  if(pElu[j] == 0)				// top Element zero
    pWnumU->UsedSize--;
  return(LNUM_OP_OK);
}
//==============================================================
// UP SquareWLnumBit64 does square a number u using binomial
// formula. See 32Bit emulation routine for description.
// NOTE: Destination and source  m u s t  be different !
// -----
//
// Input parameters: WLNUM * pProd	pointer to product
// 		     WLNUM * pU		pointer to number u
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST SquareWLnumBit64(HMEM_CTX_DEF WLNUM * pProd, WLNUM * pU)
{
  int Retcode,i;
  int uSize,ProdSize;

  int ind0,ind1,ind2,ind3,j;
  long long Mul, Prod, Carry, p, q;

  int * pElProd;
  int * pElu;

// if((pProd == NULL) || (pU == NULL)) return(LNUM_OP_NULL_PTR);

  //------------------------------------------------------------
  // check range of product, clear it
  //------------------------------------------------------------
  uSize = pU->UsedSize;			// get length
  pElu = pU->lpEl;			// get pointer
  ProdSize = uSize * 2;			// needed size
  if(pProd->AllocSize < ProdSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pProd, ProdSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pProd->UsedSize = ProdSize;		// set length count
  if(uSize == 0)			// nothing to do !!
    return(LNUM_OP_OK);

  pElProd = pProd->lpEl;		// get pointer
  pElProd[0] = 0;			// clear starting Element
  pElProd[ProdSize-1] = 0;		// clear topmost  Element
  //------------------------------------------------------------
  // calculate 1st partial sum
  //------------------------------------------------------------
  i = uSize - 1;			// figure count - 1
  if(i != 0)				// at least 2 figures
  {
    j = i;				// set for multiply
    ind0 = 1;				// start Source/Destination index

    Prod = 0;				// clear
    Carry = 0;				// dto.
    Mul = (long long) pElu[0] & B64_0FFFFFFFF;// get multiplier, 32 Bits max.
    do
    {
      //--------------------------------------------------
      // Multiply a0 * SUM
      //--------------------------------------------------
      p     = ((long long) pElu[ind0] & B64_0FFFFFFFF) * Mul;// 64 Bits max.
      q     = (p & B64_0FFFFFFFF) + Prod + Carry;	// add from Last + Carry
      Carry = (q >> 32);
      pElProd[ind0++] = (int) q;
      Prod  = (p >> 32) & B64_0FFFFFFFF;

    }while((--j) != 0);
    Prod += Carry;			

    pElProd[ind0++] = (int) Prod;		// save stored value
    pElProd[ind0]   = (int) (Prod >> 32);	// dto.
    i--;				// reduce figure count

//    ShowLnum(pProd);

    //----------------------------------------------------------
    // calculate remaining partial sums
    //----------------------------------------------------------
    if(i != 0)				// at least 2 figures
    {
      ind3 = 1+2;			// destination index to 3rd elem.
      ind0 = 1;				// start Source index
      do
      {
        Mul = (long long) pElu[ind0++] & B64_0FFFFFFFF;// get multiplier, incr. index
        ind1 = ind0;			// assign Source index
        ind2 = ind3;			// assign Destination index
	ind3 += 2;

        j = i;				// set for multiply
        Carry = 0;
        Prod  = 0;
        do
        {
          p     = ((long long) pElu[ind1++] & B64_0FFFFFFFF) * Mul; // a1 * SUM
          Prod += (p & B64_0FFFFFFFF) +
                  ((long long) pElProd[ind2] & B64_0FFFFFFFF) +
                  Carry;					 // pos. carry!
          q     = ((p >> 32) & B64_0FFFFFFFF) +
                  ((Prod >> 32) & B64_0FFFFFFFF);
          Carry = (q >> 32) & B64_0FFFFFFFF;

          pElProd[ind2++] = (int) Prod;
          Prod  = q & B64_0FFFFFFFF;
        }while((--j) != 0);

        Prod += ((long long) pElProd[ind2] & B64_0FFFFFFFF) +
		Carry;					 // pos. carry
        pElProd[ind2++] = (int) Prod;
        pElProd[ind2]   = (int) (Prod >> 32);
      }while((--i) != 0);
    }

//    ShowLnum(pProd);

    //----------------------------------------------------------
    // multiply actual partial sum times 2 (shift left 1 Bit)
    //----------------------------------------------------------
    i = ProdSize-1;			// number of figures to shift
    Prod = 0;
    ind0 = 1;
    do
    {
      Mul = (long long) pElProd[ind0] & B64_0FFFFFFFF;
      Prod = (Mul << 1) + Prod;
      pElProd[ind0++] = (int) Prod;
      Prod = (Mul >> 31) & 0x01; 		// correct

//    Prod = (Prod >> 32) & 0xFFFFFFFFL;	// wrong !
//    Prod = (Prod >> 33) & 0xFFFFFFFFL;	// also wrong !
    } while((--i) != 0);
  }

//  ShowLnum(pProd);

  //------------------------------------------------------------
  // add up figure squares
  //------------------------------------------------------------
  Prod = 0;
  Carry = 0;
  ind0 = 0;
  ind1 = 0;
  do
  {
    Mul   = (long long) pElu[ind0++] & B64_0FFFFFFFF;
    p     = Mul * Mul;

    Prod = (p & B64_0FFFFFFFF) +
           ((long long) pElProd[ind1] & B64_0FFFFFFFF) +
	   Carry;					// pos. carry

    pElProd[ind1++] = (int) Prod;

    Prod = ((Prod >> 32) & B64_0FFFFFFFF) +
            ((p >> 32) & B64_0FFFFFFFF) +
            ((long long) pElProd[ind1] & B64_0FFFFFFFF);
    Carry = ((Prod >> 32) & B64_0FFFFFFFF);

    pElProd[ind1++] = (int) Prod;

  }while((--uSize) != 0);

//  ShowLnum(pProd);


  //------------------------------------------------------------
  // check result topmost figure for zero
  //------------------------------------------------------------
  if(pElProd[ind1-1] == 0)
    pProd->UsedSize--;
  return(LNUM_OP_OK);
}
//==============================================================
// UP GetQ32EstimateBit64 calculates qhat from given
// values u[n+m], u[n+m-1], u[n+m-2], v[n-1], v[n-2].
// This is the trial divisor calculation for Division
// NOTE: Normalized Dividend/Divisor is assumed !
// -----
// Input parameters: int * pU[]		current dividend
//		     int   uIndex	Index to topmost element n+m
//		     int   vnM1		v[n-1]
//		     int   vnM2		v[n-2]
// Returns: int qhat
//==============================================================
static int FAST GetQ32EstimateBit64(int * pU, int uIndex,
		                    int vnM1, int vnM2)
{
  int TmpH[1];
  int TmpL[1];

  long long Sum1, Sum2, Dif;
  int qhatL, rhat;

  //--------------------------------------------------------
  // calculate: qhat = (u[n+m] || u[n+m-1]) / v[n-1] and
  //            rhat = (u[n+m] || u[n+m-1]) % v[n-1]
  // NOTE: qhat <= 2**32 + 1, rhat < 2**32
  //--------------------------------------------------------
  rhat = NormDiv64By32Bit64(pU[uIndex], pU[uIndex-1], vnM1, TmpH, TmpL);
  qhatL = TmpL[0];

  EST_PRINT("U: ");
  EST_PRINT_HEX_BIT64(pU[uIndex],pU[uIndex-1]);
  EST_PRINT(", VNM1: ");
  EST_PRINT_HEX_BIT32_NL(vnM1);

  EST_PRINT("BIT64 Estimate qhat: ");
  EST_PRINT_HEX_BIT64(TmpH[0],qhatL);
  EST_PRINT(" Estimate rhat: ");
  EST_PRINT_HEX_BIT32_NL(rhat);

  //--------------------------------------------------------------------
  // Check case, where qhat is either SURE too large, i.e. qhat == 2**32+1
  // or qhat might be too large by one only, i.e qhat == 2**32
  //--------------------------------------------------------------------
  if(TmpH[0] != 0)
  {
    qhatL--;					// reduce by one
    //----------------------------------------------------------------
    // Check special, trivial case: qhat == 2**32+1 ahead.
    // In that case we can always set q == 2**31-1 for the following:
    // 1. q <= 2**32 - 1 MUST hold and
    // 2. qhat - 2 <= q <= qhat
    //----------------------------------------------------------------
    if(qhatL == 0)				// qhat == 2**31+1
    {
      DIV_PRINT_NL("BIT64 Reduce 1a");
      qhatL--;					// use q = 2*+31-1 always
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32, reduce by one and check further
    // NOTE: when reducing qhat, rhat must be increased by v[n-1].
    // ----- if now rhat >= b, no further checking is needed
    //----------------------------------------------------------------
    Sum1 = ((long long) rhat & B64_0FFFFFFFF) +	// correct for qhat--
           ((long long) vnM1 & B64_0FFFFFFFF);
    if((Sum1 & B64_0FFFFFFFF00000000) != 0)	// rhat >= b
    {
      DIV_PRINT_NL("BIT32 Reduce 1b");
      return(qhatL);
    }
    //----------------------------------------------------------------
    // Case qhat == 2**32 and rhat' = rhat + vnM1 < b, must
    // check if s = qhat * v[n-2]  >  t = b * rhat' + u[n-m-2]
    //----------------------------------------------------------------
    rhat = (int) Sum1;

    Sum1 = ((long long) vnM2 & B64_0FFFFFFFF) *		// s
           ((long long) qhatL & B64_0FFFFFFFF);
    Sum2 = ((long long) rhat << 32) +
           ((long long) pU[uIndex-2] & B64_0FFFFFFFF);	// t
    Dif  = Sum2 - Sum1;
    if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
    {
      qhatL--;
      DIV_PRINT_NL("B64 Reduce 1c");
    }
    return(qhatL);
  }
  //----------------------------------------------------------------
  // In the following cases qhat < 2**32 so may be 1 or 2 too large
  // Calculate: s = qhat * v[n-2] and: t = rhat * 2**32 + u[n+m-2],
  // check if s > t.
  // NOTE: s > t is equivalent to calculate t - s and check for borrow
  //----------------------------------------------------------------
#if 1
  DIV_PRINT("qhatL: ");
  DIV_PRINT_HEX_BIT32(qhatL);
  DIV_PRINT(", vnM2: ");
  DIV_PRINT_HEX_BIT32_NL(vnM2);
#endif


  Sum1 = ((long long) qhatL & B64_0FFFFFFFF) *
         ((long long) vnM2 & B64_0FFFFFFFF);		// s
  Sum2 = ((long long) rhat << 32) +
         ((long long) pU[uIndex-2] & B64_0FFFFFFFF);	// t
  Dif  = Sum2 - Sum1;				// t - s
  if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
  {
    //---------------------------------------------------------------
    // qhat at least one too large, reduce, increase rhat, check rhat
    //---------------------------------------------------------------
    DIV_PRINT_NL("B64 Reduce 2a");
#if 0
    DIV_PRINT("Before Next Check: qhatL is': ");
    DIV_PRINT_HEX_BIT32(qhatL);
    DIV_PRINT(", rhat: ");
    DIV_PRINT_HEX_BIT32(rhat);
    DIV_PRINT(", vnM1: ");
    DIV_PRINT_HEX_BIT32_NL(vnM1);
#endif


    qhatL--;
    Dif = ((long long) rhat & B64_0FFFFFFFF) +
          ((long long) vnM1 & B64_0FFFFFFFF);

#if 0
      DIV_PRINT("reduced qhatL: ");
      DIV_PRINT_HEX_BIT32(qhatL);
      DIV_PRINT("increased rhat: ");
      DIV_PRINT_HEX_BIT64_NL((BIT32) (Dif>>32), (BIT32) Dif);
#endif



    if((Dif & B64_0FFFFFFFF00000000) == 0)	// could be too large
    {
      //----------------------------------------------------------------
      // In the following cases qhat may still be 1 too large
      // Calculate: s = qhat * v[n-2] and: t = rhat * 2**32 + u[n+m-2],
      // check if s > t.
      // NOTE: s > t is equivalent to calculate t - s and check for borrow
      //----------------------------------------------------------------
//    rhat += vnM1;
      Sum1 = ((long long) vnM2 & B64_0FFFFFFFF) *		// s
             ((long long) qhatL & B64_0FFFFFFFF);
#if 0
      DIV_PRINT("s: ");
      DIV_PRINT_HEX_BIT64_NL((BIT32) ((Sum1 >> 32) & 0xFFFFFFFFL),(BIT32) Sum1);
#endif

      Sum2 = ((long long) Dif << 32) +
             ((long long) pU[uIndex-2] & B64_0FFFFFFFF);	// t
      Dif  = Sum2 - Sum1;
      if(((((~Sum2) & Sum1) | (Dif & (~(Sum2^Sum1)))) >> 63) != 0)
      {
        DIV_PRINT_NL("B64 Reduce 2b");
        qhatL--;
      }
    }
  }
  return(qhatL);
}
#endif // defined LNUM32_USE_INT64

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Only Local Available Basic functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//==============================================================
// Copy a WLarge Number starting at the LSB.
// Destination and Source may be the same and may overlap.
// NOTE: Inline where needed direct !!
// -----
//
// Input parameters:	int   uSize	Number size in Elements
//			int * pR	Destination Buffer
//			int * pU	Source Buffer
//			int   uOffset	Source Offset
// Returns: nothing
//==============================================================
static void FAST HardCpyWLnum(int uSize, int * pR, int * pU, int uOffset)
{
  memcpy(pR,pU+uOffset,uSize*4);
}
//==============================================================
// Copy a WLarge Number starting at the MSB.
// Destination and Source may be the same and may overlap.
//
// Input parameters:	int   uSize	Number size in Elements
//			int * pR	Destination Buffer
//			int   rOffset	Destination Offset
//			int * pU	Source Buffer
// Returns: nothing
//==============================================================
static void FAST HardCpyWLnumTop(int uSize, int * pR, int rOffset, int * pU)
{
  while(uSize > 0)
  {
    uSize--;				// pre-decrement, use as index
    pR[uSize+rOffset] = pU[uSize];	// Copy Element
  }
}

//===============================================================
// Shift Left WLarge Number by n Bits. Destination may be same as
// source, so shift is started from top of number.
//
// Note: Shiftcount must be in Range 0 < n < 32 !!
// -----
//
// Input parameters:	int   nBits	Number of bits to shift
//			int * pR	Result buffer
//			int   rOffset	Destination Offset of Result
//			int   uLen	Size of Number in elements
//			int * pU	Source Buffer
// Returns: nothing
//===============================================================
static void FAST HardLshiftnWLnum(int nBits, int * pR,
		                  int rOffset, int uLen, int * pU)
{
  int uIndex = uLen-1;			// source      top most index
  int rIndex = uIndex + rOffset;		// destination top most index
  int MaskShift = 32 - nBits;		// ??
  int Mask = ~(0xFFFFFFFF << nBits);		// AND Mask
  int Tmp0 = (pU[uIndex] >> MaskShift) & Mask;	// Saver
  int Tmp1 = (pU[uIndex--] << nBits);		// Saver
  //----------------------------------------------------------------
  // check for left shift out bits in topmost source element
  // if so store at top + 1
  // Note: the calling routine is responsible for correct allocation
  // ----- of required destination size !!!
  //----------------------------------------------------------------
  if(Tmp0 != 0)				// top element shift out occured
    pR[rIndex+1] = Tmp0;		// save as top + 1 element !!!
  //----------------------------------------------------------
  // check if more than one element present in source
  //----------------------------------------------------------
  uLen--;				// reduce count
  while(uLen > 0)			// more elements than one
  {
    Tmp0 = (pU[uIndex] >> MaskShift) & Mask;	// get left outshift
    pR[rIndex--] = Tmp1 | Tmp0;			// store bits in next element
    Tmp1 = pU[uIndex--] << nBits;		// save in Element shifted bits
    uLen--;
  }
  pR[rIndex] = Tmp1;			// save lowest Element
}
//==============================================================
// Shift left WLarge Number by 1 Bit. Destination may be same as
// Source.
// NOTE: the calling routine is responsible for allocation of
// ----- required destination size if a left shift out occurs
//
// Input parameters: int * pR		Result buffer
//		     int * pU		Source buffer
//		     int   uLen		Size of Number in elements
// Returns: Nothing
/*==============================================================*/
static void FAST HardLshift1WLnum(int * pR, int * pU, int uLen)
{
  int Index = 0;			// index for source and result
  int Tmp0;
  int Tmp1 = 0;

  while(uLen > 0)
  {
    Tmp0 = pU[Index];			// fetch Element
    Tmp1 = Tmp0 + Tmp0 - Tmp1;		// add with [negative] Carry
    pR[Index++] = Tmp1;
    Tmp1 = Tmp0 >> 31;			// generate [negative] Carry
    uLen--;
  }
  if(Tmp1 != 0)				// NOTE: do NOT store if no shift out!!
    pR[Index] = 1;			// save remaining bit( ONLY if set)
}
//===============================================================
// Shift Right WLarge Number by n Bits. Destination may be same as
// source and may overlap, so shift is started from bottom of
// number + offset.
//
// Note: Shiftcount must be in Range 0 < n < 32 !!
// -----
//
// Input parameters:	int   nBits	Number of bits to shift
//			int * pR	Result buffer
//			int   uLen	Size of Number in elements
//			int * pU	Source Buffer
//			int   uOffset	Source Offset
// Returns: nothing
//===============================================================
static void FAST HardRshiftnWLnum(int nBits, int * pR, int uLen,
				  int * pU, int uOffset)
{
  int uIndex = uOffset;				// source index
  int rIndex = 0;				// result index
  int MaskShift = 32 - nBits;			// downshift count

  int Mask = ~(0xFFFFFFFF << MaskShift);	// AND bit mask
  			         	        // for upper elements
  int Tmp0 = (pU[uIndex++] >> nBits) & Mask;	// get startvalue
  int Tmp1;
  int Tmp2 = 0;

  uLen--;					// reduce count
  while(uLen > 0)				// not a single element
  {
    Tmp1 = pU[uIndex++];			// get next source element
    Tmp2 = (Tmp1 >> nBits) & Mask;		// isolate new low bits
    Tmp1 = (Tmp1 << MaskShift) | Tmp0;		// shift left lower,append rest
    pR[rIndex++] = Tmp1;			// save
    Tmp0 = Tmp2;				// save lower bits for next
    uLen--;
  }
  pR[rIndex] = Tmp0;				// save remaining bits
}
//===============================================================
// Shift Right WLarge Number by 1 Bits. Destination may be same as
// source.
// Note: Shift is started from bottom of Source !!!
// ----- (this is the reason for the LEFT(!) shifts)
//
// Input parameters:	int * pR	Result buffer
//			int * pU	Source Buffer
//			int   uLen	Size of Number in elements
// Returns: nothing
//===============================================================
static void FAST HardRshift1WLnum(int * pR, int * pU, int uLen)
{
  int uIndex = 0;				// source index
  int rIndex = 0;				// result index

  int Tmp0 = (pU[uIndex++] >> 1) & 0x7FFFFFFF;// get Bottom startvalue
  int Tmp1;
  int Tmp2 = 0;

  uLen--;
  while(uLen > 0)
  {
    Tmp1 = pU[uIndex++];			// get next source element
    Tmp2 = (Tmp1 >> 1) & 0x7FFFFFFF;		// isolate new lower bits
    Tmp1 = (Tmp1 << 31) | Tmp0;			// shift left (!!)
    pR[rIndex++] = Tmp1;			// save
    Tmp0 = Tmp2;				// save upper bits for next
    uLen--;
  }
  pR[rIndex] = Tmp0;				// save remaining bits
}


//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Global Available Basic functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//==============================================================
// UP GetBitCntWLnum calculates the number of used bits in a
// a WLNUM
//
// Input:	WLNUM *	pNum		Number
// Returns:	int BitCount		number of used bits
//==============================================================
int FAST GetBitCntWLnum(WLNUM * pNum)
{
  int UsedSize;

  if((pNum == NULL) || ((UsedSize = pNum->UsedSize) == 0))
    return(0);

  return(((UsedSize-1) * 32) +
         HardGetBitCntWLnumElem(pNum->lpEl[UsedSize-1]));
}

//==============================================================
// UP GetByteCntWLnum calculates the number of used bytes in a
// a WLNUM
//
// Input:	WLNUM *	pNum		Number
// Returns:	int ByteCount		number of used bytes
//==============================================================
int FAST GetByteCntWLnum(WLNUM * pNum)
{
  int UsedSize;

  if((pNum == NULL) || ((UsedSize = pNum->UsedSize) == 0))
    return(0);

  return(((UsedSize-1) * 4) +
         HardGetByteCntWLnumElem(pNum->lpEl[UsedSize-1]));
}
//==============================================================
// CopyWLnum copies a WLarge Number (the buffer and part of the
// contents of the control structure are copied).
// Destination m u s t  *NOT*  be same as Source
//
// Input parameters:	WLNUM * pDst	pointer to Destination
// 			WLNUM * pSrc	pointer to Source
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST CopyWLnum(HMEM_CTX_DEF WLNUM * pDst, WLNUM * pSrc)
{
  int Retcode, SrcSize;
  //-------------------------------------------------------
  // Check size of Destination, realloc if needed
  //-------------------------------------------------------
  SrcSize = pSrc->UsedSize;
  if(SrcSize > pDst->AllocSize)			// Dst. Element too small
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pDst, SrcSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //-------------------------------------------------------
  // Set Destination used size, copy if data to copy
  //-------------------------------------------------------
  pDst->UsedSize = SrcSize;		// set same used sizes
  if(SrcSize != 0)
    memcpy(pDst->lpEl,pSrc->lpEl,SrcSize * 4);
  return(LNUM_OP_OK);
}
//==============================================================
// UcompWLnum does an unsigned compare of two WLarge numbers
// NOTE: a) structure pointers must be valid, not checked !!
// ----- b) no leading 0 Elements are allowed !!!
//
// Input parameters: WLNUM * pU		pointer to number u
//	 	     WLNUM * pV		pointer to number v
// Returns:	int LNUM_1ST_GT_2ND (1)	u > v
//                  LNUM_1ST_LT_2ND(-1) u < v
//                  LNUM_1ST_EQ_2ND (0) u = v
//==============================================================
int FAST UcompWLnum(WLNUM * pU, WLNUM * pV)
{
  int uIndex = pU->UsedSize;
  int vIndex = pV->UsedSize;
  int Dif;

  int * pElu;
  int * pElv;

  if(uIndex > vIndex) return(WLNUM_1ST_GT_2ND);		// u > v
  if(uIndex < vIndex) return(WLNUM_1ST_LT_2ND);		// u < v
  if(uIndex == 0)     return(WLNUM_1ST_EQ_2ND);		// u = v = 0
  //----------------------------------------------------------
  // Elements have equal size, tougher work to do...
  //----------------------------------------------------------
  pElu = pU->lpEl;					// array base 1st
  pElv = pV->lpEl;					// array base 2nd
  //----------------------------------------------------------
  // Skip Equal Elements till exhausted or difference found
  //----------------------------------------------------------
  uIndex--;						// take care for Single
  while((uIndex >= 0) && (pElu[uIndex] == pElv[uIndex]))
    uIndex--;
  //----------------------------------------------------------
  // Check result now
  //----------------------------------------------------------
  if(uIndex < 0)
    return(WLNUM_1ST_EQ_2ND);				// u == v
  //----------------------------------------------------------
  // Elements are *NOT* same, subtract, check borrow
  //----------------------------------------------------------
  Dif = pElu[uIndex] - pElv[uIndex];			// subtract
  if((
     (((~pElu[uIndex]) & pElv[uIndex]) |
       (Dif & (~(pElu[uIndex]^pElv[uIndex])))) & 0x80000000) != 0)
    return(WLNUM_1ST_LT_2ND);				// had borrow, u < v
  return(WLNUM_1ST_GT_2ND);				// no  borrow, u > v
}
//==============================================================
// DoAddcWLnum sums two WLarge Numbers u and v and saves the
// Carry out in the Result.
// NOTE: a) Size of 1st Summand >= size of 2nd Summand
// ----- b) Size of 1st and 2nd Summand must be > 0  !!
//
// Input parameters: WLNUM * pSum	pointer to result
//	 	     WLNUM * pU		pointer to number u
// 		     WLNUM * pV		pointer to number v
//		     int   uSize	size of 1st number u
//		     int   vSize	size of 2nd number v
// Returns: Nothing
//==============================================================
static void FAST DoAddcWLnum(WLNUM * pSum, WLNUM * pU,
			     WLNUM * pV,int uSize, int vSize)
{
#if !defined LNUM32_USE_INT64
  if(HardAddWLnumEmul32(vSize, pSum->lpEl,		// do add, get CY out
               pU->lpEl, pV->lpEl, uSize-vSize) == 0)
    pSum->UsedSize = uSize;			// set max. used elements
#else
  if(HardAddWLnumBit64(vSize, pSum->lpEl,		 // dto.
               pU->lpEl, pV->lpEl, uSize-vSize) == 0)
    pSum->UsedSize = uSize;			// set max. used elements
#endif

  else						// remaining carry
  {
    pSum->UsedSize = uSize+1;			// one more Element
    pSum->lpEl[uSize] = 1;			// set Carry
  }
}
//==============================================================
// DoSubbWLnum does subtract two Wnumbers u and v
//
// NOTE: a) | Minuend (1st) | > | Subtrahend(2nd) |
//       b) Size of Minuend and Subtrahend must be != 0
//       c) As |u| > |v| no carry can be generated
//
// Input parameters: WLNUM * pDif	pointer to result
//		     WLNUM * pU		pointer to Minuend (u)
// 		     WLNUM * pV		pointer to Subtrahend(v)
//		     int   uSize	size of Minuend (u)
//		     int   vSize	size of Subtrahend (v)
// Returns: Nothing
//==============================================================
static void FAST DoSubbWLnum(WLNUM * pDif, WLNUM * pU,
			     WLNUM * pV, int uSize, int vSize)
{
  int i;
  int * pBuf = pDif->lpEl;

#if !defined LNUM32_USE_INT64
  HardSubWLnumEmul32(vSize,pDif->lpEl,pU->lpEl,	//do sub,ign.Borrow
                     pV->lpEl, uSize-vSize);
#else
  HardSubWLnumBit64(vSize,pDif->lpEl,pU->lpEl,	// do sub, ign. Borrow
                    pV->lpEl, uSize-vSize);
#endif
  //-----------------------------------------------------
  // readjust Used Elementsize after Subtract
  //-----------------------------------------------------
  for(i = uSize-1;i >=0 ;i--)
  {
    if(pBuf[i] != 0)				// first non zero'ed element
      return;
    pDif->UsedSize--;				// reduce used element count
  }
}
//==============================================================
// IsZeroWLnum checks if a WLarge Number u is Zero
//
// Input parameters:	WLNUM * pU	pointer to number u
// Returns: int Result  == 0 -> u is *NOT* zero
//			!= 0 -> u is zero
//==============================================================
int FAST IsZeroWLnum(WLNUM * pU)
{
  if(pU->UsedSize == 0) return(1);	// length 0, is zero
  if((pU->UsedSize == 1) &&		// length 1
     (pU->lpEl[0] == 0)) return(1);	// but zero contents
  return(0);				// not zero
}
//==============================================================
// IsOneWLnum checks if a WLarge Number u is One
//
// Input parameters:	WLNUM * pU	pointer to number u
// Returns: int Result  == 0 -> u is *NOT* equal 1
//			!= 0 -> u is equal 1
//==============================================================
int FAST IsOneWLnum(WLNUM * pU)
{
  if((pU->UsedSize == 1) &&		// size must be 1 element
    (pU->lpEl[0] == 1)) return(1);	// value must be one
  return(0);
}
//==============================================================
// LshiftWLnum shifts a WLarge number u by n bits to the left.
// Destination and source may be the same.
//
// Input parameters:	WLNUM * pR	   pointer to Result
//			WLNUM * pU	   pointer to number u
//			int       sBitcnt  number of bits to shift, >= 0 !!
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST LshiftWLnum(HMEM_CTX_DEF WLNUM * pR, WLNUM * pU, int sBitcnt)
{
  int Retcode, uSize, MaxSize, sElementCnt;

  int * pElr;
  int * pElu;

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;				// get size
  //-----------------------------------------------------------
  // calculate required Elementcount for destination
  // !!! CHECK THAT !!!
  //-----------------------------------------------------------
  sElementCnt = ((sBitcnt >> 5) & (~(0xFFFFFFFF << (32-5))));

  sBitcnt &= 0x1F;				// get residual bit count
  Retcode = HardGetBitCntWLnumElem(pU->lpEl[uSize-1]); // get Topmost Bitcount
  MaxSize = sElementCnt + uSize;		// required size
  if((Retcode + sBitcnt) > 32)			// check for shift out
    MaxSize ++;					// shift out, one more element
  //----------------------------------------------------------------
  // allocate required dest. buffer if necessary
  //----------------------------------------------------------------
  if(pR->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  //----------------------------------------------------
  // prepare for doing shift
  //----------------------------------------------------
  pElr = pR->lpEl;				// get result base
  pElu = pU->lpEl;				// get source base
  pR->UsedSize = MaxSize;			// set new size result
  //----------------------------------------------------
  // check if only full elements to shift left
  //----------------------------------------------------
  if(sBitcnt == 0)				// no residual bits
  {
    //--------------------------------------------------
    // full elements to shift left, special case
    //--------------------------------------------------
    HardCpyWLnumTop(uSize,pElr,sElementCnt,pElu);// copy others TOP->BOTTOM !!
  }
  else
  {
    //--------------------------------------------------
    // real  b i t  shift required...
    //--------------------------------------------------
    HardLshiftnWLnum(sBitcnt,pElr,sElementCnt,uSize,pElu); // do shift
  }
  //----------------------------------------------------
  // post-process (clear) unused elements
  //----------------------------------------------------
  if(sElementCnt != 0)					// we had a dst. offset <> 0
//    ClearBit32Array(pElr,0,sElementCnt);
    memset(pElr,0,sElementCnt*4);
  return(LNUM_OP_OK);
}
//==============================================================
// Lshift1WLnum shifts a WLarge number u one bit to the left.
// Destination and source may be the same.
//
// Input parameters: WLNUM * pR		pointer to Dest.
//		     WLNUM * pU		pointer to number u
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST Lshift1WLnum(HMEM_CTX_DEF WLNUM * pR, WLNUM * pU)
{
  int Retcode, uSize, MaxSize;

// ???????????? can this case be removed ????

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  uSize = pU->UsedSize;
  MaxSize = uSize;

  //----------------------------------------------------
  // check if shift out will occur
  //----------------------------------------------------
  if((pU->lpEl[uSize-1] & 0x80000000) != 0) // shift out
    MaxSize++;
  //----------------------------------------------------
  // allocate required dest. buffer
  //----------------------------------------------------
  if(pR->AllocSize < MaxSize)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pR->UsedSize = MaxSize;
  HardLshift1WLnum(pR->lpEl,pU->lpEl,uSize);	// do shift
  return(LNUM_OP_OK);
}
//==============================================================
// RshiftWLnum shifts a WLarge number u by n bits to the right.
// Destination and source may be the same.
//
// Input parameters: WLNUM * pR		pointer to Dest.
//		     WLNUM * pU		pointer to number u
//		     int sBitcnt	count of bits to shift
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST RshiftWLnum(HMEM_CTX_DEF WLNUM * pR, WLNUM * pU, int sBitcnt)
{
  int Retcode, ui, uSize, MaxSize, sElementCnt;

  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;
  //-----------------------------------------------------------
  // calculate remaining byte/elementcount for dest.
  //-----------------------------------------------------------
  sElementCnt = (sBitcnt >> 5) &		// get element count
       (~(0xFFFFFFFF << (32-5)));

  sBitcnt &= 0x1F;				// get residual bit count
  ui = HardGetBitCntWLnumElem(pU->lpEl[uSize-1]);// get Topmost Bitcount

  if((sElementCnt >= uSize) ||			// all zeroed !!
    ((sElementCnt == (uSize-1)) && (sBitcnt >= ui))) // dto.
  {
    pR->UsedSize = 0;				// 0
    return(LNUM_OP_OK);
  }

  MaxSize = uSize - sElementCnt;
  pR->UsedSize = MaxSize;
  //-----------------------------------------------------------
  // check if destination has appropriate size for shift
  //-----------------------------------------------------------
  if(pR != pU)					// DST not same as SRC
  {
    if(pR->AllocSize < MaxSize)			// must alloc/realloc
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, MaxSize)) != LNUM_OP_OK)
        return(Retcode);
    }
  }
  //--------------------------------------------------------------
  // check if only whole elements to shift right
  //--------------------------------------------------------------
  if(sBitcnt == 0)				// no residual bits
  {
    HardCpyWLnum(MaxSize,pR->lpEl,pU->lpEl,sElementCnt); // copy others
  }
  else						// residual bits
  {
    HardRshiftnWLnum(sBitcnt,pR->lpEl,MaxSize,pU->lpEl,sElementCnt);// do shift
    if(pR->lpEl[MaxSize-1] == 0)		// check top
      pR->UsedSize--;				// is zero, reduce
  }
  return(LNUM_OP_OK);
}
//==============================================================
// Rshift1WLnum shifts a WLarge number u 1 bit right
// Destination and source may be the same.
//
// Input parameters: WLNUM * pR		pointer to Dest.
//		     WLNUM * pU		pointer to number u
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST Rshift1WLnum(HMEM_CTX_DEF WLNUM * pR, WLNUM * pU)
{
  int Retcode, uSize;

//
// ?????? can the following trivial cases be removed ???
//
  if(IsZeroWLnum(pU) != 0)			// nothing to do
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  uSize = pU->UsedSize;
  if((uSize == 1) &&
     ((pU->lpEl[0] & 0xFFFFFFFE) == 0))		// only one bit present
  {
    pR->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  pR->UsedSize = uSize;
  if(pR != pU)
  {
    if(pR->AllocSize < uSize)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pR, uSize)) != LNUM_OP_OK)
      return(Retcode);
    }
  }
  HardRshift1WLnum(pR->lpEl,pU->lpEl,uSize); // do shift
  if(pR->lpEl[uSize-1] == 0)		// check for topmost element == 0
    pR->UsedSize--;
  return(LNUM_OP_OK);
}
//==============================================================
// UP AddWLnum does sum two Wnumbers u and v
// Destination and source may be the same.
//
// Input parameters: WLNUM * pSum	pointer to result
//		     WLNUM * pU		pointer to number u
//		     WLNUM * pV		pointer to number v
// Returns: int Status - 0 o.k., else error occured
//==============================================================
int FAST AddWLnum(HMEM_CTX_DEF WLNUM * pSum, WLNUM * pU, WLNUM * pV)
{
  int Retcode, uSize, vSize, MaxSize;

//  if((pU == NULL) || (pV == NULL) || (pSum == NULL))
//    return (LNUM_OP_NULL_PTR);		// error, no structure
  uSize = pU->UsedSize;
  vSize = pV->UsedSize;

// ???? can the simple cases be removed ??????
  //----------------------------------------
  // check for one or both zero
  //----------------------------------------
  if((uSize == 0) || (vSize == 0))
  {
    if((uSize == 0) && (vSize == 0))
    {
      pSum->UsedSize = 0;			// Zero length
      return(LNUM_OP_OK);
    }
    if(uSize == 0)				// 1st is zero, 2nd not !
    {
      if(pSum != pV)
        return(CopyWLnum(HMEM_CTX_REF1
			 pSum,pV));		// just copy 2nd number
      return(LNUM_OP_OK);			// no copy needed !!
    }
    else
    {
      if(pSum != pU)
        return(CopyWLnum(HMEM_CTX_REF1
			 pSum, pU));		// just copy 1st number
      return(LNUM_OP_OK);			// no copy needed !!
    }
  }
  //-----------------------------------------------
  // both valid, get maximum requested sum length
  //-----------------------------------------------
  MaxSize = uSize;				// assume u > v
  if(MaxSize < vSize)
    MaxSize = vSize;
  MaxSize ++;					// get maximum required length

  if(pSum->AllocSize < MaxSize)			// too small yet
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pSum, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }

  if(uSize >= vSize)
  {
    pSum->UsedSize = uSize;			// preset size
    DoAddcWLnum(pSum, pU, pV, uSize, vSize);	// add up, u >= v
  }
  else
  {
    pSum->UsedSize = vSize;			// preset size
    DoAddcWLnum(pSum, pV, pU, vSize, uSize);	// add up, u < v
  }
  return(LNUM_OP_OK);
}
//==============================================================
// Subroutine AddElementWLnum calculates the sum of a Wlarge
// number and a given number element.
// The Destination is also the source.
//
// Input parameters: WLNUM *    pWnumU   Large Number Struc.
//		     int	Summand  given summand
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST AddElementWLnum(HMEM_CTX_DEF WLNUM * pWnumU, int Summand)
{
#if !defined LNUM32_USE_INT64
  return(AddElementWLnumEmul32(HMEM_CTX_REF1 pWnumU,Summand));
#else
  return(AddElementWLnumBit64(HMEM_CTX_REF1 pWnumU,Summand));
#endif
}
//==============================================================
// UP SubWLnum does subtract two Wnumbers u and v
// Destination and source may be the same.
//
//Input parameters: WLNUM * pDif	pointer to result
// 		    WLNUM * pU		pointer to Minuend u
// 		    WLNUM * pV		pointer to Subtrahend v
// Returns: Status, 0 - o.k., else error occured
//==============================================================
int FAST SubWLnum(HMEM_CTX_DEF WLNUM * pDif, WLNUM * pU, WLNUM * pV)
{
  int Retcode, i, uSize, vSize, MaxSize;

//  if((pU == NULL) || (pV == NULL) || (pDif == NULL))	// error, no structure
//    return(LNUM_OP_NULL_PTR);

// ?????? can the trivial cases be removed ????

  uSize = pU->UsedSize;
  vSize = pV->UsedSize;
  if((uSize == 0) && (vSize == 0))
  {
    pDif->UsedSize = 0;				// Zero length
    return(LNUM_OP_OK);
  }
  if(uSize == 0)				// 1st is zero, 2nd not !
  {
    if(pDif != pV)
      return(CopyWLnum(HMEM_CTX_REF1
		       pDif, pV));		// only copy 2nd number
    return(LNUM_OP_OK);				// no copy needed !!
  }
  if(vSize == 0)				// 2nd is zero, 1st not !
  {
    if(pDif != pU)
      return(CopyWLnum(HMEM_CTX_REF1
		       pDif, pU));		// only copy 1st number
    return(LNUM_OP_OK);				// no copy needed !!
  }

 // both valid, get max. required length
  if(uSize >= vSize)
    MaxSize = uSize + 1;
  else
    MaxSize = vSize + 1;

  if(pDif->AllocSize < MaxSize)			// too small yet
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pDif, MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }

  if((i = UcompWLnum(pU,pV)) == WLNUM_1ST_EQ_2ND)// check which is smaller
  {						// same numbers, yields zero
    pDif->UsedSize = 0;				// 0
  }
  else
  {
    if(i == WLNUM_1ST_GT_2ND)
    {
      pDif->UsedSize = uSize;			// preset size
      DoSubbWLnum(pDif, pU, pV, uSize,vSize);	// subtract, u >= v
    }
    else
    {
      pDif->UsedSize = vSize;			// preset size
      DoSubbWLnum(pDif, pV, pU, vSize, uSize);	// subtract, u < v
    }
  }
  return(LNUM_OP_OK);
}
//==============================================================
// Subroutine SubElementWLnum calculates the difference of a
// Wlarge number and a given number element.
// The Destination is also the source.
// Note: It is assumed that the large number is positive and
// ----- its value is larger/same than the subtrahend!!
//
// Input parameters: WLNUM * pWlnumU      Large Number Struc.
//		     int     Subtrahend   given subtrahend
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST SubElementWLnum(WLNUM * pWnumU, int Subtrahend)
{
#if !defined LNUM32_USE_INT64
  return(SubElementWLnumEmul32(pWnumU, Subtrahend));
#else
  return(SubElementWLnumBit64(pWnumU, Subtrahend));
#endif
}
//==============================================================
// UP MulWLnum does multiply two Wnumbers u and v
// NOTE: Result  m u s t  be different from input params
// -----
//
// Input parameters: WLNUM * pProd	pointer to result
// 		     WLNUM * pU		pointer to Multiplicand
// 		     WLNUM * pV		pointer to Multiplier v
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST MulWLnum(HMEM_CTX_DEF WLNUM * pProd, WLNUM * pU, WLNUM * pV)
{
#if !defined LNUM32_USE_INT64
  return(MulWLnumEmul32(HMEM_CTX_REF1 pProd, pU, pV));
#else
  return(MulWLnumBit64(HMEM_CTX_REF1 pProd, pU, pV));
#endif
}
//==============================================================
// UP SquareWLnum does square Wnumber u
// NOTE: Result  m u s t  be different from input params
// -----
//
// Input parameters: WLNUM * pProd	pointer to result
// 		     WLNUM * pU		pointer to Multiplicand
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST SquareWLnum(HMEM_CTX_DEF WLNUM * pProd, WLNUM * pU)
{
#if !defined LNUM32_USE_INT64
  return(SquareWLnumEmul32(HMEM_CTX_REF1 pProd, pU));
#else
  return(SquareWLnumBit64(HMEM_CTX_REF1 pProd, pU));
#endif
}
//==============================================================
// UP HardDiv32Single calculates u[n-1,n-2,..,0] / B
// This is a special case for short Divisors (1 Element in size)
// NOTE: Divisor must NOT be 0 !
// -----
// Input parameters: int uLen		Size of Dividend
//		     int * pQ		Pointer to Quotient / NULL
//		     int * pRem		Pointer to Remainder / NULL
//		     int * pU		Pointer to Dividend
//		     int v		Divisor Element
// Returns: Nothing
//==============================================================
static void FAST HardDiv32Single (int uLen, int * pQ,
				  int * pRem, int * pU, int v)
{
  int SrcIndex = uLen-1;
  int DstIndex = uLen-1;
  int d, sh;
  int uH, uL, MH, MR;
  int TmpQH[1];
  int TmpQL[1];
  //-----------------------------------------------------------
  // Check if Dividend is already normalized
  //-----------------------------------------------------------
  if((v & 0x80000000) != 0)			// IS normalized !
  {
    uH = 0;
    if(pQ != NULL)				// with quotient
    {
      while(SrcIndex >= 0)
      {
        //------------------------------------------------------
        // Divide REM, u[i] by v, store quotient
        //------------------------------------------------------
#if !defined LNUM32_USE_INT64
        uH = NormDiv64By32Emul32(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
#else
        uH = NormDiv64By32Bit64(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
#endif
        pQ[DstIndex--] = TmpQL[0];
      }
    }
    else					// no quotient
    {
      while(SrcIndex >= 0)
      {
        //------------------------------------------------------
        // Divide REM, u[i] by v, store quotient
        //------------------------------------------------------
#if !defined LNUM32_USE_INT64
        uH = NormDiv64By32Emul32(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
#else
        uH = NormDiv64By32Bit64(uH, pU[SrcIndex--], v, TmpQH, TmpQL);
#endif
      }
    }
    if(pRem != NULL)
      pRem[0] = uH;
    return;
  }
  //-----------------------------------------------------------
  // Dividend is NOT normalized, normalize it
  //-----------------------------------------------------------
  d = 32 - HardGetBitCntWLnumElem(v);		// get normalize shift
  v <<= d;					// normalize Divisor

  sh = 32 - d;					// uH Right Shift count
  MH = 0x7FFFFFFF >> (31-d);			// uH Mask after Right Shift

  MR = 0x7FFFFFFF >> (d-1);
  //--------------------------------------------------------
  // Setup processing Start
  //--------------------------------------------------------
  uH = (pU[SrcIndex] >> sh) & MH;
  uL = pU[SrcIndex] << d;
  SrcIndex--;
  while(SrcIndex >= 0)
  {
    //------------------------------------------------------
    // insert next Dividend Element High Bits, Divide
    //------------------------------------------------------
    uL = uL | ((pU[SrcIndex] >> sh) & MH);
#if !defined LNUM32_USE_INT64
    uH = NormDiv64By32Emul32(uH, uL, v, TmpQH, TmpQL);
#else
    uH = NormDiv64By32Bit64(uH, uL, v, TmpQH, TmpQL);
#endif
    if(pQ != NULL)
      pQ[DstIndex--] = TmpQL[0];
    uL = pU[SrcIndex--] << d;
//    SrcIndex--; // seems to be wrong !! --> IS DEFINITLY WRONG
  }
  //--------------------------------------------------------
  // Final Division Step
  //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
  uH = NormDiv64By32Emul32(uH, uL, v, TmpQH, TmpQL);
#else
  uH = NormDiv64By32Bit64(uH, uL, v, TmpQH, TmpQL);
#endif
  if(pQ != NULL)
    pQ[DstIndex--] = TmpQL[0];

  if(pRem != NULL)
    pRem[0] = (uH >> d) & MR;
}
//==============================================================
// UP DivWLnum does divide two Wnumbers u and v producing
// quotient (if requested) and remainder (if requested).
// If a destination pointer is NULL, this part of the
// result will not be generated/stored. At least one result
// pointer must be <> NULL !!
// NOTE: Destinations  m u s t be different from sources !!
// -----
//
// Uses algorithm taken from D.E.Knuth (II)
//
// Input parameters:	WLNUM * pQout		ptr. to quotient or NULL
//	 		WLNUM * pRem		ptr. to remainder or NULL
// 			WLNUM * pU		pointer to Dividend U
// 			WLNUM * pV		pointer to Divisor V
//			WLNUM_CTX * pCtx	Work Context / NULL
// Returns: int Status, 0 - o.k., else Error occured
//
// NOTE NOTE NOTE: Test numbers must be calculated to assure
// =============== correct operation of algorithm !!!!!
//
//==============================================================
int FAST DivWLnum(HMEM_CTX_DEF
		  WLNUM * pQuot, WLNUM * pRem,
		  WLNUM * pU, WLNUM * pV, WLNUM_CTX * pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLNUM * pNumU;
  WLNUM * pNumV = NULL;
  WLNUM * ppTmpWLnum[1];
  WLNUM_CTX * pTmpCtx = NULL;

  int qhatL, vnM1, vnM2;

  int * pEluBase;
  int * pElvBase;
  int * pElQuot;
  int * pElRem;
  int WLnumReleaseCnt = 0;
  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((quot == NULL) && (rem == NULL)) || (u == NULL) || (v == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0)
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    if(pRem != NULL)				// remainder requested
      pRem->UsedSize = 0;			// set zero
    if(pQuot != NULL)				// quotient requested
    {
      if(pQuot->lpEl == NULL)			// no Element Allocated
      {
        if((pQuot->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)
          return(LNUM_OP_ALLOC_ERR);
      }
      pQuot->UsedSize = 1;			// set length 1 Element
      pQuot->lpEl[0] = 1;			// set Quotient
    }
    return(LNUM_OP_OK);
  }

  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    if(pQuot != NULL)
      pQuot->UsedSize = 0;			// set zero
    if((pRem != NULL) && (pRem != pU))
      return(CopyWLnum(HMEM_CTX_REF1
		       pRem, pU));		// copy u -> remainder
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElQuot  = NULL;				// pre-Initialize
  pElRem   = NULL;				// dto.
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;				// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pRem != NULL)				// remainder requested
    {
      if(pRem->AllocSize == 0)			// check if remainder allocated
      {
        if((pRem->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)	// alloc error
          return(LNUM_OP_ALLOC_ERR);
      }
      pElRem = pRem->lpEl;			// set pointer
      pRem->UsedSize = 1;			// preset length
    }
    if(pQuot != NULL)				// quotient requested
    {
      if(pQuot->AllocSize < uSize)
      {
        if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, uSize)) != LNUM_OP_OK)
        return(Retcode);
      }
      pElQuot = pQuot->lpEl;			// set pointer to bottom
    }
    HardDiv32Single(uSize, pElQuot, pElRem,
		    pEluBase, pV->lpEl[0]);	// do divide
    if(pQuot != NULL)				// get true quotient length
    {
      do
      {
        if(pElQuot[uSize-1] != 0) break;	// first non zero digit found
        uSize--;
      } while(uSize != 0);
      pQuot->UsedSize = uSize;			// set true size
    }

    if(pRem != NULL)				// get true remainder length
    {
      pRem->UsedSize = 1;			// preset length
      if(pElRem[0] == 0)			// is zero, special case
        pRem->UsedSize = 0;			// true size
    }
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;			// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
//    PRINT_NL("DivLong do normalize");
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount

//    PRINT("Shift up count is: ");
//    PRINT_INT_NL(NormalShift);


    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;

    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;			// set base pointer

//    PRINT_NL("Top Divisor Element now: ");
//    PRINT_HEX_BIT32_NL(pElvBase[vIndex]);

  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // Allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }

  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // resize Quotient Element if required
  //----------------------------------------------------------
  if(pQuot != NULL)				// Q: Element required ?
  {						//  Y: check/reallocate
    if(pQuot->AllocSize < LoopCnt)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, LoopCnt)) != LNUM_OP_OK)
      {
        if(pTmpCtx != NULL)
        {
          FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
        }
        else
          ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
        return(Retcode);			// error occured
      }
    }
    pElQuot = pQuot->lpEl;			// preset pointer
    pQuot->UsedSize = LoopCnt;			// preset quotient size
  }

#if 0
  PRINT("U: ");
  ShowLnum(pNumU);
  PRINT("V: ");
  ShowLnum(pNumV);
#endif

  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    qhatL = GetQ32EstimateEmul32(pEluBase, uIndex, vnM1, vnM2);
#else
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);
#endif

#if 0
    PRINT("qhat estimate: ");
    PRINT_HEX_BIT32_NL(qhatL);
#endif
    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    if(HardMulSubWLnumEmul32(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
      DIV_PRINT_NL("B32 Backadd");
      qhatL--;						// reduce estimate
    }
#else
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
      DIV_PRINT_NL("B64 Backadd");
      qhatL--;						// reduce estimate
    }
#endif

#if 0
    PRINT("qhat PostSub: ");
    PRINT_HEX_BIT32_NL(qhatL);
    ShowLnum(pNumU);
#endif

    //--------------------------------------------------------
    // Store Quotient digit if requested
    //--------------------------------------------------------
    if(pQuot != NULL)				// buffer present
      pElQuot[LoopCnt] = qhatL;			// store digit
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // Correct length of Quotient if requested
  //----------------------------------------------------------
  if(pQuot != NULL)
  {
    if(pElQuot[pQuot->UsedSize-1] == 0)		// zero element on top,
      pQuot->UsedSize --;			// reduce size
  }
  //----------------------------------------------------------
  // if Remainder requested, renormalize Reminder (from lnumu)
  //----------------------------------------------------------
  Retcode = LNUM_OP_OK;
  if(pRem != NULL)				// remainder requested
  {
    uSize = pNumU->UsedSize;			// get figure count (> 0!)
    i = uSize - 1;				// top element index
    do
    {
      if(pEluBase[i--] != 0) break;		// figure <> 0
        uSize--;
    } while (uSize != 0);
    pNumU->UsedSize = uSize;			// max. used figures
    if(uSize == 0)				// remainder is zero
      pRem->UsedSize = 0;			// is Zero
    else
    {
      if(NormalShift == 0)			// no shift required
        Retcode = CopyWLnum(HMEM_CTX_REF1
			    pRem, pNumU);	// only copy buffer
      else
        Retcode = RshiftWLnum(HMEM_CTX_REF1
			pRem,pNumU,NormalShift);// do normalize shift right
    }
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//==============================================================
// UP QuotWLnum does divide two Wnumbers u and v producing
// quotient only. Function is same as for division.
// NOTE: Destination  m u s t be different from sources !!
// -----
//
// Uses algorithm taken from D.E.Knuth (II)
//
// Input parameters:	WLNUM * pQout		pointer to quotient
// 			WLNUM * pU		pointer to Dividend U
// 			WLNUM * pV		pointer to Divisor V
//			WLNUM_CTX * pCtx	Work context / NULL
// Returns: int Status, 0 - o.k., else Error occured
//==============================================================
int FAST QuotWLnum(HMEM_CTX_DEF
	WLNUM * pQuot, WLNUM * pU, WLNUM * pV, WLNUM_CTX * pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLNUM * pNumU;
  WLNUM * pNumV = NULL;
  WLNUM * ppTmpWLnum[1];
  WLNUM_CTX * pTmpCtx = NULL;


  int qhatL, vnM1, vnM2;

  int * pEluBase;
  int * pElvBase;
  int * pElQuot;
  int WLnumReleaseCnt = 0;
  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((pQuot == NULL) && (pRem == NULL)) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0)
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    if(pQuot->lpEl == NULL)			// no Element Allocated
    {
      if((pQuot->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)
        return(LNUM_OP_ALLOC_ERR);
    }
    pQuot->UsedSize = 1;			// set length 1 Element
    pQuot->lpEl[0] = 1;				// set Quotient
    return(LNUM_OP_OK);
  }
  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    pQuot->UsedSize = 0;			// set zero
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElQuot  = NULL;				// pre-Initialize
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;				// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pQuot->AllocSize < uSize)
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, uSize)) != LNUM_OP_OK)
      return(Retcode);
    }
    pElQuot = pQuot->lpEl;			// set pointer to bottom
    HardDiv32Single(uSize, pElQuot, NULL,
		    pEluBase, pV->lpEl[0]); // do divide
    do
    {
      if(pElQuot[uSize-1] != 0) break;		// first non zero digit found
      uSize--;
    } while(uSize != 0);
    pQuot->UsedSize = uSize;			// set true size
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;				// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount
    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;
    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;			// set base pointer
  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // resize Quotient Element if required
  //----------------------------------------------------------
  if(pQuot->AllocSize < LoopCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pQuot, LoopCnt)) != LNUM_OP_OK)
    {
      if(pTmpCtx != NULL)
      {
        FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      }
      else
        ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
      return(Retcode);				// error occured
    }
  }
  pElQuot = pQuot->lpEl;			// preset pointer
  pQuot->UsedSize = LoopCnt;			// preset quotient size
  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    qhatL = GetQ32EstimateEmul32(pEluBase, uIndex, vnM1, vnM2);
#else
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);
#endif
    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    if(HardMulSubWLnumEmul32(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
      qhatL--;						// reduce estimate
#else
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                         pEluBase,LoopCnt,pElvBase, qhatL) != 0)
      qhatL--;						// reduce estimate
#endif
    //--------------------------------------------------------
    // Store Quotient digit
    //--------------------------------------------------------
    pElQuot[LoopCnt] = qhatL;			// store digit
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // Correct length of Quotient
  //----------------------------------------------------------
  if(pElQuot[pQuot->UsedSize-1] == 0)		// zero element on top,
    pQuot->UsedSize --;				// reduce size
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(LNUM_OP_OK);
}
//==============================================================
// UP ModWLnum does divide two Wnumbers u and v producing
// remainder only. Function is same as for division.
// NOTE: 1. Destination  m u s t be different from sources !!
// ----- 2. 2 Temporary Elements needed.
//
// Uses algorithm taken from D.E.Knuth (II)
//
// Input parameters:	WLNUM * pRem		pointer to remainder
// 			WLNUM * pU		pointer to Dividend U
// 			WLNUM * pV		pointer to Divisor V
//			WLNUM_CTX * pCtx	Work context / NULL
// Returns: int Status, 0 - o.k., else Error occured
//==============================================================
int FAST ModWLnum(HMEM_CTX_DEF
		WLNUM * pRem, WLNUM * pU, WLNUM * pV, WLNUM_CTX * pCtx)
{
  int Retcode, i, NormalShift, LoopCnt, uSize, vSize;

  int uIndex;					// index into number u
  int vIndex;					// index into number v

  WLNUM * pNumU;
  WLNUM * pNumV = NULL;
  WLNUM * ppTmpWLnum[1];
  WLNUM_CTX * pTmpCtx = NULL;

  int qhatL, vnM1, vnM2;

  int * pEluBase;
  int * pElvBase;
  int * pElRem;
  int WLnumReleaseCnt = 0;

  //------------------------------------------------------------
  // Check for null-pointers and Divisor == Zero
  //------------------------------------------------------------
//  if(((pQuot == NULL) && (pRem == NULL)) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);			// null pointer error
  if(IsZeroWLnum(pV) != 0) return LNUM_OP_ZERO_DIV;	// Divide by zero err.
  //----------------------------------------------------
  // check if division is required i.e. u > v
  //----------------------------------------------------
  i = UcompWLnum(pU, pV);			// check DIVIDEND >= DIVISOR
  if(i == WLNUM_1ST_EQ_2ND)			// 1st is equal to 2nd
  {
    //--------------------------------------------------
    // u == v: --> quotient = 1, remainder = 0
    //--------------------------------------------------
    pRem->UsedSize = 0;				// set zero
    return(LNUM_OP_OK);
  }
  else if(i == WLNUM_1ST_LT_2ND)		// u < v
  {
    //--------------------------------------------------
    // u < v: --> quotient = 0, remainder = v
    //--------------------------------------------------
    if(pRem != pU)
      return(CopyWLnum(HMEM_CTX_REF1
		       pRem, pU));		// copy u -> remainder
    return(LNUM_OP_OK);
  }
  //====================================================================
  // u > v, real work must be done !
  //====================================================================
  //--------------------------------------------------------------------
  // check for vsize == 1 first
  //--------------------------------------------------------------------
  pElRem   = NULL;				// dto.
  uSize    = pU->UsedSize;
  vSize    = pV->UsedSize;
  pEluBase = pU->lpEl;				// set base pointer
  if(vSize == 1)				// easier way to use
  {
    //--------------------------------------------------
    // special case, divide by a single Element only
    //--------------------------------------------------
    if(pRem->AllocSize == 0)			// check if remainder allocated
    {
      if((pRem->lpEl = BIT32_ARRAY_ALLOC(HMEM_CTX_REF,1)) == NULL)	// alloc error
        return(LNUM_OP_ALLOC_ERR);
    }
    pElRem = pRem->lpEl;			// set pointer
    pRem->UsedSize = 1;				// preset length
    HardDiv32Single(uSize, NULL, pElRem,
		    pEluBase, pV->lpEl[0]);	// do divide
    pRem->UsedSize = 1;				// preset length
    if(pElRem[0] == 0)				// is zero, special case
      pRem->UsedSize = 0;			// true size
    return(LNUM_OP_OK);
  }
  //===========================================================
  // The long, hard way needed
  //===========================================================
  pElvBase = pV->lpEl;				// set base pointer
  vIndex = vSize - 1;				// index to v[n-1]
  NormalShift = 0;
  LoopCnt = uSize - vSize;
  //-----------------------------------------------------------------
  // if no Context given, allocate one with 2 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2, uSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //----------------------------------------------------------
  // calculate Divisor normalization shift (v[n-1] >= b/2)
  // if required allocate temporary divisor and do shift
  //----------------------------------------------------------
  if((pElvBase[vIndex] & 0x80000000) == 0)	//not normalized
  {
    NormalShift = 32 - 				// Element size -
      HardGetBitCntWLnumElem(pElvBase[vIndex]);	// Topmost Element Bitcount
    if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, vSize, ppTmpWLnum)) != LNUM_OP_OK)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
      return(Retcode);
    }
    WLnumReleaseCnt++;
    pNumV = ppTmpWLnum[0];
    LshiftWLnum(HMEM_CTX_REF1
		pNumV, pV ,NormalShift);	// shift up
    pElvBase = pNumV->lpEl;			// set base pointer
  }
  vnM1 = pElvBase[vIndex--];			// get v[n-1]
  vnM2 = pElvBase[vIndex];			// get v[n-2]
  //----------------------------------------------------------
  // allocate temporary Dividend Element and normalize
  //----------------------------------------------------------
  uIndex = uSize;				// required length, minimum
  if((NormalShift +
        HardGetBitCntWLnumElem(pU->lpEl[uIndex-1])) >= 32) //  u[n-1]
  {
    uIndex++;					// one more element required
    LoopCnt++;					// one more round
  }
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, uIndex, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
    return(Retcode);
  }
  WLnumReleaseCnt++;
  pNumU = ppTmpWLnum[0];
  pEluBase = pNumU->lpEl;			// set base pointer

  if(uIndex != uSize)				// one more element allocated
  {
    pEluBase[uSize] = 0;			// clear topmost Element
    LshiftWLnum(HMEM_CTX_REF1
		pNumU, pU, NormalShift);	// normalize
  }
  else						// usize > vsize as u > v !
  {
    if(NormalShift == 0)			// no shift required
      CopyWLnum(HMEM_CTX_REF1
		pNumU, pU);			// only copy to tmp
    else
      LshiftWLnum(HMEM_CTX_REF1
		  pNumU, pU, NormalShift);	// assure u/v consistency
  }
  //----------------------------------------------------------
  // Division loop
  //----------------------------------------------------------
  do
  {
    uIndex--;			// number u access index TOP
    LoopCnt --;			// predecrement count, now can be used as index!
				// for u BASE
    //--------------------------------------------------------
    // get estimate qhat for quotient q
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    qhatL = GetQ32EstimateEmul32(pEluBase, uIndex, vnM1, vnM2);
#else
    qhatL = GetQ32EstimateBit64(pEluBase, uIndex, vnM1, vnM2);
#endif

    DIV_PRINT("qhat estimate: ");
    DIV_PRINT_HEX_BIT32_NL(qhatL);

    //--------------------------------------------------------
    // Perform multiply and subtraction
    //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
    if(HardMulSubWLnumEmul32(vSize,			// ui = ui - qi * v
                          pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
      DIV_PRINT_NL("B32 Backadd");
    }
#else
    if(HardMulSubWLnumBit64(vSize,			// ui = ui - qi * v
                          pEluBase,LoopCnt,pElvBase, qhatL) != 0)
    {
      DIV_PRINT_NL("B64 Backadd");
    }
#endif
  } while(LoopCnt != 0);			// End of Division Loop
  //----------------------------------------------------------
  // renormalize Remainder (from lnumu)
  //----------------------------------------------------------
  Retcode = LNUM_OP_OK;
  uSize = pNumU->UsedSize;			// get figure count (> 0!)
  i = uSize - 1;				// top element index
  do
  {
    if(pEluBase[i--] != 0) break;		// figure <> 0
      uSize--;
  } while (uSize != 0);
  pNumU->UsedSize = uSize;			// max. used figures
  if(uSize == 0)				// remainder is zero
    pRem->UsedSize = 0;				// is Zero
  else
  {
    if(NormalShift == 0)			// no shift required
      Retcode = CopyWLnum(HMEM_CTX_REF1
			  pRem, pNumU);	// only copy buffer
    else
      Retcode = RshiftWLnum(HMEM_CTX_REF1
			pRem,pNumU,NormalShift);// do normalize shift right
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//==============================================================
// UP MulModWLnum calculates (u * v) mod m
//
// Note: 1. destination and sources can be same.
// ----- 2. 3 Temporary Elements from Context needed.
//
// Input parameters: WLNUM * pRem	pointer to remainder
//		     WLNUM * pU		pointer to number u
//		     WLNUM * pV		pointer to number v
//		     WLNUM * pMod	pointer to modulus m
//		     WLNUM_CTX * pCtx	Work context / NULL
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST MulModWLnum(HMEM_CTX_DEF
		WLNUM * pRem, WLNUM * pU,
		WLNUM * pV, WLNUM * pMod, WLNUM_CTX * pCtx)
{
  int Retcode;
  int MaxSize;
  WLNUM * pNumTmp;
  WLNUM * ppTmpWLnum[1];
  WLNUM_CTX * pTmpCtx = NULL;

//  if((pRem==NULL) || (pU==NULL) || (pV==NULL) || (pMod==NULL))
//    return(LNUM_OP_NULL_PTR);

  if(pMod->UsedSize == 0)
    return(LNUM_OP_ZERO_DIV);
  //------------------------------------------------------------
  // Get maximum required size for temporary number
  //------------------------------------------------------------
  MaxSize = pU->UsedSize + pV->UsedSize;

  //-----------------------------------------------------------------
  // if no Context given, allocate one with 3 Elements of proper size
  //-----------------------------------------------------------------
  if(pCtx == NULL)
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3, MaxSize+1)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pCtx = pTmpCtx;
  }
  //-----------------------------------------------------------------
  // Get Temporary Number of appropriate size
  //-----------------------------------------------------------------
  if((Retcode = GetWLnumFromContext(HMEM_CTX_REF1
			pCtx, MaxSize, ppTmpWLnum)) != LNUM_OP_OK)
  {
    if(pTmpCtx != NULL)
    {
      FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
    }
    else
      ReleaseWLnumsFromContext(pCtx, 1);
    return(Retcode);
  }
  pNumTmp = ppTmpWLnum[0];
//  pTmpNum->UsedSize = 0;
  //------------------------------------------------------------
  // Multiply, Divide by modulus
  //------------------------------------------------------------
#if !defined LNUM32_USE_INT64
  if(pU == pV)
    Retcode = SquareWLnumEmul32(HMEM_CTX_REF1
				pNumTmp, pU);	// only do square
  else
    Retcode = MulWLnumEmul32(HMEM_CTX_REF1
			     pNumTmp, pU, pV); 	// do real multiply
#else
  if(pU == pV)
    Retcode = SquareWLnumBit64(HMEM_CTX_REF1
			       pNumTmp, pU);	// only do square
  else
    Retcode = MulWLnumBit64(HMEM_CTX_REF1
			    pNumTmp, pU, pV); 	// do real multiply
#endif

  if(pU == pV)
  {
    EXP_PRINT("EXP: Square out: ");
  }
  else
  {
    EXP_PRINT("EXP: Mul    out: ");
  }

  EXP_SHOWLNUM(pNumTmp);


  if(Retcode == LNUM_OP_OK)
  {
    Retcode = ModWLnum(HMEM_CTX_REF1
		pRem,pNumTmp,pMod,pCtx);	// get remainder divided by m
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else
    ReleaseWLnumsFromContext(pCtx, 1);
  return(Retcode);
}
//==============================================================
// UP ExpModStdWLnum calculates (u ** v) mod m using a precomputed
// table of powers to reduce amount of caclulations needed.
// -- slow version --
// The size of the table depends on the size of the value v.
// The contents will be (u) mod m, (u**3) mod m, (u**5) mod m
// and so on.
// The power p is scanned from top to bottom using a window of
// size 1 to 6 bits, depending on the magnitude of v.
//
// Note: 1. destination and source  m u s t  be different,
// ----- 2. 3 CTX Elements required + max. 32 for Table (to be done!)
//
// Input parameters: WLNUM * pRem	pointer to destination
//		     WLNUM * pU		pointer to number u
//		     WLNUM * pV		pointer to power v
//		     WLNUM * pMod	pointer to modulus m
//		     WLNUM_CTX * pCtx	Work context / NULL
//		     void callback(int)	Callback pointer / NULL
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST ExpModStdWLnum(HMEM_CTX_DEF
			       WLNUM * pRem, WLNUM * pU, WLNUM * pV,
			       WLNUM * pMod, WLNUM_CTX * pCtx,
			       void callback(int))
{
  int Retcode;

  int i = 0;
  int j;
  int k = 0;
  int win=0;
  int vIndex=0;
  int vIndexSave;

  int AllocIndex = 0;
  int MulFlag=0;
  int WinStart=0;
  int WinSize;

  int wIndex;
  int MaxSize;

  int LastUtc = 0;
  int ThisUtc = 0;

  WLNUM * pNumTmp0 = NULL;

  WLNUM * CalcTab[32];			// precalculated numbers

  int * pElv = NULL;

  int BitMask = 0;
  int BitMaskSave;

//  if((pRem==NULL) || (pU==NULL) || (pV==NULL) || (pMod==NULL))
//    return(LNUM_OP_NULL_PTR);
  EXP_PRINT("EXPMOD ENTER\n");

  EXP_PRINT("Modulus: ");
  EXP_SHOWLNUM(pMod);

  //--------------------------------------------------------------
  // Check for Modulus m == 0
  //--------------------------------------------------------------
  MaxSize = pMod->UsedSize;			// get length
  if((MaxSize == 0) ||
     ((MaxSize == 1) && (pMod->lpEl[0] == 0)))
    return(LNUM_OP_ZERO_DIV);
  //------------------------------------------------------------
  // calculate maximal needed elements for temporary values
  //------------------------------------------------------------
  if((pMod->lpEl[MaxSize-1] & 0x80000000) != 0) // need one element more
    MaxSize ++;					// 1 element more
  for(;;)	// ERROR FOR
  {
    //----------------------------------------------------------
    // preset value 1 for result,increase buffersize if needed
    //----------------------------------------------------------
    if(pRem->AllocSize < MaxSize)		// too few elements
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,MaxSize)) != LNUM_OP_OK)
        break;
    }
    pRem->UsedSize = 1;
    pRem->lpEl[0] = 1;
    //----------------------------------------------------------
    // Allocate 1st element and calculate (u) mod m
    //----------------------------------------------------------
    if((CalcTab[0] = AllocNewWLnum(HMEM_CTX_REF1
				   MaxSize)) == NULL)
    {
      Retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    AllocIndex++;				// one more allocated element
    if((Retcode=ModWLnum(HMEM_CTX_REF1
		  CalcTab[0],pU,pMod,pCtx)) != LNUM_OP_OK) // get (u)mod m
      break;

    EXP_PRINT("CTab[0]: ");
    EXP_SHOWLNUM(CalcTab[0]);

    //----------------------------------------------------------
    // Get size of power, allocate required temporary buffer
    //----------------------------------------------------------
    pElv = pV->lpEl;				// number base
    vIndex = pV->UsedSize-1;			// get topmost element index

    if((i = (vIndex * 32) +			// get number of bits
           (int) HardGetBitCntWLnumElem(pElv[vIndex])) == 0)
						// (u ** 0) mod m = 1
    {
      FreeWLnum(HMEM_CTX_REF1 CalcTab[0]);
      return(LNUM_OP_OK);
    }

    WinStart = i-1;				// first Bit +1 to test
    BitMask = (int)
               ((int) 1 << ((i-1) & (int) 0x1F));// initial test bit mask

#if 0
    PRINT("vIndex: ");
    PRINT_INT_NL(vIndex);
    PRINT("i: ");
    PRINT_INT_NL(i);
    PRINT("WinStart: ");
    PRINT_INT_NL(WinStart);
    PRINT("Start Mask: ");
    PRINT_HEX_BIT32_NL(BitMask);
#endif

    //----------------------------------------------------------
    // Get window size to use
    // Changed according to Algorithm 1.2.2.4 from H. Cohen:
    // lg N <= (k * (k+1) * 2^(2k))/(2^(k+1) -k - 2)
    // k = 1 for bits <= 8
    // k = 2 for bits <= 24
    // k = 3 for bits <= 69
    // k = 4 for bits <= 196
    // k = 5 for bits <= 538 bits (and above)
    //----------------------------------------------------------
    if(i <= 8) win = 1;
    else if(i <= 24) win = 2;
    else if(i <= 69) win = 3;
    else if(i <= 196) win = 4;
    else if(i <= 538) win = 5;
    else win = 6;

//    PRINT("WIN: ");
//    PRINT_INT(win);

    if(win != 1)				// must build more elements
    {
      if((pNumTmp0 = AllocNewWLnum(HMEM_CTX_REF1
				   MaxSize)) == NULL)// allocate temporary
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      if((Retcode=MulModWLnum(HMEM_CTX_REF1		// get (u**2) mod m
		      pNumTmp0,CalcTab[0],
                      CalcTab[0],pMod, pCtx)) != LNUM_OP_OK) break;

      EXP_PRINT("NumTmp0: ");
      EXP_SHOWLNUM(pNumTmp0);
      //----------------------------------------------------------
      // precalculate Table values
      //----------------------------------------------------------
      j = (1<<(win-1)) - 1;			// maximal index (rel. 0)
      k = 1;					// set start index ([1])
      do					// process alloc/preset
      {
        if((CalcTab[k] = AllocNewWLnum(HMEM_CTX_REF1
				       MaxSize)) == NULL) // allocation error
        {
	  Retcode = LNUM_OP_ALLOC_ERR;
	  break;
        }
	AllocIndex++;				// one more Element
						// get next table entry
        if((Retcode=MulModWLnum(HMEM_CTX_REF1 CalcTab[k],CalcTab[k-1],
                       pNumTmp0,pMod,pCtx)) != LNUM_OP_OK) break;
        EXP_PRINT("CTAB[k]: ");
        EXP_SHOWLNUM(CalcTab[k]);
        k++;					// to next table index
      }while((--j) != 0);
    } // win != 1
    if(Retcode == LNUM_OP_OK) break;	// no Error, continue

    while(AllocIndex != 0)      	// free elements
    {
      AllocIndex--;
      FreeWLnum(HMEM_CTX_REF1 CalcTab[AllocIndex]);
    }
    FreeWLnum(HMEM_CTX_REF1 pNumTmp0);
    return(Retcode);
  } // Error FOR

  if(callback != NULL)
  {
    if(i < 128)
    {
#if defined WIN32 || defined WIN64
#pragma warning(disable:4550)
#endif
      callback = (void(*)(int)) NULL;
#if defined WIN32 || defined WIN64
#pragma warning(default:4550)
#endif
    }
    else
      LastUtc = SecGetSystemTimeUTC();
  }
  //------------------------------------------------------------
  // processing loop
  //------------------------------------------------------------
//  Retcode = LNUM_OP_OK;
  for(;;)					// process 'infinite'
  {
    //----------------------------------------------------------
    // search 1st v-bit that is One, starting at the MSB-Bit
    //----------------------------------------------------------
    if((pElv[vIndex] & BitMask) == 0)	// no startbit found
    {
      if(MulFlag != 0)			// should we do multiply ?
      {
#if 0
        PRINT("\nSquareMod0: In  = ");
        ShowLnum(pRem);
        PRINT("SquareMod0: Mod = ");
        ShowLnum(pMod);
#endif

        if((Retcode=MulModWLnum(HMEM_CTX_REF1	// multiply * rem mod m
				pRem,pRem,pRem,pMod,pCtx)) != LNUM_OP_OK)
          break;

        EXP_PRINT("SquareMod0: Rem = ");
        EXP_SHOWLNUM(pRem);
        EXP_PRINT("\n");

//      SquareCount++;
      }
      if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
      {
        BitMask = (int) (unsigned int) 0x80000000;
        vIndex--;
      }
      if((--WinStart) < 0)
      {
        EXP_PRINT("Should finish..");
        break;					// all done
      }
      continue;					// keep on searching
    } // Bit was zero
    //----------------------------------------------------------
    // bit found, correct bitmask
    //----------------------------------------------------------
    if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
    {
      BitMask = (int) (unsigned int) 0x80000000;
      vIndex--;
    }
    //----------------------------------------------------------
    // get window size and Table Index from winsize bits
    // N O T E: take care of bitmask !!!
    //----------------------------------------------------------
    WinSize = 0;				// no size yet
    wIndex = 1;
    vIndexSave = vIndex;			// save pointer
    BitMaskSave = BitMask;			// save mask
    for(i=1;i<win;i++)				// get sizes
    {
      if((WinStart - i) < 0) break;		// check for data end
      if((pElv[vIndex] & BitMask) != 0)		// one bit found
      {
        wIndex = (wIndex << (i-WinSize)) | 1;	// correct index,insert new bit
        WinSize = i;				// save size
        BitMaskSave = BitMask;			// get current bitmask
        vIndexSave = vIndex;			// get current pointer
        if((BitMaskSave = ((BitMaskSave >>1) & (int) 0x7FFFFFFF)) == 0)
        {
          BitMaskSave = (int) (unsigned int) 0x80000000;
          vIndexSave--;
        }
      }
      if((BitMask = ((BitMask >> 1) & (int) 0x7FFFFFFF)) == 0)
      {
        BitMask = (int) (unsigned int) 0x80000000;
        vIndex--;
      }
    }
    BitMask = BitMaskSave;
    vIndex = vIndexSave;
    //----------------------------------------------------------
    // correct modulo operation (1 figure)
    //----------------------------------------------------------
    j = WinSize+1;			// number of corrections needed
    do
    {
      EXP_PRINT("SquareMod1-IN: Rem = ");
      EXP_SHOWLNUM(pRem);

      if((Retcode=MulModWLnum(HMEM_CTX_REF1	// multiply * (rem) mod m
			pRem,pRem,pRem,pMod,pCtx)) != LNUM_OP_OK)
        break;
      EXP_PRINT("SquareMod1: Rem = ");
      EXP_SHOWLNUM(pRem);
//    SquareCount++;
      j--;
    }while(j != 0);
    if(j != 0) break;			// error occured
    //----------------------------------------------------------
    // multiply with appropriate table value
    //----------------------------------------------------------
    EXP_PRINT("MulMod0In  : Rem = ");
    EXP_SHOWLNUM(pRem);
    EXP_PRINT("MulMod0In  : Mul = ");
    EXP_SHOWLNUM(CalcTab[wIndex>>1]);
    EXP_PRINT("MulMod0In  : wIndex = ");
    EXP_PRINT_INT_NL(wIndex);

					// multiply * (Table) mod m
    if((Retcode=MulModWLnum(HMEM_CTX_REF1
		   pRem,pRem,CalcTab[wIndex>>1],pMod,pCtx)) != LNUM_OP_OK)
      break;

    EXP_PRINT("MulMod0  : Rem = ");
    EXP_SHOWLNUM(pRem);

//  MulCount++;
    //----------------------------------------------------------
    // check if more input data present
    //----------------------------------------------------------
    MulFlag = 1;				// enable multiplying now
    if((WinStart -= (WinSize+1)) < 0) break;	// reduce data count
    if(callback != NULL)
    {
      ThisUtc = SecGetSystemTimeUTC();
      if(ThisUtc != LastUtc)
      {
        LastUtc = ThisUtc;
	callback(1);
      }
    }
  } // for
  //------------------------------------------------------------
  // free buffers, exit
  //------------------------------------------------------------
  while(AllocIndex != 0)
  {
    AllocIndex--;
    FreeWLnum(HMEM_CTX_REF1 CalcTab[AllocIndex]);
  }
  FreeWLnum(HMEM_CTX_REF1 pNumTmp0);
// TEST TEST TEST
//  fprintf(stdout,"\nPseudo-Mult: %d, True-Mult: %d",a,b);
// TEST TEST TEST

#if 0
  GET_END_TICS
  DiffTics = GET_DIFF_TICS

  PRINT("\nexpsize Tics: ");
  PRINT_HEX_BIT32(DiffTics);
  PRINT("\n");
//  PRINT("\nExpSize    : ");
//  PRINT_INT(ExpSize);
//  PRINT("\nSquareCount: ");
//  PRINT_INT(SquareCount);
//  PRINT("\nMulCount   : ");
//  PRINT_INT(MulCount);
#endif

  EXP_PRINT("EXPMOD EXIT\n");

  return(Retcode);
}
//==============================================================
// UP GcdWLnum calculates greatest common divisor of two
// positive Wlarge numbers u,v using binary euclidian algorithm.
// Destination may be same as Source.
//
// Input parameters: WLNUM * pRes	pointer to destination
// 		     WLNUM * pU		pointer to number u
// 		     WLNUM * pV		pointer to power v
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST GcdWLnum(HMEM_CTX_DEF WLNUM * pRes, WLNUM * pU, WLNUM * pV)
{

//  if((pRes == NULL) || (pU == NULL) || (pV == NULL))
//    return(LNUM_OP_NULL_PTR);

  int Retcode;
  int ShiftCnt=0;

  WLNUM * pUtmp;
  WLNUM * pVtmp;
  WLNUM * pTmpLnum;

  //------------------------------------------------------------
  // allocate temporary number variables
  //------------------------------------------------------------
  if((pUtmp = AllocNewWLnum(HMEM_CTX_REF1
			    pU->UsedSize+1)) == NULL) // allocate temporary
    return(LNUM_OP_ALLOC_ERR);			   // error occured
  if((pVtmp = AllocNewWLnum(HMEM_CTX_REF1
			    pV->UsedSize+1)) == NULL) // allocate temporary
  {
    FreeWLnum(HMEM_CTX_REF1 pUtmp);
    return(LNUM_OP_ALLOC_ERR);			// error occured
  }
  //------------------------------------------------------------
  // make copy of input numbers
  //------------------------------------------------------------
  if(((Retcode = CopyWLnum(HMEM_CTX_REF1 pUtmp, pU)) != LNUM_OP_OK) ||
     ((Retcode = CopyWLnum(HMEM_CTX_REF1 pVtmp, pV)) != LNUM_OP_OK))
  {
    FreeWLnum(HMEM_CTX_REF1 pUtmp);
    FreeWLnum(HMEM_CTX_REF1 pVtmp);
    return(Retcode);
  }
  //------------------------------------------------------------
  // assure utmp >= vtmp
  //------------------------------------------------------------
  if(UcompWLnum(pUtmp,pVtmp) == WLNUM_1ST_LT_2ND)
  {
    pTmpLnum = pUtmp;				// exchange u,v
    pUtmp = pVtmp;
    pVtmp = pTmpLnum;
  }
  //------------------------------------------------------------
  // Start euclidian processing
  //------------------------------------------------------------
  Retcode = LNUM_OP_OK;
  for(;;)
  {
    if(IsZeroWLnum(pVtmp) != 0) break;		// terminate
    switch(((pUtmp->lpEl[0] & 1) << 1) |	// get decision variable
            (pVtmp->lpEl[0] & 1))
//    switch(j)
    {
      case 0:					// both even, divide both by 2
        if(((Retcode = Rshift1WLnum(HMEM_CTX_REF1
				    pUtmp,pUtmp)) != LNUM_OP_OK) ||
           ((Retcode = Rshift1WLnum(HMEM_CTX_REF1
				    pVtmp,pVtmp)) != LNUM_OP_OK))
          break;
        ShiftCnt ++;
	continue;				// to outer loop

      case 1:					// utmp even, vtmp odd
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
			       pUtmp,pUtmp);	// divide by two
        break;

      case 2:					// utmp odd, vtmp even
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
			       pVtmp,pVtmp);	// divide by two
	break;

      case 3:					// both odd
						// calculate utmp=(utmp-vtmp)/2
        if((Retcode = SubWLnum(HMEM_CTX_REF1
				pUtmp,pUtmp,pVtmp)) != LNUM_OP_OK)
          break;
        Retcode = Rshift1WLnum(HMEM_CTX_REF1
				pUtmp,pUtmp);
	break;
    } // switch
    if(Retcode != LNUM_OP_OK)			// had an error
      break;

    if(UcompWLnum(pUtmp,pVtmp) == WLNUM_1ST_LT_2ND)
    {
      pTmpLnum = pUtmp;				// exchange u,v
      pUtmp = pVtmp;
      pVtmp = pTmpLnum;
    }
  } // Euclidian FOR
  //------------------------------------------------------------
  // copy back result
  //------------------------------------------------------------
  if(Retcode == LNUM_OP_OK)
  {
    if(ShiftCnt != 0)
      Retcode = LshiftWLnum(HMEM_CTX_REF1
			    pUtmp,pUtmp,ShiftCnt);

    if(Retcode == LNUM_OP_OK)
      Retcode = CopyWLnum(HMEM_CTX_REF1 pRes, pUtmp);
  }

  FreeWLnum(HMEM_CTX_REF1 pUtmp);
  FreeWLnum(HMEM_CTX_REF1 pVtmp);
  return(Retcode);
}
//==============================================================
// UP InvModLnum calculates inverse of number u modulo m
// using (simplified) extended euclid algorithm. See Knuth (II)
// exercises.
// I.e. solves  u * x = (1) mod m where x is the inverse.
// NOTE: 1. Destination may be same as Source.
// ----- 2. 2 + 6 CTX Elements needed
//
// *** S l o w  v e r s i o n  ! ***
//
// Input parameters: WLNUM * pUinv	Pointer to result
//		     WLNUM * pU		pointer to number u
// 		     WLNUM * pMod	pointer to modulus m
//		     WLNUM_CTX * pCtx	Work context / NULL --> IMPLEMENT !!
// Returns: int Status, 0 o.k., else error occured
//==============================================================
int FAST InvModWLnum(HMEM_CTX_DEF
		WLNUM * pUinv, WLNUM * pU, WLNUM * pMod, WLNUM_CTX * pCtx)
{
  int Retcode, i;
  int MaxSize;
  int Sign=1;
  int WLnumReleaseCnt = 0;

  WLNUM * Q;				// tmp. Quotient
  WLNUM * R;				// tmp. Remainder
  WLNUM * U;				// tmp. variable for GCD
  WLNUM * V;				// dto.
  WLNUM * X;				// tmp. variable for Inverse
  WLNUM * Y;				// dto.
  WLNUM * S;				// dto.

  WLNUM ** pNumArr;

  WLNUM_CTX * pTmpCtx = NULL;

//  if((pUinv == NULL) || (pU == NULL) || (pMod == NULL))
//    return(LNUM_OP_NULL_PTR);

  //------------------------------------------------------------
  // Get size of/allocate required Helper-Variables
  //------------------------------------------------------------
  MaxSize = pU->UsedSize;			// assume u large
  if(MaxSize < pMod->UsedSize)
    MaxSize = pMod->UsedSize;
  MaxSize ++;
  if(pCtx == NULL)				// no context
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 2+6, MaxSize)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pNumArr = pTmpCtx->pWLnumArr;
    U = pNumArr[0];
    V = pNumArr[1];
    X = pNumArr[2];
    Y = pNumArr[3];
    Q = pNumArr[4];
    R = pNumArr[5];
    pTmpCtx->NextFreeIndex = 6;
    pCtx = pTmpCtx;
  }
  else						// context is given
  {
    i = pCtx->NextFreeIndex;
    if((i + 2+6) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);

    U = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    V = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    X = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    Y = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    Q = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    R = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    if((U == NULL) || (V == NULL) || (X == NULL) || (Y == NULL) ||
       (Q == NULL) || (R == NULL))
      return(LNUM_OP_ALLOC_ERR);

    WLnumReleaseCnt = 6;
  }
//  k = 0;				// prepare for freeing !!

  for(;;)		// Error FOR
  {
    //------------------------------------------------------------
    // Prepare Start of Algorithm
    //------------------------------------------------------------
    X->UsedSize = 0;				// X = 0
    Y->UsedSize = 1;				// Y = 1
    Y->lpEl[0] = 1;
    if(((Retcode = CopyWLnum(HMEM_CTX_REF1 U,pU)) != LNUM_OP_OK) || // U = u
       ((Retcode = CopyWLnum(HMEM_CTX_REF1 V,pMod)) != LNUM_OP_OK)) // V = m
      break;
    //------------------------------------------------------------
    // Processing Loop
    //------------------------------------------------------------
    for(;;)
    {
      Retcode = LNUM_OP_OK;
      if(IsZeroWLnum(V) != 0) break;		// remainder is zero, stop

//      PRINT("U: ");
//      ShowLnum(U);
//      PRINT("V: ");
//      ShowLnum(V);

      if((Retcode=DivWLnum(HMEM_CTX_REF1
		    Q,R,U,V,pCtx)) != LNUM_OP_OK)// Divide U/V with remainder
        break;

//      PRINT("Q: ");
//      ShowLnum(Q);
//      PRINT("R: ");
//      ShowLnum(R);

      S = U;					// U is now free
      U = V;					// set next Dividend
      V = R;					// set next Divisor
#if !defined LNUM32_USE_INT64
      if((Retcode = MulWLnumEmul32(HMEM_CTX_REF1
				   S,Q,X)) != LNUM_OP_OK)	// Q * X
        break;
#else
      if((Retcode = MulWLnumBit64(HMEM_CTX_REF1
				  S,Q,X)) != LNUM_OP_OK)	// Q * X
        break;
#endif
//      PRINT("SMult: ");
//      ShowLnum(S);
//      PRINT("Y: ");
//      ShowLnum(Y);

      if((Retcode = AddWLnum(HMEM_CTX_REF1
			     S,S,Y)) != LNUM_OP_OK)	// Q * X + Y
        break;

//      PRINT("S: ");
//      ShowLnum(S);

      R = Y;					// Y is now free
      Y = X;
      X = S;
      Sign = - Sign;
    }
    if(Retcode != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Check if odd number of loops, if so set Y = -Y
    //------------------------------------------------------------
    if(Sign < 0)				// odd number, readjust
    {
      if((Retcode = SubWLnum(HMEM_CTX_REF1
			Y,pMod,Y)) != LNUM_OP_OK) //prepare -Y mod m
        break;
//      PRINT("Past subtract: ");
//      ShowLnum(Y);

    }
    //------------------------------------------------------------
    // Check if gcd is 1; if not, inverse does not exist
    //------------------------------------------------------------
    if(IsOneWLnum(U) == 0)
    {
      Retcode = LNUM_OP_NO_INVERSE;
      break;
    }
    //------------------------------------------------------------
    // calculate final inverse
    //------------------------------------------------------------
//    PRINT("Inverse before MOD: ");
//    ShowLnum(Y);

    Retcode = ModWLnum(HMEM_CTX_REF1 pUinv,Y, pMod, pCtx);
    break;
  } // Error FOR

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  else if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//===============================================================
// UP WLnum_bin2wlnum converts binary number representation to a
// Wlarge number representation
// NOTE: 1. binary number is in BIG ENDIAN format, i.e.
// -----    MSB is first byte in buffer, LSB is last byte
//       2. the binary number is not checked for negative value
//	 3. the binary number may have leading zeroes
//
// Input parameters :  	WLNUM * pWLnum		Destination
//			char *  pSrcBuf		Source buffer pointer
//			int     SrcOffset	start of data
//			int	SrcLen		length of data
// Returns: int	Status - 0 o.k., else error occured
//================================================================
int FAST WLnum_bin2wlnum(HMEM_CTX_DEF
			WLNUM * pWLnum, char * pSrcBuf,
			int SrcOffset, int SrcLen)
{
  int Retcode, ElementCnt, SrcRemainCnt, DstIndex;

  int WElement;
  int * pEl;
  //----------------------------------------------------
  // Check parameters, remove later ?
  //----------------------------------------------------
  if((pWLnum == NULL) || (pSrcBuf == NULL))
    return(LNUM_OP_NULL_PTR);
  if(SrcLen <= 0)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Skip leading zeroes in Source, may all be zero !
  //----------------------------------------------------
  while(SrcLen != 0)
  {
    if(pSrcBuf[SrcOffset] != 0)
      break;
    SrcOffset++;
    SrcLen--;
  }
  //----------------------------------------------------
  // Check for all zeroes first
  //----------------------------------------------------
  if(SrcLen == 0)
  {
    pWLnum->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Not all zeroes, get number of BIT32 Elements needed
  //----------------------------------------------------
  ElementCnt = (SrcLen + 3) / 4;		// get numer of BIT32 Elements
  if(pWLnum->AllocSize < ElementCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pWLnum,ElementCnt)) != LNUM_OP_OK)
      return(Retcode);
  }
  pWLnum->UsedSize = ElementCnt;		// set size
  DstIndex = ElementCnt - 1;			// set Index to top Element
  pEl = pWLnum->lpEl;
  //----------------------------------------------------
  // check if partial element must be processed first
  //----------------------------------------------------
  if((SrcRemainCnt = (SrcLen & 0x03)) != 0)	// partial element present
  {
    SrcLen -= SrcRemainCnt;			// full elements left
    WElement = 0;
    do
    {
      WElement <<= 8;				// shift up bytes
      WElement |= (int) pSrcBuf[SrcOffset++] & 0xFF; // insert next element
      SrcRemainCnt--;
    }while(SrcRemainCnt != 0);
    pEl[DstIndex--] = WElement;
  }
  //----------------------------------------------------
  // store remaining full elements (if any)
  //----------------------------------------------------
  while(DstIndex >= 0)
  {
    WElement = ((int) pSrcBuf[SrcOffset]   << 24) |
               (((int) pSrcBuf[SrcOffset+1] & 0xFF) << 16) |
               (((int) pSrcBuf[SrcOffset+2] & 0xFF) << 8) |
               ((int) pSrcBuf[SrcOffset+3] & 0xFF);
    pEl[DstIndex--] = WElement;
    SrcOffset += 4;
  }
  return(LNUM_OP_OK);
}
//===============================================================
// UP WLnum_bin2wlnumLe converts binary number representation to a
// Wlarge number representation
// NOTE: 1. binary number is in LITTLE ENDIAN format, i.e.
// -----    LSB is first byte in buffer, MSB is last byte
//       2. the binary number is not checked for negative value
//	 3. the binary number may have leading zeroes
//
// Input parameters :  	WLNUM * pWLnum		Destination
//			char *  pSrcBuf		Source buffer pointer
//			int     SrcOffset	start of data
//			int	SrcLen		length of data
// Returns: int	Status - 0 o.k., else error occured
//================================================================
int FAST WLnum_bin2wlnumLe(HMEM_CTX_DEF
			   WLNUM * pWLnum, char * pSrcBuf,
			   int SrcOffset, int SrcLen)
{
  int Retcode, ElementCnt, SrcRemainCnt, DstIndex;

  int WElement;
  int * pEl;
  //----------------------------------------------------
  // Check parameters, remove later ?
  //----------------------------------------------------
  if((pWLnum == NULL) || (pSrcBuf == NULL))
    return(LNUM_OP_NULL_PTR);
  if(SrcLen <= 0)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Remove trailing zeroes in Source, may all be zero !
  //----------------------------------------------------
  SrcOffset = SrcLen-1;			// to top of buffer
  while(SrcLen != 0)
  {
    if(pSrcBuf[SrcOffset] != 0)
      break;
    SrcOffset--;
    SrcLen--;
  }
  //----------------------------------------------------
  // Check for all zeroes first
  //----------------------------------------------------
  if(SrcLen == 0)
  {
    pWLnum->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Not all zeroes, get number of BIT32 Elements needed
  //----------------------------------------------------
  ElementCnt = (SrcLen + 3) / 4;		// get numer of BIT32 Elements
  if(pWLnum->AllocSize < ElementCnt)
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pWLnum,ElementCnt)) != LNUM_OP_OK)
      return(Retcode);
  }
  pWLnum->UsedSize = ElementCnt;		// set size
  DstIndex = ElementCnt - 1;			// set Index to top Element
  pEl = pWLnum->lpEl;
  //----------------------------------------------------
  // check if partial element must be processed first
  //----------------------------------------------------
  if((SrcRemainCnt = (SrcLen & 0x03)) != 0)	// partial element present
  {
    SrcLen -= SrcRemainCnt;			// full elements left
    WElement = 0;
    do
    {
      WElement <<= 8;				// shift up bytes
      WElement |= (int) pSrcBuf[SrcOffset--] & 0xFF; // insert next element
      SrcRemainCnt--;
    }while(SrcRemainCnt != 0);
    pEl[DstIndex--] = WElement;
  }
  //----------------------------------------------------
  // store remaining full elements (if any)
  //----------------------------------------------------
  while(DstIndex >= 0)
  {
    WElement = ((int) pSrcBuf[SrcOffset]   << 24) |
               (((int) pSrcBuf[SrcOffset-1] & 0xFF) << 16) |
               (((int) pSrcBuf[SrcOffset-2] & 0xFF) << 8) |
               ((int) pSrcBuf[SrcOffset-3] & 0xFF);
    pEl[DstIndex--] = WElement;
    SrcOffset -= 4;
  }
  return(LNUM_OP_OK);
}
//================================================================
// UP WLnum_wlnum2bin converts Wlong number representation to a
// binary number representation
// NOTE: 1. the binary representation is in BIG ENDIAN format,
// ----     i.e. MSB is first byte in buffer, LSB is last
//       2. the large number is not checked for negative value
//	 3. the binary number will n o t  have leading zeroes,
//	    if the flag is not set
//
// Input parameters :   char *	    pDstBuf	Destination buffer
//			int	    DstIndex	start of data
//			int *	    pDstLen	IN/OUT, length buffer/data
//		 	WLNUM *     pWLnum	source
//			int	    ZeroFlag	<> 0: insert leading
//						zero byte if
//						necessary (MSB bit
//						of number=1)
//						0 : do not insert
//						    leading zero
// Returns: int Status, 0 - o.k., else error occured
//================================================================
int FAST WLnum_wlnum2bin(char * pDstBuf, int DstIndex,
		         int * pDstLen, WLNUM * pWLnum, int ZeroFlag)
{
  int BufLen = pDstLen[0];
  int ElementIndex;
  int ElementCnt;
  int DstStart = DstIndex;
  int RemainCnt;

  int WElement;
  int * pEl;
  //-----------------------------------------------------
  // check parameters, assure Destination buffer size > 0
  //-----------------------------------------------------
  if((pDstBuf ==  NULL) || (pWLnum == NULL))
    return(LNUM_OP_NULL_PTR);
  if(BufLen <= 0)
    return(LNUM_OP_ZERO_SIZE);
  //-----------------------------------------------------
  // check special case WLnum == 0
  //-----------------------------------------------------
  ElementCnt = pWLnum->UsedSize;
  if(ElementCnt == 0)
  {
    pDstBuf[DstIndex] = 0;
    pDstLen[0] = 1;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Prepare check for buffer length
  //----------------------------------------------------
  pEl = pWLnum->lpEl;				// get base pointer
  ElementIndex = ElementCnt - 1;		// index to top element
  WElement = pEl[ElementIndex];			// get top Element
  RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes
  if((ZeroFlag != 0) &&				// insert zero if Top Bit set
    ((WElement & ((int) 0x080 << ((RemainCnt-1)*8))) != 0))
  {
    pDstBuf[DstIndex++] = 0;			// Insert NULL Byte
    BufLen--;					// reduce size for check...
  }
  if((((ElementCnt-1) * 4) + RemainCnt) > BufLen)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Process incomplete element if present
  //----------------------------------------------------
  if(RemainCnt != 4)				// incomplete Element
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      pDstBuf[DstIndex++] = (char) (WElement >> (RemainCnt*8));
    }
    ElementIndex--;
  }
  //----------------------------------------------------
  // Process remaining full elements if present
  //----------------------------------------------------
  while(ElementIndex >= 0)
  {
    WElement = pEl[ElementIndex];
    pDstBuf[DstIndex]   = (char) (WElement >> 24);
    pDstBuf[DstIndex+1] = (char) (WElement >> 16);
    pDstBuf[DstIndex+2] = (char) (WElement >> 8);
    pDstBuf[DstIndex+3] = (char) WElement;
    DstIndex += 4;
    ElementIndex--;
  }
  //------------------------------------------------------------
  // save length of transferred data
  //------------------------------------------------------------
  pDstLen[0] = DstIndex-DstStart;
  return(LNUM_OP_OK);
}
//================================================================
// UP WLnum_wlnum2binLe converts Wlong number representation to a
// binary number representation
// NOTE: 1. the binary representation is in LITTLE ENDIAN format,
// ----     i.e. LSB is first byte in buffer, MSB is last
//       2. the large number is not checked for negative value
//	 3. the binary number will n o t  have leading zeroes,
//	    if the flag is not set
//
// Input parameters :   char *	    pDstBuf	Destination buffer
//			int	    DstIndex	start of data
//			int *	    pDstLen	IN/OUT, length buffer/data
//		 	WLNUM *     pWLnum	source
//			int	    ZeroFlag	<> 0: insert leading
//						zero byte if
//						necessary (MSB bit
//						of number=1)
//						0 : do not insert
//						    leading zero
// Returns: int Status, 0 - o.k., else error occured
//================================================================
int FAST WLnum_wlnum2binLe(char * pDstBuf, int DstIndex,
		           int * pDstLen, WLNUM * pWLnum, int ZeroFlag)
{
  int BufLen = pDstLen[0];
  int ElementIndex;
  int ElementCnt;
  int DstEnd;
  int RemainCnt;

  int WElement;
  int * pEl;
  //-----------------------------------------------------
  // check parameters, assure Destination buffer size > 0
  //-----------------------------------------------------
  if((pDstBuf ==  NULL) || (pWLnum == NULL))
    return(LNUM_OP_NULL_PTR);
  if(BufLen <= 0)
    return(LNUM_OP_ZERO_SIZE);
  //-----------------------------------------------------
  // check special case WLnum == 0
  //-----------------------------------------------------
  ElementCnt = pWLnum->UsedSize;
  if(ElementCnt == 0)
  {
    pDstBuf[DstIndex] = 0;
    pDstLen[0] = 1;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------
  // Prepare check for buffer length
  //----------------------------------------------------
  pEl = pWLnum->lpEl;				// get base pointer
  ElementIndex = ElementCnt - 1;		// index to top element
  WElement = pEl[ElementIndex];			// get top Element
  RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes

  DstIndex = (ElementCnt-1)*4 + RemainCnt - 1;	// to buffer top
  DstEnd = DstIndex;

  if((ZeroFlag != 0) &&				// insert zero if Top Bit set
    ((WElement & ((int) 0x080 << ((RemainCnt-1)*8))) != 0))
  {
    pDstBuf[DstIndex--] = 0;			// Insert NULL Byte
    BufLen--;					// reduce size for check...
  }
  if((((ElementCnt-1) * 4) + RemainCnt) > BufLen)
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------
  // Process incomplete element if present
  //----------------------------------------------------
  if(RemainCnt != 4)				// incomplete Element
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      pDstBuf[DstIndex--] = (char) (WElement >> (RemainCnt*8));
    }
    ElementIndex--;
  }
  //----------------------------------------------------
  // Process remaining full elements if present
  //----------------------------------------------------
  while(ElementIndex >= 0)
  {
    WElement = pEl[ElementIndex];
    pDstBuf[DstIndex]   = (char) (WElement >> 24);
    pDstBuf[DstIndex-1] = (char) (WElement >> 16);
    pDstBuf[DstIndex-2] = (char) (WElement >> 8);
    pDstBuf[DstIndex-3] = (char) WElement;
    DstIndex -= 4;
    ElementIndex--;
  }
  //------------------------------------------------------------
  // save length of transferred data
  //------------------------------------------------------------
  pDstLen[0] = DstEnd - DstIndex;
  return(LNUM_OP_OK);
}
//================================================================
// UP WLnum_wlnum2binFill converts Wlong number representation to a
// binary number representation of definite length, filled with
// leading zeroes if needed
// NOTE: the binary representation is in BIG ENDIAN format,
// ----  i.e. MSB is first byte in buffer, LSB is last
//
// Input parameters :   char *	    pDstBuf	Destination buffer
//			int	    DstIndex	start of data
//			int *	    pDstLen	IN/OUT, length buffer/data
//		 	WLNUM *     pWLnum	source
//			int	    ReqNumLen	Number of bytes to generate
// Returns: int Status, 0 - o.k., else error occured
//================================================================
int FAST WLnum_wlnum2binFill(char * pDstBuf, int DstIndex,
		             int * pDstLen, WLNUM * pWLnum, int ReqNumLen)
{
  int BufLen = pDstLen[0];
  int ElementIndex;
  int ElementCnt;
//  int DstStart = DstIndex;
  int RemainCnt;
  int NumLen;
  int FillCount;

  int WElement;
  int * pEl;
  //-----------------------------------------------------
  // check parameters, assure Destination buffer size > 0
  //-----------------------------------------------------
  if((pDstBuf ==  NULL) || (pWLnum == NULL))
    return(LNUM_OP_NULL_PTR);

  if((BufLen <= 0) || (ReqNumLen <= 0))
    return(LNUM_OP_ZERO_SIZE);

  if(ReqNumLen > BufLen)
    return(LNUM_OP_PARAM_ERR);

  pDstLen[0] = ReqNumLen;
  //------------------------------------------------------
  // Get used bytecount for number, generate leading zeros
  // Check if number was 0
  //------------------------------------------------------
  NumLen = GetByteCntWLnum(pWLnum);
  if(NumLen > ReqNumLen)			// ReqNumLen <= BufLen !!
    return(LNUM_OP_PARAM_ERR);

  FillCount = ReqNumLen - NumLen;
  if(FillCount != 0)
  {
//    ClearBit8Array(pDstBuf, DstIndex, FillCount);
    memset(pDstBuf+DstIndex,0,FillCount);
    DstIndex += FillCount;
  }
  if(NumLen == 0)				// number WAS zero!
    return(LNUM_OP_OK);
  //----------------------------------------------------
  // Prepare for number output
  //----------------------------------------------------
  ElementCnt = pWLnum->UsedSize;
  pEl = pWLnum->lpEl;				// get base pointer
  ElementIndex = ElementCnt - 1;		// index to top element
  WElement = pEl[ElementIndex];			// get top Element
  RemainCnt = HardGetByteCntWLnumElem(WElement);// get number of bytes
  //----------------------------------------------------
  // Process incomplete element if present
  //----------------------------------------------------
  if(RemainCnt != 4)				// incomplete Element
  {
    while(RemainCnt != 0)
    {
      RemainCnt--;
      pDstBuf[DstIndex++] = (char) (WElement >> (RemainCnt*8));
    }
    ElementIndex--;
  }
  //----------------------------------------------------
  // Process remaining full elements if present
  //----------------------------------------------------
  while(ElementIndex >= 0)
  {
    WElement = pEl[ElementIndex];
    pDstBuf[DstIndex]   = (char) (WElement >> 24);
    pDstBuf[DstIndex+1] = (char) (WElement >> 16);
    pDstBuf[DstIndex+2] = (char) (WElement >> 8);
    pDstBuf[DstIndex+3] = (char) WElement;
    DstIndex += 4;
    ElementIndex--;
  }
  return(LNUM_OP_OK);
}
//==============================================================
// Get a (pseudo) Random large number of definite bitlength
// NOTE: the random Generator can always deliver a number
// ----  having leading zero bits. To get a number of really
//	 the required bitlength size set the top flagbit !
//
// Input params: WLNUM * pRnd		Random Number
//		 int	 BitSize	number of bits required
//		 int	 TopFlag	if <> 0 set topmost 2 bits
//		 int	 Oddflag	if <> 0 return odd number
//
// Returns: int Status, 0 - o.k., else error occured
//===============================================================
int FAST WLnumRand(HMEM_CTX_DEF WLNUM * pRnd, int BitSize,
		   int TopFlag, int OddFlag)
{
  int Retcode;
  char * pBuffer;
  int ByteCount, MsbBit, BitMask, i;

  if(BitSize <= 0)				// no bits requested
    return(LNUM_OP_ZERO_SIZE);
  //------------------------------------------------------------
  // calculate Byte requirement for buffer, allocate
  //------------------------------------------------------------
  ByteCount = (BitSize+7)/8;			// calculate required bytes
  MsbBit = BitSize % 8;				// get number of MSB (rel. 0)
  if((pBuffer = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ByteCount)) == NULL)
    return(LNUM_OP_ALLOC_ERR);			// exit
  //------------------------------------------------------------
  // get random number
  // NOTE: the random number will be interpreted as BIG ENDIAN
  //------------------------------------------------------------
// NOTE: New Random generator used
//  printf("\r\nGetting Random Bytes");
  Retcode = SecDrbgRandBytes(HMEM_CTX_REF1 pBuffer,0,ByteCount);

  if(Retcode != 0)
  {
    FREE_CARRAY(HMEM_CTX_REF,pBuffer);
    return(Retcode);
  }
//  printf("\r\nGot Random Bytes");
  //------------------------------------------------------------
  // check if odd number is requested
  //------------------------------------------------------------
  if(OddFlag != 0)				// odd number requested
    pBuffer[ByteCount-1] |= 1;			// set odd (BIG ENDIAN order !)
  //------------------------------------------------------------
  // check if top most bits should be set to 1
  //------------------------------------------------------------
  if(MsbBit == 0)				// no bits to mask off
    BitMask = 0xFF;
  else						// generate mask
    BitMask = ~(0xFF << MsbBit);

  pBuffer[0] = (unsigned char) (pBuffer[0] & BitMask);// mask off non required bits

  if(TopFlag != 0)				// must set topmost bits
  {
    if(MsbBit == 0)				// full byte, no mask off
      pBuffer[0] |= 0xC0;			// set topmost bits
    else
    {
      if(MsbBit == 1)				// special case
      {
        pBuffer[0] = 1;				// set bit
        pBuffer[1] |= (unsigned char) 0x80;	// dto.
      }
      else
      {
        pBuffer[0] = (unsigned char)
          (pBuffer[0] | (3 << (MsbBit-2)));	// set topmost bits
      }
    }
  }
  else
  {
    if(MsbBit == 0)				// full byte, no mask off
      pBuffer[0] |= (unsigned char) 0x80;	// set topmost bit
    else
    {
      pBuffer[0] = (unsigned char)
        (pBuffer[0] | (1 << (MsbBit-1)));	// set topmost bit
    }
  }
  //------------------------------------------------------------
  // convert random number to long number representation
  //------------------------------------------------------------
//  printf("\r\nConverting to large number");

#if 0
  PRINT("ByteCnt: ");
  PRINT_INT_NL(ByteCount);
#endif

  i = WLnum_bin2wlnum(HMEM_CTX_REF1 pRnd, pBuffer, 0, ByteCount);
//  printf("\r\nConverted to large number");
  do
  {
    ByteCount--;			// predecrement
    pBuffer[ByteCount] = 0;		// clear
  }while(ByteCount != 0);
  FREE_CARRAY(HMEM_CTX_REF,pBuffer);
  return(i);
}
//==============================================================
// Subroutine ModWordWLnum calculates the remainder of
// a Wlarge number for a given 16 Bit Modulus
//
// Input parameters: WLNUM * pWnumU	Large Number Struc.
//		     short   Modulus	given modulus
// Returns: int Rem	   Remainder/Errorflag
//			   if < 0 Error occured
//			   if >=0 Remainder in low word
//==============================================================
int FAST ModWordWLnum(WLNUM * pWnumU, short Modulus)
{
  int i, d;
  int uH, uL, w, ML, SL, Rem;
  int v = (int) Modulus & 0xFFFF;
  int * pEl;

  if(pWnumU == NULL)
    return(-1);
  //----------------------------------------------------------
  // check for zero divisor, by definition x mod 0 = x
  //----------------------------------------------------------
  if(Modulus == 0)				// out of range
    return(LNUM_OP_ZERO_DIV);
  if(IsZeroWLnum(pWnumU) != 0)			// 0 mod n = 0
    return(0);
  //------------------------------------------------------------
  // Normalize the Divisor to Base 16
  //------------------------------------------------------------
  d = 16 - HardGetBitCntWLnumElem(v);		// get normalize shift
  v = v << d;					// normalize Divisor
  //-------------------------------------------------------------
  // Get the BIT32 Dividend Elements normalize Shift Counts/Masks
  //-------------------------------------------------------------
  SL = (32-d) & 0x1F;				// Dividend Low right(!) shift
  ML = 0;					// assume no bits to shift
  if(SL != 0)					// must propagate bits !
  {
    ML = ~((int) 0x80000000 >>(31-d)); // Dividend Low  AND mask
  }

#if 0
  PRINT("MD:ShiftCnt = ");
  PRINT_INT(d);
  PRINT(" , Mask = ");
  PRINT_HEX_BIT32_NL(ML);
#endif
  //-------------------------------------------------------------
  // Initialize Operation
  //-------------------------------------------------------------
  pEl = pWnumU->lpEl;
  uL = 0;
  Rem = 0;
  //-----------------------------------------------------------------
  // Calculate the remainder
  //-----------------------------------------------------------------
  if(d == 0)					// special case, full elements
  {
    i = pWnumU->UsedSize;			// should not be zero
    do
    {
      i--;					// predecrement, use as index
      w = pEl[i];				// get next BIT32 Element
#if !defined LNUM32_USE_INT64
      Rem = NormDiv32By16Emul32((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Emul32((Rem << 16) | (w & 0xFFFF), v, NULL);
#else
      Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
#endif
    }while(i != 0);
  }
  else
  {
    //-----------------------------------------------------------------
    // Dividend smaller than 16 bit
    //-----------------------------------------------------------------
    i = pWnumU->UsedSize;			// should not be zero
    do
    {
      i--;					// predecrement, use as index
      uH = uL;
      uL = pEl[i];				// get next BIT32 Element
      w = (uH << d) | ((uL >> SL) & ML);	// combine to normalized Divid.
#if !defined LNUM32_USE_INT64
      Rem = NormDiv32By16Emul32((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Emul32((Rem << 16) | (w & 0xFFFF), v, NULL);
#else
      Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
      Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
#endif
    }while(i != 0);
    //-----------------------------------------------------------------
    // Post-Process remaining Element if any, renormalize
    //-----------------------------------------------------------------
    w = (uL << d);				// combine to normalized Divid.
#if !defined LNUM32_USE_INT64
    Rem = NormDiv32By16Emul32((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
    Rem = NormDiv32By16Emul32((Rem << 16) | (w & 0xFFFF), v, NULL);
#else
    Rem = NormDiv32By16Bit64((Rem << 16) | ((w >> 16) & 0xFFFF), v, NULL);
    Rem = NormDiv32By16Bit64((Rem << 16) | (w & 0xFFFF), v, NULL);
#endif
    Rem = (Rem >> d);				// re-normalize
  }
  return(Rem & 0x0000FFFF);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Prime Generation routines, only used for KEY Generation !!
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

// NOTE: The quick sieve algorithm approach to weeding out primes is
// ----  Philip Zimmermann's, as implemented in PGP.


//#define	WRND_BITS_LIMIT		255	// for Miller Rabin test
//#define	WRND_BITS_LIMIT	64	// for Miller Rabin test
#define	WRND_BITS_LIMIT	32	// for Miller Rabin test
//#define WSMALL_PRIME_CNT	1000	// small numbers < 2000, suggested
#define WSMALL_PRIME_CNT	302	// small numbers < 2000, suggested
					// by B.SCHNEIER
//#define WCHECK_ROUNDS	6		// count for Miller/Rabin test
//					// suggested by B.SCHNEIER
//#define	WCHECK_ROUNDS	10	// count for Miller/Rabin test (better)
//					// NOW: derived from bitcount !!!

//==============================================================
// Sieve of Eratosthenes for pre-calculation of 'small' prime
// numbers. Algorithmus taken from D.E. Knuth Vol. II, 4.5.4,
// solution of exercise 8 (slightly modified).
//
// NOTE: a) Maximal requested number count is limited to 6552.
//       b) The estimate for N = 2*M for lower requested number
//	    counts than 128 is approx. 2 times too large.
//	    (But there is no way to predict primal number
//	     distribution at all up to now)
//       c) The first prime number generated is 3 !! (not 2)
//
//
// Input parameters:	short * pPrimesArr	Prime Number array to load
//			int    MaxNums	 	max. number count requested
// Returns: int PrimeCnt	 > 0 numbers stored
//				== 0 helper field alloc failure
//				 < 0 number count too high
//==============================================================
int FAST DoEratosthenesWSieve(HMEM_CTX_DEF short * pPrimesArr, int MaxNums)
{
  char BitMask = (char) ((unsigned char) 0x80);
  char BitMaskHlp;

  char * pBitFieldBuf;

  int	PrimeCnt=0;				// counter and index !!
  int	NumberRange;

  int	i,k;
  int   MaxRange;
  int	HelpSize;

  int	j=0;					// S1: Initialisation
  int	p=3;					// dto.
  int	q=4;					// dto.
  //------------------------------------------------------------
  // Calculate approx. required Number-Range M = N/2
  //------------------------------------------------------------
  NumberRange = ((int) MaxNums ) * 5;		// times 10/2
  if(NumberRange >= 0x8000)			// is too large
    return(-1);
  MaxRange = (int) (NumberRange & 0xFFFF);	// M
  HelpSize = (int) ((NumberRange + 7) >> 3);	// required Bytes
  //------------------------------------------------------------
  // S1: Allocate Helper-Bitfield and preload with all ones
  //------------------------------------------------------------
  if((pBitFieldBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,HelpSize)) == NULL)
    return(0);					// allocate failure
  i = HelpSize;
  do
  {
    i--;					// predecrement, use as index
    pBitFieldBuf[i] = (char) ((unsigned char) 0xFF);	// load value
  }while(i != 0);
  //------------------------------------------------------------
  // Start algorithm (note: 0 <= k < M)
  //------------------------------------------------------------
  i = 0;					// index to bottom
  do
  {
    //----------------------------------------------------------
    // S2: Check if bit set; if so, number is prime
    //----------------------------------------------------------
    if((pBitFieldBuf[i] & BitMask) != 0)	// found prime number
    {
      pPrimesArr[PrimeCnt] = (short) p;		// save prime number
      PrimeCnt++;
      if(PrimeCnt >= MaxNums)			// Table is full
      {
        FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
        return(PrimeCnt);
      }
      //--------------------------------------------------------
      // S3: Zero out related bits
      //--------------------------------------------------------
      k = q-1;					// Bit Startindex
      do
      {
        BitMaskHlp =
          (char) ((int) 0x80 >> (k & 0x07));	// get bit mask
        pBitFieldBuf[k >> 3] = (unsigned char)
          (pBitFieldBuf[k >> 3] & ~BitMaskHlp);	// zero bit
        k += p;
      } while(k < MaxRange);
    }
    //----------------------------------------------------------
    // S4: to next, recalculate, advance bitmask
    //----------------------------------------------------------
    BitMask = (char) ((BitMask >> 1) & 0x7F);	// to next Bitmask
    if(BitMask == 0)
    {
      BitMask = (char) ((unsigned char) 0x80);
      i++;
    }
    j++;
    p += 2;
    q += 2*(p-1);
  } while(q < MaxRange);
  //------------------------------------------------------------
  // S5: check if more bits are set to one
  //------------------------------------------------------------
  while(j < MaxRange)
  {
    if((pBitFieldBuf[i] & BitMask) != 0)		// found number
    {
      pPrimesArr[PrimeCnt] = (short)((2*j) + 3);	// save number
      PrimeCnt++;
      if(PrimeCnt >= MaxNums)			// Table is full
      {
        FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
        return(PrimeCnt);
      }
    }
    BitMask = (char) ((BitMask >> 1) & 0x7F);	// next Bitmask
    if(BitMask == 0)
    {
      BitMask = (char) ((unsigned char) 0x80);
      i++;
    }
    j++;
  }
  FREE_CARRAY(HMEM_CTX_REF,pBitFieldBuf);
  return(PrimeCnt);
}

//===================================================================
// WLnumMillerRabin does Miller-Rabin checks for a Wlarge
// number n. For description of Algorithm see D.E.Knuth
// (Factoring into primes, Algorithm P) and B. Schneier (11.4,
//  factoring)
// NOTE: uses 3+4 +36 CTX Elements
// -----
//
// 1. Calculates the exponent q and the loopcount k.
//    Given n = 1 + 2**k * q => n-1 = 2**k *q, we get the
//    exponent q by shifting right n-1 until the result is odd
//    and counting the shifts yields k.
//
// 2. Get a random number a,  1 < a < n. To speed up calculations
//    limit the number of bits to min(16?? or 32??, bits(n) - 1)
//
// 3. Calculate x = (a ** q) mod n. If result is 1 or -1 (= n-1),
//    number may be prime, do next check if requested.
//
// 4. If k was 1, number is definitely *NOT* prime, terminate.
//
// 5. Setup loop count to k-1.
//
// 6. calculate x = (x ** 2) mod n, do decision:
//    if result is 1, number is definitely *NOT* prime,
//    --> terminate.
//    if result is -1 (= n-1) number may be prime, do next
//    check if requested; if all checks done number is probably
//    prime, terminate.
//
// 6. Decrement k. if k == 0 terminate, number is definiteley
//    *NOT* prime. (if so it had terminated in the last step)
//
//
// Input parameters: WLNUM * pWnumN     Number n to check
//		     int CheckCount	count of checks to perform
//		     int * pResult  	 != 0 definitely not prime
//					 == 0 probable prime
//		     WLNUM_CTX * pCtx   Large Number Workspace / NULL
//		     void callback(int)	Function for periodic call/NULL
// Returns: int Status, 0 - o.k., else error occured
//===================================================================
int FAST WLnumMillerRabin(HMEM_CTX_DEF
			  WLNUM * pWnumN, int CheckCount,
			  int * pResult, WLNUM_CTX * pCtx,
			  void callback(int))
{
  int i,j,k;

  int RndBits;				// bitcount for random number
  int ElementCnt;			// elements used in number n
  int Retcode = LNUM_OP_OK;		// assume o.k.
  int CheckStat = 0;			// probable prime, <>0 not.
  int WLnumReleaseCnt = 0;


  WLNUM * pWnm1 = NULL;			// n - 1
  WLNUM * pWrnd = NULL;			// random a
  WLNUM * pWx   = NULL;			// a ** q etc.
  WLNUM * pWres = NULL;			// temporary result

  WLNUM * pWtmp;			// needed for reference swap

  WLNUM ** pNumArr;
  WLNUM_CTX * pTmpCtx = NULL;

  int Elu;
  int u;
  int * pEl;
  //-----------------------------------------------------------
  // assure that we do at least one check !
  //-----------------------------------------------------------
  if(CheckCount <= 0)
    CheckCount = 1;			// at least one check needed
  //-----------------------------------------------------------
  // for easier error processing we use an indefinite FOR loop
  //-----------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------
    // check that number n is odd
    //-----------------------------------------------------------
    ElementCnt = pWnumN->UsedSize;		// get elementcount
    u = pWnumN->lpEl[0];			// get the LSB Element
    if(((u & 0x01) == 0) ||			// 'even' prime !!
       ((ElementCnt == 1) &&
        ((u & 0xFFFFFF00) == 0) && (u < 3)))		// too small
    {
//      if((u & 0x01) == 0)				// TEST TEST TEST
//        PRINT("\nMILLER RABIN: Number not odd");	// TEST TEST TEST
//      else						// TEST TEST TEST
//        PRINT("\nMILLER RABIN: Number too small");	// TEST TEST TEST
      Retcode = LNUM_OP_INVALID_PRIME;
      break;
    }
    //---------------------------------------------------------
    // get required bitsize for random number
    //-----------------------------------------------------------
    i = ElementCnt-1;				// topmost used
    j = HardGetBitCntWLnumElem(pWnumN->lpEl[i])+ (32*i);
    RndBits = j-1;				// set for random gen.
    if(RndBits > WRND_BITS_LIMIT)		// shrink if necessary
      RndBits = WRND_BITS_LIMIT;
    //---------------------------------------------------------
    // allocate required large numbers
    // NOTE: Take from CTX structure !!!
    //---------------------------------------------------------
    i = ElementCnt+1;				// required size + 1
    if(pCtx == NULL)				// no context given
    {
//      PRINT("MR:Alloc Context, WLNUM-Size: ");
//      PRINT_INT_NL(i);

      if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3+4+36, i)) == NULL)
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      pNumArr = pTmpCtx->pWLnumArr;
      pWnm1 = pNumArr[0];
      pWrnd = pNumArr[1];
      pWx   = pNumArr[2];
      pWres = pNumArr[3];
      pTmpCtx->NextFreeIndex = 4;
      pCtx = pTmpCtx;
    }
    else					// context is given, check size
    {
      j = pCtx->NextFreeIndex;
      if((j + 3+4+36) >= pCtx->AllocedNumCnt)
      {
        Retcode = LNUM_OP_CTX_FULL;
        break;
      }
      pWnm1 = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWrnd = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWx   = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      pWres = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
      if((pWnm1 == NULL) || (pWrnd == NULL) ||	// allocation failure
         (pWx   == NULL) || (pWres == NULL))
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      WLnumReleaseCnt = 4;
    }
    //-----------------------------------------------------------
    // 1. get n-1, q and loopcount k
    //-----------------------------------------------------------
    if((Retcode = CopyWLnum(HMEM_CTX_REF1
			    pWnm1,pWnumN)) != LNUM_OP_OK) // copy n -> n-1
      break;
    pWnm1->lpEl[0] = (pWnm1->lpEl[0] & 0xFFFFFFFE); // subtract one (was odd !!)

    if((Retcode = CopyWLnum(HMEM_CTX_REF1
			    pWres,pWnm1)) != LNUM_OP_OK) // copy (n-1) -> x
      break;
    //----------------------------------------------------------
    // search for first Element not zero to get shift count
    // NOTE: There MUST be at least one element !!
    // -----
    //----------------------------------------------------------
    pEl = pWres->lpEl;
    k = 0;					// clear shiftcount
    i = 0;					// startindex
    for(;;)					// search non zero element
    {
      if(pEl[i] != 0)
        break;
      k += 32;					// one element more
      i++;
    }

    Elu = pWres->lpEl[i];			// get element
    for(;;)
    {
      if((Elu & 0x01) != 0)			// non zero bit found
        break;
      Elu = (Elu >> 1) & 0x7FFFFFFF;		// to next bit-->optimize!!
      k++;					// increment count
    }
#if 0
    PRINT("MR:ShiftCount k = ");
    PRINT_INT(k);
    PRINT(", Full ElementCount i = ");
    PRINT_INT_NL(k);
#endif

//    PRINT("MR:WRes before normalize shift: ");
//    ShowLnum(pWres);
    if((Retcode = RshiftWLnum(HMEM_CTX_REF1
			pWres,pWres,k)) != LNUM_OP_OK) // normalize q
      break;
//    PRINT("MR:WRes after normalize shift: ");
//    ShowLnum(pWres);
    //===========================================================
    // Check loop
    //===========================================================
//    PRINT("R-Checkloop enter..");
    do
    {
      //---------------------------------------------------------
      // 2. Get Random number
      //---------------------------------------------------------
      if((Retcode = WLnumRand(HMEM_CTX_REF1 pWrnd, RndBits,0,0)) != LNUM_OP_OK)
        break;					// leave inner loop
//      PRINT("MR: Wnm1 = ");
//      ShowLnum(pWnm1);
      //---------------------------------------------------------
      // 3. Calculate a ** q mod n, check if result is 1 or -1;
      //    if so -> probably prime
      //---------------------------------------------------------
//    PRINT("Expmod enter..");

#if 0
      PRINT("MR:ExpmodIn: Wrnd (a) = ");
      ShowLnum(pWrnd);
      PRINT("MR:ExpmodIn: Wres (q) = ");
      ShowLnum(pWres);
      PRINT("MR:ExpmodIn: WnumN (N) = ");
      ShowLnum(pWnumN);
#endif

      Retcode = ExpModWLnum(HMEM_CTX_REF1
			    pWx, pWrnd, pWres, pWnumN, pCtx, callback);

//    PRINT_NL("  Expmod left");

#if 0
    PRINT("MR:ExpMod Wx = Wrnd**WRes mod(Wnum): ");
    ShowLnum(pWx);
#endif

      if(Retcode != LNUM_OP_OK)			// leave check loop
        break;
      if((IsOneWLnum(pWx) != 0) ||			// is 1
         (UcompWLnum(pWx, pWnm1) == WLNUM_1ST_EQ_2ND))	// is -1
      {
//      PRINT("-Might be prime-");
        CheckCount--;
	if(callback != NULL)
          callback(1);
        continue;				// may be prime
      }
      //-------------------------------------------------------
      // 4. initialize inner test loopcount, check if <> 0
      //    if count  i s  0 -> not prime
      //-------------------------------------------------------
      i = k-1;					// set loopcnt
      if(i == 0)
      {
//      PRINT_NL("NotPrime1");
        CheckStat = 1;				// not prime
        break;					// exit
      }
      do
      {
        //-----------------------------------------------------
        // 5. Calculate x = (x ** 2) mod n, decide on result
        //-----------------------------------------------------
#if 0
        PRINT("Wx = ");
        ShowLnum(pWx);
#endif

        if((Retcode = MulModWLnum(HMEM_CTX_REF1
			pWres,pWx,pWx,pWnumN,pCtx)) != LNUM_OP_OK)
          break;
#if 0
        PRINT("(Wx * Wx) mod Wnum = ");
        ShowLnum(pWres);
#endif

        if(IsOneWLnum(pWres) != 0)		// = 1, not prime
        {
//        PRINT_NL("NotPrime2");
          CheckStat = 1;			// set  n o t  prime
          break;
        }
        if(UcompWLnum(pWres,pWnm1) == WLNUM_1ST_EQ_2ND) // = -1
          break;				// further checking if req.

        pWtmp = pWx;				// exchg. lpres <-> lpx
        pWx   = pWres;
        pWres = pWtmp;
        i--;
      }while(i != 0);			
      //-----------------------------------------------------
      // check if all k loops processed, if so, not prime
      //-----------------------------------------------------
      if(Retcode != LNUM_OP_OK) break;// error occured, exit check loop
      if(CheckStat != 0) break;	// not prime found, exit check loop
      if(i == 0)
      {
        CheckStat = 1;		// set  n o t  prime
//      PRINT("NotPrime3");
        break;			// exit outer check loop
      }
      CheckCount--;			// reduce counter
      if(callback != NULL)
        callback(1);
    }while(CheckCount > 0);
    //-----------------------------------------------------------
    // all checks processed / Error occured / not prime stated
    //-----------------------------------------------------------
    break;				// exit for loop
  } // outmost FOR loop
  //-----------------------------------------------------------
  // report result, free allocated buffers
  //-----------------------------------------------------------
  if(Retcode != LNUM_OP_OK)		// we had an error
  {
//    PRINT("Miller Rabin Retcode: ");
//    PRINT_INT_NL(Retcode);
    pResult[0] = 1;			// force not prime
  }
  else
    pResult[0] = CheckStat;		// report true state

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//==============================================================
// Subroutine GetWPrimeCandidate fetches a random number and checks
// that it could be prime by sieving out small prime factors using
// a quick sieve algorithm.i
// NOTE: No checking for strong primality or special diffie hellman
// ----- requirements is done.
//
// Input Parameters: 	WLNUM *   pW		large number struct pointer
//			int	  Bits		number of random bits to use
//			int	  Strong	!= 0 strong prime (Bit 1 = 1)
//			short *   PrimArray	small primes array
//			int	  PrimCnt	max number of small primes
//						in the small prime array
//			short *   ModArray	Array for Modulus calculation
//			int	  DeltaStart	Start for Delta
//			int	  DeltaMax	Upper Limit for Delta
// Returns: int Status / Current Delta if >= 0
//==============================================================
static int FAST GetWPrimeCandidate(HMEM_CTX_DEF
			WLNUM * pW, int Bits, int Strong,
			short * PrimeArray, int PrimeCnt,
			short * ModArray, int DeltaStart, int DeltaMax)
{
  int i;
  int Retcode = 0;
  int RetryCnt = 0;
  int l;
  int delta=DeltaStart;		// increment to next trial num.
  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop
  //-----------------------------------------------------------------
  for(;;)
  {
    if(delta == 0)
    {
      DeltaStart = 0;
      //--------------------------------------------------------------
      // Get a random number to start generation, preload sieve values
      //--------------------------------------------------------------
#if 0
      PRINT("\nGetting Random, BitCnt: ");
      PRINT_INT(Bits);
#endif
      Retcode = WLnumRand(HMEM_CTX_REF1
			  pW, Bits, 1, 1);	// get random WLnum, odd/topset
#if 0
      PRINT(" Got Random: ");
      ShowLnum(pW);
#endif
      if(Retcode != LNUM_OP_OK)
        break;
      if(Strong != 0)
        pW->lpEl[0] |= 0x02;			// to avoid (p-1)/2 to be even


      i = PrimeCnt;
      do
      {
        i--;					// predecrement, use as index
        l = ModWordWLnum(pW, PrimeArray[i]);	// get p mod (prime)
        if( l < 0)
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;					// leave inner loop
        }
        ModArray[i] = (short) l;			// save modulus
      }while(i != 0);
      if(Retcode != LNUM_OP_OK)
        break;					// we had an error
    }
    else					// delta from last, advance
    {
      if(Strong == 0)
        delta += 2;
      else
        delta += 4;
    }
    //--------------------------------------------------------
    // now check pW for possible primality using small primes,
    // if p not prime modify p using the addition increment
    //--------------------------------------------------------
//    PRINT_NL("Check small primes... ");
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked);
      // this is done using a simple modulo operation
      //------------------------------------------------------
      i = 0;
      do
      {
        if(((delta + ((int) ModArray[i] & 0xFFFF)) %
            ((int) PrimeArray[i] & 0xFFFF)) <= 1) // not a prime
          break;
        i++;					// to next index
      }while(i < PrimeCnt);
      if(i == PrimeCnt)				// all test passed
      {
        RetryCnt = -1;
#if 0
        PRINT_NL(" Small primes checked, Prime before Element add: ");
        ShowLnum(pW);
        PRINT("Element to add: ");
        PRINT_HEX_BIT32_NL(delta-DeltaStart);
#endif

#if !defined LNUM32_USE_INT64
        Retcode = AddElementWLnumEmul32(HMEM_CTX_REF1
			pW,delta-DeltaStart);// generate number
#else
        Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
			pW,delta-DeltaStart);// generate number
#endif

#if 0
        PRINT_NL(" Prime after Element add: ");
        ShowLnum(pW);
#endif
	RetryCnt = -1;
        break;					// exit loop
      }
      else					// not a prime
      {
        if(Strong == 0)
          delta += 2;				// to next number
        else
          delta += 4;				// keep Bit 1 set !

        if(delta <= DeltaMax)			// just advance
          continue;				// do small prime check
#if 0
        PRINT(" Delta: ");
        PRINT_HEX_BIT32(delta);
        PRINT("DeltaMax: ");
        PRINT_HEX_BIT32(DeltaMax);
        PRINT(" ");
#endif

        RetryCnt++;
        delta = 0;
//      PRINT("R");
        break;
      }
    } // Prime Check loop
    if(RetryCnt < 0)				// got a prime/error
      break;
    if(RetryCnt > 10)
    {
      Retcode = LNUM_OP_INVALID_PRIME;		// set error
      break;
    }
  }
  if(Retcode == LNUM_OP_OK)			// without error
    Retcode = (int) delta;

#if 0
  PRINT_NL("Exit get candidate, Prime is:");
  ShowLnum(pW);
#endif
  return(Retcode);
}
//====================================================================
// Subroutine GetWPrimeCandidate_DH fetches a random number and checks
// that it could be prime by sieving out small prime factors using
// a quick sieve algorithm, no checking for strong primes is done,
// but Diffie-Hellman Generator requirements are observed
//
// NOTE: 1. only special Diffie / Hellman generators may be used (3,7) !
// ----- 2. uses 1 + 2 CTX Elements
//
// Input parameters: WLNUM *   pWLnum		large number struct pointer
//		     int       Bits		number of random bits to use
//		     WLNUM *   pAdd 		distance to add to random
//		     WLNUM *   pRem		remainder for additional test:
//						  (p) mod add = rem
//		     short *   PrimeArray	small primes array
//		     int       PrimeCnt		max number of small primes
//						in the small prime array
//		     WLNUM_CTX * pCtx		Context for WLNUMs/NULL
// Returns: int Status, 0 - o.k., else Error occured
/*==============================================================*/
static int FAST GetWPrimeCandidate_DH(HMEM_CTX_DEF
		WLNUM * pWLnum, int Bits,
		WLNUM * pAdd, WLNUM * pRem,
		short * PrimeArray, int PrimeCnt, WLNUM_CTX * pCtx)
{
  int i,j, Retcode;
  int WLnumReleaseCnt = 0;

  int l;

  WLNUM * pTmp = NULL;
  WLNUM_CTX * pTmpCtx = NULL;
  //-----------------------------------------------------------------
  // allocate temporary number structure
  //-----------------------------------------------------------------
  i = (Bits + 32-1) / 32 + 1; // get Element count needed
  if(pCtx == NULL)				// no context
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 1+2, i)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pTmp = pTmpCtx->pWLnumArr[0];
    pTmpCtx->NextFreeIndex = 6;
    pCtx = pTmpCtx;
  }
  else						// context given
  {
    j = pCtx->NextFreeIndex;
    if((j + 1+2) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);
    if((pTmp = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    WLnumReleaseCnt = 1;
  }
  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop
  //-----------------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------
    // get odd random number
    //---------------------------------------------------
    if((Retcode = WLnumRand(HMEM_CTX_REF1 pWLnum, Bits, 0, 1)) != LNUM_OP_OK)
      break;
    //---------------------------------------------------
    // adjust odd random to satisfy pWLnum mod pAdd = pRem:
    // 1. r = p - p mod add -> r mod add = 0 i.e. r = k * add;
    //    since add is always even, r will be even too
    // 2. p' = r + rem -> s mod add = (k*add + rem) mod add =
    //    (k*add) mod add + (rem) mod add = 0 + rem = rem
    //    so p' satisfies ganerator condition and since
    //    r is even and rem is always odd p' will also be odd !
    //---------------------------------------------------
    if((Retcode = ModWLnum(HMEM_CTX_REF1
		    pTmp, pWLnum, pAdd, pCtx)) != LNUM_OP_OK) // tmp = p mod a
      break;

    if((Retcode = SubWLnum(HMEM_CTX_REF1
			pWLnum,pWLnum,pTmp)) != LNUM_OP_OK) //p=p- p mod a (Rest)
      break;

    if(pRem == NULL)				// assume rem = 1
    {
#if !defined LNUM32_USE_INT64
      Retcode = AddElementWLnumEmul32(HMEM_CTX_REF1
				      pWLnum,1);// p=(p - p mod a)+1
#else
      Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				     pWLnum,1);// p=(p - p mod a)+1
#endif
      if(Retcode != LNUM_OP_OK) break;
    }
    else
    {
      Retcode = AddWLnum(HMEM_CTX_REF1
			 pWLnum,pWLnum,pRem);// p = (p - p mod a) + rem
      if(Retcode != LNUM_OP_OK) break;
    }
    //--------------------------------------------------------
    // now check p for possible primality using small primes,
    // if p not prime modify p using the addition increment
    //--------------------------------------------------------
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked)
      // this is done using mod operation
      //------------------------------------------------------
      i = 0;
      do
      {
        l = ModWordWLnum(pWLnum,PrimeArray[i]);	// p mod (prime) must be > 1 ??
        if(l < 0)
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;				// leave inner loop
        }
        if(l <= 1)				// not prime, get next
        {
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pWLnum,pWLnum,pAdd);// use given increment for p
          break;				// must retry / leave on error
        }
	i++;					// to next prime number
      }while(i < PrimeCnt);
      if(i == PrimeCnt) break;			// all test passed, leave loop
      if(Retcode != LNUM_OP_OK) break;		// error occured
    } // retry processing FOR-Loop
    break;					// exit outmost loop
  } // Error FOR

  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//==============================================================
// Subroutine GetWPrimeCandidate_DH_Strong fetches a random number
// and checks that it could be prime by sieving out small prime
// factors using a quick sieve algorithm, checks for strong primes
// and Diffie-Hellman Generator requirements.
//
// NOTE: 1. only special Diffie / Hellman generators may be used (3,7) !
// ----- 2. uses 3+2 CTX Elements
//
// Input Parameters: WLNUM *   pWLnum		large number struct pointer
//		     int       Bits		number of random bits to use
//		     WLNUM *   pAdd 		distance to add to random
//		     WLNUM *   pRem		remainder for additional test:
//						  (p) mod add = rem
//		     short *   PrimeArray	small primes array
//		     int       PrimeCnt		max number of small primes
//						in the small prime array
//		     WLNUM_CTX * pCtx		Context for WLNUMs/NULL
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST GetWPrimeCandidate_DH_Strong(HMEM_CTX_DEF
	  WLNUM * pWLnum, int Bits, WLNUM * pAdd, WLNUM * pRem,
	  short * PrimeArray, int PrimeCnt, WLNUM_CTX * pCtx)
{
  int i,j;
  int Retcode;
  int WLnumReleaseCnt = 0;

  int l1,l2;

  WLNUM * pQ;
  WLNUM * p2Add;
  WLNUM * pTmp;
  WLNUM ** pNumArr;

  WLNUM_CTX * pTmpCtx = NULL;
  //-----------------------------------------------------------------
  // allocate temporary number structures
  //-----------------------------------------------------------------
  i = (Bits + 32-1) / 32 + 1;			// get Element count
  if(pCtx == NULL)				// no context given
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 3+2, i)) == NULL)
      return(LNUM_OP_ALLOC_ERR);
    pNumArr = pTmpCtx->pWLnumArr;
    pQ    = pNumArr[0];
    p2Add = pNumArr[1];
    pTmp  = pNumArr[2];
    pTmpCtx->NextFreeIndex = 3;
    pCtx = pTmpCtx;
  }
  else						// context is given, check size
  {
    j = pCtx->NextFreeIndex;
    if((j + 3+2) >= pCtx->AllocedNumCnt)
      return(LNUM_OP_CTX_FULL);

    pQ    = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    p2Add = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    pTmp  = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i);
    if((pQ == NULL) || (p2Add == NULL) ||	// allocation failure
       (pTmp == NULL))
      return(LNUM_OP_ALLOC_ERR);

    WLnumReleaseCnt = 3;
  }
  //-----------------------------------------------------------------
  // for easier error processing we use an outer for loop
  //-----------------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------------
    // a strong prime satisfies the condition p = 2*q + 1 where
    // q is also prime. we generate q first and derive p from it.
    // For the known generators the following conditions
    // p mod 24 = 11, generator = 2  or
    // p mod 10 = 3 or 7, generator = 5 must hold.
    // for q this implies: q mod 24 = 5 or  q mod 10 = 1 or 3 must hold,
    // i.e. the modulus and the INT(remainder/2) is taken for q
    // generation so p will necessarily satisfy the conditions
    // proof: given q mod add = (rem-1)/2 with 'add'even, (rem-1)/2 odd
    //        1. q will be odd as q = k*add + (rem-1)/2
    //        2. p = 2 * q + 1 = 2*k*add + 2*(rem-1)/2 + 1 = 2*k*add + rem
    //           so p mod add = (2*k*add + rem) mod add =
    //		   ((2*k*add) mod add + rem mod add) mod add =
    //		   ( 0 + rem) mod add = rem q.e.d
    //---------------------------------------------------------------
    Bits--;					// 1 bit less (q is half of p)


    Retcode = Lshift1WLnum(HMEM_CTX_REF1
			   p2Add,pAdd);		// get addition value for p
    if(Retcode != LNUM_OP_OK) break;

    Retcode = WLnumRand(HMEM_CTX_REF1		// get an odd random q
			pQ, Bits, 0, 1);
    if(Retcode != LNUM_OP_OK) break;


    /* we need ((rnd-rem) % add) == 0 to satisfy DH generator requirements */

    Retcode = ModWLnum(HMEM_CTX_REF1
		       pTmp, pQ, pAdd, pCtx);	// tmp = q mod a
    if(Retcode != LNUM_OP_OK) break;

    Retcode = SubWLnum(HMEM_CTX_REF1
			 pQ,pQ,pTmp);		// q = q - q mod a
    if(Retcode != LNUM_OP_OK) break;

    if(pRem == NULL)				// assume rem = 1
    {
#if !defined LNUM32_USE_INT64
      Retcode = AddElementWLnumEmul32(HMEM_CTX_REF1
				      pQ,1);	// q = q + 1;
#else
      Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				     pQ,1);	// q = q + 1;
#endif
      if(Retcode != LNUM_OP_OK) break;
    }
    else
    {
      Retcode = Rshift1WLnum(HMEM_CTX_REF1
			     pTmp,pRem);	// tmp = (rem-1)/2
      if(Retcode != LNUM_OP_OK) break;
      Retcode = AddWLnum(HMEM_CTX_REF1
			 pQ,pQ,pTmp);		// q = q + (rem-1)/2
      if(Retcode != LNUM_OP_OK) break;
    }
    //---------------------------------------------------------
    // calculate number p from q
    //---------------------------------------------------------
    Retcode = Lshift1WLnum(HMEM_CTX_REF1
			   pWLnum,pQ);		// p = 2 * q
    if(Retcode != LNUM_OP_OK) break;

#if !defined LNUM32_USE_INT64
    Retcode = AddElementWLnumEmul32(HMEM_CTX_REF1
				    pWLnum,1);	// p = 2q + 1
#else
    Retcode = AddElementWLnumBit64(HMEM_CTX_REF1
				   pWLnum,1);	// p = 2q + 1
#endif
    if(Retcode != LNUM_OP_OK) break;
    //--------------------------------------------------------
    // now check p,q for possible primality using small primes,
    // if p,q not prime modify p,q using the addition increment
    //--------------------------------------------------------
    for(;;)
    {
      //------------------------------------------------------
      // weed out small prime numbers (2 is not checked !)
      // this is done using mod operation
      //------------------------------------------------------
      i = 0;
      do
      {
        l1 = ModWordWLnum(pWLnum,PrimeArray[i]);// p mod (prime) must be <> 0
        l2 = ModWordWLnum(pQ,PrimeArray[i]);	// q mod (prime) must be <> 0
        if((l1 < 0) || (l2 < 0))
        {
          Retcode = LNUM_OP_ZERO_DIV;		// out of range
          break;				// leave inner loop
        }
        if((l1 == 0) || (l2 == 0))		// not prime, get next
        {
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pWLnum,pWLnum,p2Add);// use increment for p
          if(Retcode != LNUM_OP_OK) break;	// leave inner loop
          Retcode = AddWLnum(HMEM_CTX_REF1
			     pQ,pQ,pAdd);	// use given increment
          break;				// must retry / leave on error
        }
	i++;					// to next prime number
      }while(i < PrimeCnt);
      if(i == PrimeCnt) break;			// all test passed, leave loop
      if(Retcode != LNUM_OP_OK) break;		// error occured
    } // retry processing FOR-Loop
    break;					// exit outmost loop
  }
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}
//==============================================================
// Generate a prime number p of given size.
// If Diffie-Hellman prime generation is requested, the prime
// will satisfy the condition (g ** a) mod p = b for all
// 1 <= b < p where g is a given generator.
// If a strong prime is requested (Diffie-Hellman only,
// (p-1)/2 is also prime) a check for stong prime is done.
//
// Note: uses 8+1 CTX Elements
// -----
//
// Input params : WLNUM *   pPrime	preallocated structure
//					for number, must not be	zero !!!
//		  int       Bits	requested size in bits
//		  WLNUM *   pStep	Increment value for prime generation.
//					If <> 0, Diffie-Hellman	
//					specific generation.
//		  WLNUM *   pRem	remainder for Diffie-Hellman generator
//					condition checking
//		  int       Strong	if <> 0, strong prime is generated
//		  WLNUM_CTX * pCtx	Work Context / NULL
//                void callback(int)	Function for periodic call/NULL
// Returns: int Status, 0 - o.k., else error occured
/*==============================================================*/
int FAST GenPrimeWLnum(HMEM_CTX_DEF
	WLNUM * pPrime, int Bits,
        WLNUM * pStep, WLNUM * pRem, int Strong, WLNUM_CTX * pCtx,
        void (*callback)(int))
{
  int i,j;
  int Retcode = LNUM_OP_OK;
  int WLnumReleaseCnt = 0;
  int CheckCount;

  int DeltaStart = 0;
  int DeltaMax;

  int pCheckState[1];

  short * pPrimeArray;				// prime number array
  short * pModArray;
  WLNUM * pTmp = NULL;

  WLNUM_CTX * pTmpCtx = NULL;
  //----------------------------------------------------
  // Allocate temporary small prime number array
  //----------------------------------------------------
  if((pPrimeArray = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,WSMALL_PRIME_CNT)) == NULL)
    return(LNUM_OP_ALLOC_ERR);
  //--------------------------------------------------------------
  // Allocate modulus array
  //--------------------------------------------------------------
  if((pModArray = BIT16_ARRAY_ALLOC(HMEM_CTX_REF,WSMALL_PRIME_CNT)) == NULL)
  {
    FREE_CARRAY(HMEM_CTX_REF,pPrimeArray);
    return(LNUM_OP_ALLOC_ERR);
  }
  //-----------------------------------------------------------
  // Calculate number of Miller-Rabin checks needed
  // See: Applied Cryptography, Table 4.4. !!!
  // NOW: According to ISO/IEC 18032 for 2**-100 propability !!!
  //-----------------------------------------------------------
// NEW for ISO!!
  if(Bits >= 2048)
    CheckCount =2;
  else if(Bits >= 1024)
    CheckCount = 4;
  else if(Bits >= 512)
    CheckCount = 7;
  else if(Bits >= 256)
    CheckCount = 16;
  else
    CheckCount = 27;
  //-----------------------------------------------------------
  // Calculate Delta Maximum = Bits + Bits/2
  //-----------------------------------------------------------
  DeltaMax = (int) (Bits + Bits/2);

  //----------------------------------------------------
  // Generate small prime numbers
  //----------------------------------------------------
  DoEratosthenesWSieve(HMEM_CTX_REF1 pPrimeArray, WSMALL_PRIME_CNT);

  //-----------------------------------------------------------
  // for easier error processing we use an indefinite FOR loop
  //-----------------------------------------------------------
  for(;;)
  {
    //---------------------------------------------------------
    // Calculate WLNUM size needed for CTX/temp. number
    //---------------------------------------------------------
    i = (Bits + 32-1) / 32 + 1 + 1;		// get Element size count
    if(pCtx == NULL)
    {
      if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 1+43+1, i)) == NULL)
        return(LNUM_OP_ALLOC_ERR);
      pCtx = pTmpCtx;
    }
    else
    {
      j = pCtx->NextFreeIndex;
      if((j + 1+43) >= pCtx->AllocedNumCnt)
        return(LNUM_OP_CTX_FULL);
    }
    //--------------------------------------------------------
    // Get temporary number structure if strong requested
    //--------------------------------------------------------
    if(Strong != 0)
    {
      if((pTmp = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, i)) == NULL)
      {
        Retcode = LNUM_OP_ALLOC_ERR;
        break;
      }
      if(pTmpCtx == NULL)
        WLnumReleaseCnt = 1;
    }
    //--------------------------------------------------------
    // generate random number, according to desired mode
    //--------------------------------------------------------
    for(;;)
    {
      if(pStep == NULL)				// standard mode
      {
//      PRINT_NL("Getting Candidate");
        Retcode = GetWPrimeCandidate(HMEM_CTX_REF1	// get candidate
		     pPrime, Bits, Strong,
	             pPrimeArray, WSMALL_PRIME_CNT, pModArray,
		     DeltaStart, DeltaMax);
        DeltaStart = (int) Retcode;
        if(Retcode > 0)
          Retcode = 0;
//      PRINT_NL("Got Candidate");
      }
      else						// Diffie/Hellman
      {
        if(Strong == 0)					// no strong prime
          Retcode = GetWPrimeCandidate_DH(HMEM_CTX_REF1	// get candidate
			pPrime, Bits, pStep, pRem,
			pPrimeArray, WSMALL_PRIME_CNT, pCtx);
        else
          Retcode = GetWPrimeCandidate_DH_Strong(HMEM_CTX_REF1 // get candidate
		  	pPrime, Bits, pStep, pRem,
			pPrimeArray, WSMALL_PRIME_CNT, pCtx);
      }
      if(Retcode != LNUM_OP_OK)
//    {						// TEST TEST TEST
//      PRINT("\nCANDIDATE ERR");			// TEST TEST TEST
        break;			// error occured
//    }						// TEST TEST TEST
      if(callback != NULL)
        callback(0);				// signal prime check
      //------------------------------------------------------
      // check candidate for primality using Miller/Rabin test
      //------------------------------------------------------
//    PRINT("Doing Miller Rabin");
#if 0
      PRINT("Candidate: ");
      ShowLnum(pPrime);
#endif

      Retcode = WLnumMillerRabin(HMEM_CTX_REF1
			pPrime, CheckCount, pCheckState, pCtx,
			callback);
//    PRINT(" finished Miller Rabin");

      if(Retcode != LNUM_OP_OK)
//    {						// TEST TEST TEST
//      PRINT("\nMILLER RABIN ERR");			// TEST TEST TEST
        break;		// leave inner loop
//    }   						// TEST TEST TEST
      //------------------------------------------------------
      // if strong prime requested must check q = (p-1)/2 too
      //------------------------------------------------------
      if((Strong != 0) && (pCheckState[0] == 0)) // strong prime requested
      {
//        PRINT(" StrongCheck ");
        if((pPrime->lpEl[0] & 0x02) == 0)	// (p-1)/2 is even, no check
        {
//          PRINT("P");
          pCheckState[0] = 1;
        }
        else
        {
          Retcode = Rshift1WLnum(HMEM_CTX_REF1
				 pTmp,pPrime);	// divide by 2 (prime is odd!)
          if(Retcode != LNUM_OP_OK)
          {
//            PRINT("\nRSHIFT ERR");		// TEST TEST TEST
            break;	// error occured
          }
          Retcode = WLnumMillerRabin(HMEM_CTX_REF1
			pTmp, CheckCount, pCheckState, pCtx,
			callback);
          if(Retcode != LNUM_OP_OK)
          {					// TEST TEST TEST
//              PRINT("\nMILLER RABIN ERROR 2");		// TEST TEST TEST
             break;	// leave inner loop
          }					// TEST TEST TEST
          if(pCheckState[0] == 0)			// TEST TEST TEST
          {
//            PRINT("\nStrong");
            break;
          }
        }
      }
      if(pCheckState[0] == 0)			// all tests passed
        break;
      if(callback != NULL)
      {
        callback(2);				// signal retry number
      }
    } // retry loop
    break;
  } // outmost FOR loop

  FREE_CARRAY(HMEM_CTX_REF,pPrimeArray);
  FREE_CARRAY(HMEM_CTX_REF,pModArray);
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);
  return(Retcode);
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Montgomery routines
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//===============================================================
// Calculate the inverse element N0' for montgomery conversion
// based on the equality:	N0(2**i) * N0'(2**i) = 1 (mod 2**i)
// 				for i = 1...w (w = 32)
//
// Input parameters:	int	N0	lowest Element of modulus n
// Returns: int N0' negative(!) invers to N0 mod 2**32
//===============================================================
static int FAST WLnumMontInvN0(int N0)
{
  int i;

  int Prod;
  int Ni0 = 1;
  int Mask = 1;

  //------------------------------------------------------------
  // get the invers Ni0 modulo 2**32
  //------------------------------------------------------------
  for(i=2;i<=32;i++)
  {
    Prod = N0 * Ni0;
    Mask = (Mask << 1) | 0x01;		// generate modulo mask 2**i
    Prod = Prod & Mask;			// isolate modulus
    if(Prod != 1)
    {
      Ni0 = Ni0 + ((int) 1 << (i-1));	// N0' = N0' + 2**(i-1)
    }
  }
  //------------------------------------------------------------
  // negate Ni0 modulo 2**32:
  // -Ni0 = (2**32 - Ni0) mod 2**32
  //------------------------------------------------------------
  EXP_PRINT("Ni0 not negated: ");
  EXP_PRINT_HEX_BIT32(Ni0);
  EXP_PRINT("\n");

//  if(Ni0 == 0)			// special case, 2**32 mod 2**32 = 0
//    return(Ni);

  Ni0 = (~Ni0) + 1;			// 2's complement (0->0)

  return(Ni0);
}
//===============================================================
// Free a montgomery context and its elements
//
// Input parameters: MONT_CTX *	pMontCtx	context / NULL
// Returns: nothing
//===============================================================
void FAST FreeWLnumMontCtx(HMEM_CTX_DEF MONT_CTX * pMontCtx)
{
  if(pMontCtx == NULL)
    return;
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pModN);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pRSquare);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pTmpLnum);
  FreeWLnum(HMEM_CTX_REF1 pMontCtx->pTmpMontLnum);

  FREE_ARRAY(HMEM_CTX_REF,pMontCtx);
}
//===============================================================
// Allocate a montgomery context and its elements,
// preset the elements
//
// Input parameters: WLNUM * pModN		Modulus to use
// Returns: MONT_CTX * pMontCtx / NULL
//===============================================================
MONT_CTX * AllocWLnumMontCtx(HMEM_CTX_DEF WLNUM * pModN)
{
  int sLen;
  int * lpEl;
  MONT_CTX * pMontCtx;
  //---------------------------------------------------------
  // check parameters first, modulus > 0 and odd !
  //---------------------------------------------------------
  if((pModN == NULL) || (pModN->UsedSize == 0) ||
     ((pModN->lpEl[0] & 0x01) == 0))
    return(NULL);
  //---------------------------------------------------------
  // allocate context, clear it
  //---------------------------------------------------------
  pMontCtx = (MONT_CTX *)
             ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,
					 sizeof(MONT_CTX)));
  if(pMontCtx == NULL)
    return(NULL);
  //---------------------------------------------------------
  // get size s for r, r > n, r = 2**(s*w), w = 32
  // allocate large number buffers for n, r**2 and tmp
  //---------------------------------------------------------
  sLen = pModN->UsedSize;			// elements to use

  for(;;)		// error FOR
  {
    pMontCtx->pModN        = AllocNewWLnum(HMEM_CTX_REF1 sLen);
    pMontCtx->pRSquare     = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));
    pMontCtx->pTmpLnum     = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));
    pMontCtx->pTmpMontLnum = AllocNewWLnum(HMEM_CTX_REF1 (2*sLen+1));

    if((pMontCtx->pModN == NULL) ||
       (pMontCtx->pRSquare == NULL) ||
       (pMontCtx->pTmpLnum == NULL) ||
       (pMontCtx->pTmpMontLnum == NULL))
      break;
    //---------------------------------------------------------
    // copy modulus to context
    //---------------------------------------------------------
    memcpy(pMontCtx->pModN->lpEl,pModN->lpEl,sLen*4);

    pMontCtx->pModN->UsedSize = sLen;
    //---------------------------------------------------------
    // Generate RSquare = r**2 (mod n)
    //---------------------------------------------------------
    lpEl = pMontCtx->pTmpLnum->lpEl;		// get buffer pointer
//    ClearBit32Array(lpEl,0,sLen*2);
    memset(lpEl,0,sLen*2*4);
    lpEl[2*sLen] = 1;				// set r = 2**(2*s*w)
    pMontCtx->pTmpLnum->UsedSize = 2*sLen + 1;

    if(ModWLnum(HMEM_CTX_REF1 pMontCtx->pRSquare,
		    pMontCtx->pTmpLnum, pModN, NULL) != LNUM_OP_OK)
      break;
    //--------------------------------------------------------
    // Generate Ni0 from n(x)[0], save s
    //--------------------------------------------------------
    pMontCtx->Ni0  = WLnumMontInvN0(pModN->lpEl[0]);
    pMontCtx->sLen = sLen;
    return(pMontCtx);
  } // error FOR
  FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
  return(NULL);
}
//=========================================================================
// Convert montgomery representation a~ to normal large number a
//
// NOTE: 1. destination c may be same as source a
// ----- 2. a must be reduced (mod n) aka. a < n !!
//	 3. to avoid reallocation of number elements, size of
//	    destination SHOULD be >= 2 * Size(Modulus n) !!
//
// Input parameters:	WLNUM * pWLnumC		result large number
//			WLNUM * pWLnumA		montgomery number a~
//			MONT_CTX * pMontCtx	Montgomery context
// Returns: int Status - 0 o.k., else error occured
//=========================================================================
int FAST MontToWLnum(HMEM_CTX_DEF WLNUM * pWLnumC,
		     WLNUM * pWLnumA, MONT_CTX * pMontCtx)
{
  int Retcode,sLen,NumSize;
  int ALen;
  int * pC;
  int * pA;
  WLNUM * pTmpLnum = NULL;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //--------------------------------------------------------
  // Avoid multiply by 0 !!
  //--------------------------------------------------------
  if(pWLnumA->UsedSize == 0)
  {
    pWLnumC->UsedSize = 0;
    return(LNUM_OP_OK);
  }
  //----------------------------------------------------------------
  // get number pointers and sizes for processing
  //----------------------------------------------------------------
  sLen = pMontCtx->sLen;
  pA   = pWLnumA->lpEl;
  ALen = pWLnumA->UsedSize;
  if(ALen > (2*sLen))				// sanity check !
    return(LNUM_OP_PARAM_ERR);

  if(pWLnumC != pWLnumA)			// dst c(x) <> src a(x)
    pTmpLnum = pWLnumC;
  else						// dst c(x) == src a(x)
    pTmpLnum = pMontCtx->pTmpLnum;
  //------------------------------------------------------------
  // Assure that CLen >= 2*sLen+1
  //------------------------------------------------------------
  if(pTmpLnum->AllocSize <= (2*sLen+1))
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
				     pTmpLnum, (2*sLen+1))) != LNUM_OP_OK)
      return(Retcode);
  }
  pC   = pTmpLnum->lpEl;
  //--------------------------------------------------------
  // Generate Montgomery product and used size:
  // 1. copies number to destination at startup (T <= A)
  // 2. clears unused elements
  // 3. multiplicates and adds up result(s)
  // 4. shifts result right s Elemets (divide by 2**(s*w))
  //--------------------------------------------------------
#if !defined LNUM32_USE_INT64
  NumSize = HardMulAddMontEmul32(ALen, pA, sLen, pC,
		      pMontCtx->pModN->lpEl,
		      pMontCtx->Ni0);
#else
  NumSize = HardMulAddMontBit64(ALen, pA, sLen, pC,
		      pMontCtx->pModN->lpEl,
		      pMontCtx->Ni0);
#endif
  //--------------------------------------------------------
  // shift right result by s elements (divide by 2**(w*s))
  // NOTE: not used!!
  //--------------------------------------------------------
//  HardRshiftBit32WLnum(sLen, pC, NumSize);
//  pTmpLnum->UsedSize = NumSize - sLen;
  pTmpLnum->UsedSize = NumSize;
  //--------------------------------------------------------
  // Check if c >= n
  // NOTE: c will always be < 2*n (per definitionem of Algorithmus)
  //--------------------------------------------------------
  if(UcompWLnum(pTmpLnum,pMontCtx->pModN) != WLNUM_1ST_LT_2ND)
  {
    Retcode = SubWLnum(HMEM_CTX_REF1 pTmpLnum, pTmpLnum,
		       pMontCtx->pModN);
    if(Retcode != LNUM_OP_OK)
      return(Retcode);
  }
  //--------------------------------------------------------
  // Copy Result to destination if required
  //--------------------------------------------------------
  if(pWLnumC == pTmpLnum)		// no copy needed
    return(LNUM_OP_OK);

  Retcode = CopyWLnum(HMEM_CTX_REF1 pWLnumC, pTmpLnum);
  return(Retcode);
}
//=========================================================================
// Perform montgomery modulo multiplication
// Implements the wordlevel algorithm
// NOTE: 1. destination c may be same as sources a,b
// ----- 2. multiplicands must be reduced to modulus n
//
// Input parameters:	WLNUM * pWLnumC		result large number
//			WLNUM * pWLnumA		Multiplicand 1
//			WLNUM * pWLnumB		Multiplicand 2
//			MONT_CTX * pMontCtx	Montgomery context
// Returns: int Status - 0 o.k., else error occured
//=========================================================================
int FAST MontMulModWLnum(HMEM_CTX_DEF WLNUM * pWLnumC,
	WLNUM * pWLnumA, WLNUM * pWLnumB, MONT_CTX * pMontCtx)
{
  int Retcode,sLen;
  WLNUM * pTmpLnum;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumB == NULL) ||
     (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------------
  // get temporary number for processing
  //----------------------------------------------------------------
  sLen     = pMontCtx->sLen;
  pTmpLnum = pMontCtx->pTmpMontLnum;
  //----------------------------------------------------------------
  // 1. Precalculate c = a~ * b~
  //----------------------------------------------------------------
  if(pWLnumA == pWLnumB)		// use squaring (faster)
  {
    Retcode = SquareWLnum(HMEM_CTX_REF1 pTmpLnum, pWLnumA);
  }
  else					// use standard multiplication
  {
    Retcode = MulWLnum(HMEM_CTX_REF1 pTmpLnum, pWLnumA, pWLnumB);
  }
  if(Retcode != LNUM_OP_OK)
    return(Retcode);
  //----------------------------------------------------------------
  // 2. convert c = a~ * b~ to c~ = a~ * b~ * r**(-1) (mod n)
  //----------------------------------------------------------------
  Retcode = MontToWLnum(HMEM_CTX_REF1 pWLnumC, pTmpLnum, pMontCtx);
  return(Retcode);
}
//=========================================================================
// Generate montgomery representation a~ of number '1'
// uses simplified MontMulMod with b(x) = 1
//
// Input parameters:	WLNUM * pWLnumC		result large number
//			MONT_CTX * pMontCtx	Montgomery context
// Returns: int Status - 0 o.k., else error occured
//=========================================================================
int FAST MontOneWLnum(HMEM_CTX_DEF WLNUM * pWLnumC, MONT_CTX * pMontCtx)
{
  int Retcode;

  //-----------------------------------------------------------
  // We use backward conversion a = a~ * r**(-1) (mod n) for
  // the number RSquare (mod n).
  // This yields: a = r**2 * r**(-1) (mod n) = r (mod n)
  // montgomery representation of 1 is: 1~ = 1 * r (mod n)
  //-----------------------------------------------------------
  Retcode = MontToWLnum(HMEM_CTX_REF1 pWLnumC, pMontCtx->pRSquare,
			pMontCtx);
  return(Retcode);
}
//=========================================================================
// Convert normal large number a to montgomery representation a~
// uses standard montgomery multplication
// NOTE: destination c may be same as source a
// -----
//
// Input parameters:	WLNUM * pWLnumC		result momtgomery number a~
//			WLNUM * pWLnumA		standard large number a
//			MONT_CTX * pMontCtx	Montgomery context
// Returns: int Status - 0 o.k., else error occured
//=========================================================================
int FAST WLnumToMont(HMEM_CTX_DEF WLNUM * pWLnumC,
		     WLNUM * pWLnumA, MONT_CTX * pMontCtx)
{
  int Retcode;
  //--------------------------------------------------------
  // Check parameters, remove later
  //--------------------------------------------------------
  if((pWLnumA == NULL) || (pWLnumC == NULL) || (pMontCtx == NULL))
    return(LNUM_OP_NULL_PTR);
  //----------------------------------------------------------------
  // calculate: c = MontMulMod(a,r**2 (mod n))
  //----------------------------------------------------------------
  Retcode = MontMulModWLnum(HMEM_CTX_REF1 pWLnumC, pWLnumA,
		pMontCtx->pRSquare, pMontCtx);
  return(Retcode);
}
//==============================================================
// UP ExpModMontWLnum calculates (u ** v) mod m using montgomery
// multiplication and a precomputed table of montgomery powers
// to reduce amount of caclulations needed.
// The size of the table depends on the size of the value v.
// The contents will be (u~) mod m, (u~**3) mod m, (u~**5) mod m
// and so on.
// The power p is scanned from top to bottom using a window of
// size 1 to 6 bits, depending on the magnitude of v.
//
// Note: 1. destination and source  m u s t  be different,
// ----- 2. 4 CTX Elements required + max. 32 for Table
//	 3. Modulus must be > 0 AND odd !!!
//
// Input parameters: WLNUM * pRem	pointer to destination
//		     WLNUM * pU		pointer to number u
//		     WLNUM * pV		pointer to power v
//		     WLNUM * pMod	pointer to modulus m
//		     WLNUM_CTX * pCtx	Work context / NULL
//		     void callback(int)	Callback pointer / NULL
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
static int FAST ExpModMontWLnum(HMEM_CTX_DEF
			        WLNUM * pRem, WLNUM * pU, WLNUM * pV,
				WLNUM * pMod, WLNUM_CTX * pCtx,
			        void callback(int))
{
  int Retcode;

  int i = 0;
  int j;
  int k = 0;
  int win=0;
  int vIndex=0;
  int vIndexSave;

  int MulFlag=0;
  int WinStart=0;
  int WinSize;

  int wIndex;
  int MaxSize;
  int TmpNumCnt;

  int WLnumReleaseCnt = 0;

  int LastUtc = 0;
  int ThisUtc = 0;

  WLNUM * pLnumTmp = NULL;
  WLNUM * CalcTab[32];			// precalculated numbers
  WLNUM ** pNumArr;

  int * pElv = NULL;

  int BitMask = 0;
  int BitMaskSave;

  WLNUM_CTX * pTmpCtx = NULL;
  MONT_CTX * pMontCtx = NULL;


//  if((pRem==NULL) || (pU==NULL) || (pV==NULL) || (pMod==NULL))
//    return(LNUM_OP_NULL_PTR);
  EXP_PRINT("EXPMOD_MONT ENTER\n");

  EXP_PRINT("Modulus: ");
  EXP_SHOWLNUM(pMod);

  //------------------------------------------------------------
  // Check error conditions for u**v (mod n) first
  //------------------------------------------------------------
  if(IsZeroWLnum(pMod) != 0)			// m == 0
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.

  if((pMod->lpEl[0] & 0x01) == 0)		// m is even
    return(LNUM_OP_INVALID_MONT_MODULUS);

  //------------------------------------------------------------
  // assure size of remainder >= MaxSize
  //------------------------------------------------------------
  MaxSize = (pMod->UsedSize * 2) + 1;		// for Carry out !!!

  if(pRem->AllocSize < MaxSize)			// too few elements
  {
    if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,MaxSize)) != LNUM_OP_OK)
      return(Retcode);
  }
  pRem->UsedSize = 0;				// set Rem = 0
  //------------------------------------------------------------
  // Check special conditions for u**v (mod n)
  //------------------------------------------------------------
  if(IsZeroWLnum(pV) != 0)			// v == 0, set Rem = 1
  {
    pRem->lpEl[0]  = 1;
    pRem->UsedSize = 1;
    return(LNUM_OP_OK);
  }
  if(IsZeroWLnum(pU) != 0)			// u == 0, set Rem = 0
    return(LNUM_OP_OK);

  //------------------------------------------------------------
  // allocate/initialize montgomery context, check modulus n
  //------------------------------------------------------------
  if((pMontCtx = AllocWLnumMontCtx(HMEM_CTX_REF1 pMod)) == NULL)
    return(LNUM_OP_ALLOC_ERR);

  EXP_PRINT("Mont r**2 (modn): ");
  EXP_SHOWLNUM(pMontCxt->pRSquare);
  EXP_PRINT("Mont Ni0: ");
  EXP_PRINT_HEX_BIT32(pMontCtx->Ni0);
  EXP_PRINT("\n");



  //------------------------------------------------------------
  // get window size to use from exponent v size (is shure > 0!)
  //------------------------------------------------------------
  pElv   = pV->lpEl;				// exponent buffer base
  vIndex = pV->UsedSize-1;		// get topmost element index
  i = (vIndex * 32) +				// get number of bits
           (int) HardGetBitCntWLnumElem(pElv[vIndex]);
  //----------------------------------------------------------
  // Get window size to use
  // Changed according to Algorithm 1.2.2.4 from H. Cohen:
  // lg N <= (k * (k+1) * 2^(2k))/(2^(k+1) -k - 2)
  // k = 1 for bits <= 8
  // k = 2 for bits <= 24
  // k = 3 for bits <= 69
  // k = 4 for bits <= 196
  // k = 5 for bits <= 538
  // k = 6 for bits > 538
  //----------------------------------------------------------
  if(i <= 8) win = 1;
  else if(i <= 24) win = 2;
  else if(i <= 69) win = 3;
  else if(i <= 196) win = 4;
  else if(i <= 538) win = 5;
  else win = 6;

//    PRINT("WIN: ");
//    PRINT_INT(win);

  TmpNumCnt = (1 << (win-1)) + 4;
  //--------------------------------------------------------------
  // Allocate context / check given context, need win + 4 elements
  //--------------------------------------------------------------
  if(pCtx == NULL)				// no context
  {
    if((pTmpCtx = AllocWLnumContext(HMEM_CTX_REF1 TmpNumCnt, MaxSize)) == NULL)
    {
      FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
      return(LNUM_OP_ALLOC_ERR);
    }
    pNumArr = pTmpCtx->pWLnumArr;
    pLnumTmp   = pNumArr[0];
    CalcTab[0] = pNumArr[1];
    pTmpCtx->NextFreeIndex = 2;
    pCtx = pTmpCtx;
  }
  else						// context is given
  {
    j = pCtx->NextFreeIndex;
    if((j + TmpNumCnt) >= pCtx->AllocedNumCnt)
    {
      FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
      EXP_PRINT("MontExp: Context Full! Alloced count: ");
      EXP_PRINT_INT_NL(pCtx->AllocedNumCnt);
      return(LNUM_OP_CTX_FULL);
    }
    pLnumTmp   = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    CalcTab[0] = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx, MaxSize);
    if((pLnumTmp == NULL) || (CalcTab[0] == NULL))
    {
      FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
      return(LNUM_OP_ALLOC_ERR);
    }
    WLnumReleaseCnt = 2;
  }

  for(;;) // Error FOR
  {
    //------------------------------------------------------------
    // Check/reduce u (mod n)
    // NOTE: we do not check if already reduced, ModWLnum does it
    //------------------------------------------------------------
    Retcode = ModWLnum(HMEM_CTX_REF1 pLnumTmp,pU,pMod,pCtx); // reduce (mod n)
    if(Retcode != LNUM_OP_OK)
      break;

    EXP_PRINT("Mont uReduced: ");
    EXP_SHOWLNUM(pLnumTmp);

    if(IsZeroWLnum(pLnumTmp) != 0)			// u (mod n) == 0, exit
      break;
    //------------------------------------------------------------
    // Get montgomery representation of 1 and u
    //------------------------------------------------------------
    if((Retcode = MontOneWLnum(HMEM_CTX_REF1 pRem,
			       pMontCtx)) != LNUM_OP_OK)
      break;

    EXP_PRINT("MontOne: ");
    EXP_SHOWLNUM(pRem);

    if((Retcode = WLnumToMont(HMEM_CTX_REF1 CalcTab[0], pLnumTmp,
			      pMontCtx)) != LNUM_OP_OK)
      break;

    EXP_PRINT("CTab[0]: ");
    EXP_SHOWLNUM(CalcTab[0]);

    //-----------------------------------------------------------
    // initialize window test bitmask
    //-----------------------------------------------------------
    WinStart = i-1;				// first Bit +1 to test
    BitMask = (int)
               ((int) 1 << ((i-1) & (int) 0x1F));// initial test bit mask

#if 0
    PRINT("vIndex: ");
    PRINT_INT_NL(vIndex);
    PRINT("i: ");
    PRINT_INT_NL(i);
    PRINT("WinStart: ");
    PRINT_INT_NL(WinStart);
    PRINT("Start Mask: ");
    PRINT_HEX_BIT32_NL(BitMask);
#endif

    //---------------------------------------------------------
    // generate the modulo multiplication tables if required
    //---------------------------------------------------------
    if(win != 1)				// must build more elements
    {
      //-------------------------------------------------
      // calculate u~**2
      //-------------------------------------------------
      if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pLnumTmp,
		       CalcTab[0], CalcTab[0], pMontCtx)) != LNUM_OP_OK)
        break;

      EXP_PRINT("LnumTmp: ");
      EXP_SHOWLNUM(pLnumTmp);
      //----------------------------------------------------------
      // precalculate remaining Table values
      //----------------------------------------------------------
      j = (1<<(win-1)) - 1;			// maximal index (rel. 0)
      k = 1;					// set start index ([1])

      Retcode = LNUM_OP_OK;
      do					// process alloc/preset
      {
        //--------------------------------------------------------
        // get temporary number to use from context
        //--------------------------------------------------------
        if((CalcTab[k] = GetWLnumPtrFromContext(HMEM_CTX_REF1 pCtx,
						MaxSize)) == NULL)
        {
          Retcode = LNUM_OP_ALLOC_ERR;
          break;
        }
        if(pTmpCtx == NULL)			// from given CTX
          WLnumReleaseCnt++;
        //--------------------------------------------------------
        // calculate ~c[i] = u~**2 * ~c[i-1]
        //--------------------------------------------------------
        if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 CalcTab[k],
		       CalcTab[k-1], pLnumTmp, pMontCtx)) != LNUM_OP_OK)
          break;

        EXP_PRINT("CTAB[k]: ");
        EXP_SHOWLNUM(CalcTab[k]);
        k++;					// to next table index
      }while((--j) != 0);
    } // win != 1

    if(Retcode != LNUM_OP_OK)			// error occured !!!
      break;

    //---------------------------------------------------------------
    // start of processing, perform callback if present
    //---------------------------------------------------------------
    if(callback != NULL)
    {
      if(i < 128)
      {
#if defined WIN32 || defined WIN64
#pragma warning(disable:4550)
#endif
        callback = (void(*)(int)) NULL;
#if defined WIN32 || defined WIN64
#pragma warning(default:4550)
#endif
      }
      else
        LastUtc = SecGetSystemTimeUTC();
    }
    //------------------------------------------------------------
    // processing loop
    //------------------------------------------------------------
//  Retcode = LNUM_OP_OK;
    for(;;)					// process 'infinite'
    {
      //----------------------------------------------------------
      // search 1st v-bit that is One, starting at the MSB-Bit
      //----------------------------------------------------------
      if((pElv[vIndex] & BitMask) == 0)	// no startbit found
      {
        if(MulFlag != 0)			// should we do multiply ?
        {
#if 0
          PRINT("\nSquareMod0: In  = ");
          ShowLnum(pRem);
          PRINT("SquareMod0: Mod = ");
          ShowLnum(pMod);
#endif
          // set c~ = c~ * c~
          if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pRem,
			        pRem, pRem, pMontCtx)) != LNUM_OP_OK)
            break;

          EXP_PRINT("MontSquareMod0: Rem = ");
          EXP_SHOWLNUM(pRem);
          EXP_PRINT("\n");

//        SquareCount++;
        }
        if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
        {
          BitMask = (int) (unsigned int) 0x80000000;
          vIndex--;
        }
        if((--WinStart) < 0)
        {
          EXP_PRINT("Should finish..");
          break;					// all done
        }
        continue;					// keep on searching
      } // Bit was zero
      //----------------------------------------------------------
      // bit found, correct bitmask
      //----------------------------------------------------------
      if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
      {
        BitMask = (int) (unsigned int) 0x80000000;
        vIndex--;
      }
      //----------------------------------------------------------
      // get window size and Table Index from winsize bits
      // N O T E: take care of bitmask !!!
      //----------------------------------------------------------
      WinSize = 0;				// no size yet
      wIndex = 1;
      vIndexSave = vIndex;			// save pointer
      BitMaskSave = BitMask;			// save mask
      for(i=1;i<win;i++)				// get sizes
      {
        if((WinStart - i) < 0)			// check for data end
          break;

        if((pElv[vIndex] & BitMask) != 0)	// '1' bit found
        {
          wIndex = (wIndex << (i-WinSize)) | 1;	// correct index,insert new bit
          WinSize = i;				// save size
          BitMaskSave = BitMask;		// get current bitmask
          vIndexSave = vIndex;			// get current pointer

          if((BitMaskSave = ((BitMaskSave >>1) & 0x7FFFFFFF)) == 0)
          {
            BitMaskSave = (int) (unsigned int) 0x80000000;
            vIndexSave--;
          }
        }
        if((BitMask = ((BitMask >> 1) & 0x7FFFFFFF)) == 0)
        {
          BitMask = (int) (unsigned int) 0x80000000;
          vIndex--;
        }
      }
      BitMask = BitMaskSave;
      vIndex = vIndexSave;
      //----------------------------------------------------------
      // correct modulo operation (1 figure)
      //----------------------------------------------------------
      j = WinSize+1;			// number of corrections needed
      do
      {
        EXP_PRINT("SquareMod1-IN: Rem = ");
        EXP_SHOWLNUM(pRem);

        // set c~ = c~ * c~
        if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pRem,
			        pRem, pRem, pMontCtx)) != LNUM_OP_OK)
          break;

        EXP_PRINT("MontSquareMod1: Rem = ");
        EXP_SHOWLNUM(pRem);
//        SquareCount++;
        j--;
      }while(j != 0);
      if(j != 0)					// error occured
        break;
      //----------------------------------------------------------
      // multiply with appropriate table value
      //----------------------------------------------------------
      EXP_PRINT("MontMulMod0In  : Rem = ");
      EXP_SHOWLNUM(pRem);
      EXP_PRINT("MontMulMod0In  : Mul = ");
      EXP_SHOWLNUM(CalcTab[wIndex>>1]);
      EXP_PRINT("MontMulMod0In  : wIndex = ");
      EXP_PRINT_INT_NL(wIndex);

      // multiply * (Table) mod m
      // set c~ = c~ * (u~**k)
      if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pRem, pRem,
			CalcTab[wIndex>>1], pMontCtx)) != LNUM_OP_OK)
        break;

      EXP_PRINT("MontMulMod0  : Rem = ");
      EXP_SHOWLNUM(pRem);

//    MulCount++;
      //----------------------------------------------------------
      // check if more input data present
      //----------------------------------------------------------
      MulFlag = 1;				// enable multiplying now
      if((WinStart -= (WinSize+1)) < 0)		// reduce data count
        break;
      if(callback != NULL)
      {
        ThisUtc = SecGetSystemTimeUTC();
        if(ThisUtc != LastUtc)
        {
          LastUtc = ThisUtc;
	  callback(1);
        }
      }
    } // for
    if(Retcode != LNUM_OP_OK)
      break;
    //-------------------------------------------------------
    // Convert back: c = c~ * r**(-1)
    //-------------------------------------------------------
    Retcode = MontToWLnum(HMEM_CTX_REF1 pRem, pRem,
				pMontCtx);
    break;
  }
  //------------------------------------------------------------
  // free buffers, exit
  //------------------------------------------------------------
  if(pTmpCtx != NULL)
  {
    FreeWLnumContext(HMEM_CTX_REF1 pTmpCtx);
  }
  if(WLnumReleaseCnt != 0)
    ReleaseWLnumsFromContext(pCtx, WLnumReleaseCnt);

  FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);

#if 0
  GET_END_TICS
  DiffTics = GET_DIFF_TICS

  PRINT("\nexpsize Tics: ");
  PRINT_HEX_BIT32(DiffTics);
  PRINT("\n");
//  PRINT("\nExpSize    : ");
//  PRINT_INT(ExpSize);
//  PRINT("\nSquareCount: ");
//  PRINT_INT(SquareCount);
//  PRINT("\nMulCount   : ");
//  PRINT_INT(MulCount);
#endif

  EXP_PRINT("MontExp EXIT, Retcode=");
  EXP_PRINT_INT_NL(Retcode);

  return(Retcode);
}

//==============================================================
// UP ExpModWLnum calculates (u ** v) mod m
// For evem modulus uses (slow) standard window algorithmus,
// for odd modulus uses montgomery window algorithmus
//
// Note: 1. destination and source  m u s t  be different,
// ----- 2. 4 CTX Elements required + max. 32 for Table !!
//
// Input parameters: WLNUM * pRem	pointer to destination
//		     WLNUM * pU		pointer to number u
//		     WLNUM * pV		pointer to power v
//		     WLNUM * pMod	pointer to modulus m
//		     WLNUM_CTX * pCtx	Work context / NULL
//		     void callback(int)	Callback pointer / NULL
// Returns: int Status, 0 - o.k., else error occured
//==============================================================
int FAST ExpModWLnum(HMEM_CTX_DEF
		     WLNUM * pRem, WLNUM * pU, WLNUM * pV,
		     WLNUM * pMod, WLNUM_CTX * pCtx,
		     void callback(int))
{
  int Retcode;
  //---------------------------------------------------------
  // check for modulus 0 first
  //---------------------------------------------------------
  if(IsZeroWLnum(pMod) != 0)			// m == 0
    return LNUM_OP_ZERO_DIV;			// Divide by zero err.
  //-------------------------------------------------------
  // Check for special mode u ** v=0 mod n, always yields 1
  //-------------------------------------------------------
  if(IsZeroWLnum(pV) != 0)			// power V is 0
  {
    if(pRem->AllocSize < 1)			// too few elements
    {
      if((Retcode = AllocWLnumElements(HMEM_CTX_REF1
			pRem,1)) != LNUM_OP_OK)
        return(Retcode);
    }
    pRem->UsedSize = 1;
    pRem->lpEl[0] = 1;
    return(LNUM_OP_OK);
  }
  //-------------------------------------------------------
  // Check for special mode u=0 ** x mod n, always yields 0
  //-------------------------------------------------------
  if(IsZeroWLnum(pU) != 0)			// base U is 0
  {
    pRem->UsedSize = 0;
    return(LNUM_OP_OK);
  }

  //---------------------------------------------------------
  // check which type of modulus given, Even/Odd
  //---------------------------------------------------------
  if((pMod->lpEl[0] & 0x01) == 0)		// modulus is EVEN-> Slow
  {
    return(ExpModStdWLnum(HMEM_CTX_REF1
		pRem, pU, pV, pMod, pCtx, callback));
  }
  else
  {
    return(ExpModMontWLnum(HMEM_CTX_REF1
		pRem, pU, pV, pMod, pCtx, callback));
  }
}


#if 1 // use if needed...
//================================================================
// TESTER ROUTINE !!!!!
// Multiply 2 numbers using montgomery multiplication
// - Generate an odd modulus n so that a * b < n (avoid truncation)
// - Allocate montgomery context
// - convert numbers: a~ = a*r (mod n), b~ = b*r (mod n)
// - multiply: c~ = a~ * b~ * r**(-1) (mod n)
// - multiply: c~ = 1~ * c~ * r**(-1) (mod n)	[Test representation of 1]
// - convert back: c = c~ * r
//
// Input parameters:	pWLnumR		Result
//			pWLnumA		Multiplier a
//			pWLnumB		Multiplier b
// Returns: int Status, 0 - o.k., else error occured
//================================================================
int FAST MontMulWLnum(HMEM_CTX_DEF WLNUM * pWLnumR,
		WLNUM * pWLnumA, WLNUM * pWLnumB)
{
  int Retcode;
  int ModLen;
  int Index;
  int MaxLen;

  WLNUM * pWLnumMod = NULL;
  WLNUM * pWLnumAs  = NULL;
  WLNUM * pWLnumBs  = NULL;
  WLNUM * pWLnumCs  = NULL;
  WLNUM * pWLnum1s  = NULL;
  int * pEl;

  MONT_CTX * pMontCtx = NULL;

  //--------------------------------------------------------
  // Check parameters
  //--------------------------------------------------------
  if((pWLnumR == NULL) || (pWLnumA == NULL) || (pWLnumB == NULL))
    return(LNUM_OP_NULL_PTR);

  //--------------------------------------------------------
  // Process simple cases: a or b = 0 first
  //--------------------------------------------------------
  pWLnumR->UsedSize = 0;
  if((pWLnumA->UsedSize == 0) || (pWLnumB->UsedSize == 0))
    return(LNUM_OP_OK);
  //--------------------------------------------------------
  // Get size of modulus to use, allocate large number
  //--------------------------------------------------------
  ModLen = pWLnumA->UsedSize + pWLnumB->UsedSize + 2;

  Retcode = LNUM_OP_ALLOC_ERR;
  for(;;)
  {
    if((pWLnumMod = AllocNewWLnum(HMEM_CTX_REF1 ModLen)) == NULL)
      break;
    //--------------------------------------------------------
    // Set the modulus (use 0x00000001,0xFFFFFFF..,0x00000001)
    //--------------------------------------------------------
    pEl = pWLnumMod->lpEl;
    pEl[0] = 0x01;
//    pEl[0] = 0xFFFFFFFF;
    for(Index=1; Index < (ModLen-1); Index++)
    {
    pEl[Index] = 0xFFFFFFFF;
//      pEl[Index] = 0;
    }
    pEl[ModLen-1] = 0x01;
//    pEl[ModLen-1] = 0xFFFFFFFF;
    pWLnumMod->UsedSize = ModLen;
    //-------------------------------------------------------
    // get montgomery context
    //-------------------------------------------------------
    pMontCtx = AllocWLnumMontCtx(HMEM_CTX_REF1 pWLnumMod);
    if(pMontCtx == NULL)
      break;

    MaxLen = ((pMontCtx->sLen * 2) + 1);		// 2*sLen + 1 !!!

    //-------------------------------------------------------
    // allocate helper large numbers a~, b~, c~, 1~
    //-------------------------------------------------------
    if((pWLnumAs = AllocNewWLnum(HMEM_CTX_REF1 MaxLen)) == NULL)
      break;
    if((pWLnumBs = AllocNewWLnum(HMEM_CTX_REF1 MaxLen)) == NULL)
      break;
    if((pWLnumCs = AllocNewWLnum(HMEM_CTX_REF1 MaxLen)) == NULL)
      break;
    if((pWLnum1s = AllocNewWLnum(HMEM_CTX_REF1 MaxLen)) == NULL)
      break;
    //-------------------------------------------------------
    // Convert a to a~, b to b~, get 1~
    //-------------------------------------------------------
    if((Retcode = WLnumToMont(HMEM_CTX_REF1 pWLnumAs, pWLnumA,
			      pMontCtx)) != LNUM_OP_OK)
      break;

    if((Retcode = WLnumToMont(HMEM_CTX_REF1 pWLnumBs, pWLnumB,
			      pMontCtx)) != LNUM_OP_OK)
      break;

    if((Retcode = MontOneWLnum(HMEM_CTX_REF1 pWLnum1s,
			       pMontCtx)) != LNUM_OP_OK)
      break;
    //-------------------------------------------------------
    // Multiply: c~ = a~ * b~
    //-------------------------------------------------------
    if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pWLnumCs,
		    pWLnumAs, pWLnumBs, pMontCtx)) != LNUM_OP_OK)

      break;
#if 1
    //-------------------------------------------------------
    // Multiply: c~ = 1~ * c~
    //-------------------------------------------------------
    if((Retcode = MontMulModWLnum(HMEM_CTX_REF1 pWLnumCs,
		    pWLnumCs, pWLnum1s, pMontCtx)) != LNUM_OP_OK)

      break;
#endif // 0
    //-------------------------------------------------------
    // Convert back: c = c~ * r**(-1)
    //-------------------------------------------------------
    if((Retcode = MontToWLnum(HMEM_CTX_REF1 pWLnumR, pWLnumCs,
			      pMontCtx)) != LNUM_OP_OK)
      break;

    Retcode = LNUM_OP_OK;
    break;
  } // Error FOR

  FreeWLnum(HMEM_CTX_REF1 pWLnumMod);
  FreeWLnum(HMEM_CTX_REF1 pWLnumAs);
  FreeWLnum(HMEM_CTX_REF1 pWLnumBs);
  FreeWLnum(HMEM_CTX_REF1 pWLnumCs);
  FreeWLnum(HMEM_CTX_REF1 pWLnum1s);
  FreeWLnumMontCtx(HMEM_CTX_REF1 pMontCtx);
  return(Retcode);
}
#endif // 0, use if needed...


/**
* Calculates the least common multiple of two WLarge numbers u and v, using
* the formula LCM(u,v) = (|u*v|)/GCD(u,v).
*
*  @param adsp_u        Pointer to parameter u
*  @param adsp_v        Pointer to parameter v
*  @param adsp_result   Pointer to structure for taking the LCM
*  @return LNUM_OP_OK on success, error code otherwise
*/
int FAST m_lcm_wlnum(HMEM_CTX_DEF
                                   WLNUM * adsp_u, WLNUM * adsp_v,
                                   WLNUM * adsp_result)
{
   WLNUM * adsl_gcd = NULL;
   WLNUM * adsl_div_result = NULL;
   int inl_u_bytesize = GetByteCntWLnum(adsp_u);
   int inl_retcode = LNUM_OP_OK;
   adsl_gcd = AllocNewWLnum(HMEM_CTX_REF1 inl_u_bytesize);
   for(;;){ //simpler error handling
      inl_retcode = GcdWLnum(HMEM_CTX_REF1 adsl_gcd, adsp_u, adsp_v);
      if(inl_retcode != LNUM_OP_OK)
      {
         break;
      }
      adsl_div_result = AllocNewWLnum(HMEM_CTX_REF1 inl_u_bytesize);
      inl_retcode = DivWLnum(HMEM_CTX_REF1 adsl_div_result, NULL,
	      adsp_u, adsl_gcd, NULL); // div_res = u/GCD(u,v)
      if(inl_retcode != LNUM_OP_OK)
      {
         break;
      }
      inl_retcode = MulWLnum(HMEM_CTX_REF1 adsp_result,
         adsl_div_result, adsp_v); // LCM(u,v) = div_res * v
      break;
   }
   FreeWLnum(HMEM_CTX_REF1 adsl_gcd);
   FreeWLnum(HMEM_CTX_REF1 adsl_div_result);
   return inl_retcode;
}
#endif // HL_ENCR_LNUM
// end of 'hoblnum32.c'


#ifdef HL_ENCR_MD
// hobmd2.c
//===========================================================
//
// This file implements the MD2 message digest (hash) algorithm.
// See RFC 1319 for description of algorithm.
// Can be compiled both for C (16 Bit / 32 Bit) and JAVA.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>


/*--------------------------------------------------------------*/
/* MD2 State Structure						*/
/*--------------------------------------------------------------*/

#define MD2_CBLOCK	16		// Blocklength in bytes
#define	MD2_X_ARRAY_LEN	48		// length of Helper array
#define	MD2_ROUNDS	18		// number of rounds
#define MD2_DIGEST_LEN	16		// Number of digest bytes
#define	MD2_ARRAY_SIZE	81		// State Array Size

#define	MD2_data	0				// Array offset
#define	MD2_ChkSum	(MD2_data   + MD2_CBLOCK)	// Array offset n
#define	MD2_X		(MD2_data   + (2*MD2_CBLOCK))	// Array offset 2*n
#define	MD2_DatCnt	(MD2_X      + MD2_X_ARRAY_LEN)	// Array offset 2*n+m



/*--------------------------------------------------------------*/
/* MD2 S-Table							*/
/*--------------------------------------------------------------*/
static unsigned char S[256] = {

  0x29, 0x2E, 0x43, 0xC9, 0xA2, 0xD8, 0x7C, 0x01,
  0x3D, 0x36, 0x54, 0xA1, 0xEC, 0xF0, 0x06, 0x13,
  0x62, 0xA7, 0x05, 0xF3, 0xC0, 0xC7, 0x73, 0x8C,
  0x98, 0x93, 0x2B, 0xD9, 0xBC, 0x4C, 0x82, 0xCA,
  0x1E, 0x9B, 0x57, 0x3C, 0xFD, 0xD4, 0xE0, 0x16,
  0x67, 0x42, 0x6F, 0x18, 0x8A, 0x17, 0xE5, 0x12,
  0xBE, 0x4E, 0xC4, 0xD6, 0xDA, 0x9E, 0xDE, 0x49,
  0xA0, 0xFB, 0xF5, 0x8E, 0xBB, 0x2F, 0xEE, 0x7A,
  0xA9, 0x68, 0x79, 0x91, 0x15, 0xB2, 0x07, 0x3F,
  0x94, 0xC2, 0x10, 0x89, 0x0B, 0x22, 0x5F, 0x21,
  0x80, 0x7F, 0x5D, 0x9A, 0x5A, 0x90, 0x32, 0x27,
  0x35, 0x3E, 0xCC, 0xE7, 0xBF, 0xF7, 0x97, 0x03,
  0xFF, 0x19, 0x30, 0xB3, 0x48, 0xA5, 0xB5, 0xD1,
  0xD7, 0x5E, 0x92, 0x2A, 0xAC, 0x56, 0xAA, 0xC6,
  0x4F, 0xB8, 0x38, 0xD2, 0x96, 0xA4, 0x7D, 0xB6,
  0x76, 0xFC, 0x6B, 0xE2, 0x9C, 0x74, 0x04, 0xF1,
  0x45, 0x9D, 0x70, 0x59, 0x64, 0x71, 0x87, 0x20,
  0x86, 0x5B, 0xCF, 0x65, 0xE6, 0x2D, 0xA8, 0x02,
  0x1B, 0x60, 0x25, 0xAD, 0xAE, 0xB0, 0xB9, 0xF6,
  0x1C, 0x46, 0x61, 0x69, 0x34, 0x40, 0x7E, 0x0F,
  0x55, 0x47, 0xA3, 0x23, 0xDD, 0x51, 0xAF, 0x3A,
  0xC3, 0x5C, 0xF9, 0xCE, 0xBA, 0xC5, 0xEA, 0x26,
  0x2C, 0x53, 0x0D, 0x6E, 0x85, 0x28, 0x84, 0x09,
  0xD3, 0xDF, 0xCD, 0xF4, 0x41, 0x81, 0x4D, 0x52,
  0x6A, 0xDC, 0x37, 0xC8, 0x6C, 0xC1, 0xAB, 0xFA,
  0x24, 0xE1, 0x7B, 0x08, 0x0C, 0xBD, 0xB1, 0x4A,
  0x78, 0x88, 0x95, 0x8B, 0xE3, 0x63, 0xE8, 0x6D,
  0xE9, 0xCB, 0xD5, 0xFE, 0x3B, 0x00, 0x1D, 0x39,
  0xF2, 0xEF, 0xB7, 0x0E, 0x66, 0x58, 0xD0, 0xE4,
  0xA6, 0x77, 0x72, 0xF8, 0xEB, 0x75, 0x4B, 0x0A,
  0x31, 0x44, 0x50, 0xB4, 0x8F, 0xED, 0x1F, 0x1A,
  0xDB, 0x99, 0x8D, 0x33, 0x9F, 0x11, 0x83, 0x14,
};

/*--------------------------------------------------------------*/
/* Subroutine MD2BlockService, processes one complete, saved	*/
/* MD2 Datablock and generates new checksum and X values	*/
/* for the MD2 State Array					*/
/*								*/
/* Input  Parameters:	BIT32 MD2_Array[]	Pointer to MD2	*/
/*						State structure	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  14.10.1998						*/
/* State: 16 Bit: checked o.k.					*/
/*        32 Bit: not yet checked				*/
/*--------------------------------------------------------------*/
static void FAST MD2BlockService(int * MD2_Array)
{
  char  c,l;
  int	i,j,k;
#define pS S

  /*--------------------------------------------------------------------*/
  /* 1. Do checksum Array, load Digest Array X[16+i], X[32+i]		*/
  /*--------------------------------------------------------------------*/
  i = 0;				// Blockbuffer start index
  j = MD2_X;				// X-Array Index Start
  k = MD2_ChkSum;			// Checksum Index Start
  l = (char) MD2_Array[MD2_ChkSum+MD2_CBLOCK-1]; // get continuation for chks.
  do
  {
    c =  (char) MD2_Array[i];		// get Databyte
    MD2_Array[j+16] = (int) c & 0x0FF;	// save digest

// NOTE: INTEL Compiler mixes up index j in the following statement!!
//    MD2_Array[j+32] = (BIT32)		// dto.
//      (c ^ (BIT8) MD2_Array[j++]) & 0xFF;

// Next 2 unrolled statements work correct with Intel Compiler...
    MD2_Array[j+32] = (int)		// dto.
      (c ^ (char) MD2_Array[j]) & 0x0FF;
    j++;

    MD2_Array[k] ^=
     (int) pS[(c ^ l) & 0xFF] & 0xFF;// get new checksum byte

    l = (char) MD2_Array[k++];		// save for processing
    i++;
  } while(i != MD2_CBLOCK);
  /*--------------------------------------------------------------------*/
  /* 2. Calculate new digest values X[i], do 18 rounds			*/
  /*--------------------------------------------------------------------*/
  l = 0;
  i = 0;
  do
  {
    j = MD2_X_ARRAY_LEN;			// total length of X-Array
    k = MD2_X;					// StartIndex X-Array
    do
    {
      MD2_Array[k] ^= (int)
        pS[(l & 0xFF)] & 0xFF;		// shuffle X-Array

      l = (char) MD2_Array[k++];		// save
      j--;
    }while(j != 0);
    l = (char)(l +(char) (i & 0xFF));		// modify value (!!)
    i++;
  } while(i != MD2_ROUNDS);
}
/****************************************************************/
/* Subroutine MD2_Init, initializes Startvalues needed for	*/
/* MD2 processing (i.e. portions of the MD2-State Array		*/
/*								*/
/* Input  Parameters:	BIT32 MD2_Array[]	Pointer to MD2	*/
/*						State Array	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  14.10.1998						*/
/* State: 16 Bit: checked o.k.					*/
/*        32 Bit: not yet checked				*/
/****************************************************************/
void FAST MD2_Init(int * MD2_Array)
{
  int i,j;

  MD2_Array[MD2_DatCnt] = 0;			// no data in block buffer

  j = MD2_X;					// StartIndex  X-Array buffer
  for (i=MD2_X_ARRAY_LEN;i>0;i--)		// Initialize X-Array with 0
    MD2_Array[j++] = 0;
  j = MD2_ChkSum;				// StartIndex Checksum buffer
  for (i=MD2_CBLOCK;i>0;i--)			// Initialize CheckSum with 0
    MD2_Array[j++] = 0;
}
/****************************************************************/
/* Subroutine MD2_Update, processes given data to generate	*/
/* new MD2 digest. This is done by loading the data into the	*/
/* helper buffer (in the state array) until an entire MD2 block	*/
/* is filled and then processing that MD2 block (from the MD2	*/
/* State Array).						*/
/*								*/
/* NOTE: length of data must be <= 0x7FFFFFFF to avoid		*/
/*       overflow						*/
/*								*/
/* Input  Parameters:	BIT32 MD2_Array[]	Pointer to MD2	*/
/*						State Array	*/
/*			BIT8  data[]		Data Buffer	*/
/*			int   Offset		StartIndex into	*/
/*						DataBuffer	*/
/*			BIT32 len		Length of data	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  14.10.1998						*/
/* State: 16 Bit: checked o.k.					*/
/*        32 Bit: not yet checked				*/
/****************************************************************/
void FAST MD2_Update(int * MD2_Array, char * data, int Offset, int len)
{
  int i;
  int nFill,nIndex,nCopy;
  int nCharIndex;

  if (len == 0) return;				// nothing to do
  /*--------------------------------------------------------------------*/
  /* set buffer indices/DataCount (note: buffer starts at index 0)	*/
  /*--------------------------------------------------------------------*/
  nIndex = (int) MD2_Array[MD2_DatCnt];
  nCharIndex = Offset;
  /*------------------------------------------------------------*/
  /* process input data using block buffer			*/
  /*------------------------------------------------------------*/
  do
  {
    /*----------------------------------------------------------*/
    /* copy data to blockbuffer until filled or data exhausted	*/
    /*----------------------------------------------------------*/
    nFill = MD2_CBLOCK - (int) MD2_Array[MD2_DatCnt];//number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((int) nFill) > len)  nCopy = (int) len; // reduce copy count
    for(i=nCopy;i>0;i--)
    {
      MD2_Array[nIndex++] =
        (int) data[nCharIndex++] & 0x0FF;	// copy bytes to buffer
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD2_Array[MD2_DatCnt] += nCopy;		// save byte count, no sign
						// change should occur !!
      return;					// exit, no complete buffer...
    }
    nIndex = 0;					// back to Block Buffer start
    MD2_Array[MD2_DatCnt] = 0;			// preset Block Buf. processed
    /*----------------------------------------------------------*/
    /* process blockbuffer to generate new portion of digest	*/
    /*----------------------------------------------------------*/
    MD2BlockService(MD2_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);				// continue until data end
}
/****************************************************************/
/* Subroutine MD2_Final, pads remaining Block buffer data and	*/
/* appends message checksum. Processes last block and stores	*/
/* message digest						*/
/*								*/
/* NOTE: by definition of previous functions, the block buffer	*/
/* has at least one free byte (otherwise the blockbuffer would	*/
/* have been processed in the UPDATE step !!!)			*/
/*								*/
/* I.   Append padding to block according to size		*/
/* II.  Process block						*/
/* III. Copy Checksum to Blockbuffer				*/
/* VI.  process last (checksum) block, store message digest	*/
/*								*/
/* Input  Parameters:	BIT32 MD2_Array[]	Pointer to MD2	*/
/*						State Array	*/
/*			BIT8 Digest[]		Digest Buffer	*/
/*			int   Offset		StartIndex into	*/
/*						Digest Buffer	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  14.10.1998						*/
/* State: 16 Bit: checked o.k.					*/
/*        32 Bit: not yet checked				*/
/****************************************************************/
void FAST MD2_Final(int * MD2_Array, char * Digest, int Offset)
{
  int i,j,nPadding;

  int nIndex = (int) MD2_Array[MD2_DatCnt];

  /*----------------------------------------------------*/
  /* calculate padding length (is definitely <> 0),	*/
  /* append padding (value of 'missing' bytes),		*/
  /* process block					*/
  /*----------------------------------------------------*/
  nPadding = MD2_CBLOCK-nIndex;			// get padding count/value
  j = nIndex;
  for(i=nPadding;i>0;i--)			// pad buffer with Constant
    MD2_Array[j++] = (int) nPadding;
  MD2BlockService(MD2_Array);			// generate digest portion
  /*------------------------------------------------------*/
  /* copy Checksum to Blockbuffer, process that last block*/
  /*------------------------------------------------------*/
  j = 0;					// StartIndex of Blockbuffer
  for(i=MD2_CBLOCK;i>0;i--)			// copy checksum to Blockbuffer
  {
    MD2_Array[j] = MD2_Array[MD2_ChkSum+j];
    j++;
  }
  MD2BlockService(MD2_Array);			// generate digest portion
  /*----------------------------------------------------*/
  /* store message digest into user supplied buffer	*/
  /*----------------------------------------------------*/
  j = 0;					// StartIndex for Copy
  for(i=MD2_DIGEST_LEN;i>0;i--)  		// copy the final digest
  {
    Digest[j+Offset] = (char) MD2_Array[MD2_X + j];
    j++;
  }
}
#endif // HL_ENCR_MD
// end of 'hobmd2.c'


#ifdef HL_ENCR_MD
// hobmd4.c
//===========================================================
//
// This file implements the MD4 message digest (hash) algorithm.
// See 'Applied Cryptography' / RFC 1321 for description of algorithm.
// Can be compiled both for C (16 Bit / 32 Bit) and JAVA.
//
//===========================================================

#ifdef WIN32
#define	FAST	_fastcall
#else
#define	FAST
#endif


//---------------------------------------------------
// Constants
//---------------------------------------------------

#define INIT_A 0x67452301
#define INIT_B 0xefcdab89
#define INIT_C 0x98badcfe
#define INIT_D 0x10325476

//---------------------------------------------------
// Macros
//---------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (int) *((int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (int) *((int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#if defined WIN64

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0x0FF) << 24) |\
            (((int) c[i+2] & 0x0FF) << 16) |\
            (((int) c[i+1] & 0x0FF) << 8)  |\
            ((int)  c[i  ] & 0x0FF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0x0FF) << 24) |\
            (((int) c[i+2] & 0x0FF) << 16) |\
            (((int) c[i+1] & 0x0FF) << 8)  |\
            ((int)  c[i  ] & 0x0FF);

#else // JAVA, Solaris etc

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0x0FF) << 24) |\
            (((int) c[i+2] & 0x0FF) << 16) |\
            (((int) c[i+1] & 0x0FF) << 8)  |\
            ((int)  c[i  ] & 0x0FF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0x0FF) << 24) |\
            (((int) c[i+2] & 0x0FF) << 16) |\
            (((int) c[i+1] & 0x0FF) << 8)  |\
            ((int)  c[i  ] & 0x0FF);
#endif
#endif


#define char2longcx(c,l,n,i) \
 { \
   l = 0;\
   switch (n) \
   { \
     case 0: l = ((int) c[i+3] & 0x0FF) << 24;\
     case 3: l|= ((int) c[i+2] & 0x0FF) << 16;\
     case 2: l|= ((int) c[i+1] & 0x0FF) <<  8;\
     case 1: l|= ((int) c[i  ] & 0x0FF);\
   } \
   if(n == 0) i += 4;\
   else i += n;\
}	

#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#if defined WIN64

#define long2char(l,c,i) c[i]   = (char) (l);\
                         c[i+1] = (char) (l>> 8);\
                         c[i+2] = (char) (l>>16);\
                         c[i+3] = (char) (l>>24);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l);\
                          c[i+1] = (char) (l>> 8);\
                          c[i+2] = (char) (l>>16);\
                          c[i+3] = (char) (l>>24);

#else // JAVA, SOLARIS etc


#define long2char(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                         c[i+1] = (char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (char) ((l>>16) & 0x0FF);\
                         c[i+3] = (char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                          c[i+1] = (char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (char) ((l>>16) & 0x0FF);\
                          c[i+3] = (char) ((l>>24) & 0x0FF);
#endif
#endif


/*--------------------------------------------------------------*/
/* BIT64 Addition (32/32 Bit + 32 Bit)				*/
/*--------------------------------------------------------------*/
#define ADD_64(SumMsw, SumLsw, Summand) \
  if((unsigned int) SumLsw > \
     ((unsigned int) SumLsw + (unsigned int) Summand)) SumMsw++; \
  SumLsw += Summand;



#if defined WIN32 || defined WIN64
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);

#define LROTATE(a,n)     _lrotl(a,n)
#define RROTATE(a,n)     _lrotr(a,n)

#else // WIN64, SOLARIS, etc

#define LROTATE(a,n)      (((a) << (n)) | \
                         ((((a) >> (32-(n)))) & (0x7FFFFFFF >>(31-n))))

#define RROTATE(a,n)     ((((a) >> (n)) & (0x7FFFFFFF >> (n-1))) | \
                          (((a) << (32-(n))))
#endif



//--------------------------------------------------
#if defined _WIN32_

#define WSWAP(a) (((a & 0xFF) <<8) | ((a & 0xFF00) >> 8))
#define LSWAP(a) (((a & 0xFF) << 24) | ((a & 0xFF00) << 8) |\
                  ((a & 0xFF0000) >> 8) | ((a & 0xFF000000) >> 24))

#else // !defined _WIN32_

#define LSWAP(a) ( \
	((int) (a >> 16) & 0xFFFF ) >> 8 | \
        ((int) (a >> 16) & 0xFFFF) << 8  | \
        (long) (((int) a & 0xFFFF) >> 8) << 16 | \
        (long) ((int) (((int) a & 0xFFFF) << 8) & 0xFFFF) << 16 )


#define WSWAP(a) ( (a >> 8) | ( (int) (a << 8) ) )

#endif // _WIN32_

/*--------------------------------------------------------------*/
/* Functions used in MD4					*/
/*--------------------------------------------------------------*/
//
// original functions F,G,H
//
//#define F(X,Y,Z)	(((X) & (Y)) |  ((~(X)) & (Z)))
//#define G(X,Y,Z)	(((X) & (Y)) | ((X) & (Z)) | ((Y) & (Z)))
//#define H(X,Y,Z)	((X) ^ (Y) ^  (Z))

/* Following simplification taken from SSLEAY for functions F */

#define	F(X,Y,Z)	((((Y) ^ (Z)) & (X)) ^ (Z))
#define G(X,Y,Z)	(((X) & (Y | Z)) | ((Y) & (Z)))
#define	H(X,Y,Z)	((X) ^ (Y) ^ (Z))



#define R1(a,b,c,d,k,s,t) { \
	a += ((k)+(t)+F((b),(c),(d))); \
	a =LROTATE(a,s); };

#define R2(a,b,c,d,k,s,t) { \
	a+=((k)+(t)+G((b),(c),(d))); \
	a =LROTATE(a,s); };

#define R3(a,b,c,d,k,s,t) { \
	a+=((k)+(t)+H((b),(c),(d))); \
	a =LROTATE(a,s); };

/*--------------------------------------------------------------*/
/* MD4 State Structure						*/
/*--------------------------------------------------------------*/
#define MD4_CBLOCK	(512 / 8)	// Blocklength in bytes (64)
#define MD4_LBLOCK	16      	// Blocklength in longs (16)
#define MD4_LAST_BLOCK  (448 / 8)	// Last Block length in bytes (56)
#define MD4_DIGEST_LEN	16		// Number of digest bytes

#define	MD4_data	0			// Array offset
#define	MD4_A		(MD4_data+MD4_LBLOCK)	// Array offset n
#define	MD4_B		(MD4_data+MD4_LBLOCK+1)	// Array offset n+1
#define	MD4_C		(MD4_data+MD4_LBLOCK+2)	// Array offset n+2
#define	MD4_D		(MD4_data+MD4_LBLOCK+3)	// Array offset n+3
#define	MD4_LenL	(MD4_data+MD4_LBLOCK+4)	// Array offset n+4
#define	MD4_LenH	(MD4_data+MD4_LBLOCK+5)	// Array offset n+5
#define	MD4_DatInd	(MD4_data+MD4_LBLOCK+6)	// Array offset n+6
#define	MD4_DatCnt	(MD4_data+MD4_LBLOCK+7)	// Array offset n+7

#define	MD4_ARRAY_SIZE	24		// Array Size (integers)



//--------------------------------------------------------------
// Subroutine MD4BlockService, processes one complete, saved
// MD4 Datablock and generates new values for A,B,C and D
//
// Date:  10.01.2005
// State: 16 Bit: not yet checked
//        32 Bit: not yet checked
//--------------------------------------------------------------
static void FAST MD4BlockService(int * MD4_Array)
{
  int A,B,C,D;

  //------------------------------------------------------
  // Get saved 'Register values'
  //------------------------------------------------------
  A = MD4_Array[MD4_A];
  B = MD4_Array[MD4_B];
  C = MD4_Array[MD4_C];
  D = MD4_Array[MD4_D];
  //-----------------------------------------
  // Process round 1
  //-----------------------------------------
  R1(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0);
  R1(D,A,B,C,MD4_Array[MD4_data + 1], 7, 0);
  R1(C,D,A,B,MD4_Array[MD4_data + 2],11, 0);
  R1(B,C,D,A,MD4_Array[MD4_data + 3],19, 0);

  R1(A,B,C,D,MD4_Array[MD4_data + 4], 3, 0);
  R1(D,A,B,C,MD4_Array[MD4_data + 5], 7, 0);
  R1(C,D,A,B,MD4_Array[MD4_data + 6],11, 0);
  R1(B,C,D,A,MD4_Array[MD4_data + 7],19, 0);

  R1(A,B,C,D,MD4_Array[MD4_data + 8], 3, 0);
  R1(D,A,B,C,MD4_Array[MD4_data + 9], 7, 0);
  R1(C,D,A,B,MD4_Array[MD4_data +10],11, 0);
  R1(B,C,D,A,MD4_Array[MD4_data +11],19, 0);

  R1(A,B,C,D,MD4_Array[MD4_data +12], 3, 0);
  R1(D,A,B,C,MD4_Array[MD4_data +13], 7, 0);
  R1(C,D,A,B,MD4_Array[MD4_data +14],11, 0);
  R1(B,C,D,A,MD4_Array[MD4_data +15],19, 0);
  //-----------------------------------------
  // Process round 2
  //-----------------------------------------
  R2(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0x5A827999);
  R2(D,A,B,C,MD4_Array[MD4_data + 4], 5, 0x5A827999);
  R2(C,D,A,B,MD4_Array[MD4_data + 8], 9, 0x5A827999);
  R2(B,C,D,A,MD4_Array[MD4_data +12],13, 0x5A827999);

  R2(A,B,C,D,MD4_Array[MD4_data + 1], 3, 0x5A827999);
  R2(D,A,B,C,MD4_Array[MD4_data + 5], 5, 0x5A827999);
  R2(C,D,A,B,MD4_Array[MD4_data + 9], 9, 0x5A827999);
  R2(B,C,D,A,MD4_Array[MD4_data +13],13, 0x5A827999);

  R2(A,B,C,D,MD4_Array[MD4_data + 2], 3, 0x5A827999);
  R2(D,A,B,C,MD4_Array[MD4_data + 6], 5, 0x5A827999);
  R2(C,D,A,B,MD4_Array[MD4_data +10], 9, 0x5A827999);
  R2(B,C,D,A,MD4_Array[MD4_data +14],13, 0x5A827999);

  R2(A,B,C,D,MD4_Array[MD4_data + 3], 3, 0x5A827999);
  R2(D,A,B,C,MD4_Array[MD4_data + 7], 5, 0x5A827999);
  R2(C,D,A,B,MD4_Array[MD4_data +11], 9, 0x5A827999);
  R2(B,C,D,A,MD4_Array[MD4_data +15],13, 0x5A827999);
  //-----------------------------------------
  // Process round 3
  //-----------------------------------------
  R3(A,B,C,D,MD4_Array[MD4_data + 0], 3, 0x6ED9EBA1);
  R3(D,A,B,C,MD4_Array[MD4_data + 8], 9, 0x6ED9EBA1);
  R3(C,D,A,B,MD4_Array[MD4_data + 4],11, 0x6ED9EBA1);
  R3(B,C,D,A,MD4_Array[MD4_data +12],15, 0x6ED9EBA1);

  R3(A,B,C,D,MD4_Array[MD4_data + 2], 3, 0x6ED9EBA1);
  R3(D,A,B,C,MD4_Array[MD4_data +10], 9, 0x6ED9EBA1);
  R3(C,D,A,B,MD4_Array[MD4_data + 6],11, 0x6ED9EBA1);
  R3(B,C,D,A,MD4_Array[MD4_data +14],15, 0x6ED9EBA1);

  R3(A,B,C,D,MD4_Array[MD4_data + 1], 3, 0x6ED9EBA1);
  R3(D,A,B,C,MD4_Array[MD4_data + 9], 9, 0x6ED9EBA1);
  R3(C,D,A,B,MD4_Array[MD4_data + 5],11, 0x6ED9EBA1);
  R3(B,C,D,A,MD4_Array[MD4_data +13],15, 0x6ED9EBA1);

  R3(A,B,C,D,MD4_Array[MD4_data + 3], 3, 0x6ED9EBA1);
  R3(D,A,B,C,MD4_Array[MD4_data +11], 9, 0x6ED9EBA1);
  R3(C,D,A,B,MD4_Array[MD4_data + 7],11, 0x6ED9EBA1);
  R3(B,C,D,A,MD4_Array[MD4_data +15],15, 0x6ED9EBA1);
  //-------------------------------------------------
  // Calculate effective new digest 'register' values
  //-------------------------------------------------
  MD4_Array[MD4_A] += A;
  MD4_Array[MD4_B] += B;
  MD4_Array[MD4_C] += C;
  MD4_Array[MD4_D] += D;
}
//================================================================
// Subroutine MD4_Init, initializes Startvalues needed for
// MD4 processing
//
// Input  Parameters:	none
// Output Parameters:	none
//
// Date:  10.01.2005
// State: 16 Bit: not yet checked
//        32 Bit: not yet checked
//================================================================
void FAST MD4_Init(int * MD4_Array)
{
  MD4_Array[MD4_A] = INIT_A;			// initialize 'Register' values
  MD4_Array[MD4_B] = INIT_B;
  MD4_Array[MD4_C] = INIT_C;
  MD4_Array[MD4_D] = INIT_D;
  MD4_Array[MD4_LenL] = 0;			// Total byte length low = 0
  MD4_Array[MD4_LenH] = 0;			// dto. high = 0
  MD4_Array[MD4_DatCnt] = 0;			// no data in block buffer
  MD4_Array[MD4_DatInd] = 0;			// index
}
//===================================================================
// Subroutine MD4_Update, processes given data to generate
// new MD4 digest. This is done by loading the data into the
// helper buffer until an entire MD4 block is filled and then
// processing that MD4 block.
//
// NOTE: length of data must be <= 0x3FFFFFFF to avoid
//       overflow
//
// Input  Parameters:	BIT32  MD4_Array[]	Pointer to MD4
//						State structure
//			BIT8   data[]		Data Buffer
//			int    offset		Start of data
//			BIT32  len		Length of data
// Output Parameters:	none
//
// Date:  10.01.2005
// State: 16 Bit: not yet checked
//        32 Bit: not yet checked
//===================================================================
void FAST MD4_Update(int * MD4_Array, char * data, int offset, int len)
{
  int i,j;
  int nIndex,nlCnt,ncCnt,nCharIndex;
  int l,l1,nFill,nCopy;


  if (len == 0)
    return;					// nothing to do
  //------------------------------------------------------------
  // Add up byte length to get new total byte length
  //------------------------------------------------------------
  l1 = len << 3;				    // get the BIT-Count
  ADD_64(MD4_Array[MD4_LenH],MD4_Array[MD4_LenL],l1); // sum up
  //------------------------------------------------------------
  // get bufferpointers and indices
  //------------------------------------------------------------
  nCharIndex = offset;
  //------------------------------------------------------------
  // process input data using block buffer
  //------------------------------------------------------------
  do
  {
    //----------------------------------------------------------
    // Fill Block buffer if possible
    //----------------------------------------------------------
    nIndex = (int) MD4_Array[MD4_DatInd];	// get current Field index
    //----------------------------------------------------------
    // copy data to blockbuffer until filled or data exhausted
    //----------------------------------------------------------
    j = (int) MD4_Array[MD4_DatCnt] & (int) 0x03;// get fill boundary
    if(j != 0)					// not on a long boundary
    {
      //--------------------------------------------------------
      // must fill up last long value from new data
      //--------------------------------------------------------
      i = (4-j) & 0x03;				// get fill byte count
      if(((int) i) > len)			// check for data end
        i = (int) len;
      MD4_Array[MD4_DatCnt] += i;		// new Byte count
      len -= i;					// reduce data count
      char2longcx(data,l1,i,nCharIndex)		// convert bytes to long
      MD4_Array[nIndex+MD4_data] |= (l1 <<(j*8));// save new long
      if((MD4_Array[MD4_DatCnt] & 0x03) == 0)	// check if long filled
      {
        nIndex++;				// increment index
        MD4_Array[MD4_DatInd]++;		// dto.
      }
      if(len == 0)
      {
        //------------------------------------------------------
        // Data exhausted, check if last byte has been filled
        //------------------------------------------------------
        if(nIndex < MD4_LBLOCK)			// data exhausted, not filled
          return;
        MD4_Array[MD4_DatInd] = 0;	        // buffer filled !
        MD4_Array[MD4_DatCnt] = 0;
        //-------------------------------------------------------
        // process blockbuffer to generate new portion of digest
        //-------------------------------------------------------
        MD4BlockService(MD4_Array);		// generate digest portion
        return;
      }
    }
    //----------------------------------------------------------
    // caclulate remaining elements to fill
    //----------------------------------------------------------
    nFill = MD4_CBLOCK - MD4_Array[MD4_DatCnt];	// number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((int) nFill) > len)
      nCopy = len;				// reduce copy count
    nlCnt = (int) nCopy/4;			// get long elements count
    ncCnt = (int) nCopy & (int) 0x03;		// get remaining bytes
    for(i=nlCnt;i>0;i--)			// long elements copy loop
    {
      char2long(data,l,nCharIndex);		// get long
      MD4_Array[nIndex+MD4_data] = l;		// byte order dep. copy
      nIndex++;
    }
    if(ncCnt != 0)
    {
      char2longcx(data,l1,ncCnt,nCharIndex)	// byte order dependent copy
      MD4_Array[nIndex+MD4_data] = l1;
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD4_Array[MD4_DatInd] = (int) nIndex & 0xFFFF;	// save index
      MD4_Array[MD4_DatCnt] += nCopy;		// save byte count
      return;
    }
    nIndex = 0;					// Buffer is now filled ...
    MD4_Array[MD4_DatInd] = 0;
    MD4_Array[MD4_DatCnt] = 0;
    //----------------------------------------------------------
    // process blockbuffer to generate new portion of digest
    //----------------------------------------------------------
    MD4BlockService(MD4_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);
}
//================================================================
// Subroutine MD4_Final, pads remaining buffer data and
// appends total message bit length (low/high). Processes
// last block(s) and stores message digest
//
// NOTE: by definition of previous functions, the block buffer
// has at least one free byte (otherwise the blockbuffer would
// have been processed in the update step !!!)
//
// Two distinct cases must be considered:
//
// a: Current Block has enough space for padding and length
//    field
//    I.   Insert one-Byte padding with bit 7 <> 0 (80h)
//    II.  Fill Block with zero until Blocklength - LEN Bytes
//    III. Insert total bit-length (low/high, 8 bytes)
//    VI.  process last block, store message digest
//
// b: Last Block remaining length is > required padding and
//    size insertion length:
//    I.   Insert one-Byte padding with bit 7 <> 0 (80h)
//    II.  Fill Block with zero padding
//    III. Process block
//    IV.  Zero next Block until Blocklength - LEN Bytes
//    V.   Insert total bit-length (low/high, 8 bytes)
//    VI.  process last block, store message digest
//
//
// Input  Parameters:	BIT32 MD4_Array		Pointer to MD4
//						State structure
//			BIT8  Digest[]		Digest Buffer
//			int   Offset		StartIndex into
//						Digest Buffer
// Output Parameters:	none
//
// Date:  10.01.2005
// State: 16 Bit: not yet checked
//        32 Bit: not yet checked
//================================================================
void FAST MD4_Final(int * MD4_Array, char * Digest, int Offset)
{
  int i,nPadding;
  int nIndex=MD4_Array[MD4_DatInd];
  //----------------------------------------------------
  // pad with 1st Element
  //----------------------------------------------------
  i = (int) MD4_Array[MD4_DatCnt] & (int) 0x03;	// get start byte pos.
  if(i != 0)
    MD4_Array[nIndex+MD4_data] |=	// append 1st pad. value
      ((int) 0x80 << (i*8));
  else MD4_Array[nIndex+MD4_data] = 0x80;	// dto.
  nIndex++;
  //----------------------------------------------------
  // calculate remaining padding length
  //----------------------------------------------------
  nPadding = (int) (MD4_LAST_BLOCK - MD4_Array[MD4_DatCnt]);// req. padding len
  if(nPadding <= 0)					// last block too large
  {
    nPadding =(int) (MD4_CBLOCK - MD4_Array[MD4_DatCnt]);// true size to pad
    nPadding -= (4-i);				// reduce padding length
    for(i=nPadding/4;i != 0;i--)		// clear rest
    {
      MD4_Array[nIndex+MD4_data] = 0;
      nIndex++;
    }
    MD4BlockService(MD4_Array);			// generate digest portion
    nIndex = 0;					// set buffer bottom
    nPadding = MD4_LAST_BLOCK;			// set remaining padding count
  }
  else						// enough space in last
    nPadding -= (4-i);				// reduce padding length
  //----------------------------------------------------
  // pad rest with zeroes, process block
  //----------------------------------------------------
  for(i=nPadding/4;i != 0;i--)			// clear rest of buffer
  {
    MD4_Array[nIndex+MD4_data] = 0;
    nIndex++;
  }
  MD4_Array[nIndex+MD4_data] = MD4_Array[MD4_LenL];	// append length low
  nIndex++;
  MD4_Array[nIndex+MD4_data] = MD4_Array[MD4_LenH];	// append length high
  MD4BlockService(MD4_Array);			// generate digest
  //----------------------------------------------------
  // store message digest
  //----------------------------------------------------
//  i = 0;					// Start Index
  long2charn(MD4_Array[MD4_A],Digest,Offset)	// get 1st part
  long2charn(MD4_Array[MD4_B],Digest,Offset+4)	// get 2nd part
  long2charn(MD4_Array[MD4_C],Digest,Offset+8)	// get 3rd part
  long2charn(MD4_Array[MD4_D],Digest,Offset+12)// get 4th part
}



#undef char2long
#undef char2longn
#undef char2longcx
#undef long2char
#undef long2charn
#undef ADD_64
#undef LROTATE
#undef RROTATE
#undef WSWAP
#undef LSWAP

#undef F
#undef G
#undef H
#undef R1
#undef R2
#undef R3
#endif // HL_ENCR_MD
// end of 'hobmd4.c'


#ifdef HL_ENCR_MD
// hobmd5.c
//===========================================================
//
// This file implements the MD5 message digest (hash) algorithm.
// See RFC 1321 for description of algorithm.
//
//===========================================================
#include "hob-encry-1.h"

//--------------------------------------------------
// Macros
//--------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#if defined WIN64

#define long2char(l,c,i) c[i]   = (char) (l);\
                         c[i+1] = (char) (l>> 8);\
                         c[i+2] = (char) (l>>16);\
                         c[i+3] = (char) (l>>24);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l);\
                          c[i+1] = (char) (l>> 8);\
                          c[i+2] = (char) (l>>16);\
                          c[i+3] = (char) (l>>24);

#else // JAVA, SOLARIS etc

#define long2char(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                         c[i+1] = (char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (char) ((l>>16) & 0x0FF);\
                         c[i+3] = (char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                          c[i+1] = (char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (char) ((l>>16) & 0x0FF);\
                          c[i+3] = (char) ((l>>24) & 0x0FF);
#endif
#endif


#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (int) *((int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (int) *((int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#if defined WIN64

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);

#else // JAVA, Solaris etc

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);
#endif
#endif

#define char2longcx(c,l,n,i) \
 { \
   l = 0;\
   switch (n) \
   { \
     case 0: l = ((int) c[i+3] & 0x0FF) << 24;\
     case 3: l|= ((int) c[i+2] & 0x0FF) << 16;\
     case 2: l|= ((int) c[i+1] & 0x0FF) << 8;\
     case 1: l|= ((int) c[i  ] & 0x0FF);\
   } \
   if(n == 0) i += 4;\
   else i += n;\
}	

#if defined WIN32 || defined WIN64
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);

#define LROTATE(a,n)     _lrotl(a,n)
#define RROTATE(a,n)     _lrotr(a,n)

#else // WIN64, SOLARIS, etc

#define LROTATE(a,n)      (((a) << (n)) | \
                         ((((a) >> (32-(n)))) & (0x7FFFFFFF >>(31-n))))

#define RROTATE(a,n)     ((((a) >> (n)) & (0x7FFFFFFF >> (n-1))) | \
                          (((a) << (32-(n))))
#endif


/*--------------------------------------------------------------*/
/* BIT64 Addition (32/32 Bit + 32 Bit)				*/
/*--------------------------------------------------------------*/
#define ADD_64(SumMsw, SumLsw, Summand) \
  if((unsigned int) SumLsw > \
     ((unsigned int) SumLsw + (unsigned int) Summand)) SumMsw++; \
  SumLsw += Summand;




/*--------------------------------------------------------------*/
/* Functions used in MD5 from RFC 1321				*/
/*--------------------------------------------------------------*/

#define	F(X,Y,Z)	((((Y) ^ (Z)) & (X)) ^ (Z))
#define	G(X,Y,Z)	((((X) ^ (Y)) & (Z)) ^ (Y))
#define	H(X,Y,Z)	((X) ^ (Y) ^ (Z))
#define	I(X,Y,Z)	(((X) | (~(Z))) ^ (Y))


#define R1(a,b,c,d,k,s,t) { \
	a += ((k)+(t)+F((b),(c),(d))); \
	a =LROTATE(a,s); \
	a += (b); };\

#define R2(a,b,c,d,k,s,t) { \
	a+=((k)+(t)+G((b),(c),(d))); \
	a =LROTATE(a,s); \
	a+=b; };

#define R3(a,b,c,d,k,s,t) { \
	a+=((k)+(t)+H((b),(c),(d))); \
	a =LROTATE(a,s); \
	a+=b; };

#define R4(a,b,c,d,k,s,t) { \
	a+=((k)+(t)+I((b),(c),(d))); \
	a =LROTATE(a,s); \
	a+=b; };


/* Implemented from RFC1321: MD5 Message-Digest Algorithm	*/
/* Note: All Long values are treated as beeing stored in 	*/
/* ----- BIG ENDIAN Format according to RFC1321			*/

#define INIT_A 0x67452301
#define INIT_B 0xefcdab89
#define INIT_C 0x98badcfe
#define INIT_D 0x10325476


/*--------------------------------------------------------------*/
/* MD5 State Structure						*/
/*--------------------------------------------------------------*/
#define MD5_CBLOCK	(512 / 8)	// Blocklength in bytes (64)
#define MD5_LBLOCK	16      	// Blocklength in longs (16)
#define MD5_LAST_BLOCK  (448 / 8)	// Last Block length in bytes (56)
#define MD5_DIGEST_LEN	16		// Number of digest bytes
#define MD5_ARRAY_SIZE	24		// State Array Size (integers)

#define	MD5_data	0			// Array offset
#define	MD5_A		(MD5_data+MD5_LBLOCK)	// Array offset n
#define	MD5_B		(MD5_data+MD5_LBLOCK+1)	// Array offset n+1
#define	MD5_C		(MD5_data+MD5_LBLOCK+2)	// Array offset n+2
#define	MD5_D		(MD5_data+MD5_LBLOCK+3)	// Array offset n+3
#define	MD5_LenL	(MD5_data+MD5_LBLOCK+4)	// Array offset n+4
#define	MD5_LenH	(MD5_data+MD5_LBLOCK+5)	// Array offset n+5
#define	MD5_DatInd	(MD5_data+MD5_LBLOCK+6)	// Array offset n+6
#define	MD5_DatCnt	(MD5_data+MD5_LBLOCK+7)	// Array offset n+7



/*--------------------------------------------------------------*/
/* Subroutine MD5BlockService, processes one complete, saved	*/
/* MD5 Datablock and generates new values for A,B,C and D	*/
/*								*/
/* Date:  04.06.1998						*/
/*--------------------------------------------------------------*/
void FAST MD5BlockService(int * MD5_Array)
{
  int A,B,C,D;

  /*--------------------------------------------------------------------*/
  /* Get saved 'Register values'					*/
  /*--------------------------------------------------------------------*/
  A = MD5_Array[MD5_A];
  B = MD5_Array[MD5_B];
  C = MD5_Array[MD5_C];
  D = MD5_Array[MD5_D];
  /*--------------------------------------------------------------------*/
  /* Process round 1							*/
  /*--------------------------------------------------------------------*/
  R1(A,B,C,D,MD5_Array[MD5_data + 0], 7,0xd76aa478);
  R1(D,A,B,C,MD5_Array[MD5_data + 1],12,0xe8c7b756);
  R1(C,D,A,B,MD5_Array[MD5_data + 2],17,0x242070db);
  R1(B,C,D,A,MD5_Array[MD5_data + 3],22,0xc1bdceee);
  R1(A,B,C,D,MD5_Array[MD5_data + 4], 7,0xf57c0faf);
  R1(D,A,B,C,MD5_Array[MD5_data + 5],12,0x4787c62a);
  R1(C,D,A,B,MD5_Array[MD5_data + 6],17,0xa8304613);
  R1(B,C,D,A,MD5_Array[MD5_data + 7],22,0xfd469501);
  R1(A,B,C,D,MD5_Array[MD5_data + 8], 7,0x698098d8);
  R1(D,A,B,C,MD5_Array[MD5_data + 9],12,0x8b44f7af);
  R1(C,D,A,B,MD5_Array[MD5_data +10],17,0xffff5bb1);
  R1(B,C,D,A,MD5_Array[MD5_data +11],22,0x895cd7be);
  R1(A,B,C,D,MD5_Array[MD5_data +12], 7,0x6b901122);
  R1(D,A,B,C,MD5_Array[MD5_data +13],12,0xfd987193);
  R1(C,D,A,B,MD5_Array[MD5_data +14],17,0xa679438e);
  R1(B,C,D,A,MD5_Array[MD5_data +15],22,0x49b40821);
  /*--------------------------------------------------------------------*/
  /* Process round 2							*/
  /*--------------------------------------------------------------------*/
  R2(A,B,C,D,MD5_Array[MD5_data + 1], 5,0xf61e2562);
  R2(D,A,B,C,MD5_Array[MD5_data + 6], 9,0xc040b340);
  R2(C,D,A,B,MD5_Array[MD5_data +11],14,0x265e5a51);
  R2(B,C,D,A,MD5_Array[MD5_data + 0],20,0xe9b6c7aa);
  R2(A,B,C,D,MD5_Array[MD5_data + 5], 5,0xd62f105d);
  R2(D,A,B,C,MD5_Array[MD5_data +10], 9,0x02441453);
  R2(C,D,A,B,MD5_Array[MD5_data +15],14,0xd8a1e681);
  R2(B,C,D,A,MD5_Array[MD5_data + 4],20,0xe7d3fbc8);
  R2(A,B,C,D,MD5_Array[MD5_data + 9], 5,0x21e1cde6);
  R2(D,A,B,C,MD5_Array[MD5_data +14], 9,0xc33707d6);
  R2(C,D,A,B,MD5_Array[MD5_data + 3],14,0xf4d50d87);
  R2(B,C,D,A,MD5_Array[MD5_data + 8],20,0x455a14ed);
  R2(A,B,C,D,MD5_Array[MD5_data +13], 5,0xa9e3e905);
  R2(D,A,B,C,MD5_Array[MD5_data + 2], 9,0xfcefa3f8);
  R2(C,D,A,B,MD5_Array[MD5_data + 7],14,0x676f02d9);
  R2(B,C,D,A,MD5_Array[MD5_data +12],20,0x8d2a4c8a);
  /*--------------------------------------------------------------------*/
  /* Process round 3							*/
  /*--------------------------------------------------------------------*/
  R3(A,B,C,D,MD5_Array[MD5_data + 5], 4,0xfffa3942);
  R3(D,A,B,C,MD5_Array[MD5_data + 8],11,0x8771f681);
  R3(C,D,A,B,MD5_Array[MD5_data +11],16,0x6d9d6122);
  R3(B,C,D,A,MD5_Array[MD5_data +14],23,0xfde5380c);
  R3(A,B,C,D,MD5_Array[MD5_data + 1], 4,0xa4beea44);
  R3(D,A,B,C,MD5_Array[MD5_data + 4],11,0x4bdecfa9);
  R3(C,D,A,B,MD5_Array[MD5_data + 7],16,0xf6bb4b60);
  R3(B,C,D,A,MD5_Array[MD5_data +10],23,0xbebfbc70);
  R3(A,B,C,D,MD5_Array[MD5_data +13], 4,0x289b7ec6);
  R3(D,A,B,C,MD5_Array[MD5_data + 0],11,0xeaa127fa);
  R3(C,D,A,B,MD5_Array[MD5_data + 3],16,0xd4ef3085);
  R3(B,C,D,A,MD5_Array[MD5_data + 6],23,0x04881d05);
  R3(A,B,C,D,MD5_Array[MD5_data + 9], 4,0xd9d4d039);
  R3(D,A,B,C,MD5_Array[MD5_data +12],11,0xe6db99e5);
  R3(C,D,A,B,MD5_Array[MD5_data +15],16,0x1fa27cf8);
  R3(B,C,D,A,MD5_Array[MD5_data + 2],23,0xc4ac5665);
  /*--------------------------------------------------------------------*/
  /* Process round 4							*/
  /*--------------------------------------------------------------------*/
  R4(A,B,C,D,MD5_Array[MD5_data + 0], 6,0xf4292244);
  R4(D,A,B,C,MD5_Array[MD5_data + 7],10,0x432aff97);
  R4(C,D,A,B,MD5_Array[MD5_data +14],15,0xab9423a7);
  R4(B,C,D,A,MD5_Array[MD5_data + 5],21,0xfc93a039);
  R4(A,B,C,D,MD5_Array[MD5_data +12], 6,0x655b59c3);
  R4(D,A,B,C,MD5_Array[MD5_data + 3],10,0x8f0ccc92);
  R4(C,D,A,B,MD5_Array[MD5_data +10],15,0xffeff47d);
  R4(B,C,D,A,MD5_Array[MD5_data + 1],21,0x85845dd1);
  R4(A,B,C,D,MD5_Array[MD5_data + 8], 6,0x6fa87e4f);
  R4(D,A,B,C,MD5_Array[MD5_data +15],10,0xfe2ce6e0);
  R4(C,D,A,B,MD5_Array[MD5_data + 6],15,0xa3014314);
  R4(B,C,D,A,MD5_Array[MD5_data +13],21,0x4e0811a1);
  R4(A,B,C,D,MD5_Array[MD5_data + 4], 6,0xf7537e82);
  R4(D,A,B,C,MD5_Array[MD5_data +11],10,0xbd3af235);
  R4(C,D,A,B,MD5_Array[MD5_data + 2],15,0x2ad7d2bb);
  R4(B,C,D,A,MD5_Array[MD5_data + 9],21,0xeb86d391);
  /*--------------------------------------------------------------------*/
  /* Calculate effective new digest 'register' values			*/
  /*--------------------------------------------------------------------*/
  MD5_Array[MD5_A] += A;
  MD5_Array[MD5_B] += B;
  MD5_Array[MD5_C] += C;
  MD5_Array[MD5_D] += D;
}
/****************************************************************/
/* Subroutine MD5_Init, initializes Startvalues needed for	*/
/* MD5 processing						*/
/*								*/
/* Input  Parameters:	none					*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  04.06.1998						*/
/****************************************************************/
void FAST MD5_Init(int * MD5_Array)
{
  MD5_Array[MD5_A] = INIT_A;			// initialize 'Register' values
  MD5_Array[MD5_B] = INIT_B;
  MD5_Array[MD5_C] = INIT_C;
  MD5_Array[MD5_D] = INIT_D;
  MD5_Array[MD5_LenL] = 0;			// Total byte length low = 0
  MD5_Array[MD5_LenH] = 0;			// dto. high = 0
  MD5_Array[MD5_DatCnt] = 0;			// no data in block buffer
  MD5_Array[MD5_DatInd] = 0;			// index
}
/****************************************************************/
/* Subroutine MD5_Update, processes given data to generate	*/
/* new MD5 digest. This is done by loading the data into the	*/
/* helper buffer until an entire MD5 block is filled and then	*/
/* processing that MD5 block.					*/
/*								*/
/* NOTE: length of data must be <= 0x3FFFFFFF to avoid		*/
/*       overflow						*/
/*								*/
/* Input  Parameters:	BIT32  MD5_Array[]	Pointer to MD5	*/
/*						State structure	*/
/*			BIT8   data[]		Data Buffer	*/
/*			int    offset		Start of data	*/
/*						usually 0, used	*/
/*						in MD5RAND	*/
/*			BIT32  len		Length of data	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  04.06.1998						*/
/****************************************************************/
void FAST MD5_Update(int * MD5_Array, char * data, int offset, int len)
{
  int i,j;
  int nIndex,nlCnt,ncCnt,nCharIndex;
  int l,l1,nFill,nCopy;


  if (len == 0) return;				// nothing to do
  /*------------------------------------------------------------*/
  /* Add up byte length to get new total byte length		*/
  /*------------------------------------------------------------*/
  l1 = len << 3;				    // get the BIT-Count
  ADD_64(MD5_Array[MD5_LenH],MD5_Array[MD5_LenL],l1); // sum up
  /*------------------------------------------------------------*/
  /* get bufferpointers and indices				*/
  /*------------------------------------------------------------*/
  nCharIndex = offset;
  /*------------------------------------------------------------*/
  /* process input data using block buffer			*/
  /*------------------------------------------------------------*/
  do
  {
    /*----------------------------------------------------------*/
    /* Fill Block buffer if possible				*/
    /*----------------------------------------------------------*/
    nIndex = (int) MD5_Array[MD5_DatInd];	// get current Field index
    /*----------------------------------------------------------*/
    /* copy data to blockbuffer until filled or data exhausted	*/
    /*----------------------------------------------------------*/
    j = (int) MD5_Array[MD5_DatCnt] & (int) 0x03;// get fill boundary
    if(j != 0)					// not on a long boundary
    {
      /*--------------------------------------------------------*/
      /* must fill up last long value from new data		*/
      /*--------------------------------------------------------*/
      i = (4-j) & 0x03;				// get fill byte count
      if(((int) i) > len) i = (int) len;	// check for data end
      MD5_Array[MD5_DatCnt] += i;		// new Byte count
      len -= i;					// reduce data count
      char2longcx(data,l1,i,nCharIndex)		// convert bytes to long
      MD5_Array[nIndex+MD5_data] |= (l1 <<(j*8));// save new long
      if((MD5_Array[MD5_DatCnt] & 0x03) == 0)	// check if long filled
      {
        nIndex++;				// increment index
        MD5_Array[MD5_DatInd]++;		// dto.
      }
      if(len == 0)
      {
        /*------------------------------------------------------*/
        /* Data exhausted, check if last byte has been filled	*/
        /*------------------------------------------------------*/
        if(nIndex < MD5_LBLOCK) return;		// data exhausted, not filled
        MD5_Array[MD5_DatInd] = 0;	        // buffer filled !
        MD5_Array[MD5_DatCnt] = 0;
        /*-------------------------------------------------------*/
        /* process blockbuffer to generate new portion of digest */
        /*-------------------------------------------------------*/
        MD5BlockService(MD5_Array);		// generate digest portion
        return;
      }
    }
    /*----------------------------------------------------------*/
    /* caclulate remaining elements to fill			*/
    /*----------------------------------------------------------*/
    nFill = MD5_CBLOCK - MD5_Array[MD5_DatCnt];	// number of bytes required
    nCopy = nFill;				// preset bytes to copy
    if(((int) nFill) > len)  nCopy = len;	// reduce copy count
    nlCnt = (int) nCopy/4;			// get long elements count
    ncCnt = (int) nCopy & (int) 0x03;		// get remaining bytes
    for(i=nlCnt;i>0;i--)			// long elements copy loop
    {
      char2long(data,l,nCharIndex);		// get long
      MD5_Array[nIndex+MD5_data] = l;		// byte order dep. copy
      nIndex++;
    }
    if(ncCnt != 0)
    {
      char2longcx(data,l1,ncCnt,nCharIndex)	// byte order dependent copy
      MD5_Array[nIndex+MD5_data] = l1;
    }
    if(nCopy < nFill)				// not enough data, exit
    {
      MD5_Array[MD5_DatInd] = (int) nIndex & 0x0FFFF;	// save index
      MD5_Array[MD5_DatCnt] += nCopy;		// save byte count
      return;
    }
    nIndex = 0;					// Buffer is now filled ...
    MD5_Array[MD5_DatInd] = 0;
    MD5_Array[MD5_DatCnt] = 0;
    /*----------------------------------------------------------*/
    /* process blockbuffer to generate new portion of digest	*/
    /*----------------------------------------------------------*/
    MD5BlockService(MD5_Array);			// generate digest portion
    len -= nFill;				// reduce remaining data count
  } while (len != 0);
}
/****************************************************************/
/* Subroutine MD5_Final, pads remaining buffer data and		*/
/* appends total message bit length (low/high). Processes	*/
/* last block(s) and stores message digest			*/
/*								*/
/* NOTE: by definition of previous functions, the block buffer	*/
/* has at least one free byte (otherwise the blockbuffer would	*/
/* have been processed in the update step !!!)			*/
/*								*/
/* Two distinct cases must be considered:			*/
/*								*/
/* a: Current Block has enough space for padding and length	*/
/*    field							*/
/*    I.   Insert one-Byte padding with bit 7 <> 0 (80h)	*/
/*    II.  Fill Block with zero until Blocklength - LEN Bytes	*/
/*    III. Insert total bit-length (low/high, 8 bytes)		*/
/*    VI.  process last block, store message digest		*/
/*								*/
/* b: Last Block remaining length is > required padding and	*/
/*    size insertion length:					*/
/*    I.   Insert one-Byte padding with bit 7 <> 0 (80h)	*/
/*    II.  Fill Block with zero padding				*/
/*    III. Process block					*/
/*    IV.  Zero next Block until Blocklength - LEN Bytes	*/
/*    V.   Insert total bit-length (low/high, 8 bytes)		*/
/*    VI.  process last block, store message digest		*/
/*								*/
/*								*/
/* Input  Parameters:	BIT32 MD5_Array		Pointer to MD5	*/
/*						State structure	*/
/*			BIT8  Digest[]		Digest Buffer	*/
/*			int   Offset		StartIndex into	*/
/*						Digest Buffer	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  04.06.1998						*/
/****************************************************************/
void FAST MD5_Final(int * MD5_Array, char * Digest, int Offset)
{
  int i,nPadding;
  int nIndex=MD5_Array[MD5_DatInd];

  /*----------------------------------------------------*/
  /* pad with 1st Element				*/
  /*----------------------------------------------------*/
  i = (int) MD5_Array[MD5_DatCnt] & (int) 0x03;	// get start byte pos.
  if(i != 0) MD5_Array[nIndex+MD5_data] |=	// append 1st pad. value
    ((int) 0x80 << (i*8));
  else MD5_Array[nIndex+MD5_data] = 0x80;	// dto.
  nIndex++;
  /*----------------------------------------------------*/
  /* calculate remaining padding length			*/
  /*----------------------------------------------------*/
  nPadding = (int) (MD5_LAST_BLOCK - MD5_Array[MD5_DatCnt]);// req. padding len
  if(nPadding <= 0)					// last block too large
  {
    nPadding =(int) (MD5_CBLOCK - MD5_Array[MD5_DatCnt]);// true size to pad
    nPadding -= (4-i);				// reduce padding length
    for(i=nPadding/4;i != 0;i--)		// clear rest
    {
      MD5_Array[nIndex+MD5_data] = 0;
      nIndex++;
    }
    MD5BlockService(MD5_Array);			// generate digest portion
    nIndex = 0;					// set buffer bottom
    nPadding = MD5_LAST_BLOCK;			// set remaining padding count
  }
  else						// enough space in last
    nPadding -= (4-i);				// reduce padding length
  /*----------------------------------------------------*/
  /* pad rest with zeroes, process block		*/
  /*----------------------------------------------------*/
  for(i=nPadding/4;i != 0;i--)			// clear rest of buffer
  {
    MD5_Array[nIndex+MD5_data] = 0;
    nIndex++;
  }
  MD5_Array[nIndex+MD5_data] = MD5_Array[MD5_LenL];	// append length low
  nIndex++;
  MD5_Array[nIndex+MD5_data] = MD5_Array[MD5_LenH];	// append length high
  MD5BlockService(MD5_Array);			// generate digest
  /*----------------------------------------------------*/
  /* store message digest				*/
  /*----------------------------------------------------*/
//  i = 0;					// Start Index
  long2charn(MD5_Array[MD5_A],Digest,Offset)	// get 1st part
  long2charn(MD5_Array[MD5_B],Digest,Offset+4)	// get 2nd part
  long2charn(MD5_Array[MD5_C],Digest,Offset+8)	// get 3rd part
  long2charn(MD5_Array[MD5_D],Digest,Offset+12)// get 4th part
}

#undef long2char
#undef long2charn
#undef char2long
#undef char2longn
#undef char2longcx
#undef LROTATE
#undef RROTATE
#undef ADD_64
#undef F
#undef G
#undef H
#undef I
#undef R1
#undef R2
#undef R3
#undef R4
#endif // HL_ENCR_MD
// end of 'hobmd5.c'


// hobmmgr.c
//***********************************************************
//
// Memory management functions for internal memory manager
// - Small/Medium block manager functions
// - Allocation/free routines through pointer
//
//***********************************************************
#include <hob-encry-1.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

//#define	DISABLE_MEMMGR
//#define	DISABLE_MANAGED_BUFFERS

//#define __XHMEM_DEBUG__
//#define __HMEMMGR_DEBUG__
//#define __HPOOLMGR_DEBUG__


#if defined DISABLE_MEMMGR
#if defined WIN32 || defined WIN64 || defined EM64T
#pragma message("MEM-Manager disabled!")
#endif // WIN32/64
#endif

#if defined DISABLE_MANAGED_BUFFERS
#if defined WIN32 || defined WIN64 || defined EM64T
#pragma message("Small buffer MEM-Manager disabled!")
#endif // WIN32/64
#endif


#if defined __HMEMMGR_DEBUG__ || defined __HPOOLMGR_DEBUG__
static int img_pool_count = 0;
#endif



//-------------------------------------------------
// Returncodes
//-------------------------------------------------
#define	HMEM_OP_OK	0
#define	HMEM_NULL_PTR	-1
#define	HMEM_PARAM_ERR	-2
#define	HMEM_ALLOC_ERR	-3


//-------------------------------------------------
// Allocation sizes
//-------------------------------------------------
//#define __HMEM_DEBUG__	// TEST TEST TEST

#define	HMEM_MAX_MANAGED_BUF_SIZE	512

#if !defined __HMEM_DEBUG__

#define	HMEM_DEFAULT_16BYTE_BLOCKS	256
#define	HMEM_DEFAULT_32BYTE_BLOCKS	 64
#define	HMEM_DEFAULT_64BYTE_BLOCKS	 32
#define	HMEM_DEFAULT_256BYTE_BLOCKS	 32
#define	HMEM_DEFAULT_512BYTE_BLOCKS	 32

#else // defined __HMEM_DEGUG__

#define	HMEM_DEFAULT_16BYTE_BLOCKS	 64
#define	HMEM_DEFAULT_32BYTE_BLOCKS	 32
#define	HMEM_DEFAULT_64BYTE_BLOCKS	 32
#define	HMEM_DEFAULT_256BYTE_BLOCKS	 32
#define	HMEM_DEFAULT_512BYTE_BLOCKS	 32

#endif


#define	DEFAULT_HMEM_POOL_SIZE		1024
#define	DEFAULT_HMEM_POOL_COUNT		4

#define	ALIGN_SIZE	16


#if !defined FALSE
#define	FALSE	0
#define	TRUE	1
#endif


#if !defined    DEF_AUX_MEMGET
#define DEF_AUX_MEMGET  0
#endif

#if !defined    DEF_AUX_MEMFREE
#define DEF_AUX_MEMFREE 1
#endif


#define	HMEM_LOCKED_STRUC_FLAG_BIT		0x01	// is locked
#define	HMEM_NO_POOLS_FLAG_BIT			0x02	// do not use pools
#define	HMEM_STRUC_LOCAL_FLAG_BIT		0x04	// is local struc


//---------------------------------------------------------
// Memory block management structure
// Note: Allocation bit array and buffer will be allocated
// ----- together with the header structure (C-Version)
//---------------------------------------------------------
typedef struct HMEMHDR_t {
  struct HMEMHDR_t * pNextMemHdr;	// pointer to next structure
  int	BlockSize;			// size of blocks managed
  int	BlockCount;			// number of blocks managed
  int	MaxUsedCount;			// number of buffers used
  int   ActUsedCount;			// actual in use count
  char * pBufStart;			// Starting Address of buffer
  char * pBufEnd;			// Last address of buffer (byte)
  int * pUsedBlockBitArray;		// start of array of block used bits
} HMEMHDR;
//---------------------------------------------------------
// Memory management link structure
//---------------------------------------------------------
typedef struct HMEMDESC_t {
  HMEMHDR *	pMemCtlAnchor16Byte;	// 16 byte blocks list  (256, 4kB)
  HMEMHDR *	pMemCtlAnchor32Byte;	// 32 byte blocks list  (64,  2kB)
  HMEMHDR *	pMemCtlAnchor64Byte;	// 64 byte blocks list  (32,  2kB)
  HMEMHDR *	pMemCtlAnchor256Byte;	// 256 byte blocks list (32,  8kB)
  HMEMHDR *	pMemCtlAnchor512Byte;	// 512 byte blocks list (32, 16kB)
  struct HMEMPOOL_STRUC_t * pUsedPoolListAnchor; // Pool used list / NULL
  struct HMEMPOOL_STRUC_t * pFreePoolListAnchor; // Pool free list / NULL
} HMEMDESC;

//-------------------------------------------------------------
// Memory pool buffer management structure
//-------------------------------------------------------------
typedef struct HMEMPOOL_STRUC_t {
  struct HMEMPOOL_STRUC_t * pNext;	// pointer to next structure/NULL
  int	AllocSize;			// actual allocated size
  char * pMemBase;			// Buffer base address
} HMEMPOOL_STRUC;

//---------------------------------------------------------
// Forward definitions
//---------------------------------------------------------
HMEMDESC * FAST AllocSmallMemDescStruc(ds__hmem * vp__ctx);
char * FAST HAllocManagedBuffer(ds__hmem * vp__ctx,
				int BufSize, HMEMDESC * pMemDesc);
int FAST HFreeManagedBuffer(ds__hmem * vp__ctx,
			    char * pMem, HMEMDESC * pMemDesc);
static void FAST FreeAllMemPoolLists(ds__hmem * vp__ctx,
			             HMEMDESC * pMemDescStruc);


//==========================================================

#if defined __XHMEM_DEBUG__
static int img_alloc_count = 0;
static int img_glbl_alloc_count = 0;
#endif


//===================================================================
// memory allocation function, session associated
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//		     int        inp__memory_size         size to allocate
// returns: void * vp__p_mem / NULL
//===================================================================
void * m__hextmalloc(ds__hmem * adsp__p_hmem_struc,int inp__memory_size)
{
  void * vp_m;

  if((adsp__p_hmem_struc == NULL) || (inp__memory_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("MallocEx, called with NULL PTR!\n");
#endif
    return NULL;
  }

  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,inp__memory_size))
    {
#if defined __XHMEM_DEBUG__
      img_alloc_count++;
      printf("Past MallocEx call, Count=%d",img_alloc_count);
      printf(", Size=%d",inp__memory_size);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  else						// new version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux2(adsp__p_hmem_struc->vp__context,
                                    DEF_AUX_MEMGET,&vp_m,inp__memory_size))
    {
#if defined __XHMEM_DEBUG__
      img_alloc_count++;
      printf("Past MallocEx call, Count=%d",img_alloc_count);
      printf(", Size=%d",inp__memory_size);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
#if defined __XHMEM_DEBUG__
  img_alloc_count++;
  printf("Past MallocEx call, Count=%d",img_alloc_count);
  printf(", Size=%d",inp__memory_size);
  printf(", pMem=%lX",vp_m);
  fflush(stdout);
#endif
  return vp_m;
}
//===================================================================
// memory allocation function, global heap (session independent)
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//		     int        inp__memory_size        size to allocate
// returns: void * vp__p_mem / NULL
//===================================================================
void * m__hextmalloc_glbl(ds__hmem * adsp__p_hmem_struc,
			  int inp__memory_size)
{
  void * vp_m;			// a void pointer


  if((adsp__p_hmem_struc == NULL) || (inp__memory_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("MallocExGlbl, called with NULL PTR!\n");
#endif
    return NULL;
  }


  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,inp__memory_size))
    {
#if defined __XHMEM_DEBUG__
      img_glbl_alloc_count++;
      printf("Past MallocExGlbl call, Count=%d",img_glbl_alloc_count);
      printf(", Size=%d",inp__memory_size);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  else						// new version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux2(NULL,
                                    DEF_AUX_MEMGET,&vp_m,inp__memory_size))
    {
#if defined __XHMEM_DEBUG__
      img_glbl_alloc_count++;
      printf("Past MallocExGlbl call, Count=%d",img_glbl_alloc_count);
      printf(", Size=%d",inp__memory_size);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
#if defined __XHMEM_DEBUG__
  img_glbl_alloc_count++;
  printf("Past MallocExGlbl call, Count=%d",img_glbl_alloc_count);
  printf(", Size=%d",inp__memory_size);
  printf(", pMem=%lX",vp_m);
  fflush(stdout);
#endif
  return vp_m;
}

//===================================================================
// memory allocation function with clear, session associated
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//                   int        inp__element_count      elements to alloc
//		     int        inp__element_size       size of element
// returns: void * vp__p_mem / NULL
//===================================================================
void * m__hextcalloc(ds__hmem * adsp__p_hmem_struc,
		     int inp__element_cnt, int inp__element_size)
{
  void * vp_m;			// a void pointer


  if((adsp__p_hmem_struc == NULL) || (inp__element_cnt <= 0) ||
     (inp__element_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("CallocEx, called with NULL PTR!\n");
#endif
    return NULL;
  }


  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,
                                     inp__element_cnt * inp__element_size))
    {
#if defined __XHMEM_DEBUG__
      img_alloc_count++;
      printf("Past CallocEx call, Count=%d",img_alloc_count);
      printf(", Size=%d",inp__element_size * inp__element_cnt);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  else
  {
    if(!adsp__p_hmem_struc->am__aux2(adsp__p_hmem_struc->vp__context,
                                     DEF_AUX_MEMGET,&vp_m,
                                     inp__element_cnt * inp__element_size))
    {
#if defined __XHMEM_DEBUG__
      img_alloc_count++;
      printf("Past CallocEx call, Count=%d",img_alloc_count);
      printf(", Size=%d",inp__element_size * inp__element_cnt);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  memset(vp_m,0,inp__element_cnt*inp__element_size);

#if defined __XHMEM_DEBUG__
  img_alloc_count++;
  printf("Past CallocEx call, Count=%d",img_alloc_count);
  printf(", Size=%d",inp__element_size * inp__element_cnt);
  printf(" ,pMem=%lX",vp_m);
  fflush(stdout);
#endif
  return vp_m;
}
//===================================================================
// memory allocation function with clear, global heap (session independent)
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//                   int        inp__element_count      elements to alloc
//		     int        inp__element_size       size of element
// returns: void * vp__p_mem / NULL
//===================================================================
void * m__hextcalloc_glbl(ds__hmem * adsp__p_hmem_struc,
		 	  int inp__element_cnt, int inp__element_size)
{
  void * vp_m;			// a void pointer


  if((adsp__p_hmem_struc == NULL) || (inp__element_cnt <= 0) ||
     (inp__element_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("CallocExGlbl, called with NULL PTR!\n");
#endif
    return NULL;
  }


  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    if(!adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMGET,&vp_m,
                                     inp__element_cnt * inp__element_size))
    {
#if defined __XHMEM_DEBUG__
      img_glbl_alloc_count++;
      printf("Past CallocExGlbl call, Count=%d",img_glbl_alloc_count);
      printf(", Size=%d",inp__element_size * inp__element_cnt);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  else
  {
    if(!adsp__p_hmem_struc->am__aux2(NULL,
                                    DEF_AUX_MEMGET,&vp_m,
                                    inp__element_cnt * inp__element_size))
    {
#if defined __XHMEM_DEBUG__
      img_glbl_alloc_count++;
      printf("Past CallocExGlbl call, Count=%d",img_glbl_alloc_count);
      printf(", Size=%d",inp__element_size * inp__element_cnt);
      printf(" ,pMem=NULL\n");
      fflush(stdout);
#endif
      return NULL;
    }
  }
  memset(vp_m,0,inp__element_cnt*inp__element_size);

#if defined __XHMEM_DEBUG__
  img_glbl_alloc_count++;
  printf("Past CallocExGlbl call, Count=%d",img_glbl_alloc_count);
  printf(", Size=%d",inp__element_size * inp__element_cnt);
  printf(" ,pMem= %lX\n",vp_m);
  fflush(stdout);
#endif
  return vp_m;
}

//===================================================================
// memory free function, session associated
//
// input parameters: ds__hmem * ads__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//===================================================================
void m__hextfree(ds__hmem * adsp__p_hmem_struc,void * vp__p_mem)
{

  if((adsp__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {
#if defined __XHMEM_DEBUG__
    printf("FreeEx, called with NULL PTR!\n");
#endif
    return;
  }



#if defined __XHMEM_DEBUG__
  img_alloc_count--;
  printf("FreeEx  , Count=%d",img_alloc_count);
  printf(", pMem=%lX\n",vp__p_mem);
  fflush(stdout);
#endif

  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
  else
  {
    adsp__p_hmem_struc->am__aux2(adsp__p_hmem_struc->vp__context,
                                 DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
}
//===================================================================
// memory free function, global heap (session independent)
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//===================================================================
void m__hextfree_glbl(ds__hmem * adsp__p_hmem_struc,void * vp__p_mem)
{
  if((adsp__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {
#if defined __XHMEM_DEBUG__
    printf("FreeExGlbl, called with NULL PTR!\n");
#endif
    return;
  }



#if defined __XHMEM_DEBUG__
  img_glbl_alloc_count--;
  printf("FreeEx  , Count=%d",img_glbl_alloc_count);
  printf(", pMem= %lX",vp__p_mem);
  fflush(stdout);
#endif

  if(adsp__p_hmem_struc->in__aux_up_version == 0) // old version of alloc
  {
    adsp__p_hmem_struc->am__aux1(DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
  else
  {
    adsp__p_hmem_struc->am__aux2(NULL,DEF_AUX_MEMFREE,&vp__p_mem,0);
  }
}

//===================================================================
// Internal memory allocation function
//
// Input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//		     int        inp__memory_size         size to allocate
// Returns: void * vp__p_mem / NULL
//===================================================================
void * m__hmalloc(ds__hmem * adsp__p_hmem_struc,int inp__memory_size)
{
  void * vp_m;

  if((adsp__p_hmem_struc == NULL) || (inp__memory_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("Malloc, called with NULL PTR!\n");
#endif
    return NULL;
  }
  //---------------------------------------------------------
  // Check if buffersize is larger than internal managed
  //---------------------------------------------------------
  if(inp__memory_size > HMEM_MAX_MANAGED_BUF_SIZE)
  {
    return(m__hextmalloc(adsp__p_hmem_struc,inp__memory_size));
  }
  //---------------------------------------------------------
  // Buffer size is smaller, manage self
  //---------------------------------------------------------
  if(adsp__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    adsp__p_hmem_struc->pHmemDesc =
      AllocSmallMemDescStruc(adsp__p_hmem_struc);
    if(adsp__p_hmem_struc->pHmemDesc == NULL)
    {
#if defined __XHMEM_DEBUG__
      printf("Malloc, pMemDesc is NULL!\n");
#endif
      return(NULL);
    }
  }
#if defined __XHLCLMEM_DEBUG__
  printf("MallocLocal, Size: %d",inp__memory_size);
  fflush(stdout);
#endif

  vp_m = HAllocManagedBuffer(adsp__p_hmem_struc,inp__memory_size,
			     adsp__p_hmem_struc->pHmemDesc);
#if defined __XHLCLMEM_DEBUG__
  printf(", pMem: ");
  if(vp_m != NULL)
  {
    printf("%lX\n",vp_m);
    fflush(stdout);
  }
  else
  {
    printf("NULL!\n");
    fflush(stdout);
  }
#endif

  return(vp_m);
}
//===================================================================
// Internal memory allocation function with clear
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//                   int        inp__element_count      elements to alloc
//		     int        inp__element_size       size of element
//===================================================================
void * m__hcalloc(ds__hmem * adsp__p_hmem_struc,
		  int inp__element_cnt, int inp__element_size)
{
  int inl__request_size;
  void * vp_m;			// a void pointer

  if((adsp__p_hmem_struc == NULL) || (inp__element_cnt <= 0) ||
     (inp__element_size <= 0))
  {
#if defined __XHMEM_DEBUG__
    printf("Calloc, called with NULL PTR!\n");
#endif
    return NULL;
  }
  //---------------------------------------------------------
  // Check if buffersize is larger than internal managed
  //---------------------------------------------------------
  inl__request_size = inp__element_cnt * inp__element_size;
  if(inl__request_size > HMEM_MAX_MANAGED_BUF_SIZE)
  {
    return(m__hextcalloc(adsp__p_hmem_struc,
                         inp__element_cnt,inp__element_size));
  }
  //---------------------------------------------------------
  // Buffer size is smaller, manage self
  //---------------------------------------------------------
  if(adsp__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    adsp__p_hmem_struc->pHmemDesc =
      AllocSmallMemDescStruc(adsp__p_hmem_struc);
    if(adsp__p_hmem_struc->pHmemDesc == NULL)
    {
#if defined __XHMEM_DEBUG__
      printf("Calloc, pMemDesc is NULL!\n");
#endif
      return(NULL);
    }
  }
#if defined __XHLCLMEM_DEBUG__
  printf("CallocLocal, Size: %d",inl__request_size);
  fflush(stdout);
#endif

  vp_m = (void *) HAllocManagedBuffer(adsp__p_hmem_struc,inl__request_size,
				      adsp__p_hmem_struc->pHmemDesc);
  if(vp_m != NULL)
  {
    memset(vp_m,0,inl__request_size);
#if defined __XHLCLMEM_DEBUG__
    printf(", pMem: %lX\n",vp_m);
    fflush(stdout);
#endif
  }
#if defined __XHLCLMEM_DEBUG__
  else
  {
    printf(", pMem: NULL!\n");
    fflush(stdout);
  }
#endif

  return(vp_m);
}
//===================================================================
// memory free function
//
// input parameters: ds__hmem * adsp__p_hmem_struc	context to use
//                   void*      vp__p_mem               memory
// returns: nothing
//===================================================================
void m__hfree(ds__hmem * adsp__p_hmem_struc,void * vp__p_mem)
{
  int inl__retcode;

  if((adsp__p_hmem_struc == NULL) || (vp__p_mem == NULL))
  {
#if defined __XHMEM_DEBUG__
    printf("Free, called with NULL PTR!\n");
#endif
    return;
  }
  //-------------------------------------------------------
  // Check if we have an internal memory manager structure
  //-------------------------------------------------------
  if(adsp__p_hmem_struc->pHmemDesc == NULL)	// no structure yet...
  {
    m__hextfree(adsp__p_hmem_struc,vp__p_mem);
    return;
  }
  //-------------------------------------------------------
  // Free by internal buffer management
  //-------------------------------------------------------
#if defined __XHLCLMEM_DEBUG__
  printf("FreeLocal, pMem: %lX",vp__p_mem);
  fflush(stdout);
#endif

  inl__retcode = HFreeManagedBuffer(adsp__p_hmem_struc,
	 			    (char *) vp__p_mem,
				    adsp__p_hmem_struc->pHmemDesc);
#if defined __XHLCLMEM_DEBUG__
  if(inl__retcode != 0)
  {
    printf("FreeLocal failed!\n");
    fflush(stdout);
  }
#endif
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Small buffer management functions
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()




//===========================================================
// Get left most one bit number of a value
//
// Input parameters: int Value
// Returns: int BitNumber, rel. 1 (0 - no bits set)	
//===========================================================
static int FAST LmoBit(int Value)
{
  int Count;

  if(Value == 0)
    return(0);

  Count = 32;
  for(;;)
  {
    if((Value & 0x80000000) != 0)		// found LMO bit
      return(Count);
    Value <<= 1;
    Count--;
  }
}


//===========================================================
// Free a memory manager control structure and buffers
//
// Input parameters: HMEM_HDR_PTR pMemCtlStruc
// Returns: nothing
//===========================================================
void FAST FreeHmemCtlStruc(ds__hmem * vp__ctx, HMEMHDR * pMemCtlStruc)
{
  m__hextfree(vp__ctx,pMemCtlStruc);
}

//===========================================================
// Allocate memory control structure, used bit array and the
// buffer to manage, initialize the control structure
//
// Input parameters:	int BlockSize		Size of blocks to manage
//			int BlockCount		Amount of blocks to manage
//
// Returns: HMEM_HDR_PTR pMemCtlStruc / NULL
//===========================================================
HMEMHDR * FAST AllocHmemCtlStruc(ds__hmem * vp__ctx,
			         int BlockSize, int BlockCount)
{
  int i,j;
  int BufLen;
  int BitArrayElements;
  int BitArrayLen;
  int TotalLen;

  char * pAllocBuf = NULL;
  HMEMHDR * pMemCtlStruc;
  //-------------------------------------------------------
  // Check parameters
  //-------------------------------------------------------
  if((BlockSize <= 0) || (BlockCount <= 0))
    return(NULL);
  //-------------------------------------------------------
  // Align Blocksize to next higher power of 2
  //-------------------------------------------------------
  i = LmoBit(BlockSize);		// get left most set (+1)
  j = 0x01 << (i-1);			// calculate power 2 base
  if(j < BlockSize)			// must use next power of 2
    j <<= 1;
  BlockSize = j;
  if(BlockSize < 16)
    BlockSize = 16;
  //-------------------------------------------------------
  // Round up Blockcount to next multiple of 32
  //-------------------------------------------------------
  BlockCount = ((BlockCount + 31) / 32) * 32;

  //-------------------------------------------------------
  // Calculate buffer size needed and size of Bitarray
  //-------------------------------------------------------
  BufLen = BlockSize * BlockCount;
  BitArrayElements = BlockCount / 32;
  BitArrayLen = BitArrayElements * 4;
  //-------------------------------------------------------
  // Allocate total buffer size needed
  //-------------------------------------------------------
  TotalLen = sizeof(HMEMHDR) + BitArrayLen + BufLen;
  if((pAllocBuf = (char *) m__hextmalloc(vp__ctx,
                                         TotalLen + ALIGN_SIZE)) == NULL)
    return(NULL);
  //-------------------------------------------------------
  // Clear the used slot bit array
  //-------------------------------------------------------
  memset(pAllocBuf + sizeof(HMEMHDR),0,BitArrayLen);

  //-------------------------------------------------------
  // Initialize structure and used bit array
  //-------------------------------------------------------
  pMemCtlStruc = (HMEMHDR *) ((void*) pAllocBuf);

  pMemCtlStruc->pNextMemHdr = NULL;
  pMemCtlStruc->BlockSize   = BlockSize;
  pMemCtlStruc->BlockCount  = BlockCount;
  pMemCtlStruc->MaxUsedCount = 0;
  pMemCtlStruc->ActUsedCount = 0;
  pMemCtlStruc->pUsedBlockBitArray = (int *)
				     ((void*) (pAllocBuf + sizeof(HMEMHDR)));
#if !defined WIN64 && !defined EM64T && !defined HL_LINUX64
  pMemCtlStruc->pBufStart   = (char *) (
    (unsigned int) ((pAllocBuf + sizeof(HMEMHDR) + BitArrayLen + ALIGN_SIZE)) &
     (unsigned int) (~((unsigned int) ALIGN_SIZE-1)) );
#else // WIN64, EM64T, HL_LINUX64
  pMemCtlStruc->pBufStart   = (char *) (
    (unsigned long long) ((pAllocBuf + sizeof(HMEMHDR) + BitArrayLen + ALIGN_SIZE)) &
     (unsigned long long) (~((unsigned long long) ALIGN_SIZE-1)) );
#endif

  pMemCtlStruc->pBufEnd     = pMemCtlStruc->pBufStart + BufLen - 1;
  return(pMemCtlStruc);
}

//===========================================================
// Free a linked list of control structure and buffers
//
// Input parameters: HMEMHDR * pMemCtlStruc	List anchor
// Returns: nothing
//===========================================================
void FAST FreeHmemCtlStrucList(ds__hmem * vp__ctx,
			       HMEMHDR * pMemCtlStruc)
{
  HMEMHDR * pNextMemCtlStruc;

  for(;;)
  {
    if(pMemCtlStruc == NULL)
      return;
    pNextMemCtlStruc = pMemCtlStruc->pNextMemHdr;
    m__hextfree(vp__ctx, pMemCtlStruc);
    pMemCtlStruc = pNextMemCtlStruc;
  }
}

//===========================================================
// Free a managed buffer from the slot list (if from list...)
//
// Input parameters: HMEMHDR * pMemCtlStruc
//		     char * pMemSlot
// Returns: int Status - 0 not found,
//		       > 0 freed,
//		       < 0 error: -1 Base is invalid
//				  -2 Already freed
//===========================================================
int FAST FreeManagedBuffer(HMEMHDR * pMemCtlStruc, char * pMemSlot)
{
  int ArrayBitNr;
  int ArrayElementNr;
  int ElementBitNr;

#if !defined WIN64 && !defined EM64T && !defined HL_LINUX64
  unsigned int Offset;
#else
  unsigned long long Offset;	
#endif
  unsigned int Mask;

//  HMEM_HDR_PTR pNext

  if((pMemCtlStruc == NULL) || (pMemSlot == NULL))
    return(HMEM_NULL_PTR);
  //-----------------------------------------------------
  // Find the structure where buffer was allocated from
  //-----------------------------------------------------
  for(;;)
  {
#if !defined WIN64 && !defined EM64T && !defined HL_LINUX64
    if(((unsigned int) pMemSlot >= (unsigned int) pMemCtlStruc->pBufStart) &&
       ((unsigned int) pMemSlot <= (unsigned int) pMemCtlStruc->pBufEnd))
#else  // WIN64, EM64T, HL_LINUX64
    if(((unsigned long long) pMemSlot >=
         (unsigned long long) pMemCtlStruc->pBufStart) &&
       ((unsigned long long) pMemSlot <=
         (unsigned long long) pMemCtlStruc->pBufEnd))
#endif
    {
      //-------------------------------------------------
      // Buffer is from this Element, find allocation bit
      //-------------------------------------------------
#if !defined WIN64 && !defined EM64T && !defined HL_LINUX64
      Offset = (unsigned int) pMemSlot -
               (unsigned int) pMemCtlStruc->pBufStart;
      ArrayBitNr = (int) ((unsigned int) Offset /
                          (unsigned int) pMemCtlStruc->BlockSize);
      if(((unsigned int) pMemCtlStruc->BlockSize * ArrayBitNr) != Offset)
#else
      Offset = (unsigned long long) pMemSlot -
               (unsigned long long) pMemCtlStruc->pBufStart;
      ArrayBitNr = (int) ((unsigned long long) Offset /
	                  (unsigned long long) pMemCtlStruc->BlockSize);
      if(((unsigned long long) pMemCtlStruc->BlockSize * ArrayBitNr) != Offset)
#endif
      {
#if defined __XHMEM_DEBUG__
        printf("MUELL1!!\n");
#endif

#if 0
        printf("pMemSlot = %08X, pBufStart = %08X\n",pMemSlot,
					pMemCtlStruc->pBufStart);
        printf("Offset = %08X, ArrayBitNr = %d\n",Offset,ArrayBitNr);
        printf("Blocksize = %d\n",pMemCtlStruc->BlockSize);
#endif
        return(-1);
      }

      ArrayElementNr = ArrayBitNr / 32;		// 32 bits per element
      ElementBitNr   = ArrayBitNr % 32;		// Bit in element
      Mask = 0x01 << ElementBitNr;
      if((pMemCtlStruc->pUsedBlockBitArray[ArrayElementNr] & Mask) == 0)
      {
#if defined __XHMEM_DEBUG__
        printf("MUELL2!!\n");
#endif
        return(-2);
      }
      pMemCtlStruc->pUsedBlockBitArray[ArrayElementNr] &= (~Mask);
      pMemCtlStruc->ActUsedCount--;
      return(1);
    }
    //----------------------------------------------------
    // Buffer not from this element, try next
    //----------------------------------------------------
    pMemCtlStruc = pMemCtlStruc->pNextMemHdr;
    if(pMemCtlStruc == NULL)
      return(0);				// not found...
  }
}


//===========================================================
// Allocate space from managed buffer array/list
// NOTE: if no slot can be found, allocate a new structure
// ----- and append to list
//
// Input parameters: HMEM_HDR_PTR pMemCtlStruc
// Returns: char * pMem / NULL
//===========================================================
char * FAST AllocManagedBuffer(ds__hmem * vp__ctx, HMEMHDR * pMemCtlStruc)
{
  int ArrayIndex;
  int MaxIndex;
  int BitCnt;
  int ArrayElementNr;
  int ArrayElement;
  HMEMHDR * pNewMemCtlStruc;
  char * pUserBuf;

  if(pMemCtlStruc == NULL)
    return(NULL);

  for(;;)
  {
    //---------------------------------------------------
    // find a free slot to use
    //---------------------------------------------------
    ArrayIndex = 0;
    MaxIndex = pMemCtlStruc->BlockCount/32;
    while(ArrayIndex < MaxIndex)
    {
      ArrayElement = pMemCtlStruc->pUsedBlockBitArray[ArrayIndex];
      if((~ArrayElement) != 0)			// not all bits set
      {
        //-------------------------------------------------
        // found an element with free slots, get first free
        //-------------------------------------------------
        BitCnt = 0;
        for(;;)
        {
          if((ArrayElement & 0x01) == 0)
            break;
          ArrayElement >>= 1;
          BitCnt++;
        }
        ArrayElementNr = (ArrayIndex * 32) + BitCnt;	// Bit nr.
        pUserBuf = pMemCtlStruc->pBufStart +
		   (pMemCtlStruc->BlockSize * ArrayElementNr);
        pMemCtlStruc->pUsedBlockBitArray[ArrayIndex] |= (0x01 << BitCnt);
	pMemCtlStruc->ActUsedCount++;
        if(pMemCtlStruc->ActUsedCount > pMemCtlStruc->MaxUsedCount)
          pMemCtlStruc->MaxUsedCount = pMemCtlStruc->ActUsedCount;
        return(pUserBuf);
      }
      ArrayIndex++;
    }
    //-----------------------------------------------------
    // no free slot found, check if more structures present
    //-----------------------------------------------------
    if(pMemCtlStruc->pNextMemHdr == NULL)	// was last one...
      break;
    pMemCtlStruc = pMemCtlStruc->pNextMemHdr;
  }
  //-------------------------------------------------------
  // No empty slot found, allocate a new structure, append
  //-------------------------------------------------------
  if((pNewMemCtlStruc = AllocHmemCtlStruc(vp__ctx,
				pMemCtlStruc->BlockSize,
				pMemCtlStruc->BlockCount)) == NULL)
    return(NULL);
  //----------------------------------------------------------
  // link structure to last used, get block from first element
  //----------------------------------------------------------
  pMemCtlStruc->pNextMemHdr = pNewMemCtlStruc;
  pUserBuf = pNewMemCtlStruc->pBufStart;
  pNewMemCtlStruc->pUsedBlockBitArray[0] |= 0x01;
  pNewMemCtlStruc->ActUsedCount = 1;
  pNewMemCtlStruc->MaxUsedCount = 1;

  return(pUserBuf);
}

//============================================================
// Free all small buffer management lists
//
// Input parameters: HMEM_DESC_PTR	pMemDescStruc
// Returns: nothing
//============================================================
void FAST FreeSmallMemDescStruc(ds__hmem * vp__ctx,
				HMEMDESC * pMemDescStruc)
{
  if(pMemDescStruc == NULL)
    return;

  //--------------------------------------------------------
  // Free pool lists first !
  //--------------------------------------------------------
  FreeAllMemPoolLists(vp__ctx,pMemDescStruc);


  //--------------------------------------------------------
  // Free the management buffer lists now
  //--------------------------------------------------------
  FreeHmemCtlStrucList(vp__ctx,pMemDescStruc->pMemCtlAnchor16Byte);
  FreeHmemCtlStrucList(vp__ctx,pMemDescStruc->pMemCtlAnchor32Byte);
  FreeHmemCtlStrucList(vp__ctx,pMemDescStruc->pMemCtlAnchor64Byte);
  FreeHmemCtlStrucList(vp__ctx,pMemDescStruc->pMemCtlAnchor256Byte);
  FreeHmemCtlStrucList(vp__ctx,pMemDescStruc->pMemCtlAnchor512Byte);
  m__hextfree(vp__ctx,pMemDescStruc);
}
//============================================================
// Free management buffer structures
//
// Input parameters: 'none' (Context only)
// Returns: nothing
//============================================================
void FAST HMemMgrFree(ds__hmem * vp__ctx)
{

  HMEMDESC * pMemDescStruc = vp__ctx->pHmemDesc;

  if(pMemDescStruc == NULL)
    return;

#if defined __XHMEM_DEBUG__
  printf("FreeMemDesc entered.\n");
#endif

  //--------------------------------------------------------
  // Free pool lists first !
  //--------------------------------------------------------
  FreeAllMemPoolLists(vp__ctx, vp__ctx->pHmemDesc);


  //--------------------------------------------------------
  // Free the management buffer lists now
  //--------------------------------------------------------
  FreeHmemCtlStrucList(vp__ctx, pMemDescStruc->pMemCtlAnchor16Byte);
  FreeHmemCtlStrucList(vp__ctx, pMemDescStruc->pMemCtlAnchor32Byte);
  FreeHmemCtlStrucList(vp__ctx, pMemDescStruc->pMemCtlAnchor64Byte);
  FreeHmemCtlStrucList(vp__ctx, pMemDescStruc->pMemCtlAnchor256Byte);
  FreeHmemCtlStrucList(vp__ctx, pMemDescStruc->pMemCtlAnchor512Byte);
  m__hextfree(vp__ctx,pMemDescStruc);
  vp__ctx->pHmemDesc = NULL;
#if defined __XHMEM_DEBUG__
  printf("FreeMemDesc ok. exit.\n");
#endif

}






//==============================================================
// Allocate small buffer management structure description array
//
// Input parameters:
// Returns: HMEMDESC * pMemDescStruc / NULL if failed
//============================================================
HMEMDESC * FAST AllocSmallMemDescStruc(ds__hmem * vp__ctx)
{
  HMEMDESC * pMemDescStruc;

  HMEMINFO MemInfoStruc;
  //-------------------------------------------------------------
  // Get size of default blocks to allocate
  //-------------------------------------------------------------
  memset(&MemInfoStruc,0,sizeof(MemInfoStruc));
  MemInfoStruc.InfoStrucSize = sizeof(HMEMINFO);

  if(vp__ctx->pMemSizeInfoCallback != NULL)
  {
    vp__ctx->pMemSizeInfoCallback(&MemInfoStruc);
    // call the info subroutine...
  }

  //-------------------------------------------------------------
  // Setup defaults if no sizes were supplied
  //-------------------------------------------------------------
  if(MemInfoStruc.InitialByte16BlockCount <= 0)
    MemInfoStruc.InitialByte16BlockCount = HMEM_DEFAULT_16BYTE_BLOCKS;

  if(MemInfoStruc.InitialByte32BlockCount <= 0)
    MemInfoStruc.InitialByte32BlockCount = HMEM_DEFAULT_32BYTE_BLOCKS;

  if(MemInfoStruc.InitialByte64BlockCount <= 0)
    MemInfoStruc.InitialByte64BlockCount = HMEM_DEFAULT_64BYTE_BLOCKS;

  if(MemInfoStruc.InitialByte256BlockCount <= 0)
    MemInfoStruc.InitialByte256BlockCount = HMEM_DEFAULT_256BYTE_BLOCKS;

  if(MemInfoStruc.InitialByte512BlockCount <= 0)
    MemInfoStruc.InitialByte512BlockCount = HMEM_DEFAULT_512BYTE_BLOCKS;

  //-------------------------------------------------------------
  // Allocate the descriptor structure
  //-------------------------------------------------------------
#if defined __XHMEM_DEBUG__
  printf("AllocMemDesc entered.\n");
#endif

  pMemDescStruc = (HMEMDESC *) m__hextcalloc(vp__ctx,1,sizeof(HMEMDESC));
  if(pMemDescStruc == NULL)
    return(NULL);
  //-------------------------------------------------------------
  // Allocate the management elements with default size each
  //-------------------------------------------------------------
  pMemDescStruc->pMemCtlAnchor16Byte  = AllocHmemCtlStruc(vp__ctx,
			16,MemInfoStruc.InitialByte16BlockCount);
  pMemDescStruc->pMemCtlAnchor32Byte  = AllocHmemCtlStruc(vp__ctx,
			32,MemInfoStruc.InitialByte32BlockCount);
  pMemDescStruc->pMemCtlAnchor64Byte  = AllocHmemCtlStruc(vp__ctx,
			64,MemInfoStruc.InitialByte64BlockCount);
  pMemDescStruc->pMemCtlAnchor256Byte = AllocHmemCtlStruc(vp__ctx,
			256,MemInfoStruc.InitialByte256BlockCount);
  pMemDescStruc->pMemCtlAnchor512Byte = AllocHmemCtlStruc(vp__ctx,
			512,MemInfoStruc.InitialByte512BlockCount);


  if((pMemDescStruc->pMemCtlAnchor16Byte == NULL) ||
     (pMemDescStruc->pMemCtlAnchor32Byte == NULL) ||
     (pMemDescStruc->pMemCtlAnchor64Byte == NULL) ||
     (pMemDescStruc->pMemCtlAnchor256Byte == NULL) ||
     (pMemDescStruc->pMemCtlAnchor512Byte == NULL))
  {
    FreeSmallMemDescStruc(vp__ctx,pMemDescStruc);
    return(NULL);
  }
#if defined __XHMEM_DEBUG__
  printf("AllocMemDesc ok. exit.\n");
#endif
  return(pMemDescStruc);
}
//==============================================================
// Free a memory block from local managed buffers or global
//
// Input parameters: BIT8PTR pMem		Memory base
//		     HMEM_DESC_PTR pMemDesc	descriptor structure
// Returns: int Status - 0 o.k., else error occured
//============================================================
int FAST HFreeManagedBuffer(ds__hmem * vp__ctx,
			    char * pMem, HMEMDESC * pMemDesc)
{
  int Retcode;

  if((pMem == NULL) || (pMemDesc == NULL))
    return(HMEM_NULL_PTR);

#if defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS

  m__hextfree(vp__ctx,pMem);
  return(HMEM_OP_OK);

#else

  //-------------------------------------------------
  // Find buffer in local structures
  //-------------------------------------------------
  for(;;)
  {
    if((Retcode =
	  FreeManagedBuffer(pMemDesc->pMemCtlAnchor16Byte,pMem)) != 0)
      break;

    if((Retcode =
	  FreeManagedBuffer(pMemDesc->pMemCtlAnchor32Byte,pMem)) != 0)
      break;

    if((Retcode =
          FreeManagedBuffer(pMemDesc->pMemCtlAnchor64Byte,pMem)) != 0)
      break;

    if((Retcode =
          FreeManagedBuffer(pMemDesc->pMemCtlAnchor256Byte,pMem)) != 0)
      break;
    if((Retcode =
          FreeManagedBuffer(pMemDesc->pMemCtlAnchor512Byte,pMem)) != 0)
      break;
    m__hextfree(vp__ctx,pMem);
    return(HMEM_OP_OK);
  }
  if(Retcode > 0)
    Retcode = HMEM_OP_OK;
  return(Retcode);
#endif // defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS
}

//==============================================================
// Allocate a memory block from local managed buffers or global
//
// Input parameters: int BufSize		size requested
//		     HMEMDESC * pMemDesc	descriptor structure
// Returns: BIT8PTR ach_pmem / NULL if failed
//============================================================
char * FAST HAllocManagedBuffer(ds__hmem * vp__ctx,
				int BufSize, HMEMDESC * pMemDesc)
{
  if((pMemDesc == NULL) || (BufSize <= 0))
    return(NULL);

#if defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS

    return(m__hextmalloc(vp__ctx,BufSize));

#else // !defined DISABLE_MEMMGR

  //-------------------------------------------------
  // Check size of requested buffer
  //-------------------------------------------------
  if(BufSize > 512)
  {
    return((char *) m__hextmalloc(vp__ctx,BufSize));
  }
  if(BufSize <= 16)
  {
    return((char *)
            AllocManagedBuffer(vp__ctx,pMemDesc->pMemCtlAnchor16Byte));
  }
  if(BufSize <= 32)
  {
    return((char *)
           AllocManagedBuffer(vp__ctx,pMemDesc->pMemCtlAnchor32Byte));
  }
  if(BufSize <= 64)
  {
    return((char *)
           AllocManagedBuffer(vp__ctx,pMemDesc->pMemCtlAnchor64Byte));
  }
  if(BufSize <= 256)
  {
    return((char *)
            AllocManagedBuffer(vp__ctx,pMemDesc->pMemCtlAnchor256Byte));
  }
  return((char *)
         AllocManagedBuffer(vp__ctx,pMemDesc->pMemCtlAnchor512Byte));
#endif // defined DISABLE_MEMMGR || defined DISABLE_MANAGED_BUFFERS
}

//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Buffer pool management functions
// NOTE: Rely on small buffer management !!!!
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()

//=================================================================
// Free a buffer pool list and the buffers
// NOTE: Buffers are freed direct from system, structures through
// ----- small buffer management routines
//	 ... AT THE MOMENT USE DIRECT FREE ! ...
//
// Input parameters:	HMEMPOOL_PTR pPoolList
// Returns: nothing
// TESTED O.K.
//=================================================================
static void FAST FreeMemPoolList(ds__hmem * vp__ctx,
				 HMEMPOOL_STRUC * pPoolList)
{
  char * pBuf;
  HMEMPOOL_STRUC * pActPoolStruc = pPoolList;
  HMEMPOOL_STRUC * pNextPoolStruc;

  while(pActPoolStruc != NULL)
  {
    pNextPoolStruc = pActPoolStruc->pNext;	// save next pointer
    if((pBuf = pActPoolStruc->pMemBase) != NULL)
    {
      m__hextfree(vp__ctx, pBuf);    	// free direct by system
    }
    m__hextfree(vp__ctx, pActPoolStruc);// free with buffer manager
    pActPoolStruc = pNextPoolStruc;
  }
}
//=================================================================
// Free all buffer pool lists and the buffers
// NOTE: Buffers are freed from system, structures with small
// ----- buffer management routines
//	 ... AT THE MOMENT USE DIRECT FREE ! ...
//
// Input parameters:	HMEM_DESC_PTR pMemDescStruc
// Returns: nothing
// TESTED O.K.
//=================================================================
static void FAST FreeAllMemPoolLists(ds__hmem * vp__ctx,
				     HMEMDESC * pMemDescStruc)
{
  if(pMemDescStruc == NULL)
    return;

  FreeMemPoolList(vp__ctx, pMemDescStruc->pUsedPoolListAnchor);
  pMemDescStruc->pUsedPoolListAnchor = NULL;
  FreeMemPoolList(vp__ctx, pMemDescStruc->pFreePoolListAnchor);
  pMemDescStruc->pFreePoolListAnchor = NULL;
}

//=================================================================
// Allocate a buffer pool structure and the buffer of requested
// size
// Note: Buffer is allocated direct from system, structure through
// ----- small buffer management routines
//	 ... AT THE MOMENT USE DIRECT ALLOCATION !!! ...
//
// Input parameters:	int MemSize	Buffer size to allocate
// Returns: HMEMPOOL_PTR pPoolDescStruc / NULL
//=================================================================
static HMEMPOOL_STRUC * FAST AllocBufferPoolStruc(ds__hmem * vp__ctx,
						  int MemSize)
{
  char * pBuf;
  HMEMPOOL_STRUC * pMemPoolStruc;

  //----------------------------------------------------
  // Allocate the control structure
  //----------------------------------------------------
  if((pMemPoolStruc = (HMEMPOOL_STRUC *) m__hextcalloc(vp__ctx,
				    1,sizeof(HMEMPOOL_STRUC))) == NULL)
    return(NULL);

  //----------------------------------------------------
  // Allocate the buffer if needed
  //----------------------------------------------------
  if(MemSize > 0)
  {
    if((pBuf = (char *) m__hextmalloc(vp__ctx,MemSize)) == NULL)
    {
      m__hextfree(vp__ctx,pMemPoolStruc);
      return(NULL);
    }
    pMemPoolStruc->AllocSize = MemSize;
    pMemPoolStruc->pMemBase  = pBuf;
  }
  return(pMemPoolStruc);
}
//=================================================================
// Re-Allocate a buffer in a pool structure
// Note: Buffer is allocated direct from system
// ----- Old buffer is freed in all cases !!
//
// Input parameters: HMEMPOOL_PTR pPoolDescStruc
//		     int NewMemSize	New buffer size to allocate
// Returns: int Status - 0 o.k.
//		       > 0 new buffer could not be allocated
//		       < 0 error occured
// TESTED O.K.
//=================================================================
static int FAST ReAllocBufferPoolStruc(ds__hmem * vp__ctx,
				HMEMPOOL_STRUC * pMemPoolStruc, int NewMemSize)
{
  char * pNewBuf;

  if(pMemPoolStruc == NULL)
    return(HMEM_NULL_PTR);

  //-----------------------------------------------------
  // Free the current buffer, allocate the new buffer
  //-----------------------------------------------------
  if(pMemPoolStruc->AllocSize >= NewMemSize)	// no realloc needed...
    return(0);

  if(pMemPoolStruc->pMemBase != NULL)		// a buffer is present
  {
    m__hextfree(vp__ctx,pMemPoolStruc->pMemBase);
    pMemPoolStruc->pMemBase  = NULL;
    pMemPoolStruc->AllocSize = 0;
  }

  if(NewMemSize > 0)
  {
    if((pNewBuf = (char *) m__hextmalloc(vp__ctx,NewMemSize)) == NULL)
      return(1);				// alloc failed !
    pMemPoolStruc->AllocSize = NewMemSize;
    pMemPoolStruc->pMemBase  = pNewBuf;
  }
  return(0);
}


//=================================================================
// Pre-Allocate a pooled buffered list with given buffer size
// and number of elements
// NOTE: Buffersize may be 0 (no buffers allocated, only list)
//
// Input parameters: int BufSize	Size of each buffer requested
//		     int ElementCnt	Number of elements requested
// Returns: HMEMPOOL_PTR pPoolList / NULL
//=================================================================
static HMEMPOOL_STRUC * AllocPoolList(ds__hmem * vp__ctx,
				      int BufSize, int ElementCnt)
{
  HMEMPOOL_STRUC * pPoolListAnchor = NULL;
  HMEMPOOL_STRUC * pLastPoolStruc = NULL;
  HMEMPOOL_STRUC * pNewPoolStruc;

  if(ElementCnt <= 0)
    return(NULL);

  //-----------------------------------------------------------
  // Allocate the structure elements, concatenate to list
  //-----------------------------------------------------------
  while(ElementCnt > 0)
  {
    if((pNewPoolStruc = AllocBufferPoolStruc(vp__ctx,
					     BufSize)) == NULL)
    {
      if(pPoolListAnchor != NULL)
      {
        FreeMemPoolList(vp__ctx, pPoolListAnchor);
      }
      return(NULL);
    }
    //-----------------------------------------------------
    // Link new element to list end
    //-----------------------------------------------------
    if(pLastPoolStruc == NULL)			// 1st element
    {
      pPoolListAnchor = pNewPoolStruc;		// load list anchor pointer
      pLastPoolStruc  = pNewPoolStruc;
    }
    else
    {
      pLastPoolStruc->pNext = pNewPoolStruc;	// link to end of list
      pLastPoolStruc = pNewPoolStruc;
    }
    ElementCnt--;
  }
  return(pPoolListAnchor);
}



//=================================================================
// 'Free' a pooled buffer
// 1. find the control structure from the used pool buffer list
// 2. unlink structure from list
// 3. link structure to head of free list
//
// Input parameters:	MEMMGR_PTR pMemDescStruc	control structure
//			void * pMem		Buffer base
// Returns: int Status -   0 not found in list
//		         > 0 succesfully freed
//			 < 0 error occured
// Tested: o.k., all pathes checked.
//=================================================================
static int FAST FreePooledBuffer(HMEMDESC * pMemDescStruc, void * pMem)
{
  HMEMPOOL_STRUC * pActUsedStruc;
  HMEMPOOL_STRUC * pLastUsedStruc;
  HMEMPOOL_STRUC * pNextUsedStruc;

  if(pMem == NULL)
    return(HMEM_NULL_PTR);
  //-----------------------------------------------------
  // 1. Find the controlling structure for the buffer
  //-----------------------------------------------------
  if(pMemDescStruc == NULL)		// obviously not from pool...
    return(0);

  pActUsedStruc = pMemDescStruc->pUsedPoolListAnchor;	// get anchor
  if(pActUsedStruc == NULL)		// not from used pool
    return(0);

  pLastUsedStruc = NULL;
  for(;;)
  {
    pNextUsedStruc = pActUsedStruc->pNext;	// get the next used pointer
    if(pMem == pActUsedStruc->pMemBase)		// found the entry
    {
      //-----------------------------------------------------------
      // unlink structure from used list, put to front of free list
      //-----------------------------------------------------------
      pActUsedStruc->pNext = pMemDescStruc->pFreePoolListAnchor; // to front
      pMemDescStruc->pFreePoolListAnchor = pActUsedStruc;	// set next

      if(pLastUsedStruc == NULL)		// was first element in list
      {
        pMemDescStruc->pUsedPoolListAnchor = pNextUsedStruc;
      }
      else
      {
        pLastUsedStruc->pNext = pNextUsedStruc;
      }
      return(1);
    }
    //-------------------------------------------------------
    // Entry not yet found, advance to next if present
    //-------------------------------------------------------
    if(pNextUsedStruc == NULL)			// was last element
      return(0);
    pLastUsedStruc = pActUsedStruc;
    pActUsedStruc  = pNextUsedStruc;
  }
}

//=================================================================
// 'Allocate' a pooled buffer of requested size
// Algorithm used:
// 1. Check if there are free pool elements available at all
//    a) no: allocate a pooled buffer structure with requested buffer
//           size and link to head of used pool list.
//    b) yes: goto 2.
//
// 2. Free elements are available. Search for an element that matches
//    the requested size AND is the optimal one (smallest suitable in list)
//    a) found appropriate pool element:
//	 - unlink from the free list and link to head of used list
//	 - return the buffer pointer
//    b) no appropriate element was found: goto 3.
//
// 3.  No matching pool element found. Do the following:
// 3.1 Search for the element with largest allocated buffer to reallocate it.
//    a) No element has a buffer allocated:
//       - Should not happen !!!
//    b) Best fit element's buffer size > requested size:
//	 - unlink from the free list and link to head of used list
//	 - return the buffer pointer
//    c) Best fit element's buffer size < requested size:
//       - Reallocate element to requested size
//       I) Realloc fails (NOTE: previous buffer has been freed!):
//	    - unlink element from free list and free structure
//	    - go back to 3.1. This will allow the system to concatenate
//	      unused buffers to satisfy a new alloc request
//	 II) Realloc succeeds:
//	     - unlink from the free list and link to head of used list
//	     - return the buffer pointer
//
//
// Input parameters:	HMEM_DESC_PTR pMemDescStruc	control structure
//			int MemSize			requested size
// Returns: char * pMem / NULL
// TESTED O.K.
//=================================================================
static char * FAST AllocPooledBuffer(ds__hmem * vp__ctx,
			HMEMDESC * pMemDescStruc, int MemSize)
{
  int Retcode;
  int NewMemSize = MemSize;
  int BestFitSize;

  HMEMPOOL_STRUC * pNextFreePool;
  HMEMPOOL_STRUC * pActFreePool;
  HMEMPOOL_STRUC * pLastFreePool;
  HMEMPOOL_STRUC * pNewPool;
  HMEMPOOL_STRUC * pActBestFitFreePool;
  HMEMPOOL_STRUC * pLastBestFitFreePool;


  if(NewMemSize <= 0)
    return(NULL);

  if(pMemDescStruc == NULL)
  {
    //--------------------------------------------------------
    // 0. initialize small buffer management, checked o.k.
    //--------------------------------------------------------
    pMemDescStruc = AllocSmallMemDescStruc(vp__ctx);
    if(pMemDescStruc == NULL)
    {
      return((char *) m__hextmalloc(vp__ctx,MemSize)); // get direct from system...
    }
    vp__ctx->pHmemDesc = pMemDescStruc;

    pNewPool = AllocPoolList(vp__ctx,DEFAULT_HMEM_POOL_SIZE,
			     DEFAULT_HMEM_POOL_COUNT);
    pMemDescStruc->pFreePoolListAnchor = pNewPool;
  }

  for(;;) // RETRY LOOP!!
  {
    //-----------------------------------------------------------
    // 1. Check if free pool elements are available at all
    //-----------------------------------------------------------
    if((pActFreePool = pMemDescStruc->pFreePoolListAnchor) == NULL)
    {
      //------------------------------------------------------------
      // no elements on free list, get new element, put to used list
      // TESTED O.K.
      //------------------------------------------------------------
      if((pNewPool = AllocBufferPoolStruc(vp__ctx,MemSize)) == NULL)
        return(NULL);

      pNewPool->pNext = pMemDescStruc->pUsedPoolListAnchor;
      pMemDescStruc->pUsedPoolListAnchor = pNewPool;
      return(pNewPool->pMemBase);
    }
    //--------------------------------------------------------------
    // 2. Free pool elements are present, find the best matching one
    // ALL PATHS TESTED O.K.
    //--------------------------------------------------------------
    pActBestFitFreePool  = NULL;
    pLastBestFitFreePool = NULL;

    pLastFreePool = NULL;
    BestFitSize = 0;

    for(;;)
    {
      if(pActFreePool->AllocSize == NewMemSize)	// optimal match !!
      {
        //-------------------------------------------------------------
        // 2.1. optimal match, unlink from free list, link to used list
        // ALL PATHS TESTED O.K.
        //-------------------------------------------------------------
        if(pLastFreePool == NULL)		// was first free element!
        {
          pMemDescStruc->pFreePoolListAnchor = pActFreePool->pNext; // unlink
        }
        else
        {
          pLastFreePool->pNext = pActFreePool->pNext; // unlink, not anchor
        }
        pActFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link in
        pMemDescStruc->pUsedPoolListAnchor = pActFreePool;	// to head
        return(pActFreePool->pMemBase);
      }
      else if(NewMemSize > pActFreePool->AllocSize) // MemSize > ElementSize
      {
        //----------------------------------------------------------------
        // 2.2. Requested buffer size LARGER than actual free element's
        //      buffer size, check if current element is a better fit than
        //      already scanned ones (aka. size difference is smaller)
        // TESTED O.K.
        //----------------------------------------------------------------
        if(pActFreePool->AllocSize > BestFitSize)	// is larger than last
        {
          pLastBestFitFreePool = pLastFreePool;		// set new last ptr
          pActBestFitFreePool  = pActFreePool;		// set new actual
          BestFitSize          = pActFreePool->AllocSize;
        }
      }
      else					// MemSize < ElementSize
      {
        //----------------------------------------------------------------
        // 2.3. Requested buffer size SMALLER than actual free element's
        //      buffer size, check if current element is a better fit than
        //      already scanned ones (aka. size difference is smaller)
        // TESTED O.K.
        //----------------------------------------------------------------
        if((BestFitSize == 0) ||			// no best element yet
           (BestFitSize < NewMemSize) ||		// smaller was best
           (pActFreePool->AllocSize < BestFitSize))	// distance smaller
        {
          pLastBestFitFreePool = pLastFreePool;		// set new last ptr
          pActBestFitFreePool  = pActFreePool;		// set new actual
          BestFitSize          = pActFreePool->AllocSize;
        }
      }
      pLastFreePool = pActFreePool;		// save current
      pActFreePool  = pActFreePool->pNext;	// advance
      if(pActFreePool == NULL)			// was last one
        break;
    }
    //-----------------------------------------------------------
    // 3.0 Now we have information about (current) best fit
    //-----------------------------------------------------------
    if(BestFitSize == 0)		// SHOULD NOT HAPPEN !!!!
    {
      //-----------------------------------------------------------------
      // No buffers found on free list, STRANGE, list should be empty now
      //-----------------------------------------------------------------
      continue;					// back to start ???
    }
    //-----------------------------------------------------------
    // 3.1 Found a candidate element, check if usable
    // ALL PATHS TESTED O.K.
    //-----------------------------------------------------------
    if(BestFitSize > NewMemSize)		// apporopriate buffer found
    {
      //----------------------------------------------------------
      // 3.2 usable buffer, unlink best fit element from free list,
      //     link to used list
      // ALL PATHS TESTED O.K.
      //----------------------------------------------------------
      if(pLastBestFitFreePool == NULL)		// was first in free list
      {
        pMemDescStruc->pFreePoolListAnchor = pActBestFitFreePool->pNext;
      }
      else					// not first, unlink
      {
        pLastBestFitFreePool->pNext = pActBestFitFreePool->pNext;
      }

      if(pMemDescStruc->pUsedPoolListAnchor == NULL)	// first element now
      {
        pActBestFitFreePool->pNext = NULL;	// terminate list
        pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
      }
      else
      {
        pActBestFitFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link
        pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
      }
      return(pActBestFitFreePool->pMemBase);
    }
    //-------------------------------------------------------------
    // 3.2. No buffer element with size > Memsize found, reallocate
    // ALL PATHS TESTED O.K.
    //-------------------------------------------------------------
    Retcode = ReAllocBufferPoolStruc(vp__ctx,
				     pActBestFitFreePool,MemSize);
    if(Retcode == 0)				// realloc succeeded
    {
      //------------------------------------------------------
      // Got a fitting element, unlink from free, link to used
      // ALL PATHS TESTED O.K.
      //------------------------------------------------------
      if(pLastBestFitFreePool == NULL)		// was first in free list
      {
        pMemDescStruc->pFreePoolListAnchor = pActBestFitFreePool->pNext;
      }
      else					// not first, unlink
      {
        pLastBestFitFreePool->pNext = pActBestFitFreePool->pNext;
      }

      if(pMemDescStruc->pUsedPoolListAnchor == NULL)	// first element mow
      {
        pActBestFitFreePool->pNext = NULL;	// terminate list
        pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
      }
      else
      {
        pActBestFitFreePool->pNext = pMemDescStruc->pUsedPoolListAnchor; // link
        pMemDescStruc->pUsedPoolListAnchor = pActBestFitFreePool;
      }
      return(pActBestFitFreePool->pMemBase);
    }
    //-------------------------------------------------------------
    // 3.3. Reallocate failed, remove element from the list, free
    //	    and retry the procedure...
    // ALL PATHS TESTED O.K.
    //-------------------------------------------------------------
    pNextFreePool = pActBestFitFreePool->pNext;	// save next pointer
    m__hfree(vp__ctx,pActBestFitFreePool);
    if(pLastBestFitFreePool == NULL)
    {
      pMemDescStruc->pFreePoolListAnchor = pNextFreePool;
    }
    else
    {
      pLastBestFitFreePool->pNext = pNextFreePool;
    }
  } // outer loop FOR
}



//================================================================
// Free a buffer from the buffer pool (or small buffers/direct)
// Mode of operation: TBD !!!
//
// Input parameters: void * ach_ppool_mem
// Returns: nothing
// TESTED O.K.
//================================================================
void FAST m__hpoolfree(ds__hmem * vp__ctx, void * ach_ppool_mem)
{
  int Retcode;

  if(ach_ppool_mem == NULL)
    return;

#if defined DISABLE_MEMMGR

  m__hextfree(vp_ctx,ach_ppool_mem);
  return;

#else // !defined DISABLE_MEMMGR
  //-----------------------------------------------------
  // Try to free from buffer pool first
  //-----------------------------------------------------
  Retcode = FreePooledBuffer(vp__ctx->pHmemDesc, ach_ppool_mem);

  if(Retcode <= 0)			// not found on list(or error?)
  {
    m__hfree(vp__ctx,ach_ppool_mem);
    return;
  }
  //-----------------------------------------------------
  // Buffer was from pool list
  //-----------------------------------------------------
#if defined __HPOOLMGR_DEBUG__
  img_pool_count--;
  printf("PoolFree,  Count=%d",img_pool_count);
  printf(" ,pMem=");
  if(ach_ppool_mem == NULL)
  {
    printf("NULL\n");
  }
  else
  {
    printf("%lX\n",ach_ppool_mem);
  }
#endif // defined __HPOOLMGR_DEBUG__
#endif // defined DISABLE_MEMMGR
}

//================================================================
// Allocate a buffer from the buffer pool
// Mode of operation: TBD !!!
//
// Input parameters: int in__memory_size	requested amount of storage
// Returns: BIT8PTR ach__pmem / NULL
//================================================================
char * FAST m__hpoolmalloc(ds__hmem * vp__ctx, int in__memory_size)
{
  char * pPoolMem;

  if(in__memory_size <= 0)
    return(NULL);

#if defined DISABLE_MEMMGR

  pPoolMem = m__hextmalloc(vp__ctx,in__memory_size);
  return(pPoolMem);

#else // !defined DISABLE_MEMMGR

  //------------------------------------------------------------------
  // Filter small buffer requests (handled by small buffer management)
  //------------------------------------------------------------------
#if !defined DISABLE_MANAGED_BUFFERS
  if(in__memory_size <= HMEM_MAX_MANAGED_BUF_SIZE)
  {
    pPoolMem = (char *) m__hmalloc(vp__ctx,in__memory_size);
    return(pPoolMem);
  }
#endif // !defined DISABLE_MANAGED_BUFFERS
  //----------------------------------------------------
  // use buffer pool list
  //----------------------------------------------------
  pPoolMem = AllocPooledBuffer(vp__ctx, vp__ctx->pHmemDesc, in__memory_size);

#if defined __HPOOLMGR_DEBUG__
  img_pool_count++;
  printf("PoolAlloc, Count=%d",img_pool_count);
  printf(", Size=%d",in__memory_size);
  printf(" ,pMem=");
  if(pPoolMem == NULL)
  {
    printf("NULL\n");
  }
  else
  {
    printf("%lX\n",pPoolMem);
  }
#endif // defined __HPOOLMGR_DEBUG__

  return(pPoolMem);
#endif // defined DISABLE_MEMMGR
}


//()()()()()()()()()()()()()()()()()()()()()()()()()()()()
//
// Output Statistics about memory usage for a context structure
//
//()()()()()()()()()()()()()()()()()()()()()()()()()()()()

#if defined __XHMEM_DEBUG__

//===========================================================
// Show statistics for small buffer management list
//
// Input parameters: HMEMHDR * pHmemList	Memory list
// Returns: nothing
//===========================================================
static void FAST ShowMemListUsage(HMEMHDR * pHmemList)
{
  int SegmentCount = 0;
  int ActSegmentCount;


  HMEMHDR * pHmemListAnchor = pHmemList;


  if(pHmemListAnchor == NULL)
  {
    printf("No elements allocated.\n");
    return;
  }
  //---------------------------------------------------------
  // Count number of blocks allocated
  //---------------------------------------------------------
  for(;;)
  {
    SegmentCount++;
    if((pHmemList = pHmemList->pNextMemHdr) == NULL)
      break;
  }
  printf("Number of segments allocated: %d",SegmentCount);
  printf("Segment Statistics:\n");

  pHmemList = pHmemListAnchor;
  ActSegmentCount = 0;
  while(ActSegmentCount < SegmentCount)
  {
    printf("SegmentNr. %d:\n",ActSegmentCount+1);
    printf("Total blocks: %d",pHmemList->BlockCount);

    printf(", Blocks in use: %d",pHmemList->ActUsedCount);

    printf(", Free Blocks: %d",
             pHmemList->BlockCount-pHmemList->ActUsedCount);

    printf(", Max. Blocks used: %d\n",pHmemList->MaxUsedCount);

    ActSegmentCount++;
    pHmemList = pHmemList->pNextMemHdr;
    printf("\n");
  }
}
//===========================================================
// Show statistics for all small buffer management list
//
// Input parameters: HMEMDESC * pHmemDesc	Memory descriptor
// Returns: nothing
//===========================================================
static void FAST ShowAllMemListUsage(HMEMDESC * pHmemDesc)
{

  if(pHmemDesc == NULL)
    return;

  printf(" 16 Byte buffer management:\n");
  ShowMemListUsage(pHmemDesc->pMemCtlAnchor16Byte);

  printf(" 32 Byte buffer management:\n");
  ShowMemListUsage(pHmemDesc->pMemCtlAnchor32Byte);

  printf(" 64 Byte buffer management:\n");
  ShowMemListUsage(pHmemDesc->pMemCtlAnchor64Byte);

  printf("256 Byte buffer management:\n");
  ShowMemListUsage(pHmemDesc->pMemCtlAnchor256Byte);

  printf("512 Byte buffer management:\n");
  ShowMemListUsage(pHmemDesc->pMemCtlAnchor512Byte);

}


//===========================================================
// Show statistics for a pooled buffer list
//
// Input parameters: HMEMPOOL_STRUC * pHmemPoolList	Pool list
// Returns: nothing
//===========================================================
static void FAST ShowMemPoolList(HMEMPOOL_STRUC * pHmemPoolList)
{
  int PoolCount = 0;
  int ActPoolCount;
  int PoolSize;

  HMEMPOOL_STRUC * pHmemPoolListAnchor = pHmemPoolList;


  if(pHmemPoolListAnchor == NULL)
  {
    printf("No pool elements allocated.\n");
    return;
  }
  //---------------------------------------------------------
  // Count number of pools allocated
  //---------------------------------------------------------
  for(;;)
  {
    PoolCount++;
    if((pHmemPoolList = pHmemPoolList->pNext) == NULL)
      break;
  }
  printf("Number of pools allocated: %d\n",PoolCount);
  printf("Pool Statistics:\n");

  pHmemPoolList = pHmemPoolListAnchor;
  ActPoolCount = 0;
  while(ActPoolCount < PoolCount)
  {
    printf("PoolNr. %d",ActPoolCount+1);
    PoolSize = pHmemPoolList->AllocSize;
    printf(", Size: %d\n",PoolSize);
    ActPoolCount++;
    pHmemPoolList = pHmemPoolList->pNext;
  }
  printf("\n");
}


//===========================================================
// Show statistics for free/used pooled buffer list
//
// Input parameters: HMEMDESC * pHmemPoolList	Pool list
// Returns: nothing
//===========================================================
static void FAST ShowAllMemPoolList(HMEMDESC * pHmemDesc)
{

  if(pHmemDesc == NULL)
    return;

  if((pHmemDesc->pUsedPoolListAnchor == NULL) &&
     (pHmemDesc->pFreePoolListAnchor == NULL))
  {
    printf("No pools in use.\n");
    return;
  }
  printf("Used pool buffer statistics:\n");
  ShowMemPoolList(pHmemDesc->pUsedPoolListAnchor);

  printf("Free pool buffer statistics:\n");
  ShowMemPoolList(pHmemDesc->pFreePoolListAnchor);
}


//===========================================================
// Show total memory manager statistics
//
// Input parameters: ds__hmem * pMemCtx	Memory context
// Returns: nothing
//===========================================================
void FAST MemStatistics(ds__hmem * vp__ctx)
{
  ds__hmem * pMemCtx = vp__ctx;
  HMEMDESC * pMemDesc;


  if(pMemCtx == NULL)
  {
    printf("No context structure available!\n");
    return;
  }
  //-------------------------------------------------
  // 1. Show statistics of managed buffers
  //-------------------------------------------------
  pMemDesc = pMemCtx->pHmemDesc;
  if(pMemDesc == NULL)
  {
    printf("No mamangement structure available.\n");
    return;
  }

  ShowAllMemListUsage(pMemDesc);
  //-------------------------------------------------
  // 2. Show statistics of pooled buffers
  //-------------------------------------------------
  ShowAllMemPoolList(pMemDesc);

  return;
}
#endif // defined __XHMEM_DEBUG__


//================================================================
//
// Allocation Helper routine, Version 1 mode
//
//================================================================
static int MemMgrV1(int Function, void * MemPtr, int Size)
{
  //--------------------------------------------
  // Distribute by function...
  //--------------------------------------------
  switch(Function)
  {
    case DEF_AUX_MEMGET:
      if((MemPtr == NULL) || (Size <= 0))
        return(FALSE);
      *((void **) MemPtr) = (void *) malloc(Size);
      if(*((void **) MemPtr) == NULL)
        return(FALSE);
      return(TRUE);

    case DEF_AUX_MEMFREE:
      if((MemPtr != NULL) && (*((void **) MemPtr) != NULL))
        free(*((void **) MemPtr));
      return(TRUE);

    default:
      return(FALSE);
  } // switch
}

//================================================================
//
// Allocation Helper routine, Version 2 mode
//
//================================================================
static int MemMgrV2(void * pContext, int Function,
	            void * MemPtr, int Size)
{
  pContext=pContext;
  //--------------------------------------------
  // Distribute by function...
  //--------------------------------------------
  switch(Function)
  {
    case DEF_AUX_MEMGET:
      if((MemPtr == NULL) || (Size <= 0))
        return(FALSE);
      *((void ** ) MemPtr) = (void *) malloc(Size);
      if(*((void **) MemPtr) == NULL)
        return(FALSE);
      return(TRUE);

    case DEF_AUX_MEMFREE:
      if((MemPtr != NULL) && (*((void **) MemPtr) != NULL))
        free(*((void **) MemPtr));
      return(TRUE);

    default:
      return(FALSE);
  } // switch
}

//================================================================
// Allocate a control structure, fill with appropriate values
//
// Input parameters: int InterfaceMode		0- V1, else V2
// Returns: Allocated, filled structure / NULL
//================================================================
ds__hmem * FAST AllocFillMemCtxStruc(int InterfaceMode)
{
  ds__hmem * pCtxStruc = NULL;

  if((pCtxStruc = (ds__hmem *) calloc(1,sizeof(ds__hmem))) == NULL)
  {
    printf("Could not allocate memory control structure!\n");
    return(NULL);
  }
  pCtxStruc->am__aux1             = &MemMgrV1;
  pCtxStruc->am__aux2             = &MemMgrV2;
  pCtxStruc->in__aux_up_version   = InterfaceMode;
  return(pCtxStruc);
}
// end of 'hobmmgr.c'


#ifdef HL_ENCR_RAND
// hobrand.c
//****************************************************
//
// NIST AES based random generator functions including
// Entropy gathering
//
//****************************************************

#if defined WIN32 || defined WIN64
#include <windows.h>
#include <wincrypt.h>
#include <iprtrmib.h>
#include <iphlpapi.h>
#include <tlhelp32.h>
#include <psapi.h>
#endif

#include <hob-encry-1.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#if !defined WIN32 && !defined WIN64
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <stdarg.h>
#include <fcntl.h>
#include <sys/times.h>
#include <sys/types.h>
#include <sys/resource.h>
#if defined HL_LINUX
#include <sys/stat.h>
#include <sys/sysinfo.h>
#include <dirent.h>
#endif // HL_LINUX
#endif // !defined WINDOWS



#if defined WIN32 || defined WIN64
#pragma warning(disable:4996)
#endif


//#define __DEBUG_INFO__		// Shows hashed data length
//#define __DEBUG__
//#define __DEBUG_WIN__

#if defined __DEBUG__
#define DBG_PRINT(a)		PRINT(a)
#define DBG_PRINT_NL(a)		PRINT_NL(a)
#else
#define DBG_PRINT(a)
#define DBG_PRINT_NL(a)
#endif


#define CRNG_REQ_MAX_BYTES	16		// max. number of byte per request
#define	CRNG_RESEED_INTERVAL	0xFFFFFFFF	// reseed limit
#define	CRNG_CHECK_INTERVAL	128		// recheck limit
//#define	CRNG_CHECK_INTERVAL	1		// for testing only !!

//-----------------------------------------------------
// Returncodes
//-----------------------------------------------------
#define DRBG_SEC_HASH_WEAK		-669	// DRBG insufficient hash
#define	DRBG_SEC_TEST_FAILED		-670	// DRBG selfcheck failed
#define	DRBG_SEC_INIT_FAILED		-671	// DRBG initialize error
#define	DRBG_SEC_INIT_WEAK		-672	// DRBG weak initialize error
#define	DRBG_SEC_RESEED_FAILED		-673	// DRBG reseeding error
#define	DRBG_SEC_RAND_FAILED		-674	// DRBG get random error

#define DRBG_W32_GET_OS_VERSION_FAIL	-675
#define DRBG_EXEC_NULLDEV_OPEN_FAIL	-676
#define DRBG_EXEC_GET_PIPE_FAIL		-677
#define	DRBG_EXEC_FORK_FAIL		-678
#define	DRBG_EXEC_CHILD_INP_TIMEOUT	-679
#define	DRBG_EXEC_STDIN_READ_ERR	-680
#define	DRBG_EXEC_SELECT_ERR		-681
#define	DRBG_EXEC_WRONG_CHILD_PID	-682
#define	DRBG_EXEC_CHILD_ABNORMAL_TERMINATE -683


//-----------------------------------------------------------------
// Structure for Secure random Generator implementation with AES128
//-----------------------------------------------------------------
typedef struct CRNG_STRUC_t {
	unsigned char St[16];		// Statearray, the variable 'V'
	unsigned char Ky[16];		// Keyarray, the variable 'Key'
	int Rs;				// Reseed counter
	int Ck;				// Check counter
	int Fl;				// Bit 1: 1-fatal error occured
					// Bit 0: 1-initialized
}CRNG_STRUC;
//-----------------------------------------------------
// Macros
//-----------------------------------------------------
#define BIGlong2charn(l,c,i) c[i+3] = (char) (l       & 0x0FF);\
                             c[i+2] = (char) ((l>> 8) & 0x0FF);\
                             c[i+1] = (char) ((l>>16) & 0x0FF);\
                             c[i]   = (char) ((l>>24) & 0x0FF);

#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;

#else // JAVA, SOLARIS, WIN64 (!)

#define long2char(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                         c[i+1] = (char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (char) ((l>>16) & 0x0FF);\
                         c[i+3] = (char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                          c[i+1] = (char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (char) ((l>>16) & 0x0FF);\
                          c[i+3] = (char) ((l>>24) & 0x0FF);
#endif

//-----------------------------------------------------
// global structure / Flags for secure random generator
//-----------------------------------------------------
static CRNG_STRUC SecRandStruc;
static int SecRandInitFlag = 0;

#if defined XH_INTERFACE
ds__hmem * pGlobalMemStruc = NULL;
#endif

//---------------------------------------------------------------
// Minimum amount of needed bytes to be hashed, Windows/Unix only
//---------------------------------------------------------------
#if defined WIN32 || defined WIN64
#if !defined WINCE
#define HASH_LIMIT	8000		// Windows excl. WINCE
#else // WINCE
#define	HASH_LIMIT	500		// Windows CE
#endif // WINCE
#else // UNIX

#if defined HL_LINUX && !defined HL_LINUX_ARM
#if 0 // Auf Anweisung von Herrn Galea Pruefung ausgebaut. 21.01.2010 G.Oed
#define	HASH_LIMIT	35000		// Linux
#else
#define	HASH_LIMIT	35
#endif // 0
#else
#if 0
#define	HASH_LIMIT	20000		// all other UNIX systems
#else
#define HASH_LIMIT	35
#endif  // 0
#endif // LINUX
#endif



//-----------------------------------------------------
// Key array for derivation function
//-----------------------------------------------------
// NOTE: Keysize adapted for AES128 Cipher
static char DfKeyData[16] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
};
//-------------------------------------------
// Test seed data for Known answer test (KAT)
//-------------------------------------------
static char CrngTestSeedData[32] = {
	0x61, 0x62, 0x63, 0x64, 0x62, 0x63, 0x64, 0x65,
	0x63, 0x64, 0x65, 0x66, 0x64, 0x65, 0x66, 0x67,
	0x65, 0x66, 0x67, 0x68,	0x66, 0x67, 0x68, 0x69,
	0x67, 0x68, 0x69, 0x6A,	0x68, 0x69, 0x6A, 0x6B,
};

// Test result data from Known answer test (KAT)
static unsigned char CrngCheckData[16] = {
	0x1A, 0x44, 0x25, 0x6F, 0xD8, 0xB8, 0x4F, 0xF4,
	0x25, 0x29, 0x55, 0x14, 0x75, 0x6F, 0x41, 0x32,
};

//---------------------------------------------
// UNIX Commands table
// NOTE: command paths are different for LINUX!
//---------------------------------------------
#if !defined JAVA && !defined WIN32 && !defined WIN64
#if !defined HL_LINUX
//  -------------------------------------------
//  Non LINUX commands
//  -------------------------------------------
static char * CmdTab[] = {
  (char *) "/usr/bin/netstat",	(char *) "-n",	NULL,
  (char *) "/usr/bin/netstat",	(char *) "-s",	NULL,
  (char *) "/usr/sbin/arp",	(char *) "-a",	NULL,
#if !defined HL_HPUX
  (char *) "/usr/sbin/ifconfig",(char *) "-a",	NULL,
#endif
  (char *) "/usr/bin/ps",	(char *) "-ael", NULL,
  (char *) "/usr/bin/who",	(char *) "-a",	NULL,
  (char *) "/usr/bin/last",	(char *) "-20",	NULL,
  (char *) "/usr/bin/df",	(char *) "-k",	NULL,
  (char *) "/usr/bin/vmstat",	(char *) "-s",	NULL,
  (char *) "/usr/bin/uptime",		NULL,	NULL,
  (char *) "/usr/bin/ipcs",	(char *) "-a",	NULL,
#if defined HL_SOLARIS
  (char *) "/usr/bin/tail",(char *) "-200", (char *) "/var/adm/messages",
#endif
#if defined HL_HPUX
  (char *) "/usr/bin/tail",(char *) "-200", (char *) "/var/adm/syslog/syslog.log",
#endif
#if defined HL_MACOS
  (char *) "/usr/bin/tail",(char *) "-200", (char *) "/var/log/system.log",
#endif
	NULL,			NULL,	NULL,
};
#else // LINUX
//  -------------------------------------------
//  LINUX commands (different paths!)
//  -------------------------------------------
static char * CmdTab[] = {
	"/bin/netstat",		"-n",	NULL,
	"/bin/netstat",		"-s",	NULL,
	"/sbin/arp",		"-a",	NULL,
	"/sbin/ifconfig",	"-a",	NULL,
	"/bin/ps",		"-ael",	NULL,
	"/usr/bin/who",		"-a",	NULL,
	"/usr/bin/last",	"-20",	NULL,
	"/bin/df",		"-k",	NULL,
	"/usr/bin/vmstat",	"-s",	NULL,
	"/usr/bin/uptime",	NULL,	NULL,
	"/usr/bin/ipcs",	"-a",	NULL,
	"/usr/bin/lastlog",	NULL,	NULL,
	"/usr/bin/tail",	"-200", "/var/log/kdm.log",
	NULL,			NULL,	NULL,
};
#endif // LINUX
#endif // UNIX


#if 0
// Show hex dump of a byte array, 16 bytes per line
static void PrintHexData(char * pData, int Offset, int Len)
{
  int Count=0;

  while(Len>0)
  {
    printf("%02X",pData[Offset++] & 0x0FF);
    Len--;
    Count++;
    if(Count == 8)
      printf("  ");
    else if(Count == 16)
    {
      printf("\n");
      Count = 0;
    }
    else
      printf(" ");
  }
  printf("\n");
}
#endif // 0


//=========================================================
// Clear a byte array with zeros
//
// Input params: BIT8PTR pArray		Array to clear
//		 int Size		Size of array
// Returns: Nothing
//=========================================================
static void SecClearByteArray(char * pArray, int Size)
{
  memset(pArray,0,Size);
}
//================================================================
// SecGetSystemTimeUTC
// gets system time in UTC format (seconds rel 00:00 01.01.1970)
//
// Input Params : none
// Returns: 	BIT32 time
//================================================================
int FAST SecGetSystemTimeUTC()
{
#if !defined WINCE
  return((int) time(NULL));		// C-Library Version
#else
  return((int) _time64(NULL));		// C-Library Version, WINCE
#endif
}

//=================================================
// Hash system specific Highspeed counter
// Windows: Performance counter
// Unix:    gettimeofday
// Java:    currentTimeMillis
//
// Input parameters: int * pShaArray		SHA-256 array
// Returns: int - size of bytes hashed
//=================================================
static int HashHighspeedCounter(int * pShaArray)
{
  int Retval;
#if defined WIN32 || defined WIN64
  LARGE_INTEGER Counter;
  QueryPerformanceCounter(&Counter);
  SHA256_Update(pShaArray,(char *) &Counter,0,
		sizeof(LARGE_INTEGER));
  Retval = sizeof(LARGE_INTEGER);
#else // UNIX
  struct timeval Timeval;
  gettimeofday(&Timeval,NULL);
  SHA256_Update(pShaArray,(char *) &Timeval,0,
		sizeof(struct timeval));
  Retval = sizeof(struct timeval);
#endif // WIN/UNIX
  return(Retval);
}
//=====================================================
// Calculate PI with a simple approximation
//
// Input parameter: none
// Returns: nothing
//=====================================================
static void CalcPi()
{
  int i,k;
  double Num,Denom,Val;
  //------------------------------------
  // Calculate PI
  //------------------------------------
  Val = 1.0;

  for(i=0; i<1000; i++)
  {
    k = (i+2) & (~0x01);
    Num = (double) k;
    k = (i+1) + (i & 0x01);
    Denom = (double) k;

    Val = Val * Num / Denom;

    if((i & 0x1F) == 0)
    {
#if defined WIN32 || defined WIN64
      Sleep(1);
#else // UNIX
      usleep(1000);
#endif
    }
  }
#if defined __DEBUG__
  Val = Val * 2.0;
  printf("Value: %g\n",Val);
#endif // __DEBUG__
}

//=========================================================
// Increment the variable 'V' modulo 2**128 (outlen)
//
// Input parameters: unsigned char * pArray State variable in BIG endian order
// Returns: nothing
//=========================================================
static void IncVStateArray(unsigned char * pArray)
{
  int Sum,SrcOff;

  Sum = 1;				// preset summand
  SrcOff = 15;				// start for Summing is LSB
  do
  {
    Sum = Sum + ((int) pArray[SrcOff] & 0x0FF);
    pArray[SrcOff--] = (unsigned char) Sum;
    Sum = (Sum >> 8) & 0x0FF;
  }while(SrcOff >= 0);
}
//================================================================
// CTR-DRBG Update function specialized for AES128 crypto function
// Updates V and Key using AES ECB encrypt mode.
//
// Input parameters: CRNG_STRUC * pStruc	Generator structure
//		     char *       pInData	Data to XOR or NULL if none
// Returns: nothing
//================================================================
static void CTR_DRBG_Update128(CRNG_STRUC * pStruc, char * pInData)
{
  int i;
  ds_aes_key EncryptTab;
  //---------------------------------------------------------
  // Generate the subkey array required for encryption
  //---------------------------------------------------------
  m_aes_set_encrypt_key((unsigned char *) pStruc->Ky,4,
			&EncryptTab);
  //---------------------------------------------------------
  // Generate new Key data (16 bytes) first
  //---------------------------------------------------------
  IncVStateArray(pStruc->St);			// V = V+1 mod 2**128
  m_aes_ecb_encrypt(pStruc->St,pStruc->Ky,&EncryptTab,1, AES_NR_MIN);
  //---------------------------------------------------------
  // Generate new State data (16 bytes) next
  //---------------------------------------------------------
  IncVStateArray(pStruc->St);			// V = V+1 mod 2**128
  m_aes_ecb_encrypt(pStruc->St, pStruc->St, &EncryptTab,1, AES_NR_MIN);
  //---------------------------------------------------------
  // XOR in given data if any
  //---------------------------------------------------------
  if(pInData != NULL)
  {
    for(i=0;i<16;i++)
    {
      pStruc->Ky[i] = (unsigned char) (pStruc->Ky[i] ^ pInData[i]);
      pStruc->St[i] = (unsigned char) (pStruc->St[i] ^ pInData[i+16]);
    }
  }
}
//================================================================
// Derivation function for the seed data in block cipher mode
// specialized for AES128 usage (seedlen=32 byte, blocklen=16 byte,
// keylen=16 byte).
//
// Input parameters: char * pInpData		Raw input data, 32 Bytes
//		     char * pOutData		Output data, 32 Bytes
// Returns: nothing
//================================================================
static void BlockCipherDf_AES128(char * pInpData, char * pOutData)
{
  char KeyArray[16];
  char XArray[16];
//  char TmpIV[16];
  char IvSArray[64];
  char TmpArray[64];

  ds_aes_key EncryptTab;
  //--------------------------------------------------------
  // Note: We use combined Array for IV and S from spec.
  // ----- First 16 bytes are the IV, remaining bytes are S
  //--------------------------------------------------------
  memset(IvSArray,0,16);			// Zero the IV
  memset(IvSArray+57,0,7);			// Set additional padding zero
  //--------------------------------------------------------
  // Format the S-String from length, input and padding
  //--------------------------------------------------------
  BIGlong2charn(32,IvSArray,16);		// store the input byte length
  BIGlong2charn(32,IvSArray,20);		// store the output byte length
  memcpy(IvSArray+24,pInpData,32);		// append input data

  IvSArray[32+16+8] = (unsigned char) 0x80;	// store the padding byte

//  printf("IVS Array:\n");
//  PrintHexData(IvSArray,0,64);

  //---------------------------------------------------------
  // Generate the temporary key, for i=0 at first
  //---------------------------------------------------------
  memset(KeyArray,0,16);			// clear key (chaining) value

  m_aes_set_encrypt_key((unsigned char *) DfKeyData,4,
			 &EncryptTab); // generate key

  m_aes_cbc_encrypt((unsigned char *) IvSArray,
		    (unsigned char *) TmpArray,
		    &EncryptTab,4,
		    (unsigned char *) KeyArray,AES_NR_MIN);
  //---------------------------------------------------------
  // Generate the X value, for i=1 next
  //---------------------------------------------------------
  BIGlong2charn(1,IvSArray,0);			// set i=1 for IV

  memset(XArray,0,16);			// clear X (chaining) value

  m_aes_cbc_encrypt((unsigned char *) IvSArray,
		    (unsigned char *) TmpArray,
                    &EncryptTab,4,
		    (unsigned char *) XArray,AES_NR_MIN);
  //----------------------------------------------------------------
  // Expand X value for needed output size bytes using temporary key
  //----------------------------------------------------------------
  m_aes_set_encrypt_key((unsigned char *) KeyArray,4, &EncryptTab);

  m_aes_ecb_encrypt((unsigned char *) XArray,
		    (unsigned char *) XArray,
		    &EncryptTab,1,AES_NR_MIN);
  memcpy(pOutData,XArray,16);

  m_aes_ecb_encrypt((unsigned char *) XArray,
		    (unsigned char *) XArray,
		    &EncryptTab,1,AES_NR_MIN);
  memcpy(pOutData+16,XArray,16);
}
//================================================================
// CTR-DRBG Instantiate function specialized for AES128 crypto function
// NOTE: No personalization data/NONCE are used
//
// Input parameters: CRNG_STRUC * pStruc	Generator structure
//		     char * pEntropy		Entropy data to use
// Returns: nothing
//================================================================
static void FAST CTR_DRBG_Instantiate128(CRNG_STRUC * pStruc,
					 char * pEntropy)
{
  char SeedMaterial[32];

  //----------------------------------------------------------------
  // Initialize the structure set V=0, Key=0, Reseedcount=1, Flags=1
  //----------------------------------------------------------------
  memset(pStruc->St,0,16);			// set V  =0
  memset(pStruc->Ky,0,16);			// set Key=0

  pStruc->Rs = 1;				// reseed counter = 1
  pStruc->Ck =  1;				// check counter = 1
  pStruc->Fl = 0x01;				// Flags = initialized
  //-----------------------------------------
  // Generate seeding material from raw input
  //-----------------------------------------
  BlockCipherDf_AES128(pEntropy,SeedMaterial);
  //----------------------------------------------------------
  // Set initial key and state variables
  //----------------------------------------------------------
  CTR_DRBG_Update128(pStruc,SeedMaterial);
  SecClearByteArray(SeedMaterial,32);
  CTR_DRBG_Update128(pStruc,NULL);
}
//================================================================
// CTR-DRBG Reseed function specialized for AES128 crypto function
// NOTE: No personalization data/NONCE are used
//
// Input parameters: CRNG_STRUC * pStruc	Generator structure
//		     char * pEntropy		Entropy data to use
// Returns: nothing
//================================================================
static void FAST CTR_DRBG_Reseed128(CRNG_STRUC * pStruc, char * pEntropy)
{
  char SeedMaterial[32];

  //-----------------------------------------
  // Generate seeding material from raw input
  //-----------------------------------------
  BlockCipherDf_AES128(pEntropy,SeedMaterial);

  //----------------------------------------------------------
  // Update key and state variables
  //----------------------------------------------------------
  CTR_DRBG_Update128(pStruc,SeedMaterial);
  SecClearByteArray(SeedMaterial,32);
  CTR_DRBG_Update128(pStruc,NULL);
  pStruc->Rs = 1;				// Reseed counter = 1
  pStruc->Fl = 0x01;				// set initialized

}
//================================================================
// CTR-DRBG Generate function specialized for AES128 crypto function
// NOTE: No personalization data/NONCE are used, size of data to
// ----- return is given in bytes
//
// Input parameters: CRNG_STRUC * pStruc Generator structure
//		     char *  pOutData	Output buffer
//		     int     OutOff	start of destination data
//		     int     OutLen	number of bytes requested
//		     int     NoReseed	if <> 0 no reseed checking done
// Returns: int Status - 0 o.k., < 0 parameter error,
//			 1 - not initialized
//			 2 - reseed needed
//================================================================
static int FAST CTR_DRBG_Generate128(CRNG_STRUC * pStruc, char * pOutData,
					    int OutOff, int OutLen,
					    int NoReseed)
{
  int CopyLen;
  unsigned char OutBlock[16];
  ds_aes_key EncryptTab;
  //-------------------------------------------
  // Check parameters first
  //-------------------------------------------
  if((pStruc == NULL) || (pOutData == NULL))
    return(-1);				// NULL pointer

  if((OutLen < 0) || (OutLen > CRNG_REQ_MAX_BYTES))
    return(-2);				// parameter error

  if((pStruc->Fl & 0x01) == 0)	// not initialized
    return(1);

  //-------------------------------------------
  // Check if reseed is needed
  //-------------------------------------------
  if(NoReseed == 0)
  {
    if(pStruc->Rs == 0)		// already 2**32 requests were issued
      return(2);
  }
  //-------------------------------------------
  // Generate the output data using V and Key K
  //-------------------------------------------
  m_aes_set_encrypt_key(pStruc->Ky, 4, &EncryptTab);

  while(OutLen != 0)
  {
    CopyLen = OutLen;
    if(CopyLen > AES_BLOCK_SIZE)
      CopyLen = AES_BLOCK_SIZE;

    IncVStateArray(pStruc->St);			// V = V+1 mod 2**128
    m_aes_ecb_encrypt(pStruc->St, OutBlock, &EncryptTab, 1, AES_NR_MIN);

//    printf("CopyLen: %d",CopyLen);
//    printf(" DstOff: %d\n,OutOff);

    memcpy(pOutData+OutOff,OutBlock,CopyLen);

    OutLen -= CopyLen;
    OutOff += AES_BLOCK_SIZE;
  }
  //-----------------------------------------------
  // Update the state/key arrays next
  //-----------------------------------------------
  CTR_DRBG_Update128(pStruc,NULL);
  if(NoReseed == 0)
    pStruc->Rs ++;

  return(0);
}
//=======================================================
// Test operation of the AES128 DBRG generator:
// 1. Instantiate the generator using test seed data
// 2. Generate 16 byte of random data, compare against
//    known result
//
// Input parameters: none
// Returns: int Status - 0 o.k., else error occured
//=======================================================
static int FAST CTR_DRBG_Test()
{
  int Retcode,i;
  char ResultData[16];
  CRNG_STRUC * pTestStruc;
  CRNG_STRUC TestStruc;
  pTestStruc = &TestStruc;
  //------------------------------------------------------
  // initialize generator, 'seed' it, get 'Random' data
  //------------------------------------------------------
  CTR_DRBG_Instantiate128(pTestStruc,CrngTestSeedData);
  Retcode = CTR_DRBG_Generate128(pTestStruc,(char *) ResultData,0,16,0);
  if(Retcode != 0)
  {
//    printf("Retcode was: %d\n",Retcode);
    return(-9995);
  }
//  PrintHexData(ResultData,0,16);
  //---------------------------------------------
  // Compare result with KAT result data
  //---------------------------------------------
  for(i=0;i<16;i++)
  {
    if(ResultData[i] != (char) CrngCheckData[i])
      return(-9996);
  }
  return(0);
}

//================================================================
// Get requested number of random bytes from the CRT_DRBG
// with AES128. If requested number of bytes is larger than 16
// bytes, multiple requests are done with as many full blocks as
// needed.
//
// Input parameters: CRNG_STRUC * pStruc Generator structure
//		     char * pOutData	Output buffer
//		     int     OutOff	start for destination data
//		     int     OutLen	number of bytes requested
//		     int     NoReseed	if <> 0, no reseed checking done
// Returns: int Status - 0 o.k., < 0 parameter error,
//			 1 - not initialized
//			 2 - reseed needed
//================================================================
static int FAST DRBGGetRandBytes(CRNG_STRUC * pStruc, char * pOutData,
				        int OutOff,int OutLen,int NoReseed)
{
  int BlockCnt,InBlkCnt,Retcode;

  BlockCnt = OutLen/CRNG_REQ_MAX_BYTES;
  InBlkCnt = OutLen - (BlockCnt * CRNG_REQ_MAX_BYTES);
  //-----------------------------------------------------
  // Generate full blocks if required
  //-----------------------------------------------------
  while(BlockCnt != 0)
  {
    if((Retcode = CTR_DRBG_Generate128(pStruc,pOutData,OutOff,
				       CRNG_REQ_MAX_BYTES,NoReseed)) != 0)
      return(Retcode);
    BlockCnt--;
    OutOff += CRNG_REQ_MAX_BYTES;
    pStruc->Ck++;
    if(pStruc->Ck > CRNG_CHECK_INTERVAL) // check needed ?
    {
      pStruc->Ck = 1;			// check counter = 1
      Retcode = CTR_DRBG_Test();
      if(Retcode != 0)
      {
        pStruc->Fl &= ~0x01;		// set to not initialized
        return(Retcode);
      }
    }
  }
  //-----------------------------------------------------
  // Generate remaining bytes if required
  //-----------------------------------------------------
  if(InBlkCnt != 0)
  {
    if((Retcode = CTR_DRBG_Generate128(pStruc,pOutData,OutOff,InBlkCnt,
				       NoReseed)) != 0)
      return(Retcode);
    pStruc->Ck++;
    if(pStruc->Ck > CRNG_CHECK_INTERVAL) // Check needed ?
    {
      pStruc->Ck = 1;
      Retcode = CTR_DRBG_Test();
      if(Retcode != 0)
      {
        pStruc->Fl &= ~0x01;		// set to not initialized
        return(Retcode);
      }
    }
  }
  return(0);
}



#if defined WIN32 || defined WIN64
//=============================================================
// WINDOWS: Hash system times if function is available on
//          current system
//
// Input parameters: int * pShaArray
// Returns: int Status > 0 o.k. number of bytes hashed
//=============================================================
static int HashSysTimes(int * pShaArray)
{
  FILETIME IdleTime;
  FILETIME KernelTime;
  FILETIME UserTime;
  FARPROC  hAddr;
  HMODULE hLib;
  //--------------------------------------------
  // Get Address of function from kernel32.dll
  //--------------------------------------------
  if((hLib =LoadLibrary("kernel32.dll")) == NULL)
  {
    DBG_PRINT("kernel32.dll load failed!\n");
    return(-1);
  }
  if((hAddr = GetProcAddress(hLib,"GetSystemTimes")) == NULL)
  {
    DBG_PRINT("No GetSystemTimes found!\n");
    return(0);
  }

  (*hAddr)(&IdleTime,&KernelTime,&UserTime);
  SHA256_Update(pShaArray,(char *) &IdleTime,0,
		sizeof(FILETIME));
  SHA256_Update(pShaArray,(char *) &KernelTime,0,
		sizeof(FILETIME));
  SHA256_Update(pShaArray,(char *) &UserTime,0,
		sizeof(FILETIME));
  FreeLibrary(hLib);

  return(sizeof(FILETIME) * 3);
}

#if !defined WINCE
//=============================================================
// WINDOWS: Hash performance information if function is available on
//          current system
//
// Input parameters: int * pShaArray
// Returns: int Status > 0 o.k., else no function present/error
//=============================================================
static int HashPerfInfo(int * pShaArray)
{
  PERFORMANCE_INFORMATION PerfInfo;
  FARPROC  hAddr;
  HMODULE hLib;
  //--------------------------------------------
  // Get Address of function from Psapi.dll
  //--------------------------------------------
  if((hLib =LoadLibrary("Psapi.dll")) == NULL)
  {
    DBG_PRINT("Psapi.dll load failed!\n");
    return(-1);
  }
  if((hAddr = GetProcAddress(hLib,"GetPerformanceInfo")) == NULL)
  {
    DBG_PRINT("No GetPerformanceInfo found!\n");
    return(0);
  }

  (*hAddr)(&PerfInfo,sizeof(PERFORMANCE_INFORMATION));
  SHA256_Update(pShaArray,(char *) &PerfInfo,0,
		sizeof(PERFORMANCE_INFORMATION));
  FreeLibrary(hLib);

  return(sizeof(PERFORMANCE_INFORMATION));
}
#endif // !defined WINCE

#if !defined WINCE
//=====================================================
// WINDOWS: Hash process information for a given process ID
// Input parameters: int ProcessId
//		     int * pShaArray
// Returns: int Status - > 0 o.k.
//=====================================================
static int HashProcessInfo(int ProcessId, int * pShaArray)
{
  int i=0;
  int BytesHashed = 0;
  DWORD Priority;
  HANDLE hProcess;
  FILETIME CreateTime,ExitTime,KernelTime,UserTime;
  IO_COUNTERS IoCounters;
  PROCESS_MEMORY_COUNTERS MemCounters;

  hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcessId);
  if(hProcess == NULL)
    return(-1);

  Priority = GetPriorityClass(hProcess);
  if(Priority != 0)
  {
    SHA256_Update(pShaArray,(char *) &Priority, 0, sizeof(DWORD));
    i++;
    BytesHashed += sizeof(DWORD);
  }

  if(GetProcessIoCounters(hProcess,&IoCounters) != 0)
  {
    SHA256_Update(pShaArray,(char *) &IoCounters,0,
		  sizeof(IO_COUNTERS));
    i++;
    BytesHashed += sizeof(IO_COUNTERS);
  }

  if(GetProcessTimes(hProcess,&CreateTime,&ExitTime,&KernelTime,&UserTime) !=0)
  {
    SHA256_Update(pShaArray,(char *) &CreateTime,0, sizeof(FILETIME));
    SHA256_Update(pShaArray,(char *) &ExitTime,0, sizeof(FILETIME));
    SHA256_Update(pShaArray,(char *) &KernelTime,0, sizeof(FILETIME));
    SHA256_Update(pShaArray,(char *) &UserTime,0, sizeof(FILETIME));
    i++;
    BytesHashed += (sizeof(FILETIME) * 4);
  }

  if(GetProcessMemoryInfo(hProcess,&MemCounters,sizeof(MemCounters)) != 0)
  {
    SHA256_Update(pShaArray,(char *) &MemCounters,0,
		  sizeof(MemCounters));
    i++;
    BytesHashed += sizeof(MemCounters);
  }

  CloseHandle(hProcess);

  if(i > 0)
    return(BytesHashed);
  else
    return(i);
}
#endif // !defined WINCE

#if !defined WINCE
//==============================================================
// WINDOWS: Collect information about all processes in the system
// - Priority class, IO-Counters, Times, Memoryinfo, Modules, Threads
//
// Input parameters: int * pShaArray		SHA256 array to use
// Returns: int Status > 0 o.k., number of bytes hashed
//==============================================================
static int FAST CollectSnapshots(int * pShaArray)
{
  int Retcode,i;
  int BytesHashed;
  int ProcessCount,ThreadCount,ModulesCount;

  HANDLE hSnap,hSnapModule,hSnapThread;
  PROCESSENTRY32 ProcEntry;
  MODULEENTRY32 ModuleEntry;
  THREADENTRY32 ThreadEntry;
  FILETIME        dsl_procwatchtime;
  FILETIME        dsl_processtime;
  ULARGE_INTEGER  dsl_time1;
  ULARGE_INTEGER  dsl_time2;


  ProcessCount = 0;
  ThreadCount  = 0;
  ModulesCount = 0;

  i = 0;
  BytesHashed = 0;

  // Make snapshot of all processes in system
  hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
  if(hSnap == INVALID_HANDLE_VALUE)
    return(-1);

  ProcEntry.dwSize = sizeof(ProcEntry);
  dsl_procwatchtime.dwHighDateTime = 0;
  dsl_procwatchtime.dwLowDateTime = 0;

  Retcode = Process32First(hSnap,&ProcEntry);
  if(Retcode == 0)
  {
    CloseHandle(hSnap);
    return(0);
  }
  do
  {
    ProcessCount++;

//     printf("NextProcess\n");

    if((Retcode = HashProcessInfo(ProcEntry.th32ProcessID,pShaArray)) > 0)
    {
      i++;
      BytesHashed += Retcode;
    }
    else
    { // if the HashProcessInfo fails in consequence of missing access rights, it consumes a lot of time
      if (Retcode < 0)
      {
        if ((dsl_procwatchtime.dwLowDateTime == 0) && (dsl_procwatchtime.dwHighDateTime == 0))
           GetSystemTimeAsFileTime(&dsl_procwatchtime);
        else
        {
          GetSystemTimeAsFileTime(&dsl_processtime);
          dsl_time1.u.HighPart = dsl_processtime.dwHighDateTime;
          dsl_time1.u.LowPart = dsl_processtime.dwLowDateTime;
          dsl_time2.u.HighPart = dsl_procwatchtime.dwHighDateTime;
          dsl_time2.u.LowPart = dsl_procwatchtime.dwLowDateTime;
	  // if error situations take more than 30 seconds, stop the process hashing
          if ((dsl_time1.QuadPart - dsl_time2.QuadPart) > 150000000)  // 30 sec.
             break;
        }
      }
    }
    //-------------------------------------------------
    // Make a snapshot of modules used by given process
    //-------------------------------------------------
    for(;;)
    {
      hSnapModule = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,
					     ProcEntry.th32ProcessID);
      if(hSnapModule == INVALID_HANDLE_VALUE)
      {
//        printf("No modules handle, errno=%08X!\n",GetLastError());
        break;
      }

      ModuleEntry.dwSize = sizeof(MODULEENTRY32);

      if(Module32First(hSnapModule,&ModuleEntry) == 0)
      {
//        printf("No first module!\n");
        CloseHandle(hSnapModule);
        break;
      }
      //-------------------------------------------------
      // Hash module information of all modules
      //-------------------------------------------------
//      printf("Have first module!\n");
      do
      {
        ModulesCount++;
        SHA256_Update(pShaArray,(char *) &ModuleEntry,0,
		      sizeof(MODULEENTRY32));
        i++;
        BytesHashed += sizeof(MODULEENTRY32);
//        printf("NextModule\n");
      }while(Module32Next(hSnapModule,&ModuleEntry) != 0);
      CloseHandle(hSnapModule);
      break;
    }

    //-------------------------------------------------
    // Make a snapshot of threads used by given process
    //-------------------------------------------------
    for(;;)
    {
      hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD,
					     ProcEntry.th32ProcessID);
      if(hSnapThread == INVALID_HANDLE_VALUE)
        break;

      ThreadEntry.dwSize = sizeof(THREADENTRY32);

      if(Thread32First(hSnapThread,&ThreadEntry) == 0)
      {
        CloseHandle(hSnapThread);
        break;
      }
      //---------------------------------------
      // Hash thread information of all threads
      //---------------------------------------
      do
      {
        ThreadCount++;
        SHA256_Update(pShaArray,(char *) &ThreadEntry,0,
		      sizeof(THREADENTRY32));
        i++;
	BytesHashed += sizeof(THREADENTRY32);
//        printf("NextThread\n");
      }while(Thread32Next(hSnapThread,&ThreadEntry) != 0);
      CloseHandle(hSnapThread);
      break;
    }
  }while(Process32Next(hSnap,&ProcEntry) != 0);

  CloseHandle(hSnap);

  // check, if the HashProcessInfo function was stopped by a timeout
  if ((dsl_procwatchtime.dwLowDateTime != 0) || (dsl_procwatchtime.dwHighDateTime != 0))
  {
    SHA256_Update(pShaArray,(char *) &dsl_procwatchtime,0,
		      sizeof(FILETIME));
	BytesHashed += sizeof(FILETIME);
    SHA256_Update(pShaArray,(char *) &dsl_processtime,0,
		      sizeof(FILETIME));
	BytesHashed += sizeof(FILETIME);
  }

//  printf("Processes: %d\n",ProcessCount);
//  printf("Modules:   %d\n",ModulesCount);
//  printf("Threads:   %d\n",ThreadCount);

  if(i > 0)
    return(BytesHashed);
  else
    return(i);
}
#endif // !defined WINCE


//=======================================================
// WINDOWS: Hash network tables and statistics
//
// Input parameters: int * pShaArray
// Returns: int Status > 0 o.k., number of bytes hashed
//=======================================================
static int GetNetHashes(HMEM_CTX_DEF int * pShaArray)
{
  int BytesHashed;
  int i,TableLen;

  MIB_IPSTATS IpStats;
  MIB_UDPSTATS UdpStats;
  MIB_TCPSTATS TcpStats;

  char * pBuf = NULL;

  i = 0;
  BytesHashed = 0;
  //----------------------------
  // Hash the Interface(s) table
  //----------------------------
  TableLen = 0;
  GetIfTable((MIB_IFTABLE *) pBuf,(PULONG) &TableLen,0);	// get required size
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TableLen)) != NULL)
  {
    if(GetIfTable((MIB_IFTABLE *) pBuf,(PULONG) &TableLen,0) == NO_ERROR)
    {
      DBG_PRINT("Got IF table\n");
      SHA256_Update(pShaArray,pBuf,0,TableLen);
      BytesHashed += TableLen;
      i++;
    }
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }
  //------------------------------------
  // Hash the Ipnet table and statistics
  //------------------------------------
  TableLen = 0;
  GetIpNetTable((MIB_IPNETTABLE *) pBuf,(PULONG) &TableLen,0); // get required size
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TableLen)) != NULL)
  {
    if(GetIpNetTable((MIB_IPNETTABLE *) pBuf,(PULONG) &TableLen,0) == NO_ERROR)
    {
      DBG_PRINT("Got IP table\n");
      SHA256_Update(pShaArray,pBuf,0,TableLen);
      BytesHashed += TableLen;
      i++;
    }
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }

  if(GetIpStatistics(&IpStats) == NO_ERROR)
  {
    DBG_PRINT("Got IP statistics\n");
    SHA256_Update(pShaArray,(char *) &IpStats,0,sizeof(IpStats));
    BytesHashed += sizeof(IpStats);
    i++;
  }
  //----------------------------------
  // Hash the UDP table and statistics
  //----------------------------------
  TableLen = 0;
  GetUdpTable((MIB_UDPTABLE *) pBuf,(PDWORD) &TableLen,0); // get required size
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TableLen)) != NULL)
  {
    if(GetUdpTable((MIB_UDPTABLE *) pBuf,(PDWORD) &TableLen,0) == NO_ERROR)
    {
      DBG_PRINT("Got UDP table\n");
      SHA256_Update(pShaArray,pBuf,0,TableLen);
      BytesHashed += TableLen;
      i++;
    }
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }
  if(GetUdpStatistics(&UdpStats) == NO_ERROR)
  {
    DBG_PRINT("Got UDP statistics\n");
    SHA256_Update(pShaArray,(char *) &UdpStats,0,sizeof(UdpStats));
    BytesHashed += sizeof(UdpStats);
    i++;
  }
  //----------------------------------
  // Hash the TCP table and statistics
  //----------------------------------
  TableLen = 0;
  GetTcpTable((MIB_TCPTABLE *) pBuf,(PDWORD) &TableLen,0); // Get required size
  if((pBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,TableLen)) != NULL)
  {
    if(GetTcpTable((MIB_TCPTABLE *) pBuf,(PDWORD) &TableLen,0) == NO_ERROR)
    {
      DBG_PRINT("Got TCP table\n");
      SHA256_Update(pShaArray,pBuf,0,TableLen);
      BytesHashed += TableLen;
      i++;
    }
    FREE_ARRAY(HMEM_CTX_REF,pBuf);
  }

  if(GetTcpStatistics(&TcpStats) == NO_ERROR)
  {
    DBG_PRINT("Got TCP statistics\n");
    SHA256_Update(pShaArray,(char *) &TcpStats,0,sizeof(TcpStats));
    BytesHashed += sizeof(TcpStats);
    i++;
  }
  if(i > 0)
    return(BytesHashed);
  else
    return(i);
}

#if !defined WINCE
//====================================================================
// WINDOWS: Hash files in eventlog directory/directories
// Registry path is \HKLM\SYSTEM\CurrentControlset\Services\Eventlog
//
// Input parameter: int * pShaArray	SHA256 Hash Array
//		    int * pBytesHashed  Number of bytes hashed
// Returns: int Status > 0 o.k., else error occured/no files found
//====================================================================
static int HashEvtDir(HMEM_CTX_DEF int * pShaArray, int * pBytesHashed)
{
  int BytesHashed;
  int Retcode,Index,Index2,PathIndex;
  int MaxSubkeys,MaxSubkeyLen,SubkeyLen;
  int ValueType,ValueLen;
  int Percentage;

  char SubkeyBuf[512];

  char * pValueBuf;
  char * pPathBuf;
  char ** pPathArray;
  HKEY hKey;
  HKEY hSubkey = NULL;
  FILETIME LastAccessTime;
  char DriveBuf[4];
  char DirBuf[MAX_PATH];

  HANDLE hFile;
  WIN32_FIND_DATA FileInfo;

  Percentage = 0;
  BytesHashed = 0;
  //-----------------------------------------------------------------------
  // Open main key for subkeys enumeration, get numer of keys,
  // longest size of key, allocate required subkey name buffer
  //-----------------------------------------------------------------------
  Retcode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			 "SYSTEM\\CurrentControlSet\\Services\\Eventlog",0,
			 KEY_READ, &hKey);
  if(Retcode != ERROR_SUCCESS)
    return(-1);

#if defined __DEBUG_WIN__
  printf("Main key open o.k.\n");
#endif

  Retcode = RegQueryInfoKey(hKey,NULL,NULL,NULL,
			      (LPDWORD) &MaxSubkeys,(LPDWORD) &MaxSubkeyLen,
			      NULL,NULL,NULL,NULL,NULL,
			      &LastAccessTime);
  if((Retcode != ERROR_SUCCESS) || (MaxSubkeys == 0))
  {
    RegCloseKey(hKey);
    return(-2);
  }

#if defined __DEBUG_WIN__
  printf("Query info key o.k., %d entries\n",MaxSubkeys);
#endif

  // Hash last access times
  SHA256_Update(pShaArray,(char *) &LastAccessTime, 0,
		sizeof(LastAccessTime));
  BytesHashed += sizeof(LastAccessTime);

  //----------------------------------------
  // Allocate buffers
  //----------------------------------------
  pPathArray = (char **) BIT8_ARRAY_ALLOC(HMEM_CTX_REF,
				MaxSubkeys * sizeof (char *)); // alloc path
  memset(pPathArray,0,MaxSubkeys * sizeof (char *)); // set NULLs
  //-------------------------------------------------------------
  // Enumerate Subkeys for Main key one by one, extract the paths
  //-------------------------------------------------------------
  Index = 0;
  PathIndex = 0;
  while(Index < MaxSubkeys)
  {
    //-----------------------------------------
    // Get next subkey name, open it
    //-----------------------------------------
    hSubkey = NULL;
    SubkeyLen = sizeof(SubkeyBuf)-1;

#if defined __DEBUG_WIN__
    printf("Try subkey, %s\n",SubkeyBuf);
#endif

    Retcode = RegEnumKeyEx(hKey,Index,SubkeyBuf,(LPDWORD) &SubkeyLen,
			   NULL,NULL,NULL,NULL);
    if(Retcode != ERROR_SUCCESS)
      continue;

    SubkeyBuf[SubkeyLen] = 0;		// terminate (NUL might be missing)
    Index++;

#if defined __DEBUG_WIN__
    printf("Got subkey, %s\n",SubkeyBuf);
#endif

    Retcode = RegOpenKeyEx(hKey,SubkeyBuf,0,KEY_READ,&hSubkey);
    if(Retcode != ERROR_SUCCESS)
      continue;

#if defined __DEBUG_WIN__
    printf("Subkey open o.k.\n");
#endif
    //------------------------------------------------
    // Got a new subkey handle, query 'File' Value
    //------------------------------------------------
    Retcode = RegQueryValueEx(hSubkey,"File",NULL,
			      (LPDWORD) &ValueType,NULL,
			      (LPDWORD) &ValueLen);
    if((Retcode != ERROR_SUCCESS) || ((ValueType != REG_SZ) &&
       (ValueType != REG_EXPAND_SZ)))
    {
#if defined __DEBUG_WIN__
      printf("QueryEX Retcode = %d\n",Retcode);
#endif
      RegCloseKey(hSubkey);
      hSubkey = NULL;
      continue;
    }
    //-------------------------------------------------------
    // 'File' value is present allocate buffer, read value
    //-------------------------------------------------------
#if defined __DEBUG_WIN__
    printf("FILE value found, subkey: %s\n",SubkeyBuf);
#endif

    pValueBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ValueLen+2);
    Retcode = RegQueryValueEx(hSubkey,"File",NULL,
			      NULL,(LPBYTE) pValueBuf,
			      (LPDWORD) &ValueLen);
    RegCloseKey(hSubkey);			// no longer needed
    hSubkey = NULL;
    if(Retcode != ERROR_SUCCESS)
    {
      FREE_ARRAY(HMEM_CTX_REF,pValueBuf);
      continue;
    }
    //--------------------------------------------------
    // Expand path if required, strip filename/extension
    //--------------------------------------------------
    if(ValueType == REG_EXPAND_SZ)
    {
#if defined __DEBUG_WIN__
      printf("Expanding path for %s\n",pValueBuf);
#endif
      pPathBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,MAX_PATH+ValueLen+2);
      Retcode = ExpandEnvironmentStrings(pValueBuf,pPathBuf,
					 MAX_PATH+ValueLen);
      FREE_ARRAY(HMEM_CTX_REF,pValueBuf);
      pPathBuf[Retcode] = 0;
      if(Retcode == 0)
      {
        FREE_ARRAY(HMEM_CTX_REF,pPathBuf);
        continue;
      }
      pPathArray[PathIndex] = pPathBuf;
    }
    else
    {
      pPathArray[PathIndex] = pValueBuf;
    }


#if defined __DEBUG_WIN__
    printf("Expanded path is: %s\n",pPathArray[PathIndex]);
#endif
    //-------------------------------------------------------
    // Remove File/Extension from path
    //-------------------------------------------------------
    _splitpath(pPathArray[PathIndex],DriveBuf,DirBuf,NULL,NULL);
#if defined __DEBUG_WIN__
    printf("Drive: %s, Dir: %s \n",DriveBuf,DirBuf);
#endif
    _makepath(pPathArray[PathIndex],DriveBuf,DirBuf,"*","*");
#if defined __DEBUG_WIN__
    printf("Extracted path is: %s\n",pPathArray[PathIndex]);
#endif
    PathIndex++;
  }
  //---------------------------------------------
  // Close registry keys
  //---------------------------------------------
  if(hSubkey != NULL)
    RegCloseKey(hSubkey);
  RegCloseKey(hKey);

  //----------------------------------------------
  // Remove duplicate pathes from Array
  //----------------------------------------------
  for(Index2=PathIndex-1;Index2 > 0; Index2--)
  {
    for(Index = Index2-1;Index >= 0; Index--)
    {
      if(stricmp(pPathArray[Index2],pPathArray[Index]) == 0) // same path
      {
        FREE_ARRAY(HMEM_CTX_REF,pPathArray[Index2]);
        pPathArray[Index2] = NULL;
        break;
      }
    }
  }
  //-------------------------------------------------------
  // Enumerate files in directories, hash structures
  //-------------------------------------------------------
  for(Index = 0; Index < PathIndex; Index++)
  {
    if(pPathArray[Index] == NULL)
     continue;

    for(;;)
    {
      hFile = FindFirstFile(pPathArray[Index],&FileInfo);
      if(hFile == INVALID_HANDLE_VALUE)
        break;

#if defined __DEBUG_WIN__
      printf("Found first file.\n");
#endif
      SHA256_Update(pShaArray,(char *) &FileInfo,0,
		    sizeof(FileInfo));
      BytesHashed += sizeof(FileInfo);
      //-----------------------------------------
      // Enumerate more files if any
      //-----------------------------------------
      for(;;)
      {
        Retcode = FindNextFile(hFile,&FileInfo);
        if(Retcode != 0)
        {
#if defined __DEBUG_WIN__
          printf("Found next file.\n");
#endif
          SHA256_Update(pShaArray,(char *) &FileInfo,0,
		        sizeof(FileInfo));
          BytesHashed += sizeof(FileInfo);
          continue;
        }
#if defined __DEBUG_WIN__
        printf("No more files.\n");
#endif
        break;
      }
      Percentage += 2;
      FindClose(hFile);
      break;
    }
    FREE_ARRAY(HMEM_CTX_REF,pPathArray[Index]);
  }
  FREE_ARRAY(HMEM_CTX_REF,pPathArray);

  *pBytesHashed = BytesHashed;
  return(Percentage);
}
#endif // !defined WINCE

//=============================================================
// WINDOWS: Collect entropy for DRBG seed on windows systems
//
// Input parameters: char *  pDigest		Output buffer, 32 bytes
//		     int *   pBytesHashed	Number of bytes hashed
// Returns: int Collected percentage, should be near 100
//=============================================================
static int SysGetEntropy(HMEM_CTX_DEF char * pDigest, int * pBytesHashed)
{
  int BytesHashed,Retcode;
  int Index,Len,TotalPercentage;
  int Bit32Val1;
  LARGE_INTEGER Bit64Val1,Bit64Val2,Bit64Val3;

  char * pName;

  int ShaArray[SHA256_ARRAY_SIZE];

  POINT Point;
  SYSTEMTIME SysTime;
//  PERFORMANCE_INFORMATION PerfInfo;
#ifdef WINCE // AG added
#define MEMORYSTATUSEX MEMORYSTATUS // AG added
#define GlobalMemoryStatusEx GlobalMemoryStatus // AG added
#endif // AG added
  MEMORYSTATUSEX MemoryStatusEx;
  long LongVal;
  HCRYPTPROV hProv;
  char TmpBuffer[32];

  SHA256_Init(ShaArray);
  TotalPercentage = 0;
  BytesHashed = 0;
  //-------------------------------------------------------
  // 1. Hash initial performance counter
  //-------------------------------------------------------
  BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  TotalPercentage += 2;

  //-------------------------------------------------------
  // 2. Get standard function values
  //-------------------------------------------------------
  GetLocalTime(&SysTime);			// Time / Date
  SHA256_Update(ShaArray,(char *) &SysTime,0,
	        sizeof(SYSTEMTIME));
  BytesHashed += sizeof(SYSTEMTIME);
  TotalPercentage += 4;

  Bit32Val1 = GetCurrentProcessId();		// Process ID
  SHA256_Update(ShaArray,(char *) &Bit32Val1,0,4);
  TotalPercentage += 4;
  BytesHashed += 4;

  Bit32Val1 = GetCurrentThreadId();		// Thread ID
  SHA256_Update(ShaArray,(char *) &Bit32Val1,0,4);
  TotalPercentage += 4;
  BytesHashed += 4;

  Bit32Val1 = GetTickCount();			// System Tics
  SHA256_Update(ShaArray,(char *) &Bit32Val1,0,4);
  TotalPercentage += 4;
  BytesHashed += 4;

  QueryPerformanceFrequency(&Bit64Val1);	// Performance frequency
  SHA256_Update(ShaArray,(char *) &Bit64Val1,0,
				  sizeof(LARGE_INTEGER));
  BytesHashed += sizeof(LARGE_INTEGER);

#if !defined WINCE
  if((Retcode = HashPerfInfo(ShaArray)) > 0)	// performance info
  {
    DBG_PRINT("Got Performance info\n");
    TotalPercentage += 4;
    BytesHashed += Retcode;
  }
#endif // !defined WINCE
  BytesHashed += HashHighspeedCounter(ShaArray);// get performance counter
  TotalPercentage += 4;

  //---------------------------------------------
  // 3. Get process information for all processes
  //---------------------------------------------
#if !defined WINCE
  if((Retcode = CollectSnapshots(ShaArray)) > 0)
  {
    DBG_PRINT("Got Process info\n");
    TotalPercentage += 4;
    BytesHashed += Retcode;
  }
#endif // !defined WINCE
  //---------------------------------------------
  // 4. Calculate PI, measure times
  //---------------------------------------------
  BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  if((Retcode = HashSysTimes(ShaArray)) > 0) // get system times (idle, kernel...)
  {
    DBG_PRINT("Got System times\n");
    TotalPercentage += 4;
    BytesHashed += Retcode;
  }
  CalcPi();
  BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  TotalPercentage += 4;
  if((Retcode = HashSysTimes(ShaArray)) > 0)	// get system times (idle, kernel...)
  {
    TotalPercentage += 4;
    BytesHashed += Retcode;
  }
  //---------------------------------------------
  // 5. Get some more simple informations
  //---------------------------------------------
  if(GetDiskFreeSpaceEx("\\", (ULARGE_INTEGER *) &Bit64Val1,
			      (ULARGE_INTEGER *) &Bit64Val2,
			      (ULARGE_INTEGER *) &Bit64Val3) != 0)
  {
    SHA256_Update(ShaArray,(char *) &Bit64Val1,0,
		  sizeof(LARGE_INTEGER));
    SHA256_Update(ShaArray,(char *) &Bit64Val2,0,
		  sizeof(LARGE_INTEGER));
    SHA256_Update(ShaArray,(char *) &Bit64Val3,0,
		  sizeof(LARGE_INTEGER));
    DBG_PRINT("Got Disk space\n");
    TotalPercentage += 4;
    BytesHashed += (sizeof(LARGE_INTEGER) * 3);
  }

  GlobalMemoryStatusEx(&MemoryStatusEx);	// free memory
  SHA256_Update(ShaArray, (char *) &MemoryStatusEx,0,
	        sizeof(MEMORYSTATUSEX));
  TotalPercentage += 4;
  BytesHashed += sizeof(MEMORYSTATUSEX);

  if(GetCaretPos(&Point) != 0)			// position of caret
  {
    SHA256_Update(ShaArray,(char *) &Point,0,
	          sizeof(POINT));
    DBG_PRINT("Got Caret position\n");
    TotalPercentage += 4;
    BytesHashed += sizeof(POINT);
  }

  Bit32Val1 = GetMessagePos();			// Cursor for last Msg
  SHA256_Update(ShaArray, (char *) &Bit32Val1,0,4);
  TotalPercentage += 4;
  BytesHashed += 4;


  if(GetCursorPos(&Point) != 0)
  {
    SHA256_Update(ShaArray,(char *) &Point,0,
	          sizeof(POINT));
    DBG_PRINT("Got Cursor position\n");
    TotalPercentage += 4;
    BytesHashed += sizeof(POINT);
  }

#if !defined WINCE // AG added
  LongVal = GetMessageTime();
  SHA256_Update(ShaArray,(char *) &LongVal,0,
	        sizeof(LONG));
  TotalPercentage += 4;
  BytesHashed += sizeof(LONG);
  BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
#endif // !defined WINCE // AG added
  //-----------------------------------------------------
  // 6. Hash event/logging fileinfo
  //-----------------------------------------------------
#if !defined WINCE
  if(HashEvtDir(HMEM_CTX_REF1 ShaArray,&Retcode) > 0)
  {
    DBG_PRINT("Got event log\n");
    TotalPercentage += 8;
    BytesHashed += Retcode;
    BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  }
#endif // !defined WINCE
  //-----------------------------------------------------
  // 7. Hash environment settings (strings)
  //-----------------------------------------------------
#if !defined WINCE // AG added
  if((pName = GetEnvironmentStrings()) != NULL)
  {
    Index = 0;
    for(;;)
    {
      if((Len = (int) strlen(pName+Index)) <= 0)
        break;
      SHA256_Update(ShaArray,pName,Index,Len);
      BytesHashed += Len;
      Index += Len + 1;
    }
    FreeEnvironmentStrings(pName);
    DBG_PRINT("Got environment strings\n");
    TotalPercentage += 4;
    BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  }
#endif // !defined WINCE // AG added
  //-------------------------------------------------------
  // 8. Get random from CRYPTO-API, high percentage
  //-------------------------------------------------------
  if(CryptAcquireContext(&hProv,NULL,MS_ENHANCED_PROV,
                         PROV_RSA_FULL,CRYPT_VERIFYCONTEXT) != 0)
  {
    if(CryptGenRandom(hProv,32,(BYTE *) TmpBuffer) != 0)
    {
      SHA256_Update(ShaArray,TmpBuffer,0,32);
      DBG_PRINT("Got crypt random\n");
      TotalPercentage += 14;
      BytesHashed += 32;
      BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
    }
    CryptReleaseContext(hProv,0);
  }

  //-------------------------------------------------------
  // 10. Hash network tables and statistics
  //-------------------------------------------------------
  if((Retcode = GetNetHashes(HMEM_CTX_REF1 ShaArray)) > 0)
  {
    DBG_PRINT("Got Network info\n");
    TotalPercentage += 8;
    BytesHashed += Retcode;
    BytesHashed += HashHighspeedCounter(ShaArray); // get performance counter
  }

  SHA256_Final(ShaArray,pDigest,0);

  pBytesHashed[0] = BytesHashed;
  return(TotalPercentage);
}

#else // NON-Windows, UNIX systems


//*****************************************************************
//
// Routines only used for LINUX
//
//*****************************************************************

#if defined HL_LINUX
//=================================================================
// Hash Linux sysinfo
// NOTE: only available on linux!
//
// Input parameters: int * pShaArray		SHA25 hash array
// Returns: int Status > 0 o.k., number of bytes hashed
//=================================================================
static int HashLinuxSysinfo(int * pShaArray)
{
  struct sysinfo Sysinfo;

  if(sysinfo(&Sysinfo) == 0)
  {
    SHA256_Update(pShaArray,(char *) &Sysinfo,0,
		  sizeof(struct sysinfo));
    return(sizeof(struct sysinfo));
  }
  else
    return(0);
}
//=================================================================
// Hash data from given file (especially /proc/.. is used)
//
// Input parameters: int *    pShaArray		SHA25 hash array
//		     char *   pFileName		full qualified name
// Returns: int Status > 0 o.k., number of bytes hashed
//=================================================================
static int HashFileData(int * pShaArray, char * pFileName)
{
  int Len,i;
  int BytesHashed;
  FILE * hFile;
  char Buffer[2048];

  BytesHashed = 0;
  //--------------------------------------
  // Open file for read
  //--------------------------------------
  if((hFile = fopen(pFileName,"r")) == NULL)
    return(-1);
  //--------------------------------------
  // Read data till EOF/error
  //--------------------------------------
  DBG_PRINT("Start hash file data\n");
  i = 0;
  for(;;)
  {
    Len = fread(Buffer,1,sizeof(Buffer),hFile);
    if(Len > 0)
    {
      SHA256_Update(pShaArray,Buffer,0,Len);
      DBG_PRINT("File data hashed.\n");
      i++;
      BytesHashed += Len;
    }
    if(Len != sizeof(Buffer))
    {
      fclose(hFile);
      if(i > 0)
        return(BytesHashed);
      else
        return(i);
    }
  }
}
//======================================================
// Hash processor/system variable data in LINUX /proc/
// directory.
// Used entries are: meminfo, slabinfo, zoneinfo, uptime
//                   and interrupts
//
// Input parameters: int * pShaArray		SHA256 array
// Returns: int Status > 0 o.k., number of bytes hashed
//======================================================
static int HashLinuxProc(int * pShaArray)
{
  int Retcode,BytesHashed;
  int i = 0;
  BytesHashed = 0;
  //---------------------------------------------------
  // Hash /proc/meminfo, /proc/slabinfo, /proc/zoneinfo
  // /proc/interrupts and /proc/uptime
  //---------------------------------------------------
  if((Retcode = HashFileData(pShaArray,"/proc/meminfo")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if((Retcode = HashFileData(pShaArray,"/proc/slabinfo")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if((Retcode = HashFileData(pShaArray,"/proc/zoneinfo")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if((Retcode = HashFileData(pShaArray,"/proc/interrupts")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if((Retcode = HashFileData(pShaArray,"/proc/uptime")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if((Retcode = HashFileData(pShaArray,"/proc/stat")) > 0)
  {
    i++;
    BytesHashed += Retcode;
  }
  if(i > 0)
    return(BytesHashed);
  else
    return(i);
}
//===========================================================
// Hash elements' information for a given directory
//
// Input parameters: int * pShaArray		SHA-256 Array
//		     char * pName		Directory full path
// Returns: int Status > 0 o.k., number of bytes hashed
//===========================================================
static int HashDir(int * pShaArray, char * pName)
{
  int BytesHashed;
  int i,DirLen,Len;
  DIR * hDir;
  struct dirent * pDirent;
  struct stat StatStruc;

  char NameBuf[1024];

  if((hDir = opendir(pName)) == NULL)
    return(-1);

  i = 0;
  BytesHashed = 0;

  DirLen = strlen(pName);
  //----------------------------------------------
  // Copy directory name to namebuffer, append '/'
  //----------------------------------------------
  memcpy(NameBuf,pName,DirLen);
  if(NameBuf[DirLen-1] != '/')
  {
    NameBuf[DirLen] = '/';
    DirLen++;
  }
  NameBuf[DirLen] = 0;
#if defined __DEBUG__
  printf("Hashing Directory is: %s\n",NameBuf);
#endif
  //---------------------------------------------
  // Enumerate directory entries
  //---------------------------------------------
  for(;;)
  {
    errno = 0;				// assure errno is 0  !!!
    pDirent = readdir(hDir);
    if(pDirent == NULL)
    {
#if defined __DEBUG__
      printf("readdir NULL, errno=%d\n",errno);
#endif
      if((errno != 0) && (errno != ENOENT)) // has an error, skip entry
        continue;

      closedir(hDir);
      if(i > 0)
        return(BytesHashed);
      else
        return(i);
    }
    if(pDirent->d_name[0] != '.')	// ignore '.' and '..' entries
    {
      //---------------------------------------------
      // found next entry, construct name, get status
      //---------------------------------------------
      strcpy(NameBuf+DirLen,pDirent->d_name);
#if defined __DEBUG__
      printf("found: %s\n",NameBuf);
#endif

      if(stat(NameBuf,&StatStruc) == 0)
      {
        DBG_PRINT("Hashing Entry.\n");
        Len = strlen(NameBuf);
        SHA256_Update(pShaArray,NameBuf,0,Len);
        SHA256_Update(pShaArray,(char *) &StatStruc,0,
		      sizeof(StatStruc));
        i++;
        BytesHashed += (Len + sizeof(StatStruc));
      }
      else
      {
#if defined __DEBUG__
        printf("Stat error, errno=%d\n",errno);
#endif
      }
    }
  }
}
#endif // HL_LINUX

//********************************************************
//
// Functions used only on UNIX systems
//
//********************************************************

//=======================================================
// Hash 16 byte data from /dev/random
// NOTE: If no data available do NOT block on read !!!
//
// Input parameters: int * pShaArray		SHA-256 Array
// Returns: int Status > 0 o.k.
//=======================================================
static int HashDevRandom(int * pShaArray)
{
  int Len,fd,Flags;
  FILE * hFile;
  char TmpBuf[32];

  //------------------------------------
  // Open file, set mode to non blocking
  //------------------------------------
  if((hFile = fopen("/dev/random","r")) == NULL)
    return(-1);

  fd = fileno(hFile);
  Flags = fcntl(fd,F_GETFL);
  Flags |= O_NONBLOCK;
  fcntl(fd,F_SETFL,Flags);


  Len = fread(TmpBuf,1,16,hFile);
  fclose(hFile);

  if(Len > 0)
    SHA256_Update(pShaArray,TmpBuf,0,Len);
  return(Len);
}
//================================================================
// Execute an external command, hash its output data
// -- UNIX Version --
//
// Input parameters: char *	pCmdName	command to process
//		     char *	pParam1		1st parameter/NULL
//		     char *	pParam2		2nd parameter/NULL
//		     int	ExpExitCode	Expected Exitcode
//		     int *	pShaArray	SHA-256 Array
// Returns: int Status >= 0 o.k., number of bytes hashed
//================================================================
static int ExecHashCmdOutput(char * pCmdName, char * pParam1,
		char * pParam2, int ExpExitCode, int * pShaArray)
{

#define	UNIX_WAIT_DELAY	100

  int Retcode;
  int ChildProcessID;
  int DevNullID = -1;
  int PipeArr[2];
  int BytesRead;
  int ChildStatus;

  fd_set ReadSet;
  struct timeval tvWait;

  char ReadBuf[8192];

  int ShaHashDataLen = 0;

  //=========================================================
  // Prepeare Stdin/Stdout/StdErr for use with child
  //=========================================================
  //---------------------------------------------------------
  // 2.1. Open /dev/null for use as Stdin for child
  //---------------------------------------------------------
  if((DevNullID = open("/dev/null",O_RDWR)) == -1)
  {
    DBG_PRINT("Could not open '/dev/null'!\n");
    return(DRBG_EXEC_NULLDEV_OPEN_FAIL);
  }
  //---------------------------------------------------------
  // 2.2. Create the Pipe for intercommunication
  //---------------------------------------------------------
  if((Retcode = pipe(PipeArr)) != 0)
  {
    close(DevNullID);
    DBG_PRINT("Could not create IPC pipe!\n");
    return(DRBG_EXEC_GET_PIPE_FAIL);
  }
//  printf("Pipe create o.k.\n");
  //---------------------------------------------------------
  // 2.3. Fork the child process now
  //---------------------------------------------------------
  if((ChildProcessID = fork()) < 0)
  {
    close(PipeArr[0]);
    close(PipeArr[1]);
    close(DevNullID);

    DBG_PRINT("Could not fork !\n");
    return(DRBG_EXEC_FORK_FAIL);
  }
  if(ChildProcessID == 0)
  {
    //------------------------------------------------------
    // Child Process continues here, duplicate handles
    //------------------------------------------------------
    DBG_PRINT("Child Enter, doing DUP\n");
    dup2(DevNullID, STDIN_FILENO);
    dup2(PipeArr[1],STDOUT_FILENO);
// NOTE: Comment out the following line for output from child on STDERR !!!
    dup2(DevNullID,STDERR_FILENO);
    close(PipeArr[0]);
    close(PipeArr[1]);
    close(DevNullID);

#if 0 // TEST TEST TEST
    fprintf(stderr,"Executing: %s\n",pCmdName);
    fprintf(stderr,"Arguments: ");
    if(pParam1 != NULL)
    {
      fprintf(stderr,"%s",pParam1);
      if(pParam2 != NULL)
        fprintf(stderr," %s",pParam2);
    }
    fprintf(stderr,"\n");
#endif

    Retcode = execl(pCmdName,pCmdName,pParam1,pParam2,(char *) NULL);

#if 0
    if(Retcode < 0)
    {
      fprintf(stderr,"Could not exec child, Retcode: %d !\n", Retcode);
      fprintf(stderr,"errno: %d\n",errno);
    }
    else
    {
      DBG_PRINT_ERR("Child exited...\n");
    }
#endif
    exit(Retcode);
  }
  //-------------------------------------------------------------
  // Parent continues here...
  //-------------------------------------------------------------
  close(PipeArr[1]);
//  sleep(2);

  ShaHashDataLen = 0;
  for(;;)
  {
    //--------------------------------------------------
    // wait for data received on STDIN, EOF
    //--------------------------------------------------
    tvWait.tv_sec  = UNIX_WAIT_DELAY;
    tvWait.tv_usec = 0;

    FD_ZERO(&ReadSet);
    FD_SET(PipeArr[0],&ReadSet);
//    printf("PARENT: Before Select\n");

    Retcode = select(PipeArr[0]+1, &ReadSet, NULL, NULL, &tvWait);
//    printf("PARENT: Past Select, Retcode: %d\n",Retcode);
    switch(Retcode)
    {
      case 0:					// timed out
        DBG_PRINT("Child Input Timed out, aborting !\n");
        Retcode = DRBG_EXEC_CHILD_INP_TIMEOUT;
        break;

      case 1:					// Data available
        for(;;)
        {
          BytesRead = read(PipeArr[0], ReadBuf, sizeof(ReadBuf)-1);
          if(BytesRead == -1)
          {
            if(errno == EINTR)
              continue;
            DBG_PRINT("Error reading STDIN !\n");
            Retcode = DRBG_EXEC_STDIN_READ_ERR;
            break;
          }
          if(BytesRead == 0)
          {
            DBG_PRINT("\nEOF\n");
            Retcode = 0;
            break;
          }
          ReadBuf[BytesRead] = 0;
#if defined __DEBUG__ || defined __INFO__
//          printf("Parent STDIN: ");
          printf("%s\n",ReadBuf);
#endif
          SHA256_Update(pShaArray,ReadBuf,0,BytesRead);
          ShaHashDataLen += BytesRead;
          Retcode = 1;
          break;
        }
        break;

      default:					// error occured...
        Retcode = DRBG_EXEC_SELECT_ERR;
        break;
    }
    if(Retcode <= 0)
      break;
  }
  if(Retcode < 0)
  {
    close(PipeArr[0]);
    close(DevNullID);
    return(Retcode);
  }

  Retcode = waitpid(ChildProcessID, &ChildStatus, 0);
  close(PipeArr[0]);
  close(DevNullID);
  if(Retcode != ChildProcessID)
  {
    DBG_PRINT("Wait Child returned wrong process ID!\n");
    return(DRBG_EXEC_WRONG_CHILD_PID);
  }

  //--------------------------------------------------------------
  // Process status from child termination if available
  //--------------------------------------------------------------
  if(WIFEXITED(ChildStatus) != 0)		// child terminated normally
  {
    Retcode = WEXITSTATUS(ChildStatus);		// get child's exit status
    if(Retcode == ExpExitCode)			// is as expected
    {
      DBG_PRINT("Child terminated o.k.\n");
      return(ShaHashDataLen);
    }
    else
    {
#if defined __DEBUG__ || defined __INFO__
      printf("Child terminated normally, but Termination code: %d\n",Retcode);
#endif
      return(0);				// no data hashed...
    }
  }
  else
  {
    DBG_PRINT("Child abnormal termination!\n");
    return(DRBG_EXEC_CHILD_ABNORMAL_TERMINATE);
  }
}
//===============================================================
// UNIX: Gather Entropy on UNIX systems
// On Linux additional actions are taken
//
// Input parameters: char * pDigestBuf		32 Byte output buffer
//		     int *  pBytesHashed	Number of bytes hashed
// Returns: int Status - > 0 approx. percentage gathered, else error
//================================================================
static int SysGetEntropy(HMEM_CTX_DEF char * pDigestBuf, int * pBytesHashed)
{
  int Retcode;
  int Percentage,i,BytesHashed;
  int Index;
  int TmpVal;
  char * CmdName, * Param1, * Param2;

  struct tms Tms;
  struct rusage RusageStruc;

  char TmpData[256];
  int ShaArray[SHA256_ARRAY_SIZE];

  SHA256_Init(ShaArray);

  Percentage = 0;
  BytesHashed = 0;
  //----------------------------------------------------
  // 1. Get pid, ppid, uid, gid, times, clock, rusage,
  //    hash them, all systems
  //----------------------------------------------------
  DBG_PRINT("DRBG gathering system entropy start.\n");

  BytesHashed = HashHighspeedCounter(ShaArray);

  Index = 0;
  TmpVal = getpid();
  long2char(TmpVal, TmpData, Index);
  TmpVal = getppid();
  long2char(TmpVal, TmpData, Index);
  TmpVal = getuid();
  long2char(TmpVal, TmpData, Index);
  TmpVal = getgid();
  long2char(TmpVal, TmpData, Index);
  TmpVal = times(&Tms);
  long2char(TmpVal, TmpData, Index);

  SHA256_Update(ShaArray,TmpData,0,Index);
  Percentage += 4;				// 4
  BytesHashed += Index;

  TmpVal = clock();
  if(TmpVal != -1)
  {
    Index = 0;
    long2char(TmpVal, TmpData, Index);
    SHA256_Update(ShaArray,TmpData,0,Index);
    Percentage += 2;				// 6
    BytesHashed += Index;
    DBG_PRINT("DRBG clock hashed.\n");
  }

  if(getrusage(RUSAGE_SELF,&RusageStruc) == 0)
  {
    SHA256_Update(ShaArray,
		 (char *) ((void *) &RusageStruc),0,
                 sizeof(RusageStruc));
    Percentage += 2;				// 8
    BytesHashed += sizeof(RusageStruc);
    DBG_PRINT("DRBG rusage hashed.\n");
  }

  BytesHashed += HashHighspeedCounter(ShaArray);


  //----------------------------------------------------
  // 1b. Hash linux specific values from /proc/, sysinfo
  //     get /var/log entry descriptions
  //----------------------------------------------------
#if defined HL_LINUX
  if((Retcode = HashLinuxProc(ShaArray)) > 0)
  {
    BytesHashed += Retcode;
    BytesHashed += HashHighspeedCounter(ShaArray);
    Percentage += 10;				// 18
    DBG_PRINT("DRBG: /proc/ hashed.\n");
  }

  if((Retcode = HashLinuxSysinfo(ShaArray)) > 0)
  {
    BytesHashed += Retcode;
    BytesHashed += HashHighspeedCounter(ShaArray);
    Percentage += 2;				// 20
    DBG_PRINT("DRBG: sysinfo hashed.\n");
  }

  if((Retcode = HashDir(ShaArray,"/var/log")) > 0)
  {
    BytesHashed += Retcode;
    BytesHashed += HashHighspeedCounter(ShaArray);
    Percentage += 4;				// 24
    DBG_PRINT("DRBG: /var/log hashed.\n");
  }
#endif // HL_LINUX
  //----------------------------------------------
  // 2. Calculate PI, all systems
  //----------------------------------------------
  CalcPi();
  BytesHashed += HashHighspeedCounter(ShaArray);
  Percentage += 4;				// 28
  DBG_PRINT("DRBG: PI hashed.\n");
  //----------------------------------------------
  // 3. Hash /dev/random, all systems
  //----------------------------------------------
  DBG_PRINT("DRBG: Hashing /dev/random...\n");
  if((i=HashDevRandom(ShaArray)) > 0)
  {
    Percentage += i;				// 48
    BytesHashed += i;
    DBG_PRINT("DRBG: /dev/random hashed.\n");
  }
  DBG_PRINT("DRBG: Past hashing /dev/random\n");
  //----------------------------------------------
  // 4. Hash selected system commands
  //----------------------------------------------
  i = 0;
  for(;;)
  {
    CmdName = CmdTab[i];
    Param1  = CmdTab[i+1];
    Param2  = CmdTab[i+2];
    i += 3;
    if(CmdName == NULL)
      break;
    //----------------------------------------------------
    // Exec command, hash output
    //----------------------------------------------------
    if((Retcode = ExecHashCmdOutput(CmdName,Param1,Param2,0,ShaArray)) > 0)
    {
      Percentage += 4;				// +52 (ca.13 commands)
      BytesHashed += Retcode;
      BytesHashed += HashHighspeedCounter(ShaArray);
      DBG_PRINT("DRBG: Cmd hashed.\n");
    }
  }

  SHA256_Final(ShaArray,pDigestBuf,0);
  DBG_PRINT("DRBG: Entropy gather ended.\n");

  pBytesHashed[0] = BytesHashed;
  return(Percentage);
}
#endif // UNIX only


//========================================================
// Initialize the secure random generator:
// Fetch 32 byte entropy from system, initialize structure
// set global initialized flag
//
// Input parameters: none
// Returns: int Status - > 0 o.k., else fetch Entropy failed
//========================================================
int FAST SecDrbgInit(HMEM_CTX_DEF1)
{
  int Retcode;
  int BytesHashed[1];
  char EntropyData[32];
  //------------------------------------------------
  // 1. Perform DRBG selfcheck
  //------------------------------------------------
  Retcode = CTR_DRBG_Test();
  if(Retcode != 0)
  {
//    printf("PRNG Selfcheck failed, RC=%d\n",Retcode);
    return(DRBG_SEC_TEST_FAILED);
  }
  //---------------------------------------------------
  // 2. Fetch entropy according to system in use,
  //    check percentage estimate returned
  //---------------------------------------------------
  Retcode = SysGetEntropy(HMEM_CTX_REF1 EntropyData,BytesHashed);

#if defined __DEBUG_INFO__
  printf("SECDRBG: Percentage: %d\n",Retcode);
#endif

  if(Retcode <= 0)
    return(DRBG_SEC_INIT_FAILED);
  if(Retcode < 50)
    return(DRBG_SEC_INIT_WEAK);

#if defined __DEBUG_INFO__
  printf("SECDRBG: Bytes hashed: %d\n",BytesHashed[0]);
#endif
  if(BytesHashed[0] < HASH_LIMIT)
    return(DRBG_SEC_HASH_WEAK);

  //------------------------------------------------
  // 3. Initialize the DRBG now
  //------------------------------------------------
  CTR_DRBG_Instantiate128(&SecRandStruc,EntropyData);
  SecClearByteArray(EntropyData,32);
  SecRandInitFlag = 1;
  return(Retcode);
}
//========================================================
// Fetch random bytes from secure random generator, if reseed
// required, fetch 32 byte entropy from system, reseed the
// generator
//
// Input parameters: char * pDstBuf		Destination for output
//		     int     DstOff		start of data in buffer
//		     int     DstLen		size of data requested
// Returns: int Status - 0 o.k., else fetch Entropy failed/not initialized
//========================================================
int FAST SecDrbgRandBytes(HMEM_CTX_DEF char * pDstBuf,
			  int DstOff, int DstLen)
{
  int Retcode;
  int BytesHashed[1];
  char EntropyData[32];
  //----------------------------------------
  // 0. Check if generator is initialized
  //----------------------------------------
  if(SecRandInitFlag == 0)
  {
    printf("PRNG Not Initialized !!\n");
    return(DRBG_SEC_RAND_FAILED);
  }
  //----------------------------------------
  // 1. Get bytes as requested, check result
  //----------------------------------------
  Retcode = DRBGGetRandBytes(&SecRandStruc,pDstBuf,DstOff,DstLen,0);
  if(Retcode == 0)
    return(Retcode);

  if(Retcode != 2)
  {
//    printf("PRNG RC=%d\n",Retcode);
    return(DRBG_SEC_RAND_FAILED);
  }
  //----------------------------------------------------------
  // 2. DRBG needs reseeding, fetch entropy for reseed, reseed
  //----------------------------------------------------------
  Retcode = CTR_DRBG_Test();
  if(Retcode != 0)
    return(DRBG_SEC_TEST_FAILED);
  SecRandStruc.Ck = 1;

  Retcode = SysGetEntropy(HMEM_CTX_REF1 EntropyData,BytesHashed);
  if(Retcode < 50)
    return(DRBG_SEC_RESEED_FAILED);

#if defined __DEBUG_INFO__
  printf("SECDRBG: Bytes hashed: %d\n",BytesHashed[0]);
#endif
  if(BytesHashed[0] < HASH_LIMIT)
    return(DRBG_SEC_RESEED_FAILED);

  CTR_DRBG_Reseed128(&SecRandStruc,EntropyData);
  SecClearByteArray(EntropyData,32);
  //-------------------------------------------
  // 3. Retry random bytes fetch
  //-------------------------------------------
  Retcode = DRBGGetRandBytes(&SecRandStruc,pDstBuf,DstOff,DstLen,0);
  if(Retcode != 0)
    return(DRBG_SEC_RAND_FAILED);
  return(0);
}
#ifdef XYZ1
//========================================================
// Fetch random bytes from secure random generator
// seed/reseed if required.
//
// Input parameters: char *  abyrp_dstbuf	Destination for output
//		     int     imp_dstlen		size of data requested
// Returns: int Status - 0 o.k., else fetch Entropy failed/not initialized
//========================================================
int m_secdrbg_randbytes(char * abyrp_dstbuf,int imp_dstlen)
{
  int iml_retcode;
  int iml_byteshashed;
  char byrl_entropydata[32];

#if defined XH_INTERFACE
  ds__hmem * vp__ctx;

  if(pGlobalMemStruc == NULL)
    pGlobalMemStruc = AllocFillMemCtxStruc(1);

  vp__ctx = pGlobalMemStruc;
#endif
  //----------------------------------------
  // 0. Check if generator is initialized
  //----------------------------------------
  if(SecRandInitFlag == 0)
  {
    iml_retcode = SecDrbgInit(HMEM_CTX_REF);
    if(iml_retcode <= 0)
      return(DRBG_SEC_RAND_FAILED);
  }
  //----------------------------------------
  // 1. Get bytes as requested, check result
  //----------------------------------------
  iml_retcode = DRBGGetRandBytes(&SecRandStruc,
				 abyrp_dstbuf,0,imp_dstlen,0);
  if(iml_retcode == 0)
    return(iml_retcode);

  if(iml_retcode != 2)
    return(DRBG_SEC_RAND_FAILED);
  //----------------------------------------------------------
  // 2. DRBG needs reseeding, fetch entropy for reseed, reseed
  //----------------------------------------------------------
  iml_retcode = CTR_DRBG_Test();
  if(iml_retcode != 0)
    return(DRBG_SEC_TEST_FAILED);
#if !defined JAVA
  SecRandStruc.Ck = 1;
#endif

  iml_retcode = SysGetEntropy(HMEM_CTX_REF1 byrl_entropydata,
			      &iml_byteshashed);
  if(iml_retcode < 50)
    return(DRBG_SEC_RESEED_FAILED);

#if !defined JAVA
#if defined __DEBUG_INFO__
  printf("SECDRBG: Bytes hashed: %d\n",iml_byteshashed);
#endif
  if(iml_byteshashed < HASH_LIMIT)
    return(DRBG_SEC_RESEED_FAILED);
#endif // !defined JAVA

  CTR_DRBG_Reseed128(&SecRandStruc,byrl_entropydata);
  SecClearByteArray(byrl_entropydata,32);
  //-------------------------------------------
  // 3. Retry random bytes fetch
  //-------------------------------------------
  iml_retcode = DRBGGetRandBytes(&SecRandStruc,
				 abyrp_dstbuf,0,imp_dstlen,0);
  if(iml_retcode != 0)
    return(DRBG_SEC_RAND_FAILED);
  return(0);
}
#endif




//========================================================
// Fetch random bytes from secure random generator without reseed
// checking/update for testing purposes only !
//
// Input parameters: char *  pDstBuf		Destination for output
//		     int     DstOff		start of data in buffer
//		     int     DstLen		size of data requested
// Returns: int Status - 0 o.k., else fetch Entropy failed/not initialized
//========================================================
int FAST SecDrbgRandBytes_Test(char * pDstBuf, int DstOff, int DstLen)
{
  int Retcode;
  //----------------------------------------
  // 0. Check if generator is initialized
  //----------------------------------------
  if(SecRandInitFlag == 0)
    return(DRBG_SEC_RAND_FAILED);

  printf("Warning: PRNG without reseeding used!\n");

  //----------------------------------------
  // 1. Get bytes as requested, check result
  //----------------------------------------
  Retcode = DRBGGetRandBytes(&SecRandStruc,pDstBuf,DstOff,DstLen,1);
  return(Retcode);
}

#undef BIGlong2charn
#undef long2char
#undef long2charn
#endif // HL_ENCR_RAND
// end of 'hobrand.c'


#ifdef HL_ENCR_RC
// hobrc2.c
//===========================================================
//
// This file implements the RC2 block cipher algorithm.
//
// RC2 as implemented from a posting from Newsgroups: sci.crypt
// Sender: pgut01@cs.auckland.ac.nz (Peter Gutmann)
// Subject: Specification for Ron Rivests Cipher No.2
// Message-ID: <4fk39f$f70@net.auckland.ac.nz>
// Date: 11 Feb 1996 06:45:03 GMT
//
// See RRC2.DOC for description of algorithm.
// NOTE: the Key-reduction is missing in the description but is
// ----- implemented within all known SSL servers !
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <memory.h>

//-----------------------------------------------
// Macros
//-----------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (int) *((int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (int) *((int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#if defined WIN64

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);

#else // JAVA, Solaris etc

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);
#endif
#endif


#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#if defined WIN64

#define long2char(l,c,i) c[i]   = (char) (l);\
                         c[i+1] = (char) (l>> 8);\
                         c[i+2] = (char) (l>>16);\
                         c[i+3] = (char) (l>>24);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l);\
                          c[i+1] = (char) (l>> 8);\
                          c[i+2] = (char) (l>>16);\
                          c[i+3] = (char) (l>>24);

#else // JAVA, SOLARIS etc

#define long2char(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                         c[i+1] = (char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (char) ((l>>16) & 0x0FF);\
                         c[i+3] = (char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                          c[i+1] = (char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (char) ((l>>16) & 0x0FF);\
                          c[i+3] = (char) ((l>>24) & 0x0FF);
#endif
#endif


//-----------------------------------
// constants
//-----------------------------------
#define RC2_ENCRYPT	1
#define RC2_DECRYPT	0

#define RC2_BLOCK	8
#define RC2_KEY_LENGTH	16

#define	RC2_MAX_KEY_WORDS 64		//  64 * 16 Bit = 1024 Bit
#define	RC2_MAX_KEY_BYTES 128		// 128 *  8 Bit = 1024 Bit



//-----------------------------------------------------------
static unsigned char RC2_SBox[256] = {
  0xD9, 0x78, 0xF9, 0xC4, 0x19, 0xDD, 0xB5, 0xED,
  0x28, 0xE9, 0xFD, 0x79, 0x4A, 0xA0, 0xD8, 0x9D,
  0xC6, 0x7E, 0x37, 0x83, 0x2B, 0x76, 0x53, 0x8E,
  0x62, 0x4C, 0x64, 0x88, 0x44, 0x8B, 0xFB, 0xA2,
  0x17, 0x9A, 0x59, 0xF5, 0x87, 0xB3, 0x4F, 0x13,
  0x61, 0x45, 0x6D, 0x8D, 0x09, 0x81, 0x7D, 0x32,
  0xBD, 0x8F, 0x40, 0xEB, 0x86, 0xB7, 0x7B, 0x0B,
  0xF0, 0x95, 0x21, 0x22, 0x5C, 0x6B, 0x4E, 0x82,
  0x54, 0xD6, 0x65, 0x93, 0xCE, 0x60, 0xB2, 0x1C,
  0x73, 0x56, 0xC0, 0x14, 0xA7, 0x8C, 0xF1, 0xDC,
  0x12, 0x75, 0xCA, 0x1F, 0x3B, 0xBE, 0xE4, 0xD1,
  0x42, 0x3D, 0xD4, 0x30, 0xA3, 0x3C, 0xB6, 0x26,
  0x6F, 0xBF, 0x0E, 0xDA, 0x46, 0x69, 0x07, 0x57,
  0x27, 0xF2, 0x1D, 0x9B, 0xBC, 0x94, 0x43, 0x03,
  0xF8, 0x11, 0xC7, 0xF6, 0x90, 0xEF, 0x3E, 0xE7,
  0x06, 0xC3, 0xD5, 0x2F, 0xC8, 0x66, 0x1E, 0xD7,
  0x08, 0xE8, 0xEA, 0xDE, 0x80, 0x52, 0xEE, 0xF7,
  0x84, 0xAA, 0x72, 0xAC, 0x35, 0x4D, 0x6A, 0x2A,
  0x96, 0x1A, 0xD2, 0x71, 0x5A, 0x15, 0x49, 0x74,
  0x4B, 0x9F, 0xD0, 0x5E, 0x04, 0x18, 0xA4, 0xEC,
  0xC2, 0xE0, 0x41, 0x6E, 0x0F, 0x51, 0xCB, 0xCC,
  0x24, 0x91, 0xAF, 0x50, 0xA1, 0xF4, 0x70, 0x39,
  0x99, 0x7C, 0x3A, 0x85, 0x23, 0xB8, 0xB4, 0x7A,
  0xFC, 0x02, 0x36, 0x5B, 0x25, 0x55, 0x97, 0x31,
  0x2D, 0x5D, 0xFA, 0x98, 0xE3, 0x8A, 0x92, 0xAE,
  0x05, 0xDF, 0x29, 0x10, 0x67, 0x6C, 0xBA, 0xC9,
  0xD3, 0x00, 0xE6, 0xCF, 0xE1, 0x9E, 0xA8, 0x2C,
  0x63, 0x16, 0x01, 0x3F, 0x58, 0xE2, 0x89, 0xA9,
  0x0D, 0x38, 0x34, 0x1B, 0xAB, 0x33, 0xFF, 0xB0,
  0xBB, 0x48, 0x0C, 0x5F, 0xB9, 0xB1, 0xCD, 0x2E,
  0xC5, 0xF3, 0xDB, 0x47, 0xE5, 0xA5, 0x9C, 0x77,
  0x0A, 0xA6, 0x20, 0x68, 0xFE, 0x7F, 0xC1, 0xAD,
};



//================================================================
// Subroutine RC2_SetKey sets up the RC2 key Array from given key data
//
// Input Paramteters :		short * KeyArr	RC2 Keydata Array
//				char * KeyData	Key Array base
//				int   KeyLen	Key data length (bytes)
//				int   KeyBits	if 0, no key reduction used.
// Returns: Nothing
//================================================================
void FAST RC2_SetKey(short * KeyArr, char * KeyData, int KeyLen, int KeyBits)
{

  char TmpKey[128];			// temporary array, bytewide
  char c,d;
#define pRC2_SBox RC2_SBox
  int i,j;


  //--------------------------------------------------------
  // Step 0. Limit requested bytes and bits
  //--------------------------------------------------------
  if(KeyLen > 128)				// limit size of Key input data
    KeyLen=128;
  if ((KeyBits <= 0) || (KeyBits > 1024))	// limit bits to Max.
    KeyBits=1024;
  //--------------------------------------------------------
  // Step 1. Copy Key material to Temporary Buffer
  //--------------------------------------------------------
  if(KeyLen == 0)
  {
    TmpKey[0] = 0;				// initialize 1st Element
    c = 0;					// Clear Sum variable
  }
  else
  {
    memcpy(TmpKey,KeyData,KeyLen);
    c = TmpKey[KeyLen-1];		// get last byte from initdata
  }
  //--------------------------------------------------------
  // Step 2. Key expansion up to 128 Bytes
  // 2.0. IndexS = 0, IndexE = Len-1 or 0 if Len == 0
  // 2.1. Sum = SBox[(Key[IndexE] + Key[IndexS])]
  // 2.2. IndexS++, IndexE++
  // 2.2. Key[IndexE] = Sum
  // 2.3. while IndexE < 128 goto 2.1.
  // 2.4. Key[0] = SBox[Key[0]]
  //--------------------------------------------------------
  i = KeyLen;
  j = 0;
  while(i < RC2_MAX_KEY_BYTES)
  {
    c = pRC2_SBox[((int) (TmpKey[j++] + c)) & 0xFF];
    TmpKey[i++] = c;
  }
  TmpKey[0] = pRC2_SBox[(int) TmpKey[0] & 0xFF]; // zus. eingefuegt !!
						 // ist weiter unten

  //--------------------------------------------------------
  // hier stimmt was nicht, wenn bits = 1024 ist !!!!
  // dann j = 128, i = 0 !!!! -> while Schleife dreht hohl !!
  // ==> Fehler: Schleife war nicht abweisend, ist nun abweisend
  //--------------------------------------------------------
  /* hmm.... key reduction to 'bits' bits */

  if(KeyBits != 0)
  {

    j = (KeyBits+7)/8;			// number of used bytes of key
    i = RC2_MAX_KEY_BYTES-j;		// index to topmost used byte


    c = (unsigned char) ((int) 0xFF >> (-KeyBits & 0x07)); // Bit reduction Mask
    d = TmpKey[i] = RC2_SBox[(TmpKey[i] & c) & 0xFF]; // remove unused bits

    while(i != 0)
    {
      i--;
      d = TmpKey[i] = pRC2_SBox[(TmpKey[(i+j) & 0xFF] ^ d) & 0xFF];
    }
  }
  //--------------------------------------------------------
  // Byte to word conversion, machine independent
  //--------------------------------------------------------
  i = j = 0;
  do
  {
    KeyArr[i] = (short) (((short) TmpKey[j] & (short) 0xFF) |
                        (((short) TmpKey[j+1] & (short) 0xFF) << 8));
    j += 2;
    i ++;
  } while(i < RC2_MAX_KEY_WORDS);
}

//================================================================
// Subroutine RC2_encrypt does RC2 Encryption/Decryption,
// cannot be used separately !!
//
// Input Paramteters :		int * d		8 byte data block to process
//				short * key	RC2 Keydata Array
//				int   mode	RC2_ENCRYPT -> do encryption
//						RC2_DECRYPT -> do decryption
// Returns: Nothing
//================================================================
void FAST RC2_encrypt(int * d,short * key,int mode)
{
  int i,n,k;
  short x0,x1,x2,x3,t;
  int l;

  //----------------------------------------------------------
  // split 8 Input bytes to 4 words a 16 bits
  //----------------------------------------------------------
  l  = d[0];					// get low 4 bytes
  x0 = (short) (l & 0xFFFF);			// Byte 0,1
  x1 = (short) ((l>>16) & 0xFFFF);		// Byte 2,3

  l  = d[1];					// get high 4 bytes
  x2 = (short) (l & 0xFFFF);			// Byte 4,5
  x3 = (short) ((l>>16) & 0xFFFF);		// Byte 6,7
  //----------------------------------------------------------
  // do encrypt/decrypt
  //----------------------------------------------------------
  n=3;
  i=5;						// 5 Subrounds first
  if (mode == RC2_ENCRYPT)
  {
    //-------------------------------------------------------
    // RC2 Encryption
    //-------------------------------------------------------
    k = 0;					// index to key table start
    for (;;)
    {
      //-----------------------------------------------------
      // RC2 Sub-Round (for all 4 words)
      //-----------------------------------------------------
      t  = (short) ((x0 + (x1 & ~x3) + (x2 & x3) + key[k++]) & 0xFFFF);
      x0 = (short) ((t<<1) | ((t>>15) & (char) 0x01));

      t  = (short) ((x1 + (x2 & ~x0) + (x3 & x0) + key[k++]) & 0xFFFF);
      x1 = (short) ((t<<2) | ((t>>14) & (char) 0x03));

      t  = (short) ((x2 + (x3 & ~x1) + (x0 & x1) + key[k++]) & 0xFFFF);
      x2 = (short) ((t<<3) | ((t>>13) & (char) 0x07));

      t  = (short) ((x3 + (x0 & ~x2) + (x1 & x2) + key[k++]) & 0xFFFF);
      x3 = (short) ((t<<5) | ((t>>11) & (char) 0x1F));

      i--;
      if(i == 0)
      {
        n--;
        if(n == 0) break;		// all round processed
        i = 5;				// prepare for last 5 Rounds
	if(n == 2) i++;			// middle 6 Rounds correction
        //-----------------------------------------------------
        // additional permutation after Round 5 and 11
        //-----------------------------------------------------
        x0 = (short) (x0 + key[x3 & 0x3F]);
        x1 = (short) (x1 + key[x0 & 0x3F]);
        x2 = (short) (x2 + key[x1 & 0x3F]);
        x3 = (short) (x3 + key[x2 & 0x3F]);
      }
    }
  }
  else  // Decrypt
  {
    //-------------------------------------------------------
    // RC2 Decryption
    //-------------------------------------------------------
    k = 63;				// index to key table start
    for (;;)
    {
      //-----------------------------------------------------
      // RC2 Sub-Round (for all 4 words)
      //-----------------------------------------------------
      t  = (short) (((x3<<11) | ((x3>>5) & 0x07FF)) & 0xFFFF);
      x3 = (short) ((t-(x0& ~x2)-(x1&x2)- key[k--]) & 0xFFFF);

      t  = (short) (((x2<<13) | ((x2>>3) & 0x1FFF)) & 0xFFFF);
      x2 = (short) ((t-(x3& ~x1)-(x0&x1)- key[k--]) & 0xFFFF);

      t  = (short) (((x1<<14) | ((x1>>2) & 0x3FFF)) & 0xFFFF);
      x1 = (short) ((t-(x2& ~x0)-(x3&x0)- key[k--]) & 0xFFFF);

      t  = (short) (((x0<<15) | ((x0>>1) & 0x7FFF)) & 0xFFFF);
      x0 = (short) ((t-(x1& ~x3)-(x2&x3)- key[k--]) & 0xFFFF);

      i--;
      if(i == 0)
      {
        n--;
        if(n == 0) break;		// all round processed
        i = 5;				// prepare for last 5 Rounds
	if(n == 2) i++;			// middle 6 Rounds correction
        //-----------------------------------------------------
        // additional permutation after Round 5 and 11
        //-----------------------------------------------------
        x3 = (short) ((x3-key[x2 & 0x3F]) & 0xFFFF);
        x2 = (short) ((x2-key[x1 & 0x3F]) & 0xFFFF);
        x1 = (short) ((x1-key[x0 & 0x3F]) & 0xFFFF);
        x0 = (short) ((x0-key[x3 & 0x3F]) & 0xFFFF);
      }
    }
  }
  //-----------------------------------------------------------
  // store 8 output bytes
  //-----------------------------------------------------------
  d[0] = (int) ((((int) x0) & 0xFFFF) |
                ((((int) x1) & 0xFFFF) << 16));

  d[1] = (int) ((((int) x2) & 0xFFFF) |
                ((((int) x3) & 0xFFFF) << 16));
}
//================================================================
// Subroutine RC2_cbc_encrypt_decrypt does RC2 Cipher Block Chaining
// Encryption/Decryption, the IV-Vektor is updated each time.
//
// NOTE: the data length  m u s t  be a multiple of 8 bytes, i.e.:
// ----- When doing Encryption padding has to be done first if necessary.
//	 When doing Decryption padding must be removed if necessary
//	 after decryption.
//
// Input Paramteters :	char * pInp		Source Data Array base
//			int    InpOffset	Start of Data
//			char * pOutp[]		Destination bufffer base
//			int    OutpOffset	Start of Data
//			int    length		Datacount (multiple of 8 bytes)
//			short * key		RC2 Keydata Array
//			char * iv		Initialization vector (8 bytes)
//			int    mode		RC2_ENCRYPT -> do encryption
//						RC2_DECRYPT -> do decryption
// Returns: Nothing
//================================================================
void FAST RC2_cbc_encdecrypt(char * pInp, int InpOffset,
			     char * pOutp, int OutpOffset,
			     int length, short * key,
			     char * iv, int mode)
{
  int i,j;
  int tin0,tin1;
  int tout0,tout1,xor0,xor1;
  int l=length;
  int tin[2];

  if(mode == RC2_ENCRYPT)
  {
    i = 0;
    char2long(iv,tout0,i);
    char2longn(iv,tout1,i);

    i = InpOffset;
    j = OutpOffset;
    for (l-=8; l>=0; l-=8)
    {
      char2long(pInp,tin0,i);
      char2long(pInp,tin1,i);
      tin0 ^= tout0;
      tin1 ^= tout1;
      tin[0] = tin0;
      tin[1] = tin1;
      RC2_encrypt(tin,key,RC2_ENCRYPT);
      tout0 = tin[0];
      long2char(tout0,pOutp,j);
      tout1 = tin[1];
      long2char(tout1,pOutp,j);
    }
    i = 0;
    long2char(tout0,iv,i);
    long2charn(tout1,iv,i);
  }
  else // Decrypt
  {
    i = 0;
    char2long(iv,xor0,i);
    char2longn(iv,xor1,i);

    i = InpOffset;
    j = OutpOffset;
    for (l-=8; l>=0; l-=8)
    {
      char2long(pInp,tin0,i);
      tin[0]=tin0;
      char2long(pInp,tin1,i);
      tin[1]=tin1;
      RC2_encrypt(tin,key,RC2_DECRYPT);
      tout0 = tin[0] ^ xor0;
      tout1 = tin[1] ^ xor1;
      long2char(tout0,pOutp,j);
      long2char(tout1,pOutp,j);
      xor0 = tin0;
      xor1 = tin1;
    }
    i = 0;
    long2char(xor0,iv,i);
    long2charn(xor1,iv,i);
  }
  tin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;
  tin[0] = tin[1] = 0;
}

#undef char2long
#undef char2longn
#undef long2char
#undef long2charn

#undef pRC2_SBox
#endif // HL_ENCR_RC
// end of 'hobrc2.c'


#ifdef HL_ENCR_RC
// hobrc4.c
//===========================================================
//
// This file implements the RC4 stream cipher algorithm.
//
// See RRC4.DOC for description of algorithm.
//
//===========================================================
#include "hob-encry-1.h"


#define	RC4_x		0			// index 0 into structure
#define	RC4_y		1			// index 1 into structure
#define	RC4_data	2			// index 2 into structure

//=============================================================
// Subroutine RC4_SetKey, generates RC4 state array from
// given encryption key.
//
// Input Params  :   BIT8 state[]	RC4 State Array Base
//		     BIT8 data[]	Key data Array Base
//		     int  Offset	Start of Key Data
//		     int  len		length of Key Data
//
//  Returns: Nothing
//==============================================================
void FAST RC4_SetKey(char * state, char * data, int Offset, int len)
{
  char  tmp;
  int   id1=Offset;
  int	index=len+Offset;
  int	id2=0;
  int i;

  //---------------------------------------------------
  // preload RC4 State Array, set x = 0, y = 0
  //---------------------------------------------------
  for (i=0; i<256; i++)	state[i+RC4_data] = (char) (i & 0xFF);	// preset
  state[RC4_x] = 0;
  state[RC4_y] = 0;

#define SK_LOOP(n) { \
		tmp= state[(n)+RC4_data]; \
		id2 = ((((int) data[id1]) & 0xFF) + \
                       (((int) tmp) & 0xFF) + id2) & 0xFF; \
                id1++; \
		if (id1 == index) id1=Offset; \
		state[(n)+RC4_data]=state[id2+RC4_data]; \
		state[id2+RC4_data]=tmp; }
  //---------------------------------------------------
  // Correlate with key data
  //---------------------------------------------------
  for (i=0; i < 256; i+=4)
  {
    SK_LOOP(i+0);
    SK_LOOP(i+1);
    SK_LOOP(i+2);
    SK_LOOP(i+3);
  }
}
//=============================================================
// Subroutine RC4, does RC4 Stream Cipher Encryption
// Note: If Input and Output refer to the same array,
// ----- then InputOffset should be >= OutputOffset to avoid
//	 corrupting the encryption (is done in ascending order)
//
// Input Params  :   BIT8 indata[]	Input data Array Base
//		     int  InpOffset	Start of Input Data
//		     int  len		length of Data
//		     BIT8 outdata[]	Output Data Array Base
//		     int  OutpOffset	Start of Output Data
//		     BIT8 key[]		Cipher State Array Base
//  Returns: Nothing
//==============================================================
void FAST RC4(char * indata, int InpOffset, int len,
	      char * outdata, int OutpOffset, char * key)
{
  int x,y,tx;
  int i = len;
  int j = InpOffset;
  int k = OutpOffset;

  if(i == 0) return;			// nothing to do

  x=((int) key[RC4_x]) & 0xFF;
  y=((int) key[RC4_y]) & 0xFF;

#define LOOP(in,out) \
		x  = (x+1) & 0xFF; \
		tx = ((int) key[x+RC4_data]) & 0xFF; \
		y  = (tx + y) & 0xFF; \
		key[x+RC4_data] = key[y+RC4_data]; \
		key[y+RC4_data] = (char) (tx & 0xFF); \
		out = (char)(key[((tx + ((int) key[x+RC4_data])) & 0xff) +\
                            RC4_data] ^ (in));

#define RC4_LOOP(a,b)	LOOP(a[j++],b[k++])

  for (;;)
  {
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
    RC4_LOOP(indata,outdata); i--; if(i == 0) break;
  }
  key[RC4_x] = (char) (x & 0xFF);
  key[RC4_y] = (char) (y & 0xFF);
}
//======================================================================
// Encrypt a datablock with given key, single pass
//
// Input params:	char * byrp_indata	Data to encrypt
//			int    imp_inpoffset	start of data in buffer
//			int    imp_inplen	length of data
//			char * byrp_key		Key to use
//			int    imp_keyoffset	start of key in buffer
//			int    imp_keylen	size of key data
//			char * byrp_outdata	result buffer
//			int    imp_outpoffset	start of result in buffer
// Returns: nothing
//=======================================================================
void FAST m_rc4_singlepass(char * byrp_indata, int imp_inpoffset,
			int imp_inplen, char * byrp_key, int imp_keyoffset,
			int imp_keylen, char * byrp_outdata,int imp_outpoffset)
{
  int i;
  char byrl_state[258];

  RC4_SetKey(byrl_state,byrp_key,imp_keyoffset,imp_keylen);
  RC4(byrp_indata,imp_inpoffset,imp_inplen,byrp_outdata,imp_outpoffset,
      byrl_state);
  for(i=0;i<258;i++)
    byrl_state[i] = 0;
}
#endif // HL_ENCR_RC
// end of 'hobrc4.c'


// hobrpmd.c
//*************************************************************
//
// RIPEMD 160 Digest Functions
// adapted from OPENSSL, for further description see the
// original files
//
//*************************************************************
#include <hob-encry-1.h>
#include <stdlib.h>


//--------------------------------------------------
// Macros
//--------------------------------------------------
#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define	long2char(l,c,i) (*((int *) &c[i]) = l); i += 4;
#define	long2charn(l,c,i) (*((int *) &c[i]) = l);

#else // JAVA, SOLARIS, WIN64 (!)

#if defined WIN64

#define long2char(l,c,i) c[i]   = (char) (l);\
                         c[i+1] = (char) (l>> 8);\
                         c[i+2] = (char) (l>>16);\
                         c[i+3] = (char) (l>>24);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l);\
                          c[i+1] = (char) (l>> 8);\
                          c[i+2] = (char) (l>>16);\
                          c[i+3] = (char) (l>>24);

#else // JAVA, SOLARIS etc

#define long2char(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                         c[i+1] = (char) ((l>> 8) & 0x0FF);\
                         c[i+2] = (char) ((l>>16) & 0x0FF);\
                         c[i+3] = (char) ((l>>24) & 0x0FF);\
                         i += 4;
#define long2charn(l,c,i) c[i]   = (char) (l       & 0x0FF);\
                          c[i+1] = (char) ((l>> 8) & 0x0FF);\
                          c[i+2] = (char) ((l>>16) & 0x0FF);\
                          c[i+3] = (char) ((l>>24) & 0x0FF);
#endif
#endif


#if defined WIN32 && !defined _M_IA64 && !defined WINCE // AG added && !defined WINCE
#define char2long(c,l,i) l = (int) *((int *) &c[i]); \
                         i += 4;

#define char2longn(c,l,i) l = (int) *((int *) &c[i]); \

#else // JAVA, WIN64, SOLARIS

#if defined WIN64

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);

#else // JAVA, Solaris etc

#define char2long(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int) c[i  ] & 0xFF);\
       i +=4;

#define char2longn(c,l,i)\
       l  = (((int) c[i+3] & 0xFF) << 24) |\
            (((int) c[i+2] & 0xFF) << 16) |\
            (((int) c[i+1] & 0xFF) << 8)  |\
            ((int)  c[i  ] & 0xFF);
#endif
#endif

#define char2longcx(c,l,n,i) \
 { \
   l = 0;\
   switch (n) \
   { \
     case 0: l = ((int) c[i+3] & 0x0FF) << 24;\
     case 3: l|= ((int) c[i+2] & 0x0FF) << 16;\
     case 2: l|= ((int) c[i+1] & 0x0FF) << 8;\
     case 1: l|= ((int) c[i  ] & 0x0FF);\
   } \
   if(n == 0) i += 4;\
   else i += n;\
}	

// Padding Insertion macro for RIPEMD

#define char2longcn(c,l,n)\
{ \
  switch (n)\
  { \
    case 0: \
      l = (((int)  c[3]                 << 24)|\
           (((int) c[2] & (int) 0xFF) << 16)|\
           (((int) c[1] & (int) 0xFF) <<  8)|\
           (((int) c[0] & (int) 0xFF)      ));\
      break;\
    case 1: \
      l |=(((int)  c[2]                 << 24)|\
           (((int) c[1] & (int) 0xFF) << 16)|\
           (((int) c[0] & (int) 0xFF) <<  8));\
      break;\
    case 2: \
      l |=(((int)  c[1]                 << 24)|\
           (((int) c[0] & (int) 0xFF) << 16));\
      break;\
    case 3: \
      l |=((int)  c[0]                  << 24);\
      break;\
  } \
}


// special without case 0, for RIPEMD

#define char2long3n(c,l,n,i) \
 { \
   l = 0;\
   switch (n) \
   { \
     case 3: l= ((int) ((short) c[i+2] & (short) 0xFF)<< 16);\
     case 2: l|= ((int)(((short) c[i+1] & (short) 0xFF)<< 8) & (int) 0xFFFF);\
     case 1: l|= ((int) ((short) c[i] & (short) 0xFF)      & (int) 0xFFFF);\
   } \
}	



#if defined WIN32 || defined WIN64
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);

#define LROTATE(a,n)     _lrotl(a,n)
#define RROTATE(a,n)     _lrotr(a,n)

#else // WIN64, SOLARIS, etc

#define LROTATE(a,n)      (((a) << (n)) | \
                         ((((a) >> (32-(n)))) & (0x7FFFFFFF >>(31-n))))

#define RROTATE(a,n)     ((((a) >> (n)) & (0x7FFFFFFF >> (n-1))) | \
                          (((a) << (32-(n))))
#endif


/*--------------------------------------------------------------*/
/* BIT64 Addition (32/32 Bit + 32 Bit)				*/
/*--------------------------------------------------------------*/
#define ADD_64(SumMsw, SumLsw, Summand) \
  if((unsigned int) SumLsw > \
     ((unsigned int) SumLsw + (unsigned int) Summand)) SumMsw++; \
  SumLsw += Summand;







//------------------------------------------------------
// Data structure
//------------------------------------------------------
#define RPMD_CBLOCK	64
#define RPMD_LBLOCK	16
#define RPMD_BLOCK	16
#define RPMD_LAST_BLOCK  56
#define RMD160_DIGEST_LEN	20
#define	RPMD_ARRAY_SIZE	24		// state array size (integers)

#define	RPMD_data	0				// Array offset 0
#define	RPMD_A		(RPMD_data+RPMD_BLOCK)		// Array offset + n
#define	RPMD_B		(RPMD_data+RPMD_BLOCK+1)	// Array offset + n+1
#define	RPMD_C		(RPMD_data+RPMD_BLOCK+2)	// Array offset + n+2
#define	RPMD_D		(RPMD_data+RPMD_BLOCK+3)	// Array offset + n+3
#define	RPMD_E		(RPMD_data+RPMD_BLOCK+4)	// Array offset + n+4
#define	RPMD_Nl		(RPMD_data+RPMD_BLOCK+5)	// Array offset + n+5
#define	RPMD_Nh		(RPMD_data+RPMD_BLOCK+6)	// Array offset + n+6
#define	RPMD_num	(RPMD_data+RPMD_BLOCK+7)	// Array offset + n+7

//===========================================================
// Constants and Function Macros for RIPEMD160
//===========================================================
// Initialization Constants

#define RPMD160_A       0x67452301
#define RPMD160_B       0xEFCDAB89
#define RPMD160_C       0x98BADCFE
#define RPMD160_D       0x10325476
#define RPMD160_E       0xC3D2E1F0


// Additive constants, left and right side

#define	YL_0    0x00000000
#define YL_1	0x5A827999
#define YL_2    0x6ED9EBA1
#define YL_3    0x8F1BBCDC
#define YL_4    0xA953FD4E

#define YR_0    0x50A28BE6
#define YR_1    0x5C4DD124
#define YR_2    0x6D703EF3
#define YR_3    0x7A6D76E9
#define YR_4    0x00000000

// Data Access Indices left and right

#define ZL_00   (int) 0
#define ZL_01   (int) 1
#define ZL_02   (int) 2
#define ZL_03   (int) 3
#define ZL_04   (int) 4
#define ZL_05   (int) 5
#define ZL_06   (int) 6
#define ZL_07   (int) 7
#define ZL_08   (int) 8
#define ZL_09   (int) 9
#define ZL_10   (int) 10
#define ZL_11   (int) 11
#define ZL_12   (int) 12
#define ZL_13   (int) 13
#define ZL_14   (int) 14
#define ZL_15   (int) 15

#define ZL_16   (int) 7
#define ZL_17   (int) 4
#define ZL_18   (int) 13
#define ZL_19   (int) 1
#define ZL_20   (int) 10
#define ZL_21   (int) 6
#define ZL_22   (int) 15
#define ZL_23   (int) 3
#define ZL_24   (int) 12
#define ZL_25   (int) 0
#define ZL_26   (int) 9
#define ZL_27   (int) 5
#define ZL_28   (int) 2
#define ZL_29   (int) 14
#define ZL_30   (int) 11
#define ZL_31   (int) 8

#define ZL_32   (int) 3
#define ZL_33   (int) 10
#define ZL_34   (int) 14
#define ZL_35   (int) 4
#define ZL_36   (int) 9
#define ZL_37   (int) 15
#define ZL_38   (int) 8
#define ZL_39   (int) 1
#define ZL_40   (int) 2
#define ZL_41   (int) 7
#define ZL_42   (int) 0
#define ZL_43   (int) 6
#define ZL_44   (int) 13
#define ZL_45   (int) 11
#define ZL_46   (int) 5
#define ZL_47   (int) 12

#define ZL_48   (int) 1
#define ZL_49   (int) 9
#define ZL_50   (int)11
#define ZL_51   (int)10
#define ZL_52   (int) 0
#define ZL_53   (int) 8
#define ZL_54   (int)12
#define ZL_55   (int) 4
#define ZL_56   (int)13
#define ZL_57   (int) 3
#define ZL_58   (int) 7
#define ZL_59   (int)15
#define ZL_60   (int)14
#define ZL_61   (int) 5
#define ZL_62   (int) 6
#define ZL_63   (int) 2

#define ZL_64   (int) 4
#define ZL_65   (int) 0
#define ZL_66   (int) 5
#define ZL_67   (int) 9
#define ZL_68   (int) 7
#define ZL_69   (int) 12
#define ZL_70   (int) 2
#define ZL_71   (int) 10
#define ZL_72   (int) 14
#define ZL_73   (int) 1
#define ZL_74   (int) 3
#define ZL_75   (int) 8
#define ZL_76   (int) 11
#define ZL_77   (int) 6
#define ZL_78   (int) 15
#define ZL_79   (int) 13

#define ZR_00   (int) 5
#define ZR_01   (int) 14
#define ZR_02   (int) 7
#define ZR_03   (int) 0
#define ZR_04   (int) 9
#define ZR_05   (int) 2
#define ZR_06   (int) 11
#define ZR_07   (int) 4
#define ZR_08   (int) 13
#define ZR_09   (int) 6
#define ZR_10   (int) 15
#define ZR_11   (int) 8
#define ZR_12   (int) 1
#define ZR_13   (int) 10
#define ZR_14   (int) 3
#define ZR_15   (int) 12

#define ZR_16   (int) 6
#define ZR_17   (int) 11
#define ZR_18   (int) 3
#define ZR_19   (int) 7
#define ZR_20   (int) 0
#define ZR_21   (int) 13
#define ZR_22   (int) 5
#define ZR_23   (int) 10
#define ZR_24   (int) 14
#define ZR_25   (int) 15
#define ZR_26   (int) 8
#define ZR_27   (int) 12
#define ZR_28   (int) 4
#define ZR_29   (int) 9
#define ZR_30   (int) 1
#define ZR_31   (int) 2

#define ZR_32   (int) 15
#define ZR_33   (int) 5
#define ZR_34   (int) 1
#define ZR_35   (int) 3
#define ZR_36   (int) 7
#define ZR_37   (int) 14
#define ZR_38   (int) 6
#define ZR_39   (int) 9
#define ZR_40   (int) 11
#define ZR_41   (int) 8
#define ZR_42   (int) 12
#define ZR_43   (int) 2
#define ZR_44   (int) 10
#define ZR_45   (int) 0
#define ZR_46   (int) 4
#define ZR_47   (int) 13

#define ZR_48   (int) 8
#define ZR_49   (int) 6
#define ZR_50   (int) 4
#define ZR_51   (int) 1
#define ZR_52   (int) 3
#define ZR_53   (int) 11
#define ZR_54   (int) 15
#define ZR_55   (int) 0
#define ZR_56   (int) 5
#define ZR_57   (int) 12
#define ZR_58   (int) 2
#define ZR_59   (int) 13
#define ZR_60   (int) 9
#define ZR_61   (int) 7
#define ZR_62   (int) 10
#define ZR_63   (int) 14

#define ZR_64   (int) 12
#define ZR_65   (int) 15
#define ZR_66   (int) 10
#define ZR_67   (int) 4
#define ZR_68   (int) 1
#define ZR_69   (int) 5
#define ZR_70   (int) 8
#define ZR_71   (int) 7
#define ZR_72   (int) 6
#define ZR_73   (int) 2
#define ZR_74   (int) 13
#define ZR_75   (int) 14
#define ZR_76   (int) 0
#define ZR_77   (int) 3
#define ZR_78   (int) 9
#define ZR_79   (int) 11


// Bitshift counts left and right

#define SL_00   (int) 11
#define SL_01   (int) 14
#define SL_02   (int) 15
#define SL_03   (int) 12
#define SL_04   (int) 5
#define SL_05   (int) 8
#define SL_06   (int) 7
#define SL_07   (int) 9
#define SL_08   (int) 11
#define SL_09   (int) 13
#define SL_10   (int) 14
#define SL_11   (int) 15
#define SL_12   (int) 6
#define SL_13   (int) 7
#define SL_14   (int) 9
#define SL_15   (int) 8

#define SL_16   (int) 7
#define SL_17   (int) 6
#define SL_18   (int) 8
#define SL_19   (int) 13
#define SL_20   (int) 11
#define SL_21   (int) 9
#define SL_22   (int) 7
#define SL_23   (int) 15
#define SL_24   (int) 7
#define SL_25   (int) 12
#define SL_26   (int) 15
#define SL_27   (int) 9
#define SL_28   (int) 11
#define SL_29   (int) 7
#define SL_30   (int) 13
#define SL_31   (int) 12

#define SL_32   (int) 11
#define SL_33   (int) 13
#define SL_34   (int) 6
#define SL_35   (int) 7
#define SL_36   (int) 14
#define SL_37   (int) 9
#define SL_38   (int) 13
#define SL_39   (int) 15
#define SL_40   (int) 14
#define SL_41   (int) 8
#define SL_42   (int) 13
#define SL_43   (int) 6
#define SL_44   (int) 5
#define SL_45   (int) 12
#define SL_46   (int) 7
#define SL_47   (int) 5

#define SL_48   (int) 11
#define SL_49   (int) 12
#define SL_50   (int) 14
#define SL_51   (int) 15
#define SL_52   (int) 14
#define SL_53   (int) 15
#define SL_54   (int) 9
#define SL_55   (int) 8
#define SL_56   (int) 9
#define SL_57   (int) 14
#define SL_58   (int) 5
#define SL_59   (int) 6
#define SL_60   (int) 8
#define SL_61   (int) 6
#define SL_62   (int) 5
#define SL_63   (int) 12

#define SL_64   (int) 9
#define SL_65   (int) 15
#define SL_66   (int) 5
#define SL_67   (int) 11
#define SL_68   (int) 6
#define SL_69   (int) 8
#define SL_70   (int) 13
#define SL_71   (int) 12
#define SL_72   (int) 5
#define SL_73   (int) 12
#define SL_74   (int) 13
#define SL_75   (int) 14
#define SL_76   (int) 11
#define SL_77   (int) 8
#define SL_78   (int) 5
#define SL_79   (int) 6

#define SR_00   (int) 8
#define SR_01   (int) 9
#define SR_02   (int) 9
#define SR_03   (int) 11
#define SR_04   (int) 13
#define SR_05   (int) 15
#define SR_06   (int) 15
#define SR_07   (int) 5
#define SR_08   (int) 7
#define SR_09   (int) 7
#define SR_10   (int) 8
#define SR_11   (int) 11
#define SR_12   (int) 14
#define SR_13   (int) 14
#define SR_14   (int) 12
#define SR_15   (int) 6

#define SR_16   (int) 9
#define SR_17   (int) 13
#define SR_18   (int) 15
#define SR_19   (int) 7
#define SR_20   (int) 12
#define SR_21   (int) 8
#define SR_22   (int) 9
#define SR_23   (int) 11
#define SR_24   (int) 7
#define SR_25   (int) 7
#define SR_26   (int) 12
#define SR_27   (int) 7
#define SR_28   (int) 6
#define SR_29   (int) 15
#define SR_30   (int) 13
#define SR_31   (int) 11

#define SR_32   (int) 9
#define SR_33   (int) 7
#define SR_34   (int) 15
#define SR_35   (int) 11
#define SR_36   (int) 8
#define SR_37   (int) 6
#define SR_38   (int) 6
#define SR_39   (int) 14
#define SR_40   (int) 12
#define SR_41   (int) 13
#define SR_42   (int) 5
#define SR_43   (int) 14
#define SR_44   (int) 13
#define SR_45   (int) 13
#define SR_46   (int) 7
#define SR_47   (int) 5

#define SR_48   (int) 15
#define SR_49   (int) 5
#define SR_50   (int) 8
#define SR_51   (int) 11
#define SR_52   (int) 14
#define SR_53   (int) 14
#define SR_54   (int) 6
#define SR_55   (int) 14
#define SR_56   (int) 6
#define SR_57   (int) 9
#define SR_58   (int) 12
#define SR_59   (int) 9
#define SR_60   (int) 12
#define SR_61   (int) 5
#define SR_62   (int) 15
#define SR_63   (int) 8

#define SR_64   (int) 8
#define SR_65   (int) 5
#define SR_66   (int) 12
#define SR_67   (int) 9
#define SR_68   (int) 12
#define SR_69   (int) 5
#define SR_70   (int) 14
#define SR_71   (int) 6
#define SR_72   (int) 8
#define SR_73   (int) 13
#define SR_74   (int) 6
#define SR_75   (int) 5
#define SR_76   (int) 15
#define SR_77   (int) 13
#define SR_78   (int) 11
#define SR_79   (int) 11


#define F1(x,y,z)	((x) ^ (y) ^ (z))
#define F2(x,y,z)	((((y) ^ (z)) & (x)) ^ (z))
#define F3(x,y,z)	(((~(y)) | (x)) ^ (z))
#define F4(x,y,z)	((((x) ^ (y)) & (z)) ^ (y))
#define F5(x,y,z)	(((~(z)) | (y)) ^ (x))


#define RIP1(a,b,c,d,e,w,s) { \
	a+=F1(b,c,d)+X(w); \
        a=LROTATE(a,s)+e; \
        c=LROTATE(c,10); }

#define RIP2(a,b,c,d,e,w,s,K) { \
	a+=F2(b,c,d)+X(w)+K; \
        a=LROTATE(a,s)+e; \
        c=LROTATE(c,10); }

#define RIP3(a,b,c,d,e,w,s,K) { \
	a+=F3(b,c,d)+X(w)+K; \
        a=LROTATE(a,s)+e; \
        c=LROTATE(c,10); }

#define RIP4(a,b,c,d,e,w,s,K) { \
	a+=F4(b,c,d)+X(w)+K; \
        a=LROTATE(a,s)+e; \
        c=LROTATE(c,10); }

#define RIP5(a,b,c,d,e,w,s,K) { \
	a+=F5(b,c,d)+X(w)+K; \
        a=LROTATE(a,s)+e; \
        c=LROTATE(c,10); }


//===================================================================






//==================================================================
// Process a full Block of Data from the RPMD-Array
//
// Input parameters: int * RPMD_Array
// Returns: nothing
//==================================================================
#if defined X
#undef X
#endif

#define X(i)	RPMD_Array[i]


static void FAST Ripemd160_Block(int * RPMD_Array)
{
  int A,B,C,D,E;
  int a,b,c,d,e;

  A = RPMD_Array[RPMD_A];
  B = RPMD_Array[RPMD_B];
  C = RPMD_Array[RPMD_C];
  D = RPMD_Array[RPMD_D];
  E = RPMD_Array[RPMD_E];

  RIP1(A,B,C,D,E,ZL_00,SL_00);
  RIP1(E,A,B,C,D,ZL_01,SL_01);
  RIP1(D,E,A,B,C,ZL_02,SL_02);
  RIP1(C,D,E,A,B,ZL_03,SL_03);
  RIP1(B,C,D,E,A,ZL_04,SL_04);
  RIP1(A,B,C,D,E,ZL_05,SL_05);
  RIP1(E,A,B,C,D,ZL_06,SL_06);
  RIP1(D,E,A,B,C,ZL_07,SL_07);
  RIP1(C,D,E,A,B,ZL_08,SL_08);
  RIP1(B,C,D,E,A,ZL_09,SL_09);
  RIP1(A,B,C,D,E,ZL_10,SL_10);
  RIP1(E,A,B,C,D,ZL_11,SL_11);
  RIP1(D,E,A,B,C,ZL_12,SL_12);
  RIP1(C,D,E,A,B,ZL_13,SL_13);
  RIP1(B,C,D,E,A,ZL_14,SL_14);
  RIP1(A,B,C,D,E,ZL_15,SL_15);

  RIP2(E,A,B,C,D,ZL_16,SL_16,YL_1);
  RIP2(D,E,A,B,C,ZL_17,SL_17,YL_1);
  RIP2(C,D,E,A,B,ZL_18,SL_18,YL_1);
  RIP2(B,C,D,E,A,ZL_19,SL_19,YL_1);
  RIP2(A,B,C,D,E,ZL_20,SL_20,YL_1);
  RIP2(E,A,B,C,D,ZL_21,SL_21,YL_1);
  RIP2(D,E,A,B,C,ZL_22,SL_22,YL_1);
  RIP2(C,D,E,A,B,ZL_23,SL_23,YL_1);
  RIP2(B,C,D,E,A,ZL_24,SL_24,YL_1);
  RIP2(A,B,C,D,E,ZL_25,SL_25,YL_1);
  RIP2(E,A,B,C,D,ZL_26,SL_26,YL_1);
  RIP2(D,E,A,B,C,ZL_27,SL_27,YL_1);
  RIP2(C,D,E,A,B,ZL_28,SL_28,YL_1);
  RIP2(B,C,D,E,A,ZL_29,SL_29,YL_1);
  RIP2(A,B,C,D,E,ZL_30,SL_30,YL_1);
  RIP2(E,A,B,C,D,ZL_31,SL_31,YL_1);

  RIP3(D,E,A,B,C,ZL_32,SL_32,YL_2);
  RIP3(C,D,E,A,B,ZL_33,SL_33,YL_2);
  RIP3(B,C,D,E,A,ZL_34,SL_34,YL_2);
  RIP3(A,B,C,D,E,ZL_35,SL_35,YL_2);
  RIP3(E,A,B,C,D,ZL_36,SL_36,YL_2);
  RIP3(D,E,A,B,C,ZL_37,SL_37,YL_2);
  RIP3(C,D,E,A,B,ZL_38,SL_38,YL_2);
  RIP3(B,C,D,E,A,ZL_39,SL_39,YL_2);
  RIP3(A,B,C,D,E,ZL_40,SL_40,YL_2);
  RIP3(E,A,B,C,D,ZL_41,SL_41,YL_2);
  RIP3(D,E,A,B,C,ZL_42,SL_42,YL_2);
  RIP3(C,D,E,A,B,ZL_43,SL_43,YL_2);
  RIP3(B,C,D,E,A,ZL_44,SL_44,YL_2);
  RIP3(A,B,C,D,E,ZL_45,SL_45,YL_2);
  RIP3(E,A,B,C,D,ZL_46,SL_46,YL_2);
  RIP3(D,E,A,B,C,ZL_47,SL_47,YL_2);

  RIP4(C,D,E,A,B,ZL_48,SL_48,YL_3);
  RIP4(B,C,D,E,A,ZL_49,SL_49,YL_3);
  RIP4(A,B,C,D,E,ZL_50,SL_50,YL_3);
  RIP4(E,A,B,C,D,ZL_51,SL_51,YL_3);
  RIP4(D,E,A,B,C,ZL_52,SL_52,YL_3);
  RIP4(C,D,E,A,B,ZL_53,SL_53,YL_3);
  RIP4(B,C,D,E,A,ZL_54,SL_54,YL_3);
  RIP4(A,B,C,D,E,ZL_55,SL_55,YL_3);
  RIP4(E,A,B,C,D,ZL_56,SL_56,YL_3);
  RIP4(D,E,A,B,C,ZL_57,SL_57,YL_3);
  RIP4(C,D,E,A,B,ZL_58,SL_58,YL_3);
  RIP4(B,C,D,E,A,ZL_59,SL_59,YL_3);
  RIP4(A,B,C,D,E,ZL_60,SL_60,YL_3);
  RIP4(E,A,B,C,D,ZL_61,SL_61,YL_3);
  RIP4(D,E,A,B,C,ZL_62,SL_62,YL_3);
  RIP4(C,D,E,A,B,ZL_63,SL_63,YL_3);

  RIP5(B,C,D,E,A,ZL_64,SL_64,YL_4);
  RIP5(A,B,C,D,E,ZL_65,SL_65,YL_4);
  RIP5(E,A,B,C,D,ZL_66,SL_66,YL_4);
  RIP5(D,E,A,B,C,ZL_67,SL_67,YL_4);
  RIP5(C,D,E,A,B,ZL_68,SL_68,YL_4);
  RIP5(B,C,D,E,A,ZL_69,SL_69,YL_4);
  RIP5(A,B,C,D,E,ZL_70,SL_70,YL_4);
  RIP5(E,A,B,C,D,ZL_71,SL_71,YL_4);
  RIP5(D,E,A,B,C,ZL_72,SL_72,YL_4);
  RIP5(C,D,E,A,B,ZL_73,SL_73,YL_4);
  RIP5(B,C,D,E,A,ZL_74,SL_74,YL_4);
  RIP5(A,B,C,D,E,ZL_75,SL_75,YL_4);
  RIP5(E,A,B,C,D,ZL_76,SL_76,YL_4);
  RIP5(D,E,A,B,C,ZL_77,SL_77,YL_4);
  RIP5(C,D,E,A,B,ZL_78,SL_78,YL_4);
  RIP5(B,C,D,E,A,ZL_79,SL_79,YL_4);

  a = A;
  b = B;
  c = C;
  d = D;
  e = E;

  // Do other half

  A = RPMD_Array[RPMD_A];
  B = RPMD_Array[RPMD_B];
  C = RPMD_Array[RPMD_C];
  D = RPMD_Array[RPMD_D];
  E = RPMD_Array[RPMD_E];


  RIP5(A,B,C,D,E,ZR_00,SR_00,YR_0);
  RIP5(E,A,B,C,D,ZR_01,SR_01,YR_0);
  RIP5(D,E,A,B,C,ZR_02,SR_02,YR_0);
  RIP5(C,D,E,A,B,ZR_03,SR_03,YR_0);
  RIP5(B,C,D,E,A,ZR_04,SR_04,YR_0);
  RIP5(A,B,C,D,E,ZR_05,SR_05,YR_0);
  RIP5(E,A,B,C,D,ZR_06,SR_06,YR_0);
  RIP5(D,E,A,B,C,ZR_07,SR_07,YR_0);
  RIP5(C,D,E,A,B,ZR_08,SR_08,YR_0);
  RIP5(B,C,D,E,A,ZR_09,SR_09,YR_0);
  RIP5(A,B,C,D,E,ZR_10,SR_10,YR_0);
  RIP5(E,A,B,C,D,ZR_11,SR_11,YR_0);
  RIP5(D,E,A,B,C,ZR_12,SR_12,YR_0);
  RIP5(C,D,E,A,B,ZR_13,SR_13,YR_0);
  RIP5(B,C,D,E,A,ZR_14,SR_14,YR_0);
  RIP5(A,B,C,D,E,ZR_15,SR_15,YR_0);

  RIP4(E,A,B,C,D,ZR_16,SR_16,YR_1);
  RIP4(D,E,A,B,C,ZR_17,SR_17,YR_1);
  RIP4(C,D,E,A,B,ZR_18,SR_18,YR_1);
  RIP4(B,C,D,E,A,ZR_19,SR_19,YR_1);
  RIP4(A,B,C,D,E,ZR_20,SR_20,YR_1);
  RIP4(E,A,B,C,D,ZR_21,SR_21,YR_1);
  RIP4(D,E,A,B,C,ZR_22,SR_22,YR_1);
  RIP4(C,D,E,A,B,ZR_23,SR_23,YR_1);
  RIP4(B,C,D,E,A,ZR_24,SR_24,YR_1);
  RIP4(A,B,C,D,E,ZR_25,SR_25,YR_1);
  RIP4(E,A,B,C,D,ZR_26,SR_26,YR_1);
  RIP4(D,E,A,B,C,ZR_27,SR_27,YR_1);
  RIP4(C,D,E,A,B,ZR_28,SR_28,YR_1);
  RIP4(B,C,D,E,A,ZR_29,SR_29,YR_1);
  RIP4(A,B,C,D,E,ZR_30,SR_30,YR_1);
  RIP4(E,A,B,C,D,ZR_31,SR_31,YR_1);

  RIP3(D,E,A,B,C,ZR_32,SR_32,YR_2);
  RIP3(C,D,E,A,B,ZR_33,SR_33,YR_2);
  RIP3(B,C,D,E,A,ZR_34,SR_34,YR_2);
  RIP3(A,B,C,D,E,ZR_35,SR_35,YR_2);
  RIP3(E,A,B,C,D,ZR_36,SR_36,YR_2);
  RIP3(D,E,A,B,C,ZR_37,SR_37,YR_2);
  RIP3(C,D,E,A,B,ZR_38,SR_38,YR_2);
  RIP3(B,C,D,E,A,ZR_39,SR_39,YR_2);
  RIP3(A,B,C,D,E,ZR_40,SR_40,YR_2);
  RIP3(E,A,B,C,D,ZR_41,SR_41,YR_2);
  RIP3(D,E,A,B,C,ZR_42,SR_42,YR_2);
  RIP3(C,D,E,A,B,ZR_43,SR_43,YR_2);
  RIP3(B,C,D,E,A,ZR_44,SR_44,YR_2);
  RIP3(A,B,C,D,E,ZR_45,SR_45,YR_2);
  RIP3(E,A,B,C,D,ZR_46,SR_46,YR_2);
  RIP3(D,E,A,B,C,ZR_47,SR_47,YR_2);

  RIP2(C,D,E,A,B,ZR_48,SR_48,YR_3);
  RIP2(B,C,D,E,A,ZR_49,SR_49,YR_3);
  RIP2(A,B,C,D,E,ZR_50,SR_50,YR_3);
  RIP2(E,A,B,C,D,ZR_51,SR_51,YR_3);
  RIP2(D,E,A,B,C,ZR_52,SR_52,YR_3);
  RIP2(C,D,E,A,B,ZR_53,SR_53,YR_3);
  RIP2(B,C,D,E,A,ZR_54,SR_54,YR_3);
  RIP2(A,B,C,D,E,ZR_55,SR_55,YR_3);
  RIP2(E,A,B,C,D,ZR_56,SR_56,YR_3);
  RIP2(D,E,A,B,C,ZR_57,SR_57,YR_3);
  RIP2(C,D,E,A,B,ZR_58,SR_58,YR_3);
  RIP2(B,C,D,E,A,ZR_59,SR_59,YR_3);
  RIP2(A,B,C,D,E,ZR_60,SR_60,YR_3);
  RIP2(E,A,B,C,D,ZR_61,SR_61,YR_3);
  RIP2(D,E,A,B,C,ZR_62,SR_62,YR_3);
  RIP2(C,D,E,A,B,ZR_63,SR_63,YR_3);

  RIP1(B,C,D,E,A,ZR_64,SR_64);
  RIP1(A,B,C,D,E,ZR_65,SR_65);
  RIP1(E,A,B,C,D,ZR_66,SR_66);
  RIP1(D,E,A,B,C,ZR_67,SR_67);
  RIP1(C,D,E,A,B,ZR_68,SR_68);
  RIP1(B,C,D,E,A,ZR_69,SR_69);
  RIP1(A,B,C,D,E,ZR_70,SR_70);
  RIP1(E,A,B,C,D,ZR_71,SR_71);
  RIP1(D,E,A,B,C,ZR_72,SR_72);
  RIP1(C,D,E,A,B,ZR_73,SR_73);
  RIP1(B,C,D,E,A,ZR_74,SR_74);
  RIP1(A,B,C,D,E,ZR_75,SR_75);
  RIP1(E,A,B,C,D,ZR_76,SR_76);
  RIP1(D,E,A,B,C,ZR_77,SR_77);
  RIP1(C,D,E,A,B,ZR_78,SR_78);
  RIP1(B,C,D,E,A,ZR_79,SR_79);

  D = RPMD_Array[RPMD_B] + c + D;
  RPMD_Array[RPMD_B] = RPMD_Array[RPMD_C] + d + E;
  RPMD_Array[RPMD_C] = RPMD_Array[RPMD_D] + e + A;
  RPMD_Array[RPMD_D] = RPMD_Array[RPMD_E] + a + B;
  RPMD_Array[RPMD_E] = RPMD_Array[RPMD_A] + b + C;
  RPMD_Array[RPMD_A] = D;
}


//===============================================================
// Subroutine RMD160_Init, initializes Startvalues needed for
// RIPEMD160 processing
//
// Input  Parameters:	int *  RPMD_Array	RIPEMD State structure
// Returns: nothing
//===============================================================
void FAST RMD160_Init(int * RPMD_Array)
{
  RPMD_Array[RPMD_A]   = RPMD160_A;
  RPMD_Array[RPMD_B]   = RPMD160_B;
  RPMD_Array[RPMD_C]   = RPMD160_C;
  RPMD_Array[RPMD_D]   = RPMD160_D;
  RPMD_Array[RPMD_E]   = RPMD160_E;
  RPMD_Array[RPMD_Nl]  = 0;
  RPMD_Array[RPMD_Nh]  = 0;
  RPMD_Array[RPMD_num] = 0;
}

//================================================================
// Subroutine RMD160_Update, processes given data to generate
// new RIPEMD160 digest. This is done by loading the data into the
// helper buffer until an entire RIPEMD160 block is filled and then
// processing that RIPEMD160 block.
//
// NOTE: length of data must be <= 0x3FFFFFFF to avoid
//       overflow
//
// Input  Parameters:	int *  RPMD_Array	Pointer to RIPEMD structure
//			char * data		Data Buffer
//			int    offset		Start of data
//			int    len		Length of data
// Returns: Nothing
//================================================================
void FAST RMD160_Update(int * RPMD_Array, char * data, int Offset, int len)
{
  int i,j,ew,ec,sw,sc;

  int l;

  if (len == 0) return;				// check zero length

  //----------------------------------------------------------------
  // calulate new total B I T - length
  //----------------------------------------------------------------
  l = len << 3;					// get Bitcount
  ADD_64(RPMD_Array[RPMD_Nh],RPMD_Array[RPMD_Nl],l);// sum up

  i = Offset;					// Data-Array StartIndex
  if(RPMD_Array[RPMD_num] != 0)			// check for saved data in array

  {
    //=================================================================
    // stored data in array, fill up until RIPEMD-Block complete (16 longs)
    // or data exhausted
    //=================================================================
    sw = (int) ((((short) RPMD_Array[RPMD_num] & (0x7F)) >> 2)); // full longs
    sc = (int)   (RPMD_Array[RPMD_num] & 0x03);	       // and rem. bytes

    // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)


    if((RPMD_Array[RPMD_num] + len) >= RPMD_CBLOCK)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = RPMD_Array[sw + RPMD_data];	// get address of next or incomplete
      char2longcx(data,l,sc,i);		// get required bytes
      RPMD_Array[sw + RPMD_data] = l;	// save to array
      sw++;				// to next location
      for (; sw < RPMD_LBLOCK; sw++)	// continue copying full longs
      {
        char2long(data,l,i);
        RPMD_Array[sw + RPMD_data] = l;
      }
      len -= (RPMD_CBLOCK - RPMD_Array[RPMD_num]);	// reduce length

      Ripemd160_Block(RPMD_Array);			// get digest
      RPMD_Array[RPMD_num] = 0;				// no data in array
      /* drop through and do the rest */
    }

    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      RPMD_Array[RPMD_num] += len;	// remaining bytes, always < 64
      if ((sc+ (int) len) < 4)		// cannot fill a full long
      {
        l = RPMD_Array[sw + RPMD_data];	// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((int) data[i++] & 0xFF) << 24;	// save byte
            len--;
            if(len == 0) break;

          case 1:					// 1 byte saved
            l |= (((int) data[i++] & 0xFF) << 16);	// insert next
            len--;
            if(len == 0) break;

          case 2:					// 2 byte saved
            l |= (((int) data[i++] & 0xFF) << 8);	// insert next
            len--;
            if(len == 0) break;

          case 3:					// 3 byte saved
            l |= ((int) data[i++] & 0xFF);		// insert next
            break;
        }
        RPMD_Array[sw + RPMD_data] = l;	// save incomplete long
      }
      else
      {
        ew = (int) (RPMD_Array[RPMD_num] & 0xFF); // get ending byte count
        ec = ew & 0x03;				// incomplete ending byte count
        ew >>= 2;				// full longs for copy
        l = RPMD_Array[sw + RPMD_data];	// get saved bytes (if any)
        char2longcx(data,l,sc,i);	// insert bytes or copy full long
  	RPMD_Array[sw + RPMD_data] = l;	// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          char2long(data,l,i);
          RPMD_Array[sw + RPMD_data] = l;
        }
        if(ec != 0)			// remaining bytes to copy into a long
        {
          char2long3n(data,l,ec,i);
          RPMD_Array[sw + RPMD_data] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= RPMD_CBLOCK)		// only for full blocks
  {
    j = RPMD_data;			// index to Stored data
    for(sw=(RPMD_BLOCK/4);sw != 0; sw--)	// full long copy loop
    {
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
      char2long(data,l,i); RPMD_Array[j++] = l;
    }
    Ripemd160_Block(RPMD_Array);			// process Digest
    len -= RPMD_CBLOCK;				// subtract blocklength
  }
  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;				// is always < SHA_BLOCK !!
  RPMD_Array[RPMD_num] = (int) ec & 0xFF;	// save remaining data bytes
  ew = ec >> 2;					// calculate full long count
  ec &= 0x03;					// get last remaining bytes

  sw = 0;					// index data field start
  for (; sw < ew; sw++)				// copy full longs if any
  {
    char2long(data,l,i);
    RPMD_Array[sw + RPMD_data] = l;
  }
  // next line was missing in original !!
  if(ec != 0)					// copy remaining bytes if any
  {
    char2long3n(data,l,ec,i);
    RPMD_Array[sw + RPMD_data] = l;
  }

}
//=============================================================
// Subroutine RMD160_Final, pads remaining buffer data and
// appends total message bit length (low/high). Processes
// last block(s) and stores message digest
//
// Input  Parameters:	int * RPMD_Array	Pointer to RIPEMD structure
//			char * Digest		Digest Buffer
//			int   Offset		StartIndex into Digest Buffer
// Returns: nothing
/****************************************************************/
void FAST RMD160_Final(int * RPMD_Array, char * Digest, int Offset)
{
  int i,j;

  int l;


  static unsigned char end[4] = {0x80,0x00,0x00,0x00};	// padding bytes array

  /* Array data should definitly have room for at least one more byte. */

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) RPMD_Array[RPMD_num];	// get stored BYTE count
  i = j >> 2;				// get full BIT32 count

  l = RPMD_Array[i+RPMD_data];		// get last stored long
  char2longcn(end,l,(j & 0x03));	// insert 1..4 padding bytes
  RPMD_Array[i+RPMD_data] = l;		// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (RPMD_Array[RPMD_num] >= RPMD_LAST_BLOCK)	// not enough room
  {
    for (; i<RPMD_LBLOCK; i++) RPMD_Array[i+RPMD_data] = 0; // zero data
    Ripemd160_Block(RPMD_Array);			// generate digest
    i = 0;					// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<(RPMD_LBLOCK-2); i++) RPMD_Array[i+RPMD_data]=0; // clear

  RPMD_Array[RPMD_data+(RPMD_LBLOCK-1)] = RPMD_Array[RPMD_Nh]; // set length high
  RPMD_Array[RPMD_data+(RPMD_LBLOCK-2)] = RPMD_Array[RPMD_Nl]; // dto. low
  Ripemd160_Block(RPMD_Array);			// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear RIPEMD Array (safety)
  //---------------------------------------------------------------
  l = RPMD_Array[RPMD_A]; long2charn(l,Digest,Offset+0);
  l = RPMD_Array[RPMD_B]; long2charn(l,Digest,Offset+4);
  l = RPMD_Array[RPMD_C]; long2charn(l,Digest,Offset+8);
  l = RPMD_Array[RPMD_D]; long2charn(l,Digest,Offset+12);
  l = RPMD_Array[RPMD_E]; long2charn(l,Digest,Offset+16);

  i = 0;					// index to array start
  do{RPMD_Array[i] = 0;i++;}while(i < RPMD_ARRAY_SIZE); // clear
}






#undef long2char
#undef long2charn
#undef char2long
#undef char2longn
#undef char2longcx
#undef char2longcn
#undef char2long3n
#undef LROTATE
#undef RROTATE
#undef ADD_64

#undef F1
#undef F2
#undef F3
#undef F4
#undef F5
#undef RIP1
#undef RIP2
#undef RIP3
#undef RIP4
#undef RIP5
// end of 'hobrpmd.c'


#ifdef HL_ENCR_RSA
// hobrsa.c
//===========================================================
//
// This file implements RSA public/private encryption/decryption
// algorithm.
//
// See RSA PKCS-1 for description of algorithm.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>

#define RSA_STRONG_PRIMES	0


#if defined WIN32
#pragma warning(disable:4310)
#endif

//====================================================
// Global Returncodes
//====================================================
#define	RSA_OP_OK				 0
#define	LNUM_OP_OK				 0

//====================================================
// Specific Returncodes, Range is -700 ... -799
//====================================================
//----------------------------------------------------
// Fast Exponentation Returncodes
//----------------------------------------------------
#define RSA_FAST_EXPMOD_FAILURE			-700

//----------------------------------------------------
// Public Encrypt Returncodes
//----------------------------------------------------
#define RSA_PUBENC_ALLOC_ERR			-710
#define RSA_PUBENC_DATA_TOO_LARGE		-711
#define RSA_PUBENC_KEY_SIZE_TOO_LARGE		-712
#define RSA_PUBENC_RANDOM_GET_FAILURE		-713
#define RSA_PUBENC_LNUM_ALLOC_ERR		-714
#define RSA_PUBENC_BYTES_TO_LNUM_ERR		-715
#define RSA_PUBENC_EXPMOD_ERR			-716
#define RSA_PUBENC_LNUM_TO_BYTES_ERR		-717

//----------------------------------------------------
// Private Encrypt Returncodes
//----------------------------------------------------
#define RSA_PRIVENC_ALLOC_ERR			-720
#define RSA_PRIVENC_SRCDATA_TOO_LARGE		-721
#define RSA_PRIVENC_DSTBUF_TOO_SMALL		-722
#define RSA_PRIVENC_LNUM_ALLOC_ERR		-723
#define RSA_PRIVENC_BYTES_TO_LNUM_ERR		-724
#define RSA_PRIVENC_FAST_EXPMOD_ERR		-725
#define RSA_PRIVENC_EXPMOD_ERR			-726
#define RSA_PRIVENC_LNUM_TO_BYTES_ERR		-727

//----------------------------------------------------
// Public Decrypt Returncodes
//----------------------------------------------------
#define RSA_PUBDEC_ALLOC_ERR			-730
#define RSA_PUBDEC_LNUM_ALLOC_ERR		-731
#define RSA_PUBDEC_BYTES_TO_LNUM_ERR		-732
#define RSA_PUBDEC_SRCDATA_TOO_LARGE		-733
#define RSA_PUBDEC_EXPMOD_ERR			-734
#define RSA_PUBDEC_LNUM_TO_BYTES_ERR		-735
#define RSA_PUBDEC_BLOCKTYPE_NOT_00_01		-736
#define RSA_PUBDEC_NO_DATA_BLOCK_DELIM		-737
#define RSA_PUBDEC_BAD_FF_HEADER		-738
#define RSA_PUBDEC_BAD_PAD_BYTE_COUNT		-739
#define RSA_PUBDEC_DSTBUF_TOO_SMALL		-740
#define	RSA_PUBDEC_BLOCKTYPE_NOT_01		-741	// TLS

//----------------------------------------------------
// Private Decrypt Returncodes
//----------------------------------------------------
#define RSA_PRIVDEC_ALLOC_ERR			-750
#define RSA_PRIVDEC_LNUM_ALLOC_ERR		-751
#define RSA_PRIVDEC_BYTES_TO_LNUM_ERR		-752
#define RSA_PRIVDEC_SRCDATA_TOO_LARGE		-753
#define RSA_PRIVDEC_FAST_EXPMOD_ERR		-754
#define RSA_PRIVDEC_EXPMOD_ERR			-755
#define RSA_PRIVDEC_LNUM_TO_BYTES_ERR		-756
#define RSA_PRIVDEC_BLOCKTYPE_NOT_02		-757
#define RSA_PRIVDEC_NO_DATA_BLOCK_DELIM		-758
#define RSA_PRIVDEC_BAD_PAD_BYTE_COUNT		-759
#define RSA_PRIVDEC_DSTBUF_TOO_SMALL		-760
#define	RSA_PRIVDEC_GET_RAND_ERR		-761

//----------------------------------------------------
// Signature Generate/Verify Returncodes
//----------------------------------------------------
#define	RSA_SIG_PARAMS_MISSING			-770
#define	RSA_SIG_DSTBUF_TOO_SMALL		-771
#define	RSA_SIG_INVALID_SIGNATURE_LEN		-772
#define	RSA_SIG_TMP_ALLOC_ERR			-773
#define	RSA_SIG_UNKNOWN_ALGOR_TYPE		-774
#define RSA_SIG_PRIV_ENCRYPT_ERR		-775
#define RSA_SIG_PUBLIC_DECRYPT_ERR		-776
#define	RSA_SIG_VERIFY_FAILURE			-777


//----------------------------------------------------------
// definitions for signature digests
//----------------------------------------------------------
#define	MD2_WITH_RSA_ALGOR		0
#define	MD5_WITH_RSA_ALGOR		1
#define	SHA1_WITH_RSA_ALGOR		2
#define	RIPEMD160_WITH_RSA_ALGOR	3

#define	RSA_MAX_DIGEST_LEN		20	// from SHA1/RIPEMD
#define	MAX_DIGEST_STATE_LEN		100	// pruefen, obs langt

#define	RSA_DEF_MD_SIGN_HDR_LEN		18	// length of header, MD2/MD5
#define	RSA_DEF_SHA_SIGN_HDR_LEN	15	// length of header, SHA1
#define	RSA_DEF_RIPEMD_SIGN_HDR_LEN	15	// length of header, RIPEMD160
#define	RSA_MAX_SIGN_HDR_LEN		18	// max. length of header

#define	RSA_DEF_MD_HDR_ALG_ID_IND	13	// index of Algor-ID Byte

#define MD2_WITH_RSA_ALGOR_ID_BYTE	0x02	// PKCS1 MD2
#define MD5_WITH_RSA_ALGOR_ID_BYTE	0x05	// PKCS1 MD5

#define RSA_DEFAULT_PUB_EXP		0x010001 // Fermat number F4

//---------------------------------------------------------------
#if 0
static void ShowHexString(char * pString,int len)
{
  int i;
  char c;

  printf("\n");
  for(i=0;i<len;i++)
  {
    c = pString[i];
    printf("%02X",c);
  }
}
//---------------------------------------------------------------
static void ShowLnum(WLNUM * lnum)
{
  int len;
  char c;
  int l;
  int * lpEl;

  len = lnum->UsedSize * sizeof(int);
  lpEl = lnum->lpEl;

  printf("\n");
  if(len != 0)
  {
    do
    {
      len--;
      l = lpEl[len];
      printf("0x08lX",l);
    }while(len != 0);
  }
}
#endif
//================================================================
//================================================================
// Clear RSA Data-Structure pointers
//
// Input Parameters :	Pointer to structure
// Output Parameters:   none
//================================================================
static void FAST RSAClrPtrs(RSA_STRUC * rsa)
{
  //----------------------------------------------------------
  // invalidate pointers
  //----------------------------------------------------------
  rsa->Modul   = NULL;
  rsa->PubExp  = NULL;
  rsa->PrivExp = NULL;
  rsa->Prime_p = NULL;
  rsa->Prime_q = NULL;
  rsa->Dmodpm1 = NULL;
  rsa->Dmodqm1 = NULL;
  rsa->Invqmp  = NULL;
}
//================================================================
// Free a RSA Data-Structure: clear allocated large number buffers,
// invalidate pointers.
//
// Input Parameters :	Pointer to structure
// Output Parameters:   none
//================================================================
void FAST RSA_Free(HMEM_CTX_DEF RSA_STRUC * rsa)
{
  if (rsa == NULL)
    return;
  //----------------------------------------------------------
  // clear stored values and free (if appropriate)
  //----------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Modul);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->PubExp);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->PrivExp);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Prime_p);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Prime_q);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Dmodpm1);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Dmodqm1);
  ClearFreeWLnum(HMEM_CTX_REF1 rsa->Invqmp);
  //----------------------------------------------------------
  // invalidate pointers
  //----------------------------------------------------------
  RSAClrPtrs(rsa);
  FREE_CARRAY(HMEM_CTX_REF,rsa);
}
//================================================================
// Allocate a new RSA data-Structure
//
// Input Parameters :	Required Element counts
//			int	nElementcnt	Modulus size
//			int	eElementcnt	Publ. Exp. size
//			int	dElementcnt	Priv. Exp. size
//			int	pElementcnt	Prime p size	
//			int	qElementcnt	Prime q size	
// Output Parameters:   RSA structure pointer: <> 0 o.k.
//						= 0 error occured
//================================================================
RSA_STRUC * FAST RSA_New(HMEM_CTX_DEF	   int nElementcnt,
				   int eElementcnt,
				   int dElementcnt,
				   int pElementcnt,
				   int qElementcnt)
{
  RSA_STRUC * rsa;
  //-------------------------------------------------
  // allocate new structure, clear pointers
  //-------------------------------------------------
  rsa = (RSA_STRUC *)
         ((void *) BIT8_ARRAY_CALLOC(HMEM_CTX_REF,1,sizeof(RSA_STRUC)));
  if(rsa == NULL)
    return(NULL);
  //-------------------------------------------------
  // Allocate required number structures
  //-------------------------------------------------
  if(((rsa->Modul   = AllocNewWLnum(HMEM_CTX_REF1
				      nElementcnt)) == NULL) ||
     ((rsa->PubExp  = AllocNewWLnum(HMEM_CTX_REF1
                                      eElementcnt)) == NULL) ||
     ((rsa->PrivExp = AllocNewWLnum(HMEM_CTX_REF1
				      dElementcnt)) == NULL) ||
     ((rsa->Prime_p = AllocNewWLnum(HMEM_CTX_REF1
				      pElementcnt)) == NULL) ||
     ((rsa->Prime_q = AllocNewWLnum(HMEM_CTX_REF1
				      qElementcnt)) == NULL) ||
     ((rsa->Dmodpm1 = AllocNewWLnum(HMEM_CTX_REF1
				      pElementcnt)) == NULL) ||
     ((rsa->Dmodqm1 = AllocNewWLnum(HMEM_CTX_REF1
				      qElementcnt)) == NULL) ||
     ((rsa->Invqmp  = AllocNewWLnum(HMEM_CTX_REF1
				      qElementcnt)) == NULL))
  {
    RSA_Free(HMEM_CTX_REF1 rsa);
    return(NULL);
  }
  return(rsa);
}
//================================================================
// Get Modulus (n) size from stored value in bytes
//
// Input Parameters :	Pointer to structure
// Output Parameters:   Modulus size in bytes
//================================================================
int FAST RSA_Size(RSA_STRUC * rsa)
{
  if((rsa == NULL) || (rsa->Modul == NULL))
    return(0);
  return(GetByteCntWLnum(rsa->Modul));
}
//================================================================
// Get Modulus (n) size from stored value in bits
//
// Input Parameters :	Pointer to structure
// Output Parameters:   Modulus size in bits
//================================================================
int FAST RSA_BitSize(RSA_STRUC * rsa)
{
  int UsedSize;
  int * lpEl;

  if((rsa == NULL) || (rsa->Modul == NULL))
    return(0);
  UsedSize = rsa->Modul->UsedSize;		// get used elements
  if(UsedSize == 0) return(0);			// none
  lpEl = rsa->Modul->lpEl;			// get pointer
  return(HardGetBitCntWLnumElem(lpEl[UsedSize-1]) +
	 ((UsedSize-1) * sizeof(int) * 8));
}
//================================================================
// Check if all parameters present for chinese remainder calculation
// of the EXPMOD function
//
// Input Parameters :	Pointer to structure
// Output Parameters:   == 0 - not all present
//			!= 0 all present
//================================================================
static int FAST ChkExtRsaParamsPresent(RSA_STRUC * rsa)
{
  if ((rsa->Prime_p != NULL) &&				// prime p present
      (rsa->Prime_p->UsedSize != 0) &&			// not empty
      (rsa->Prime_q != NULL) &&				// prime q present
      (rsa->Prime_q->UsedSize != 0) &&			// not empty
      (rsa->Dmodpm1 != NULL) &&				// d mod(p-1) present
      (rsa->Dmodpm1->UsedSize != 0) &&			// not empty
      (rsa->Dmodqm1 != NULL) &&				// d mod(q-1) present
      (rsa->Dmodqm1->UsedSize != 0) &&			// not empty
      (rsa->Invqmp != NULL) &&				// q**-1 mod(p) present
      (rsa->Invqmp->UsedSize != 0))			// not empty
    return(1);
  return(0);
}
//=======================================================================
// Do modulo exponentation for private key processing using the
// chinese remainder theorem.
//
// Input parameters:	WLNUM *    	res	result struct.
//		        WLNUM * 	u	input
//			RSA_STRUC *	rsa	RSA structure ptr.
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
static int FAST RSA_ExpMod(HMEM_CTX_DEF
			WLNUM * res, WLNUM * u, RSA_STRUC * rsa)
{
  int i;

  int retcode  = RSA_FAST_EXPMOD_FAILURE;	// preset failure
  WLNUM * r1 = NULL;
  WLNUM * m1 = NULL;
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  //---------------------------------------------------------
  // allocate temporary large numbers
  //---------------------------------------------------------
  i  = rsa->Prime_p->UsedSize;			// get p size
  r1 = AllocNewWLnum(HMEM_CTX_REF1 i);		// get struc, preallocate
  m1 = AllocNewWLnum(HMEM_CTX_REF1 i);		// dto.
  if((m1 != NULL) && (r1 != NULL) &&		// Allocate fail detect
    //---------------------------------------------------------
    // calculate (a**(d mod(p-1)) mod p, (b**(d mod(q-1)) mod q
    //---------------------------------------------------------
					// r1 = u mod q
    (ModWLnum(HMEM_CTX_REF1
	       r1,u,rsa->Prime_q,NULL) == LNUM_OP_OK) &&
					// b = r1**(d mod(q-1)) mod q
    (ExpModWLnum(HMEM_CTX_REF1
		   m1,r1,rsa->Dmodqm1,
	           rsa->Prime_q,NULL,NULL) == LNUM_OP_OK) &&

    (ModWLnum(HMEM_CTX_REF1
	       r1,u,rsa->Prime_p,NULL) == LNUM_OP_OK) &&

						// a = r1**(d mod(p-1)) mod p
    (ExpModWLnum(HMEM_CTX_REF1
		   res,r1,rsa->Dmodpm1,
       rsa->Prime_p,NULL,NULL) == LNUM_OP_OK) &&
						// a = a + p
    (AddWLnum(HMEM_CTX_REF1
	       r1,res,rsa->Prime_p) == LNUM_OP_OK) &&

						// a - b
    (SubWLnum(HMEM_CTX_REF1
	       res,r1,m1) == LNUM_OP_OK) &&
						// (a - b) * qinv
    (MulWLnum(HMEM_CTX_REF1
	       r1,res,rsa->Invqmp) == LNUM_OP_OK) &&

						// ((a-b) * qinv) mod p
    (ModWLnum(HMEM_CTX_REF1
	       res,r1,rsa->Prime_p,NULL) == LNUM_OP_OK) &&
						// (((a-b)*qinv)modp)*q
    (MulWLnum(HMEM_CTX_REF1
	       r1,res,rsa->Prime_q) == LNUM_OP_OK) &&
						// x=(((a-b)*qinv)modp)*q+b
    (AddWLnum(HMEM_CTX_REF1
	       res,r1,m1) == LNUM_OP_OK))
      retcode=RSA_OP_OK;			// set o.k.


  FreeWLnum(HMEM_CTX_REF1 m1);
  FreeWLnum(HMEM_CTX_REF1 r1);
  return(retcode);
}	
//=======================================================================
// Encrypt a Message Block using the Public Key
// Note: if zerofill mode is selected, the ouput will be padded
// ----- with leading zeroes until buffersize is reached
//	 if standard mode is selected, a leading zero will be
//	 inserted if the MSB bit is 1.
//
// Input parameters:	char *	    MsgBuf	message block array base
//			int	    MsgOff	offset to Start
//			int	    MsgLen	length of input data block
//			char *	    DstBuf	encrypted output block ptr.
//			int	    DstOff	offset to Start
//			int *	    pDstLen	size (In/Out)	
//			RSA_STRUC * rsa		RSA structure ptr.
//			int	    ZeroFill	== 0 - Standard mode
//						<> 0 - fill with leading zeroes
//
// Output Parameters:	int Status		<> RSA_OP_OK: Error
//=======================================================================
int FAST  RSA_PublicEncrypt(HMEM_CTX_DEF
			    char * MsgBuf, int MsgOff, int  MsgLen,
			    char * DstBuf, int DstOff, int * pDstLen,
			    RSA_STRUC * rsa, int ZeroFill)
{
  int i,j,k,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char * Tmpbuf;

  WLNUM * f = NULL;
  WLNUM * ret = NULL;
  //------------------------------------------------------
  // check for correct message length (<= Modulus length -11)
  // and destination buffer size
  //------------------------------------------------------
  num = RSA_Size(rsa);			// get modulus length (must be >= 12)
  if (MsgLen > (num-11))		// check for correct blocklen
    return(RSA_PUBENC_DATA_TOO_LARGE);
  if(((ZeroFill == 0) && (pDstLen[0] <= num)) || // include leading zero
     ((ZeroFill != 0) && (pDstLen[0] < num)))	// no leading zero...
    return(RSA_PUBENC_KEY_SIZE_TOO_LARGE);
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PUBENC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //==========================================================
    // 1. format the encryption block...
    //==========================================================
    Tmpbuf[tmpind++] = 0;			// Starting delimiter
    Tmpbuf[tmpind++] = 2;			// Blocktype(BT): public key

    j = num - MsgLen - 3;			// length of padding string

    retcode = SecDrbgRandBytes(HMEM_CTX_REF1 Tmpbuf,tmpind,j);
    if(retcode != 0)
    {
      retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
      break;
    }
    //-------------------------------------------------------------
    // assure there is no 0x00 character in the generated random data
    //-------------------------------------------------------------
    for (i=0; i<j; i++)
    {
      if(Tmpbuf[tmpind] == 0)			// found a zero, must replace
      {
        k = 1000;				// loop limit
        retcode = 0;
        do
        {
          retcode = SecDrbgRandBytes(HMEM_CTX_REF1 Tmpbuf,tmpind,1);
          if(retcode != 0)
            break;

          k--;					// reduce limiting counter

        }while((Tmpbuf[tmpind] == 0) && (k != 0));// until <> zero or limit
        if(retcode != 0)
        {
          retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
          break;
        }

        if(Tmpbuf[tmpind] == 0)			// timed out
        {
          retcode=RSA_PUBENC_RANDOM_GET_FAILURE;	// set reason
          break;
        }
      } // zero detected
      tmpind++;					// to next location
    } // for
    if(retcode != RSA_OP_OK)			// Error occured...
      break;
    //----------------------------------------------------------
    // append the data delimiter and the data octets
    //----------------------------------------------------------
    Tmpbuf[tmpind++] = 0;			// set data delimiter
    j = MsgOff;					// start of message data
    for(i=0;i<MsgLen;i++)
    {
      Tmpbuf[tmpind++] = MsgBuf[j++];		// append data byte
    }
    //==========================================================
    // 2. convert encryption block to integer (large number)
    //==========================================================
    f   = AllocNewWLnum(HMEM_CTX_REF1
		      (num + 4-1)/4);		// get a large number
    ret = AllocNewWLnum(HMEM_CTX_REF1
		      (num + 4-1)/4);		// dto.
    if((f == NULL) || (ret == NULL))		// no structure(s)
    {
      retcode = RSA_PUBENC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
    if(WLnum_bin2wlnum(HMEM_CTX_REF1
			 f,Tmpbuf,0,num) != LNUM_OP_OK) //to large number
    {
      retcode = RSA_PUBENC_BYTES_TO_LNUM_ERR;
      break;
    }
    //============================================================
    // 3. do RSA encryption
    //============================================================
    if(ExpModWLnum(HMEM_CTX_REF1
		   ret,f,rsa->PubExp,rsa->Modul,
		   NULL,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PUBENC_EXPMOD_ERR;
      break;
    }
    //============================================================
    // 4. convert encrypted integer (large number) back to byte string,
    //    insert leading Zeroes if necessary
    //============================================================
    if(ZeroFill != 0)
    {
      if(WLnum_wlnum2binFill(
		DstBuf,DstOff,pDstLen,ret,num) != LNUM_OP_OK) // convert to bytes
      {
        retcode = RSA_PUBENC_LNUM_TO_BYTES_ERR;
        break;
      }
// for Testing only !!!!
#if 0
      i = num - GetByteCntWLnum(ret);	// get number of bytes
      if(i != 0)
        printf("RSA-Pub muell1\n");
#endif
//
    }
    else
    {
      if(WLnum_wlnum2bin(
		DstBuf,DstOff,pDstLen,ret,0) != LNUM_OP_OK) // convert to bytes
      {
        retcode = RSA_PUBENC_LNUM_TO_BYTES_ERR;
        break;
      }
    }
    break;
  } // outmost for loop
  //------------------------------------------------------------------
  // clear sensitive data, free used buffers
  //------------------------------------------------------------------
  do{num--;Tmpbuf[num] = 0;}while(num != 0);	// clear sensitve data

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);
  FreeWLnum(HMEM_CTX_REF1 f);			// free large number
  FreeWLnum(HMEM_CTX_REF1 ret);			// dto.
  return(retcode);				// return
}
//=======================================================================
// Encrypt a Message Block using the Private Key. When stored parameters
// p,q,d mod(p-1), d mod(q-1) and q^-1 mod(p) are available,
// uses chinese remainder theorem to speed up encryption
//
// NOTE: Supports 3 modes of output number generation now:
// ----- a) ZeroFlag = 0	do NOT insert any leading zeros anyway
//				(output may be also shorter than modulus size)
//       b) ZeroFlag > 0        insert leading zero byte if MSB bit of
//				number is set (may be shorter/longer, ASN.1)
//	 c) ZeroFlag < 0	output size exact as modulus given, generate
//				leading zero bytes until size reached
//
// Input parameters:    char *	    InpBuf	message block ptr.
//			int         InpLen	length of input data block
//			char *	    DstBuf	encrypted output block ptr.
//			int	    DstOffset	start
//			int *	    pDstLen	size (in/out)
//			RSA_STRUC * rsa		RSA structure ptr.
//			int	    ZeroFlag	see above
//
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
int FAST RSA_PrivateEncryptEx(HMEM_CTX_DEF
			      char * InpBuf, int InpLen,
                              char * DstBuf, int DstOffset, int * pDstLen,
			      RSA_STRUC * rsa, int ZeroFlag)
{
  int i,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char * Tmpbuf;

  WLNUM * f = NULL;
  WLNUM * ret = NULL;
  //------------------------------------------------------
  // check for correct message length (<= Modulus length -11)
  //------------------------------------------------------
					// get modulus length (must be >= 12)
  num = RSA_Size(rsa);
  if (InpLen > (num-11))		// check for correct blocklen
    return(RSA_PRIVENC_SRCDATA_TOO_LARGE);
  //------------------------------------------------------
  // check for correct destination buffer length
  //------------------------------------------------------
  if(pDstLen[0] < (num+1))		// buffer too small
    return(RSA_PRIVENC_DSTBUF_TOO_SMALL);
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PRIVENC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  //==========================================================
  // 1. format the encryption block...
  //==========================================================
  Tmpbuf[tmpind++] = 0;				// Starting delimiter
  Tmpbuf[tmpind++] = 1;				// Blocktype(BT): private key

  i = num - InpLen - 3;				// length of padding string
  for(;i != 0;i--)
    Tmpbuf[tmpind++] = (char) ((unsigned char) 0xFF);	// pad with 0xFF bytes
  //----------------------------------------------------------
  // append the data delimiter and the data octets
  //----------------------------------------------------------
  Tmpbuf[tmpind++] = 0;			// set data delimiter
  memcpy(Tmpbuf+tmpind,InpBuf,InpLen);
  //==========================================================
  // 2. convert encryption block to integer (large number)
  //==========================================================
  f   = AllocNewWLnum(HMEM_CTX_REF1 num);// get a large number
  ret = AllocNewWLnum(HMEM_CTX_REF1 num);// dto.
  if((f == NULL) || (ret == NULL))		// no structure(s)
    retcode = RSA_PRIVENC_LNUM_ALLOC_ERR;	// set error reason
  else
  {						 // convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1
			 f,Tmpbuf,1,num-1) != LNUM_OP_OK)
      retcode = RSA_PRIVENC_BYTES_TO_LNUM_ERR;
  }
  //============================================================
  // 3. do RSA encryption; check if easier way possible
  //============================================================
  if(retcode == RSA_OP_OK)
  {
    if(ChkExtRsaParamsPresent(rsa) != 0)
    {
      if(RSA_ExpMod(HMEM_CTX_REF1 ret,f,rsa) != RSA_OP_OK)
        retcode = RSA_PRIVENC_FAST_EXPMOD_ERR;
    } // fast expmod
    else
    {
      if(ExpModWLnum(HMEM_CTX_REF1
	   ret,f,rsa->PrivExp,rsa->Modul, NULL, NULL) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_EXPMOD_ERR;
    }
  }
  //============================================================
  // 4. convert encrypted integer (large number) back to byte string
  //============================================================
  if(retcode == RSA_OP_OK)
  {
    if(ZeroFlag >= 0)				// old mode
    {
      if(WLnum_wlnum2bin(
		  DstBuf,DstOffset,pDstLen,ret,ZeroFlag) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_LNUM_TO_BYTES_ERR;
    }
    else					// new mode, fill up
    {
      if(WLnum_wlnum2binFill(
		  DstBuf,DstOffset,pDstLen,ret,num) != LNUM_OP_OK)
        retcode = RSA_PRIVENC_LNUM_TO_BYTES_ERR;
    }
  } // outmost for loop
  //------------------------------------------------------------------
  // clear sensitive data, free used buffers
  //------------------------------------------------------------------
  do{num--;Tmpbuf[num] = 0;}while(num != 0);	// clear sensitve data
  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);
  FreeWLnum(HMEM_CTX_REF1 f);			// free large number
  FreeWLnum(HMEM_CTX_REF1 ret);			// dto.
  return(retcode);				// return
}
//=======================================================================
// Encrypt a Message Block using the Private Key. When stored parameters
// p,q,d mod(p-1), d mod(q-1) and q^-1 mod(p) are available,
// uses chinese remainder theorem to speed up encryption
// IS NOW A WRAPPER TO NEW ROUTINE (with fill)
//
// Note: when the cipherblock has the MSB bit set (BIG ENDIAN)
// ----- a leading zero is inserted in front of the cipher block,
//	 if requested
//
// Input parameters:    char *	    InpBuf	message block ptr.
//			int         InpLen	length of input data block
//			char *	    DstBuf	encrypted output block ptr.
//			int	    DstOffset	start
//			int *	    pDstLen	size (in/out)
//			RSA_STRUC * rsa		RSA structure ptr.
//			int	    ZeroFlag	== 0 dont't insert zero
//						!= 0 insert zero if required
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
int FAST RSA_PrivateEncrypt(HMEM_CTX_DEF
			    char * InpBuf, int InpLen,
                            char * DstBuf, int DstOffset, int * pDstLen,
			    RSA_STRUC * rsa, int ZeroFlag)
{
  int NewZeroFlag = 0;

  if(ZeroFlag != 0)
    NewZeroFlag = 1;
  return(RSA_PrivateEncryptEx(HMEM_CTX_REF1
			      InpBuf, InpLen, DstBuf, DstOffset,
			      pDstLen, rsa, NewZeroFlag));
}

//=======================================================================
// Decrypt a Message Block using the Public Key, extended version
// (Block type checking mode)
//
// Note: the cipherblock (INTEGER) may start with a leading zero
// -----
//
// Input parameters:	int          Buflen	length of input data block
//		        char *	     InpBuf	cipher block ptr.
//			int	     InputOffset Start Index into inp.Buff.
//			char *	     OutpBuf	decrypted output block ptr.
//			int *	     pMsgLen	decoded message length
//			RSA_STRUC *  rsa	RSA structure ptr.
//			int	     Flags	Bit 0: 0 Allow block types 0,1
//						       1 only block type1 valid
//						Bit 31-1 reserved
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
int FAST RSA_PublicDecryptEx(HMEM_CTX_DEF
			     int Buflen, char * InpBuf, int InputOffset,
                             char * OutpBuf, int * pMsgLen,
                             RSA_STRUC * rsa, int Flags)
{
  int i,j,num;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char padvalue;

  char * Tmpbuf;
  int lpi;

  WLNUM * f = NULL;
  WLNUM * ret = NULL;
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  num = RSA_Size(rsa);		// get modulus length (must be >= 12)
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)
    return(RSA_PUBDEC_ALLOC_ERR);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //============================================================
    // 1. convert cipher text to integer (large number), check < n
    //============================================================
    f   = AllocNewWLnum(HMEM_CTX_REF1 num); // get a large number
    ret = AllocNewWLnum(HMEM_CTX_REF1 num); // dto.
    if((f == NULL) || (ret == NULL))		// no structure(s)
    {
      retcode = RSA_PUBDEC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
						// convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1
		f,InpBuf,InputOffset,Buflen) != LNUM_OP_OK)
    {
      retcode = RSA_PUBDEC_BYTES_TO_LNUM_ERR;
      break;
    }
    i = UcompWLnum(f,rsa->Modul); // check < n
    if(i != WLNUM_1ST_LT_2ND)
    {
      retcode = RSA_PUBDEC_SRCDATA_TOO_LARGE;
      break;
    }
    //============================================================
    // 2. do RSA decryption
    //============================================================
    if(ExpModWLnum(HMEM_CTX_REF1
		     ret,f,rsa->PubExp,rsa->Modul,NULL,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PUBDEC_EXPMOD_ERR;
      break;
    }
    //============================================================
    // 3. convert decrypted integer (large number) back to byte string
    // NOTE: the leading zero will not appear in the output string
    //============================================================
    lpi = num;					// size of buffer
    if(WLnum_wlnum2bin(Tmpbuf,0,&lpi,ret,0) != LNUM_OP_OK) // convert to bytes
    {
      retcode = RSA_PUBDEC_LNUM_TO_BYTES_ERR;
      break;
    }
    //============================================================
    // 4. check decrypted message block, Blocktypes 00 and 01 possible
    //    NOTE: SSL only allows Blocktype 0x01, but Certificates
    //    ----- might use Blocktype 0x00 !!
    //============================================================
    padvalue = 0;			// padding for type 0
    if((Tmpbuf[tmpind] != 0x00) &&	// not Blocktype (BT) 00
       (Tmpbuf[tmpind] != 0x01))	// not Blocktype (BT) 01
    {
      retcode = RSA_PUBDEC_BLOCKTYPE_NOT_00_01;
      break;
    }
    if((Tmpbuf[tmpind] == 0x00) && ((Flags & 0x01) != 0))
    {
      retcode = RSA_PUBDEC_BLOCKTYPE_NOT_01;	// TLS 1.1 requirement
      break;
    }

    if(Tmpbuf[tmpind++] == 0x01)	// must use alternate padding
      padvalue = (char) ((unsigned char) 0xFF);
    //------------------------------------------------------------
    // skip padding data
    //------------------------------------------------------------
    j=num-2;				// minus BT and leading 00 bef. data
    i = 0;
    do
    {
      if (Tmpbuf[tmpind] != padvalue)	// not a padding byte (00/FF)
        break;				// further checking required
      tmpind++;				// to next byte
      i++;				// to next
    }while(i < j);
    //------------------------------------------------------------
    // check if enough padding data and data delimiter are present
    //------------------------------------------------------------
    if(padvalue == (char) 0xFF)		// type 1 processing
    {
      if (i == j)			// no data delimiter found
      {
        retcode = RSA_PUBDEC_NO_DATA_BLOCK_DELIM;
        break;
      }
      if(Tmpbuf[tmpind++] != 0)		// not a data delimiter (00)
      {
	retcode = RSA_PUBDEC_BAD_FF_HEADER;
	break;
      }
      i++;				// skip data delimiter
    }
    if (i < 9)				// too few padding bytes(inc. data del)
    {
      retcode = RSA_PUBDEC_BAD_PAD_BYTE_COUNT;
      break;
    }
    //============================================================
    // 5. copy data (if any) to output buffer
    //============================================================
    j = j - i;				// get remaining data length
    if(pMsgLen[0] < j)				// buffer too small
    {
      retcode = RSA_PUBDEC_DSTBUF_TOO_SMALL;
      break;
    }
    pMsgLen[0] = j;			// report output data count
    if(j > 0)
      memcpy(OutpBuf,Tmpbuf+tmpind,j);
#if 0
    i = 0;				// output index
    for(;j>0;j--)			// data copy loop
      OutpBuf[i++] = Tmpbuf[tmpind++];
#endif
    break;				// exit FOR loop
  } // outmost for loop
  //---------------------------------------------------
  // clear sensitive data
  //---------------------------------------------------
  do{num--;Tmpbuf[num]=0;}while(num != 0);

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);				// free buffer
  FreeWLnum(HMEM_CTX_REF1 f);
  FreeWLnum(HMEM_CTX_REF1 ret);

  return(retcode);
}
//=======================================================================
// Decrypt a Message Block using the Public Key
// --- Now a Wrapper to RSA_PublicDecryptEx ---
//
// Note: the cipherblock (INTEGER) may start with a leading zero
// -----
//
// Input parameters:	int          Buflen	length of input data block
//		        char *	     InpBuf	cipher block ptr.
//			int	     InputOffset Start Index into inp.Buff.
//			char *	     OutpBuf	decrypted output block ptr.
//			int *	     pMsgLen	decoded message length
//			RSA_STRUC *  rsa	RSA structure ptr.
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
int FAST RSA_PublicDecrypt(HMEM_CTX_DEF
			   int Buflen, char * InpBuf, int InputOffset,
                           char * OutpBuf, int * pMsgLen, RSA_STRUC * rsa)
{
  return(RSA_PublicDecryptEx(HMEM_CTX_REF1
			     Buflen, InpBuf, InputOffset,
                             OutpBuf, pMsgLen, rsa, 0));
}
//=======================================================================
// Decrypt a Message Block using the Private Key.
// To avoid timing attacks, RSA-blinding is used.
//
// Note: the cipherblock (INTEGER) may start with a leading zero
// -----
//
// Input parameters:    char *	    InpBuf	cipher block ptr.
//			int	    InpOff	Start Index into inp.Buff.
//			int         Inplen	length of input data block
//			char *	    OutpBuf	decrypted output block ptr.
//			int *	    MsgLen	decoded message length
//			RSA_STRUC * rsa		RSA structure ptr.
// Output Parameters:	int Status		<> 0 RSA_OP_OK: Error
//=======================================================================
int FAST RSA_PrivateDecrypt(HMEM_CTX_DEF
			    char * InpBuf, int InpOff, int Inplen,
                            char * OutpBuf, int * pMsgLen, RSA_STRUC * rsa)
{
  int i,j,num,count,modbits;
  int retcode = RSA_OP_OK;
  int tmpind = 0;

  char * Tmpbuf;
  int lpi;

  WLNUM * f    = NULL;
  WLNUM * r    = NULL;
  WLNUM * rinv = NULL;
  WLNUM * k    = NULL;
  WLNUM * ret  = NULL;
  WLNUM * tmp;
  //------------------------------------------------------
  // get temporary buffer/allocate
  //------------------------------------------------------
  num = RSA_Size(rsa);			// get modulus length (must be >= 12)
  if((Tmpbuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,num)) == NULL)// alloc buffer of modulus size
    return(RSA_PRIVDEC_ALLOC_ERR);
  modbits = RSA_BitSize(rsa);
  //------------------------------------------------------
  // to ease error handling we use a dummy FOR loop that will
  // terminate when an error is encountered. So all cleanup stuff
  // can be done at a central place
  //------------------------------------------------------
  for(;;)	
  {
    //===============================================================
    // 1. convert cipher text to integer (large number), check if < n
    //===============================================================
    f    = AllocNewWLnum(HMEM_CTX_REF1 num);	    // get a large number
    r    = AllocNewWLnum(HMEM_CTX_REF1 num);	    // dto.
    rinv = AllocNewWLnum(HMEM_CTX_REF1 num);	    // dto.
    k    = AllocNewWLnum(HMEM_CTX_REF1 num);	    // dto.
    ret  = AllocNewWLnum(HMEM_CTX_REF1 num);	    // dto.
    if((f == NULL) || (r == NULL) || (rinv == NULL) ||
       (k == NULL) || (ret == NULL))			// no structure(s)
    {
      retcode = RSA_PRIVDEC_LNUM_ALLOC_ERR;	// set error reason
      break;
    }
						// convert to large number
    if(WLnum_bin2wlnum(HMEM_CTX_REF1
			 f,InpBuf,InpOff,Inplen) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_BYTES_TO_LNUM_ERR;
      break;
    }
    i = UcompWLnum(f,rsa->Modul);		// check < n
    if(i != WLNUM_1ST_LT_2ND)
    {
#if 0
      ShowLnum(rsa->Modul);
      PRINT("\n");
      ShowLnum(f);
      PRINT("\n");
#endif
      retcode = RSA_PRIVDEC_SRCDATA_TOO_LARGE;
      break;
    }
    //============================================================
    // 1.1. Choose Random number r with 1 <= r < n
    //============================================================
    retcode = LNUM_OP_OK;
    for(count=32;count > 0; count--)
    {
      if(WLnumRand(HMEM_CTX_REF1 r,modbits,1,1) != LNUM_OP_OK)
      {
        retcode =RSA_PRIVDEC_GET_RAND_ERR;
        break;
      }
      i = UcompWLnum(r,rsa->Modul);		// check < n
      if(i == WLNUM_1ST_GT_2ND)
      {
        if(ModWLnum(HMEM_CTX_REF1
		     rinv,r,rsa->Modul,NULL) != LNUM_OP_OK)
        {
          retcode =RSA_PRIVDEC_GET_RAND_ERR;
          break;
        }
        tmp  = rinv;
        rinv = r;
        r    = tmp;
      }
      //--------------------------------------------------------
      // get Inverse for r mod n
      //--------------------------------------------------------
      if((i = InvModWLnum(HMEM_CTX_REF1
			  rinv,r,rsa->Modul,NULL)) == LNUM_OP_OK)
        break;
      if(i != LNUM_OP_NO_INVERSE)
      {
        retcode =RSA_PRIVDEC_GET_RAND_ERR;
        break;
      }
    }
    if(retcode != LNUM_OP_OK)
      break;
    if(count == 0)
    {
      retcode =RSA_PRIVDEC_GET_RAND_ERR;
      break;
    }
    //---------------------------------------------------------------
    // 1.2. Calculate (r**e) mod n
    //---------------------------------------------------------------
    if(ExpModWLnum(HMEM_CTX_REF1
		     k,r,rsa->PubExp,rsa->Modul,NULL,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_EXPMOD_ERR;
      break;
    }
    //---------------------------------------------------------------
    // 1.3. Calculate C' = C * k
    //---------------------------------------------------------------
    if(MulModWLnum(HMEM_CTX_REF1
		     f,f,k,rsa->Modul,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_EXPMOD_ERR;
      break;
    }
//    printf("RSA private decrypt Blinding applied.\n");
    //============================================================
    // 2. do RSA encryption, check if easier way possible
    //============================================================
    if(ChkExtRsaParamsPresent(rsa) != 0)
    {
      if(RSA_ExpMod(HMEM_CTX_REF1 ret,f,rsa) != RSA_OP_OK)
      {
        retcode = RSA_PRIVDEC_FAST_EXPMOD_ERR;
        break;
      }
    } // fast expmod
    else
    {
      if(ExpModWLnum(HMEM_CTX_REF1
		       ret,f,rsa->PrivExp,rsa->Modul,NULL,NULL) != LNUM_OP_OK)
      {
        retcode = RSA_PRIVDEC_EXPMOD_ERR;
        break;
      }
    }
    //---------------------------------------------------------------
    // 2.1. Calculate P = P' * R**-1
    //---------------------------------------------------------------
    if(MulModWLnum(HMEM_CTX_REF1
		     ret,ret,rinv,rsa->Modul,NULL) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_EXPMOD_ERR;
      break;
    }
    //============================================================
    // 3. convert decrypted integer (large number) back to byte string
    // NOTE: the leading zero will not appear in the output string
    //============================================================
    lpi = num;					// size of buffer
						// convert to bytes
    if(WLnum_wlnum2bin(Tmpbuf,0,&lpi,ret,0) != LNUM_OP_OK)
    {
      retcode = RSA_PRIVDEC_LNUM_TO_BYTES_ERR;
      break;
    }
    //============================================================
    // 4. check decrypted message block, only Blocktypes 02 valid
    //============================================================
    if(Tmpbuf[tmpind++] != 0x02)	// not Blocktype (BT) 02
    {
      retcode = RSA_PRIVDEC_BLOCKTYPE_NOT_02;
      break;
    }
    //------------------------------------------------------------
    // skip padding data
    //------------------------------------------------------------
    j=num-2;				// minus BT and leading 00 bef. data
    i = 0;
    do
    {
      if (Tmpbuf[tmpind++] == 00) break;// start of data found
      i++;				// to next
    }while(i < j);
    //------------------------------------------------------------
    // check if enough padding data/data delimiter present
    //------------------------------------------------------------
    if (i == j)				// no data delimiter found
    {
        retcode = RSA_PRIVDEC_NO_DATA_BLOCK_DELIM;
        break;
    }
    if (i < 8)				// too few padding bytes(excl. data del)
    {
      retcode = RSA_PRIVDEC_BAD_PAD_BYTE_COUNT;
      break;
    }
    i++;				// skip data delimiter
    //============================================================
    // 5. copy data (if any) to output buffer
    //============================================================
    j = j - i;				// get remaining data length
    if(pMsgLen[0] < j)				// buffer too small
    {
      retcode = RSA_PRIVDEC_DSTBUF_TOO_SMALL;
      break;
    }
    pMsgLen[0] = j;			// report output data count
    if(i > 0)
      memcpy(OutpBuf,Tmpbuf+tmpind,j);

#if 0
    i = 0;				// output index
    for(;j>0;j--)			// data copy loop
      OutpBuf[i++]=Tmpbuf[tmpind++];
#endif
    break;				// exit FOR loop
  } // outmost for loop
  //---------------------------------------------------
  // clear sensitive data
  //---------------------------------------------------
  do{num--;Tmpbuf[num]=0;}while(num != 0);

  FREE_CARRAY(HMEM_CTX_REF,Tmpbuf);			// free buffer
  FreeWLnum(HMEM_CTX_REF1 f);
  FreeWLnum(HMEM_CTX_REF1 r);
  FreeWLnum(HMEM_CTX_REF1 rinv);
  FreeWLnum(HMEM_CTX_REF1 k);
  FreeWLnum(HMEM_CTX_REF1 ret);

  return(retcode);
}
//----------------------------------------------------------------------
static unsigned char RSA_Def_MD_Sign_Hdr[RSA_DEF_MD_SIGN_HDR_LEN] =
  {0x30, 0x20,				// Outer Sequence
     0x30, 0x0C,			// Algoritm ID Sequence
       0x06, 0x08, 0x2A,		// Algoritm ObjID (RSA-PKCS1),
       0x86, 0x48, 0x86, 0xF7,
         0x0D, 0x02, 0xFF,		// MD2/MD5 digest Algorithm
       0x05, 0x00,			// Algorithm-Params: NULL
     0x04, 0x10				// OctetString: Digest(MD2/MD5)
};

static unsigned char RSA_Def_SHA_Sign_Hdr[RSA_DEF_SHA_SIGN_HDR_LEN] =
  {0x30, 0x21,				// Outer Sequence
     0x30, 0x09,			// Algoritm ID Sequence
       0x06, 0x05, 0x2B,		// Algoritm ObjID (OIW),
         0x0E, 0x03, 0x02, 0x1A,	// SHA1 digest Algorithm
       0x05, 0x00,			// Algorithm-Params: NULL
     0x04, 0x14				// OctetString: Digest(SHA1)
};

static unsigned char RSA_Def_RIPEMD_Sign_Hdr[RSA_DEF_RIPEMD_SIGN_HDR_LEN] =
  {0x30, 0x21,				// Outer Sequence
     0x30, 0x09,			// Algoritm ID Sequence
       0x06, 0x05, 0x2B,		// Algoritm ObjID (TELESEC),
         0x24, 0x03, 0x02, 0x01,	// RIPEMD Algorithm
       0x05, 0x00,			// Algorithm-Params: NULL
     0x04, 0x14				// Oct. Digest(RIPEMD160)
};

//=====================================================================
// UP RSA_signEx generates/verifies a PKCS1 conforming signature from a
// given message/signature.
// Checks RSA block type 0x01 when requested
//
// 1.  Generate Digest from Message (MD2, MD5, SHA1, RIPEMD160)
// 2a. Encode Digest into an ASN.1 DER encoded octet string
// 2b. Prepend octet string with ASN.1 DER encoded Algorithm Identifier
// 2c. Encapsulate the whole as an ASN.1 Sequence
//
// Generate Mode:
// 3.  RSA-Encrypt this ASN.1 sequence with the given private key
//     and stores the encrypted signature, sets the true signature length
//     if the signature has the MSB bit set, inserts leading zero byte
//     -- no longer a zero inserted as will be encoded as Bitstring !!
//
//     Note: The Signature Buffer must be at least as long as the
//     ----- RSA Encryption Modulus + 1 !!!
//
// Verify Mode:
// 3. RSA-Decrypts the given signature with the given public key
//    The given signature may have a leading Zero byte.
// 4. Compares the decrypted given signature to the DER encoded
//    own digest
//    Note: The Signature Size must be less or same as the
//    ----- RSA Encryption Modulus !!!
//
//
// Input parameters  :	int     DigestType	Type of message Digest to use:
//						0 - MD2, 1 - MD5, 2 - SHA1,
//						3 - RIPEMD160
//			char *  MessageBuf	Pointer to message buffer
//			int	MsgBufOffset	Start-Index into buffer
//			int     MessageLen	Length of Message beginning at
//						Start-Index
//			char *  SignatureBuf	Pointer to signature buffer
//			int	SignatBufOffset	Start-Index into buffer
//			int *   pSignatureLen	Generate-Mode:
//						length of signature buffer,
//						will be updated to true length
//						Verify-Mode:
//						length of given Signature
//			RSA_STRUC * rsa		RSA-Structure with modulus,
//					        public exp., etc.
//			int	mode		type of requested operation:
//						0 - generate signature
//						<> 0 - verify given signature
//			int	     Flags	Bit 0: 0 Allow block types 0,1
//						       1 only block type1 valid
//						Bit 31-1 reserved
//
// Returns:		int Status		0 - o.k.
//						<> 0 : Error occured:
//						RSA_SIG_PARAMS_MISSING
//						RSA_SIG_TOO_SMALL_SIGNATURE_BUF
//						RSA_SIG_INVALID_SIGNATURE_LEN
//						RSA_SIG_TMP_ALLOC_FAILED
//						RSA_SIG_UNKNOWN_ALGOR_TYPE
//						RSA_SIG_ENCRYPT_DECRYPT_FAILED
//						RSA_SIG_VERIFY_FAILURE
//=====================================================================
int FAST RSA_signEx(HMEM_CTX_DEF
	  int DigestType,
	  char * MessageBuf,   int MsgBufOffset,     int MessageLen,
	  char * SignatureBuf, int SignatBufOffset,  int * pSignatureLen,
	  RSA_STRUC * rsa, int mode, int Flags)
{
  int i;
  int RetCode;
  int ModulusLen;
  int EncodedDigestLen;

  char * TmpBuf = NULL;
  char * TmpSignatBuf=NULL;

  int DigestState[MAX_DIGEST_STATE_LEN];
  int DecodedDigestLen;

  //-----------------------------------------------------------
  // Get the RSA-Modulus length, check if modulus
  // and public or private exponent are present and have size <> 0,
  // check for correct signature buffer size
  //-----------------------------------------------------------
  if(rsa->Modul == NULL)
    return(RSA_SIG_PARAMS_MISSING);			// no modulus ptr
  ModulusLen = RSA_Size(rsa);				// get modulus size
  if(ModulusLen == 0)
    return(RSA_SIG_PARAMS_MISSING);			// invalid size

  if(mode == 0)						// generate option
  {
    if((rsa->PrivExp == NULL) ||			// no pointer
       (rsa->PrivExp->UsedSize == 0))		  	// no private exp.
      return(RSA_SIG_PARAMS_MISSING);
    if(pSignatureLen[0] < ModulusLen)
      return(RSA_SIG_DSTBUF_TOO_SMALL);
  }
  else							// verify option
  {
    if((rsa->PubExp == NULL) ||				// no pointer
       (rsa->PubExp->UsedSize == 0))		   	// no public exp.
      return(RSA_SIG_PARAMS_MISSING);
    i = pSignatureLen[0];				// get total length
    if(SignatureBuf[SignatBufOffset] == 0)		// leading zero case !
      i--;
    if(i > ModulusLen)
      return(RSA_SIG_INVALID_SIGNATURE_LEN);
  }
  //-----------------------------------------------------------
  // Allocate temporary buffer for signature generation:
  // length =   ASN1 headers   (max. 18 Bytes for MD2/MD5)
  //          + Digest Buffer  (max. 20 Bytes for SHA1)
  //-----------------------------------------------------------
  if((TmpBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF, RSA_MAX_SIGN_HDR_LEN +
			  RSA_MAX_DIGEST_LEN)) == NULL)
    return(RSA_SIG_TMP_ALLOC_ERR);
  //-----------------------------------------------------------
  // If Verify Mode requested, allocate Decrypted Signature
  // buffer of modulus length
  //-----------------------------------------------------------
  if(mode != 0)					// verify mode
  {
    if((TmpSignatBuf = BIT8_ARRAY_ALLOC(HMEM_CTX_REF,ModulusLen)) == NULL)
    {
      FREE_CARRAY(HMEM_CTX_REF,TmpBuf);		// free other buffer
      return(RSA_SIG_TMP_ALLOC_ERR);
    }
  }
  //-----------------------------------------------------------
  // set specific data according to the requested Message Digest,
  // generate the message digest
  //-----------------------------------------------------------
  switch(DigestType)
  {
    //---------------------------------------------------------
    // MD2 Digest requested, generate
    //---------------------------------------------------------
    case MD2_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set MD2 Algorithm ID
      //-------------------------------------------------------
      memcpy(TmpBuf,RSA_Def_MD_Sign_Hdr,RSA_DEF_MD_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_MD_HDR_ALG_ID_IND] =	// insert Algor-ID (PKCS1)
         MD2_WITH_RSA_ALGOR_ID_BYTE;

      EncodedDigestLen = RSA_DEF_MD_SIGN_HDR_LEN+ // set Encoded total length
			 MD5_DIGEST_LEN;
      //-------------------------------------------------------
      // generate MD2 Message Digest
      //-------------------------------------------------------
      MD2_Init(DigestState);			// initialize State Array
							// generate Digest
      MD2_Update(DigestState,MessageBuf,
                 MsgBufOffset,MessageLen);
							// store the digest
      MD2_Final(DigestState,TmpBuf,
		RSA_DEF_MD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // MD5 Digest requested, generate
    //---------------------------------------------------------
    case MD5_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set MD5 Algorithm ID
      //-------------------------------------------------------
      memcpy(TmpBuf,RSA_Def_MD_Sign_Hdr,RSA_DEF_MD_SIGN_HDR_LEN);

      TmpBuf[RSA_DEF_MD_HDR_ALG_ID_IND] =	// insert Algor-ID (PKCS1)
         MD5_WITH_RSA_ALGOR_ID_BYTE;

      EncodedDigestLen = RSA_DEF_MD_SIGN_HDR_LEN+ // set Encoded total length
			 MD5_DIGEST_LEN;
      //-------------------------------------------------------
      // generate MD5 Message Digest
      //-------------------------------------------------------
      MD5_Init(DigestState);			// initialize State Array
							// generate Digest
      MD5_Update(DigestState,MessageBuf,
                 MsgBufOffset,MessageLen);
							// store the digest
      MD5_Final(DigestState,TmpBuf,
		RSA_DEF_MD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // SHA1 Digest requested, generate
    //---------------------------------------------------------
    case SHA1_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set compare data length
      //-------------------------------------------------------
      memcpy(TmpBuf,RSA_Def_SHA_Sign_Hdr,RSA_DEF_SHA_SIGN_HDR_LEN);

      EncodedDigestLen = RSA_DEF_SHA_SIGN_HDR_LEN+ // get Encoded total length
			 SHA_DIGEST_LEN;
      //-------------------------------------------------------
      // generate SHA1 Message Digest
      //-------------------------------------------------------
      SHA1_Init(DigestState);			// initialize State Array
							// generate Digest
      SHA1_Update(DigestState,MessageBuf,
                  MsgBufOffset,MessageLen);
							// store the digest
      SHA1_Final(DigestState,TmpBuf,
		 RSA_DEF_SHA_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // RIPEMD160 Digest requested, generate
    //---------------------------------------------------------
    case RIPEMD160_WITH_RSA_ALGOR:
      //-------------------------------------------------------
      // preload the Digest Header data, set compare data length
      //-------------------------------------------------------
      memcpy(TmpBuf,RSA_Def_RIPEMD_Sign_Hdr,RSA_DEF_RIPEMD_SIGN_HDR_LEN);

      EncodedDigestLen = RSA_DEF_RIPEMD_SIGN_HDR_LEN+ // get Encoded total length
			 RMD160_DIGEST_LEN;
      //-------------------------------------------------------
      // generate RIPEMD160 Message Digest
      //-------------------------------------------------------
      RMD160_Init(DigestState);			// initialize State Array
							// generate Digest
      RMD160_Update(DigestState,MessageBuf,
                  MsgBufOffset,MessageLen);
							// store the digest
      RMD160_Final(DigestState,TmpBuf,
		   RSA_DEF_RIPEMD_SIGN_HDR_LEN);
      break;
    //---------------------------------------------------------
    // unknown digest type
    //---------------------------------------------------------
    default:
      FREE_CARRAY(HMEM_CTX_REF,TmpBuf);
      FREE_CARRAY(HMEM_CTX_REF,TmpSignatBuf);
      return(RSA_SIG_UNKNOWN_ALGOR_TYPE);		// should not happen
  } // switch
  //===========================================================
  // Distribute according to generate/verify mode
  //===========================================================
  if(mode == 0)					// generate
  {
    //---------------------------------------------------------
    // RSA-encrypt the Encoded Message Digest and store it to user
    //---------------------------------------------------------
    RetCode = RSA_PrivateEncrypt(HMEM_CTX_REF1
				 TmpBuf,EncodedDigestLen,
			         SignatureBuf,SignatBufOffset,
				 pSignatureLen,rsa,0);
#ifdef __HIGH_SECURITY__
    for(i=0;i < EncodedDigestLen;i++) TmpBuf[i] = 0;	// clear encoded digest
#endif

    FREE_CARRAY(HMEM_CTX_REF,TmpBuf);			// free the buffer
    //-----------------------------------------------------------
    // Check the return-Code
    //-----------------------------------------------------------
    if(RetCode != RSA_OP_OK)
    {
#if 0
      PRINT("\n 0: Retcode: ");
      PRINT_INT(RetCode);
      PRINT("\n");
#endif
      return(RSA_SIG_PRIV_ENCRYPT_ERR);
    }
    return(RetCode);
  }
  //-------------------------------------------------------------
  // Signature verify mode requested...
  //-------------------------------------------------------------
  else						// verify mode
  {
    //---------------------------------------------------------
    // RSA-decrypt the Encoded Message Digest and store it temporary
    //---------------------------------------------------------
    DecodedDigestLen = ModulusLen;		// set DstBuf-Size

    RetCode = RSA_PublicDecryptEx(HMEM_CTX_REF1
				  pSignatureLen[0],SignatureBuf,
				  SignatBufOffset,
				  TmpSignatBuf,
				  &DecodedDigestLen,
				  rsa,Flags);
    if(RetCode != RSA_OP_OK)				// decryption error
    {
#if 0
      PRINT("\n 1: Retcode: ");
      PRINT_INT(RetCode);
      PRINT(" ModulusLen: ");
      PRINT_INT(ModulusLen);
      PRINT("\nSignature: ");
//    OpenFile();
      ShowHexString(SignatureBuf,ModulusLen);
      PRINT("\nModulus: ");
      ShowLnum(rsa->Modul);
      ShowLnum(rsa->PubExp);
//    CloseFile();
      PRINT("\n");
#endif
      RetCode = RSA_SIG_PUBLIC_DECRYPT_ERR;	// set correct ret-code
    }
    else
    {
      //---------------------------------------------------------
      // Compare the decrypted, encoded message signature to the
      // self generated encoded signature (Note: due to restricted
      // BER encoding [i.e. DER encoding] values must match 1:1,
      // but a leading ZERO byte is also accepted !)
      //---------------------------------------------------------
      RetCode =	RSA_SIG_VERIFY_FAILURE;			// assume compare error
      if(DecodedDigestLen == EncodedDigestLen)		// same length
      {
        for(i=0;i<(int)DecodedDigestLen;i++)		// do compare
        {
          if(TmpSignatBuf[i] != TmpBuf[i]) break;	// compare error
        }
        if(i >= (int) DecodedDigestLen)			// o.k.
          RetCode = RSA_OP_OK;				// Verify o.k
      }
    }
#ifdef __HIGH_SECURITY__
    for(i=0;i < EncodedDigestLen;i++) TmpBuf[i] = 0;	// clear encoded digest
    for(i=0;i < ModulusLen;i++) TmpSignatBuf[i] = 0;	// dto.
#endif

    FREE_CARRAY(HMEM_CTX_REF,TmpBuf);			// free the buffer
    FREE_CARRAY(HMEM_CTX_REF,TmpSignatBuf);			// dto.

    return(RetCode);
  } // else Verify case
}
//=====================================================================
// UP RSA_sign generates/verifies a PKCS1 conforming signature from a
// given message/signature.
// --- Wrapper to RSA_signEx ---
//
// 1.  Generate Digest from Message (MD2, MD5, SHA1, RIPEMD160)
// 2a. Encode Digest into an ASN.1 DER encoded octet string
// 2b. Prepend octet string with ASN.1 DER encoded Algorithm Identifier
// 2c. Encapsulate the whole as an ASN.1 Sequence
//
// Generate Mode:
// 3.  RSA-Encrypt this ASN.1 sequence with the given private key
//     and stores the encrypted signature, sets the true signature length
//     if the signature has the MSB bit set, inserts leading zero byte
//     -- no longer a zero inserted as will be encoded as Bitstring !!
//
//     Note: The Signature Buffer must be at least as long as the
//     ----- RSA Encryption Modulus + 1 !!!
//
// Verify Mode:
// 3. RSA-Decrypts the given signature with the given public key
//    The given signature may have a leading Zero byte.
// 4. Compares the decrypted given signature to the DER encoded
//    own digest
//    Note: The Signature Size must be less or same as the
//    ----- RSA Encryption Modulus !!!
//
//
// Input parameters  :	int     DigestType	Type of message Digest to use:
//						0 - MD2, 1 - MD5, 2 - SHA1,
//						3 - RIPEMD160
//			char *  MessageBuf	Pointer to message buffer
//			int	MsgBufOffset	Start-Index into buffer
//			int     MessageLen	Length of Message beginning at
//						Start-Index
//			char *  SignatureBuf	Pointer to signature buffer
//			int	SignatBufOffset	Start-Index into buffer
//			int *   pSignatureLen	Generate-Mode:
//						length of signature buffer,
//						will be updated to true length
//						Verify-Mode:
//						length of given Signature
//			RSA_STRUC * rsa		RSA-Structure with modulus,
//					        public exp., etc.
//			int	mode		type of requested operation:
//						0 - generate signature
//						<> 0 - verify given signature
//
// Returns:		int Status		0 - o.k.
//						<> 0 : Error occured:
//						RSA_SIG_PARAMS_MISSING
//						RSA_SIG_TOO_SMALL_SIGNATURE_BUF
//						RSA_SIG_INVALID_SIGNATURE_LEN
//						RSA_SIG_TMP_ALLOC_FAILED
//						RSA_SIG_UNKNOWN_ALGOR_TYPE
//						RSA_SIG_ENCRYPT_DECRYPT_FAILED
//						RSA_SIG_VERIFY_FAILURE
//=====================================================================
int FAST RSA_sign(HMEM_CTX_DEF
	  int DigestType,
	  char * MessageBuf,   int MsgBufOffset,     int MessageLen,
	  char * SignatureBuf, int SignatBufOffset,  int * pSignatureLen,
	  RSA_STRUC * rsa, int mode)
{
  return(RSA_signEx(HMEM_CTX_REF1
                    DigestType, MessageBuf, MsgBufOffset, MessageLen,
	            SignatureBuf, SignatBufOffset, pSignatureLen,
		    rsa, mode, 0));
}
//===========================================================================
// Subroutine RSA_GenKey generates RSA key pair
//
// Input Parameters :	int	bits			Number of Modulus bits
//			iint	e_value			Public Exponent to use
//			void (*callback) (int)		Callback function,
//							only used for C !!
// Returns: RSA_PTR	Pointer to RSA structure/NULL
//============================================================================
RSA_STRUC * FAST RSA_GenKey(HMEM_CTX_DEF int bits, int e_value,
              		  	      void (*callback)(int))
{
  int retcode = LNUM_OP_OK;

  WLNUM * r0  = NULL;
  WLNUM * r1  = NULL;
  WLNUM * r2  = NULL;
  WLNUM * tmp;


//  int n=0;

  int elementcnt;
  int pelementcnt;
  int qelementcnt;

  int pbits,qbits;
  int shiftcnt,dbitcnt;

  RSA_STRUC * rsa = NULL;

  for(;;)					// error loop
  {
    //-------------------------------------------------------------
    // Allocate number structures
    //-------------------------------------------------------------
    elementcnt = (((bits+1)/2) + 32-1)/32 + 1;
    r0 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    r1 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    r2 = AllocNewWLnum(HMEM_CTX_REF1 elementcnt);
    if((r0 == NULL) || (r1 == NULL) || (r2 == NULL))
    {
      retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //-------------------------------------------------------------
    // get bits for p and q and element counts
    //-------------------------------------------------------------
    pbits = (bits + 1)/2;			// p bitcount
    qbits = bits - pbits;			// q bitcount
    pelementcnt = (((pbits+1)/2) + 32-1)/32 + 1;
    qelementcnt = (((qbits+1)/2) + 32-1)/32 + 1;
    shiftcnt = pbits - 100;			// upper 100 bits test shift
    if(shiftcnt < 0)
      shiftcnt = 0;
    dbitcnt = (bits + 1) / 2;			// d size test bitcount
    //-------------------------------------------------------------
    // allocate RSA-Structure and number structures
    //-------------------------------------------------------------
    rsa = RSA_New(HMEM_CTX_REF1 elementcnt,
		  4,
		  elementcnt,
	          pelementcnt,
		  qelementcnt);			// size of prime q
    if (rsa == NULL)
    {
      retcode = LNUM_OP_ALLOC_ERR;		// allocation error
      break;
    }
    //---------------------------------------------------------
    // store value e into the RSA-Structure
    //---------------------------------------------------------
    rsa->PubExp->lpEl[0] = e_value;
    rsa->PubExp->UsedSize = 1;				// set size
    //---------------------------------------------------------
    // generate p and q, retry loop
    //---------------------------------------------------------
    for(;;)
    {
      //----------------------------------------------------------
      // generate Prime p
      //----------------------------------------------------------
      for (;;)
      {
        retcode = GenPrimeWLnum(HMEM_CTX_REF1
			rsa->Prime_p,pbits,0,0,RSA_STRONG_PRIMES,
			NULL,callback);
        if(retcode != LNUM_OP_OK)
        {
// TEST TEST
          printf("Failed to generate Prime number, RC=%d\n",retcode);
          break;
        }
        //-----------------------------------------------------------
        // check GCD(p-1,e) = 1 (as GCD((p-1)*(q-1),e) = 1 must hold)
        //-----------------------------------------------------------
							// copy number
        if((retcode = CopyWLnum(HMEM_CTX_REF1
			r2,rsa->Prime_p)) != LNUM_OP_OK)
          break;
							// r2 = p - 1
        if((retcode = SubElementWLnum(r2,(int)1)) != LNUM_OP_OK)
          break;

							// r1 = ggT(e,p-1)
        if((retcode = GcdWLnum(HMEM_CTX_REF1
			r1,r2,rsa->PubExp)) != LNUM_OP_OK)
          break;

        if(IsOneWLnum(r1) != 0)				// no common divisor
          break;
        //--------------------------------------------------------
        // prime p is not usable, get other one
        //--------------------------------------------------------
        if (callback != NULL)
          callback(3);					// not usable prime
      }
      if(retcode != LNUM_OP_OK)				// error occured...
        break;
      if(callback != NULL)
        callback(4);					// found first prime
      //----------------------------------------------------------
      // generate Prime q
      //----------------------------------------------------------
      for (;;)
      {
        retcode = GenPrimeWLnum(HMEM_CTX_REF1
			rsa->Prime_q,qbits,0,0,RSA_STRONG_PRIMES,
			NULL,callback);
        if(retcode != LNUM_OP_OK)
          break;
        //-----------------------------------------------------------
        // check GCD(q-1,e) = 1 (as GCD((p-1)*(q-1),e) = 1 must hold)
        //-----------------------------------------------------------
							// copy number
        if((retcode = CopyWLnum(HMEM_CTX_REF1
				r2,rsa->Prime_q)) != LNUM_OP_OK)
          break;

							// r2 = q - 1
        if((retcode = SubElementWLnum(r2,(int)1)) != LNUM_OP_OK)
          break;
							// r1 = ggT(e,q-1)
        if((retcode = GcdWLnum(HMEM_CTX_REF1
			r1,r2,rsa->PubExp)) != LNUM_OP_OK)
          break;
        //--------------------------------------------------------
        // GCD(q-1,e) = 1, check if same prime as p
        //--------------------------------------------------------
        if(IsOneWLnum(r1) != 0)				// no common divisor
        {
          if(UcompWLnum(rsa->Prime_p, rsa->Prime_q) !=
             WLNUM_1ST_EQ_2ND) break;			// o.k.
        }
        //--------------------------------------------------------
        // prime q is not usable, get other one
        //--------------------------------------------------------
        if(callback != NULL)
          callback(3);					// not usable prime
      }
      if(retcode != LNUM_OP_OK) break;			// error occured...
      if(callback != NULL)
        callback(5);					// found 2nd prime
      //----------------------------------------------------------
      // if p < q we must exchange p and q
      //----------------------------------------------------------
      if(UcompWLnum(rsa->Prime_p, rsa->Prime_q) ==
         WLNUM_1ST_LT_2ND)					// p < q
      {
        tmp = rsa->Prime_p;				// exchange p,q
        rsa->Prime_p = rsa->Prime_q;
        rsa->Prime_q = tmp;
      }
      //----------------------------------------------------------
      // check if p and q differ in the upper 100 bits
      //----------------------------------------------------------
      if((retcode = SubWLnum(HMEM_CTX_REF1 r0,
			     rsa->Prime_p,rsa->Prime_q)) != LNUM_OP_OK)
        break;
      if((retcode = RshiftWLnum(HMEM_CTX_REF1
				  r1,r0,shiftcnt)) != LNUM_OP_OK)
        break;

      if(IsZeroWLnum(r1) != 0)			// same upper 100 bits!
      {
        if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      //----------------------------------------------------------
      // calculate n = p * q  and
      // d = e **(-1) mod ((p-1)*(q-1)), d mod (p-1), d mod (q-1)
      //----------------------------------------------------------
      if((retcode = MulWLnum(HMEM_CTX_REF1
			rsa->Modul,rsa->Prime_p,
	                rsa->Prime_q)) != LNUM_OP_OK)
        break;


      // calculate d
							// copy number
      if((retcode = CopyWLnum(HMEM_CTX_REF1
			r1,rsa->Prime_p)) != LNUM_OP_OK)
        break;
							// r1 = p - 1
      if((retcode = SubElementWLnum(r1,(char)1)) != LNUM_OP_OK)
        break;

							// copy number
      if((retcode = CopyWLnum(HMEM_CTX_REF1
			r2,rsa->Prime_q)) != LNUM_OP_OK)
        break;

							// r2 = q - 1
      if((retcode = SubElementWLnum(r2,(char)1)) != LNUM_OP_OK)
        break;

							// r0 = (p-1)*(q-1)
      if((retcode = MulWLnum(HMEM_CTX_REF1 r0,r1,r2)) != LNUM_OP_OK)
        break;

							// d
      if((retcode = InvModWLnum(HMEM_CTX_REF1
		rsa->PrivExp, rsa->PubExp,r0,NULL)) != LNUM_OP_OK)
        break;
      //--------------------------------------------------------------------
      // Assert (2^nlen/2) < d < LCM(p-1,q-1)  and  1 = de mod(LCM(p-1,q-1))
      //--------------------------------------------------------------------
      if(GetBitCntWLnum(rsa->PrivExp) < dbitcnt)
      {
        if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      // r0 = LCM((p-1),(q-1))
      if((retcode = m_lcm_wlnum(HMEM_CTX_REF1 r0,r1,r2)) != LNUM_OP_OK)
         break;

      if(UcompWLnum(rsa->PrivExp, r0) != WLNUM_1ST_LT_2ND)
      {
         if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      // assert 1 = de mod(LCM(p-1,q-1))
      if((retcode = MulModWLnum(HMEM_CTX_REF1 r1, rsa->PubExp,
         rsa->PrivExp,r0,NULL)) != LNUM_OP_OK)
        break;

      if(IsOneWLnum(r1) == 0)
      {
         if(callback != NULL)
          callback(6);					// not usable prime
        continue;				// get another p,q pair!!
      }
      break; // retry FOR p,q search
    }
    if(retcode != LNUM_OP_OK)
      break;
						    // calculate d mod (p-1)

    if((retcode = DivWLnum(HMEM_CTX_REF1
	    NULL,rsa->Dmodpm1,rsa->PrivExp,r1,NULL)) != LNUM_OP_OK)
      break;

						    // calculate d mod (q-1)

    if((retcode = DivWLnum(HMEM_CTX_REF1
	    NULL,rsa->Dmodqm1,rsa->PrivExp,r2,NULL)) != LNUM_OP_OK)
      break;

					    // calculate inverse of q mod p

    retcode = InvModWLnum(HMEM_CTX_REF1
		rsa->Invqmp,rsa->Prime_q, rsa->Prime_p,NULL);
//    if(retcode != LNUM_OP_OK) break;		// not required, break follows
    break;
  } // error FOR loop

  if(retcode != LNUM_OP_OK)
  {
#ifdef _TEST_
    PRINT("\nKeyGen Failure, Returncode: ");
    PRINT_INT(retcode);
#endif
    RSA_Free(HMEM_CTX_REF1 rsa);
    rsa = NULL;
  }
  //----------------------------------------------------------
  // Output the prime numbers and parameters (for Test Purposes only)
  //----------------------------------------------------------
#ifdef _TEST_
  if(retcode == LNUM_OP_OK)
  {
    printf("\n Prime   p: ");
    ShowLnum(rsa->Prime_p);

    printf("\n Prime   q: ");
    ShowLnum(rsa->Prime_q);

    printf("\n Modulus n: ");
    ShowLnum(rsa->Modul);

    printf("\n PubExp  e: ");
    ShowLnum(rsa->PubExp);

    printf("\n R0      r: ");
    ShowLnum(r0);

    printf("\n PrivExp d: ");
    ShowLnum(rsa->PrivExp);
  }
#endif

  FreeWLnum(HMEM_CTX_REF1 r0);
  FreeWLnum(HMEM_CTX_REF1 r1);
  FreeWLnum(HMEM_CTX_REF1 r2);
  return(rsa);
}
//================================================================
// Perform RSA Exponentation (either public or private exponent)
// NOTE: 1. All numeric data must be specified in BIG endian format !
// ----- 2. Destination buffer must have at least same size as the rsa
//	    modulus n !
//
// Input parameters:	unsigned char * aby_rsa_data	  plain/ciphertext (IN)
//			int	        i_rsa_data_len	  length in byte
//			unsigned char * aby_rsa_exp	  exponent e or d
//			int 		i_rsa_exp_len	  length of exponent
//			unsigned char * aby_rsa_modulus	  modulus n
//			int		i_rsa_modulus_len length of modulus
//			unsigned char * aby_dst_buf	  buffer for result
//			int *		ai_dst_len	  IN: buffer size
//							  OUT: bytes used
// Returns: int status - 0 o.k., else error occured
//================================================================
int FAST rsa_crypt_raw(HMEM_CTX_DEF
	unsigned char * aby_rsa_data, int i_rsa_data_len,
	unsigned char * aby_rsa_exp,  int i_rsa_exp_len,
	unsigned char * aby_rsa_modulus, int i_rsa_modulus_len,
	unsigned char * aby_dst_buf, int * ai_dst_len)
{
  int i_retcode;
  int i_rsa_lnum_elements;
  int i_dst_buf_len;

  WLNUM * ds_lnum_data;				// Plain/Ciphertext (in)
  WLNUM * ds_lnum_exp;				// Exponent e/d
  WLNUM * ds_lnum_modulus;			// Modulus n
  WLNUM * ds_lnum_result;			// Cipher/Plaintext (out)

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((aby_rsa_data == NULL) || (aby_rsa_exp == NULL) ||
     (aby_rsa_modulus == NULL) || (ai_dst_len == NULL))
    return(LNUM_OP_NULL_PTR);

  i_dst_buf_len = ai_dst_len[0];

  if((i_rsa_modulus_len <= 0) || (i_rsa_data_len <= 0) ||
     (i_rsa_exp_len <= 0) || (i_dst_buf_len <= 0))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((i_rsa_data_len > i_rsa_modulus_len) ||
     (i_rsa_exp_len > i_rsa_modulus_len) ||
     (i_dst_buf_len < i_rsa_modulus_len))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  i_rsa_lnum_elements = ((i_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    ds_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 i_rsa_lnum_elements);
    ds_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 i_rsa_lnum_elements);
    ds_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 i_rsa_lnum_elements);
    ds_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 i_rsa_lnum_elements);
    if((ds_lnum_data == NULL) || (ds_lnum_exp == NULL) ||
       (ds_lnum_modulus == NULL) || (ds_lnum_result == NULL))
    {
      i_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((i_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  ds_lnum_data,
          (char *) aby_rsa_data,0,i_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((i_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  ds_lnum_exp,
          (char *) aby_rsa_exp,0,i_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((i_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
          ds_lnum_modulus,
          (char *) aby_rsa_modulus,0,i_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((i_retcode = ExpModWLnum(HMEM_CTX_REF1
		      ds_lnum_result, ds_lnum_data,
		      ds_lnum_exp, ds_lnum_modulus,
		      NULL,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    i_retcode = WLnum_wlnum2bin((char *) aby_dst_buf,0,ai_dst_len,
		                ds_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 ds_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 ds_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 ds_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 ds_lnum_modulus);
  if(i_retcode != 0)
  {
    ai_dst_len[0] = 0;
  }
  return(i_retcode);
}
#endif // HL_ENCR_RSA
// end of 'hobrsa.c'


#ifdef HL_ENCR_RSA
// hobrsaraw.c
//===========================================================
//
// This file implements RSA public/private encryption/decryption
// algorithm.
//
// See RSA PKCS-1 for description of algorithm.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>


//================================================================
// Perform RSA Exponentation (either public or private exponent)
// NOTE: 1. All numeric data must be specified in BIG endian format !
// ----- 2. Destination buffer must have at least same size as the rsa
//	    modulus n !
//
// Input parameters:	unsigned char * abyp_rsa_data	  plain/ciphertext (IN)
//			int	        imp_rsa_data_len  length in byte
//			unsigned char * abyp_rsa_exp	  exponent e or d
//			int 		imp_rsa_exp_len	  length of exponent
//			unsigned char * abyp_rsa_modulus  modulus n
//			int		imp_rsa_modulus_len length of modulus
//			unsigned char * abyp_dst_buf	  buffer for result
//			int *		aimp_dst_len	  IN: buffer size
//							  OUT: bytes used
// Returns: int status - 0 o.k., else error occured
//================================================================
int FAST m_rsa_crypt_raw_big(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

#if defined __INSURE__
  _Insure_checking_enable(0);
#endif

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_NULL_PTR);
  }

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_PARAM_ERR);
  }
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
  {
#if defined __INSURE__
    _Insure_checking_enable(1);
#endif
    return(LNUM_OP_PARAM_ERR);
  }
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnum(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = ExpModWLnum(HMEM_CTX_REF1
		   	   dsl_lnum_result, dsl_lnum_data,
			   dsl_lnum_exp, dsl_lnum_modulus,
			   NULL,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2bin((char *) abyp_dst_buf,0,aimp_dst_len,
		                  dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }

#if defined __INSURE__
  _Insure_checking_enable(1);
#endif
  return(iml_retcode);
}
//================================================================
// Perform RSA Exponentation (either public or private exponent)
// NOTE: 1. All numeric data must be specified in LITTLE endian format !
// ----- 2. Destination buffer must have at least same size as the rsa
//	    modulus n !
//
// Input parameters:	unsigned char * abyp_rsa_data	  plain/ciphertext (IN)
//			int	        imp_rsa_data_len  length in byte
//			unsigned char * abyp_rsa_exp	  exponent e or d
//			int 		imp_rsa_exp_len	  length of exponent
//			unsigned char * abyp_rsa_modulus  modulus n
//			int		imp_rsa_modulus_len length of modulus
//			unsigned char * abyp_dst_buf	  buffer for result
//			int *		aimp_dst_len	  IN: buffer size
//							  OUT: bytes used
// Returns: int status - 0 o.k., else error occured
//================================================================
int FAST m_rsa_crypt_raw_little(HMEM_CTX_DEF
	unsigned char * abyp_rsa_data, int imp_rsa_data_len,
	unsigned char * abyp_rsa_exp,  int imp_rsa_exp_len,
	unsigned char * abyp_rsa_modulus, int imp_rsa_modulus_len,
	unsigned char * abyp_dst_buf, int * aimp_dst_len)
{
  int iml_retcode;
  int iml_rsa_lnum_elements;
  int iml_dst_buf_len;

  WLNUM * dsl_lnum_data;			// Plain/Ciphertext (in)
  WLNUM * dsl_lnum_exp;				// Exponent e/d
  WLNUM * dsl_lnum_modulus;			// Modulus n
  WLNUM * dsl_lnum_result;			// Cipher/Plaintext (out)

  //----------------------------------------------------------
  // check parameters given first
  //----------------------------------------------------------
  if((abyp_rsa_data == NULL) || (abyp_rsa_exp == NULL) ||
     (abyp_rsa_modulus == NULL) || (aimp_dst_len == NULL))
    return(LNUM_OP_NULL_PTR);

  iml_dst_buf_len = * aimp_dst_len;

  if((imp_rsa_modulus_len <= 0) || (imp_rsa_data_len <= 0) ||
     (imp_rsa_exp_len <= 0) || (iml_dst_buf_len <= 0))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // check consistency of parameters
  //----------------------------------------------------------
  if((imp_rsa_data_len > imp_rsa_modulus_len) ||
     (imp_rsa_exp_len > imp_rsa_modulus_len) ||
     (iml_dst_buf_len < imp_rsa_modulus_len))
    return(LNUM_OP_PARAM_ERR);
  //----------------------------------------------------------
  // Allocate needed large numbers for calculation
  //----------------------------------------------------------
  iml_rsa_lnum_elements = ((imp_rsa_modulus_len + 3) / 4) + 1;

  for(;;)	// error FOR
  {
    dsl_lnum_data    = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_exp     = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_modulus = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    dsl_lnum_result  = AllocNewWLnum(HMEM_CTX_REF1 iml_rsa_lnum_elements);
    if((dsl_lnum_data == NULL) || (dsl_lnum_exp == NULL) ||
       (dsl_lnum_modulus == NULL) || (dsl_lnum_result == NULL))
    {
      iml_retcode = LNUM_OP_ALLOC_ERR;
      break;
    }
    //----------------------------------------------------------
    // Convert data from buffers to large number format
    //----------------------------------------------------------
    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_data,
          (char *) abyp_rsa_data,0,imp_rsa_data_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
	  dsl_lnum_exp,
          (char *) abyp_rsa_exp,0,imp_rsa_exp_len)) != LNUM_OP_OK)
      break;

    if((iml_retcode = WLnum_bin2wlnumLe(HMEM_CTX_REF1
          dsl_lnum_modulus,
          (char *) abyp_rsa_modulus,0,imp_rsa_modulus_len)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Exponentiate now ( C = P ** e mod n   /   P = C ** d mod n)
    //------------------------------------------------------------
    if((iml_retcode = ExpModWLnum(HMEM_CTX_REF1
		   	   dsl_lnum_result, dsl_lnum_data,
			   dsl_lnum_exp, dsl_lnum_modulus,
			   NULL,NULL)) != LNUM_OP_OK)
      break;
    //------------------------------------------------------------
    // Convert result large number back to byte buffer
    //------------------------------------------------------------
    iml_retcode = WLnum_wlnum2binLe((char *) abyp_dst_buf,0,aimp_dst_len,
		                    dsl_lnum_result,0);
    break;
  }
  //---------------------------------------------------------
  // Free temporary large numbers, clear private key one
  //---------------------------------------------------------
  ClearFreeWLnum(HMEM_CTX_REF1 dsl_lnum_exp);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_data);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_result);
  FreeWLnum(HMEM_CTX_REF1 dsl_lnum_modulus);
  if(iml_retcode != 0)
  {
    * aimp_dst_len = 0;
  }
  return(iml_retcode);
}
#endif // HL_ENCR_RSA
// end of 'hobrsaraw.c'


#ifdef HL_ENCR_SHA
// hobsha1.c
//===========================================================
//
// This file implements the SHA-1 message digest (hash) algorithm.
// See US-Standard FIPS PUB 180-1 for description.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <memory.h>

//------------------------------------------------
// Macros
//------------------------------------------------
// from bytes to long

#define BIGchar2long(c,l,i) \
  {\
    l = ((int)  c[i+3] & 0x0FF) | \
        (((int)  c[i+2] & 0x0FF)  <<  8) | \
        (((int)  c[i+1] & 0x0FF)  << 16) | \
        (((int)  c[i]   & 0x0FF)  << 24);\
        i +=4; \
  }

// the same as above, but no pointer increment
#define BIGchar2longn(c,l,i) \
  {\
    l = ((int)  c[i+3] & 0x0FF) | \
        (((int)  c[i+2] & 0x0FF)  <<  8) | \
        (((int)  c[i+1] & 0x0FF)  << 16) | \
        (((int)  c[i]   & 0x0FF)  << 24); \
  }

#define BIGchar2longc(c,l,n,i)\
{ \
  switch (n)\
  { \
    case 0: \
      l =  ((int) c[i++] & 0x0FF)  << 24; \
    case 1: \
      l |= ((int) c[i++] & 0x0FF)  << 16; \
    case 2: \
      l |= ((int) c[i++] & 0x0FF)  <<  8;\
    case 3: \
      l |= ((int) c[i++] & 0x0FF);\
  } \
}


// the same as above, but no pointer is used !!
#define BIGchar2longcn(c,l,n)\
{ \
  switch (n)\
  { \
    case 0: \
      l = ((int)   c[3] & 0x0FF) | \
          (((int)  c[2] & 0x0FF)  <<  8) | \
          (((int)  c[1] & 0x0FF)  << 16) | \
          (((int)  c[0] & 0x0FF)  << 24); \
      break;\
    case 1: \
      l |=((int)   c[2] & 0x0FF) |\
          (((int)  c[1] & 0x0FF)  <<  8) |\
          (((int)  c[0] & 0x0FF)  << 16); \
      break;\
    case 2: \
      l |=((int)   c[1] & 0x0FF) |\
          (((int)  c[0] & 0x0FF)  <<  8);\
      break;\
    case 3: \
      l |=((int)  c[0] & 0x0FF);\
      break;\
  } \
}


#define BIGchar2long3n(c,l,n,i)\
{ \
  l = 0; \
  switch (n)\
  { \
    case 3: \
      l  = ((int) c[i+2] & 0x0FF)  <<  8; \
    case 2: \
      l |= ((int) c[i+1] & 0x0FF)  << 16; \
    case 1: \
      l |= ((int) c[i]   & 0x0FF)  << 24; \
      break;\
  } \
}


#define BIGlong2charn(l,c,i) c[i+3] = (char) (l       & 0x0FF);\
                             c[i+2] = (char) ((l>> 8) & 0x0FF);\
                             c[i+1] = (char) ((l>>16) & 0x0FF);\
                             c[i]   = (char) ((l>>24) & 0x0FF);


//------------------------------------------------
// State structure definitions
//------------------------------------------------
#define SHA_CBLOCK	64
#define SHA_LBLOCK	16
#define SHA_BLOCK	16
#define SHA_LAST_BLOCK  56
#define SHA_LENGTH_BLOCK 8
//#define SHA_DIGEST_LEN	20

#if 0
// NOTE NOTE NOTE: Do NOT Change the following offsets, or the
// --------------- SHA-1 macros below will not work any longer !!!
#endif // 0

#define	SHA_data	0			// Array offset 0
#define	SHA_h0		(SHA_data+SHA_BLOCK)	// Array offset + n
#define	SHA_h1		(SHA_data+SHA_BLOCK+1)	// Array offset + n+1
#define	SHA_h2		(SHA_data+SHA_BLOCK+2)	// Array offset + n+2
#define	SHA_h3		(SHA_data+SHA_BLOCK+3)	// Array offset + n+3
#define	SHA_h4		(SHA_data+SHA_BLOCK+4)	// Array offset + n+4
#define	SHA_Nl		(SHA_data+SHA_BLOCK+5)	// Array offset + n+5
#define	SHA_Nh		(SHA_data+SHA_BLOCK+6)	// Array offset + n+6
#define	SHA_num		(SHA_data+SHA_BLOCK+7)	// Array offset + n+7

//#define	SHA_ARRAY_SIZE	(SHA_num+1)		// size of array
#define SHA_ARRAY_SIZE	24		// size of state array (integers)




#define K_00_19	(unsigned int) 0x5a827999
#define K_20_39 (unsigned int) 0x6ed9eba1
#define K_40_59 (unsigned int) 0x8f1bbcdc
#define K_60_79 (unsigned int) 0xca62c1d6


#if defined WIN32 || defined WIN64	// only faster on older Pentiums ???
#define	ULROT1(l)	_lrotl(l,1)
#define	ULROT5(l)	_lrotl(l,5)
#define	URROT2(l)	_lrotl(l,30)
#elif !defined JAVA || defined CSHARP
#define	ULROT1(l) (l << 1) | ((l >> 31) & 0x01)
#define	ULROT5(l) (l << 5) + ((l >> 27) & 0x1F)
#define	URROT2(l) ((l >> 2) & 0x3FFFFFFF) | (l << 30)
#else // JAVA only
#define	ULROT1(l) (l << 1) | (l >>> 31)
#define	ULROT5(l) (l << 5) + (l >>> 27)
#define	URROT2(l) (l >>> 2) | (l << 30)
#endif

// NOTE: we assume that base offset for SHA_Array is 0 !!

#define Xupdate(a,i) \
  a = (SHA_Array[i      & 0x0F]^SHA_Array[(i+2)  & 0x0F]^\
       SHA_Array[(i+8)  & 0x0F]^SHA_Array[(i+13) & 0x0F]);\
  SHA_Array[i & 0x0F] = a = ULROT1(a);

#define BODY_00_15(i,a,b,c,d,e,f) \
  f = SHA_Array[i] + e + K_00_19 + ULROT5(a) + (((c ^ d) & b) ^ d); \
  b = URROT2(b);

#define BODY_16_19(i,a,b,c,d,e,f) \
  Xupdate(f,i); \
  f += e + K_00_19 + ULROT5(a) + (((c ^ d) & b) ^ d); \
  b = URROT2(b);

#define BODY_20_39(i,a,b,c,d,e,f) \
  Xupdate(f,i); \
  f += e + K_20_39 + ULROT5(a) + (b^c^d); \
  b = URROT2(b);

#define BODY_40_59(i,a,b,c,d,e,f) \
  Xupdate(f,i); \
  f += e + K_40_59 + ULROT5(a) + ((b & c) | ((b | c) & d)); \
  b = URROT2(b);

#define BODY_60_79(i,a,b,c,d,e,f) \
  Xupdate(f,i); \
  f = SHA_Array[i & 0x0F]+e+ K_60_79 + ULROT5(a) + (b^c^d); \
  b = URROT2((b));


//==============================================================



#if 0
/* Implemented from SHA-1 document - The Secure Hash Algorithm */
#endif


#define INIT_DATA_h0 (unsigned int) 0x67452301
#define INIT_DATA_h1 (unsigned int) 0xefcdab89
#define INIT_DATA_h2 (unsigned int) 0x98badcfe
#define INIT_DATA_h3 (unsigned int) 0x10325476
#define INIT_DATA_h4 (unsigned int) 0xc3d2e1f0


#if 0
//---------------------------------------------------------------
// NOTE: following macro will not run on itanium / ARM !!!
// ----- when WIN64 is defined, also WIN32 will be defined !!
//---------------------------------------------------------------
#endif

#if defined WIN32 && !defined _M_IA64 && !defined WINCE
#undef BIGchar2long
#undef BIGchar2longn

#define	BIGchar2long(c,l,m) \
	l = _byteswap_ulong(*((unsigned int *) (c +m))); \
	m += 4;

#define	BIGchar2longn(c,l,m) \
	l = _byteswap_ulong(*((unsigned int *) (c +m)));
#endif



void FAST sha1_block(unsigned int * SHA_Array)
{
  unsigned int iT;
  unsigned int iA = SHA_Array[SHA_h0];
  unsigned int iB = SHA_Array[SHA_h1];
  unsigned int iC = SHA_Array[SHA_h2];
  unsigned int iD = SHA_Array[SHA_h3];
  unsigned int iE = SHA_Array[SHA_h4];


  BODY_00_15( 0,iA,iB,iC,iD,iE,iT);
  BODY_00_15( 1,iT,iA,iB,iC,iD,iE);
  BODY_00_15( 2,iE,iT,iA,iB,iC,iD);
  BODY_00_15( 3,iD,iE,iT,iA,iB,iC);
  BODY_00_15( 4,iC,iD,iE,iT,iA,iB);
  BODY_00_15( 5,iB,iC,iD,iE,iT,iA);
  BODY_00_15( 6,iA,iB,iC,iD,iE,iT);
  BODY_00_15( 7,iT,iA,iB,iC,iD,iE);
  BODY_00_15( 8,iE,iT,iA,iB,iC,iD);
  BODY_00_15( 9,iD,iE,iT,iA,iB,iC);
  BODY_00_15(10,iC,iD,iE,iT,iA,iB);
  BODY_00_15(11,iB,iC,iD,iE,iT,iA);
  BODY_00_15(12,iA,iB,iC,iD,iE,iT);
  BODY_00_15(13,iT,iA,iB,iC,iD,iE);
  BODY_00_15(14,iE,iT,iA,iB,iC,iD);
  BODY_00_15(15,iD,iE,iT,iA,iB,iC);
  BODY_16_19(16,iC,iD,iE,iT,iA,iB);
  BODY_16_19(17,iB,iC,iD,iE,iT,iA);
  BODY_16_19(18,iA,iB,iC,iD,iE,iT);
  BODY_16_19(19,iT,iA,iB,iC,iD,iE);

  BODY_20_39(20,iE,iT,iA,iB,iC,iD);
  BODY_20_39(21,iD,iE,iT,iA,iB,iC);
  BODY_20_39(22,iC,iD,iE,iT,iA,iB);
  BODY_20_39(23,iB,iC,iD,iE,iT,iA);
  BODY_20_39(24,iA,iB,iC,iD,iE,iT);
  BODY_20_39(25,iT,iA,iB,iC,iD,iE);
  BODY_20_39(26,iE,iT,iA,iB,iC,iD);
  BODY_20_39(27,iD,iE,iT,iA,iB,iC);
  BODY_20_39(28,iC,iD,iE,iT,iA,iB);
  BODY_20_39(29,iB,iC,iD,iE,iT,iA);
  BODY_20_39(30,iA,iB,iC,iD,iE,iT);
  BODY_20_39(31,iT,iA,iB,iC,iD,iE);
  BODY_20_39(32,iE,iT,iA,iB,iC,iD);
  BODY_20_39(33,iD,iE,iT,iA,iB,iC);
  BODY_20_39(34,iC,iD,iE,iT,iA,iB);
  BODY_20_39(35,iB,iC,iD,iE,iT,iA);
  BODY_20_39(36,iA,iB,iC,iD,iE,iT);
  BODY_20_39(37,iT,iA,iB,iC,iD,iE);
  BODY_20_39(38,iE,iT,iA,iB,iC,iD);
  BODY_20_39(39,iD,iE,iT,iA,iB,iC);

  BODY_40_59(40,iC,iD,iE,iT,iA,iB);
  BODY_40_59(41,iB,iC,iD,iE,iT,iA);
  BODY_40_59(42,iA,iB,iC,iD,iE,iT);
  BODY_40_59(43,iT,iA,iB,iC,iD,iE);
  BODY_40_59(44,iE,iT,iA,iB,iC,iD);
  BODY_40_59(45,iD,iE,iT,iA,iB,iC);
  BODY_40_59(46,iC,iD,iE,iT,iA,iB);
  BODY_40_59(47,iB,iC,iD,iE,iT,iA);
  BODY_40_59(48,iA,iB,iC,iD,iE,iT);
  BODY_40_59(49,iT,iA,iB,iC,iD,iE);
  BODY_40_59(50,iE,iT,iA,iB,iC,iD);
  BODY_40_59(51,iD,iE,iT,iA,iB,iC);
  BODY_40_59(52,iC,iD,iE,iT,iA,iB);
  BODY_40_59(53,iB,iC,iD,iE,iT,iA);
  BODY_40_59(54,iA,iB,iC,iD,iE,iT);
  BODY_40_59(55,iT,iA,iB,iC,iD,iE);
  BODY_40_59(56,iE,iT,iA,iB,iC,iD);
  BODY_40_59(57,iD,iE,iT,iA,iB,iC);
  BODY_40_59(58,iC,iD,iE,iT,iA,iB);
  BODY_40_59(59,iB,iC,iD,iE,iT,iA);

  BODY_60_79(60,iA,iB,iC,iD,iE,iT);
  BODY_60_79(61,iT,iA,iB,iC,iD,iE);
  BODY_60_79(62,iE,iT,iA,iB,iC,iD);
  BODY_60_79(63,iD,iE,iT,iA,iB,iC);
  BODY_60_79(64,iC,iD,iE,iT,iA,iB);
  BODY_60_79(65,iB,iC,iD,iE,iT,iA);
  BODY_60_79(66,iA,iB,iC,iD,iE,iT);
  BODY_60_79(67,iT,iA,iB,iC,iD,iE);
  BODY_60_79(68,iE,iT,iA,iB,iC,iD);
  BODY_60_79(69,iD,iE,iT,iA,iB,iC);
  BODY_60_79(70,iC,iD,iE,iT,iA,iB);
  BODY_60_79(71,iB,iC,iD,iE,iT,iA);
  BODY_60_79(72,iA,iB,iC,iD,iE,iT);
  BODY_60_79(73,iT,iA,iB,iC,iD,iE);
  BODY_60_79(74,iE,iT,iA,iB,iC,iD);
  BODY_60_79(75,iD,iE,iT,iA,iB,iC);
  BODY_60_79(76,iC,iD,iE,iT,iA,iB);
  BODY_60_79(77,iB,iC,iD,iE,iT,iA);
  BODY_60_79(78,iA,iB,iC,iD,iE,iT);
  BODY_60_79(79,iT,iA,iB,iC,iD,iE);

  SHA_Array[SHA_h0] += iE;
  SHA_Array[SHA_h1] += iT;
  SHA_Array[SHA_h2] += iA;
  SHA_Array[SHA_h3] += iB;
  SHA_Array[SHA_h4] += iC;
}

/****************************************************************/
/* Subroutine SHA1_Init, initializes Startvalues needed for	*/
/* SHA1 processing						*/
/*								*/
/* Input  Parameters:	BIT32  SHA1_Array[]	Pointer to SHA1	*/
/*						State structure	*/
/* Output Parameters:	none					*/
/*								*/
/****************************************************************/
void FAST SHA1_Init(int * SHA_Array)
{

#if defined WIN32 && defined _DEBUG
// The next added to keep INSURE happy
  memset(SHA_Array,0,SHA_ARRAY_SIZE*4);
#endif

  SHA_Array[SHA_h0]  = INIT_DATA_h0;
  SHA_Array[SHA_h1]  = INIT_DATA_h1;
  SHA_Array[SHA_h2]  = INIT_DATA_h2;
  SHA_Array[SHA_h3]  = INIT_DATA_h3;
  SHA_Array[SHA_h4]  = INIT_DATA_h4;
  SHA_Array[SHA_Nl]  = 0;
  SHA_Array[SHA_Nh]  = 0;
  SHA_Array[SHA_num] = 0;
}
//================================================================
// Subroutine SHA1_Update, processes given data to generate
// new SHA1 digest. This is done by loading the data into the
// helper buffer until an entire SHA1 block is filled and then
// processing that SHA1 block.
//
// NOTE: length of data must be <= 0x3FFFFFFF to avoid overflow
//
// Input  Parameters:	BIT32  SHA_Array[]	SHA State structure
//			BIT8   data[]		Data Buffer
//			int    offset		Start of data
//			BIT32  len		Length of data
// Returns: nothing
//
// Date:  14.10.1998, 2005/11/29
// Checked o.k.
//================================================================
void FAST SHA1_Update(int * SHA_Array, char * data, int Offset, int len)
{
  int i,j,ew,ec,sw,sc;
  unsigned int l;

  if(len == 0)				// check zero length
    return;
  //----------------------------------------------------------------
  // calulate new total B I T - length
  //----------------------------------------------------------------
  l = (unsigned int) SHA_Array[SHA_Nl];	// Save for Carry check
  SHA_Array[SHA_Nl] =			// add new length bit count
    (unsigned int) SHA_Array[SHA_Nl] + (unsigned int) (len << 3);

  if(l > (unsigned int) SHA_Array[SHA_Nl])	// had a Carry out
    SHA_Array[SHA_Nh]++;

  i = Offset;					// Data-Array StartIndex
  if(SHA_Array[SHA_num] != 0)			// check for saved data in array
  {
    //=================================================================
    // stored data in array, fill up until SHA-Block complete (16 longs)
    // or data exhausted
    //=================================================================
    sw = (int) (SHA_Array[SHA_num] >> 2);	 // full 4Byte longs
    sc = (int) (SHA_Array[SHA_num] & 0x03);	 // remaining bytes

    // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

    if((SHA_Array[SHA_num] + len) >= SHA_CBLOCK)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = SHA_Array[sw + SHA_data];	// get address of next or incomplete
      BIGchar2longc(data,l,sc,i);	// get required bytes
      SHA_Array[sw + SHA_data] = l;	// save to array
      sw++;				// to next location
      for (; sw < SHA_LBLOCK; sw++)	// continue copying full longs
      {
        BIGchar2long(data,l,i);
        SHA_Array[sw + SHA_data] = l;
      }
      len -= (SHA_CBLOCK - SHA_Array[SHA_num]);	// reduce length

      sha1_block((unsigned int *) SHA_Array);	// get digest
      SHA_Array[SHA_num] = 0;			// no data in array
    }
    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      SHA_Array[SHA_num] += len;	// remaining bytes, always < 64
      if ((sc + (int) len) < 4)		// cannot fill a full long
      {
        l = SHA_Array[sw + SHA_data];	// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((int) data[i++] & 0xFF) << 24;	// save byte
            len--;
            if(len == 0)
              break;

          case 1:					// 1 byte saved
            l |= (((int) data[i++] & 0xFF) << 16);	// insert next
            len--;
            if(len == 0)
              break;

          case 2:					// 2 byte saved
            l |= (((int) data[i++] & 0xFF) << 8);	// insert next
            len--;
            if(len == 0)
              break;

          case 3:					// 3 byte saved
            l |= ((int) data[i++] & 0xFF);		// insert next
            break;
        }
        SHA_Array[sw + SHA_data] = l;	// save incomplete long
      }
      else
      {
        ew = (int) SHA_Array[SHA_num];	// get ending byte count
        ec = ew & 0x03;			// incomplete ending byte count
        ew >>= 2;			// full longs for copy

        l = SHA_Array[sw + SHA_data];	// get saved bytes (if any)
        BIGchar2longc(data,l,sc,i);	// insert bytes or copy full long
  	SHA_Array[sw + SHA_data] = l;	// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          BIGchar2long(data,l,i);
          SHA_Array[sw + SHA_data] = l;
        }
        if(ec != 0)			// remaining bytes to copy into a long
        {
          BIGchar2long3n(data,l,ec,i);
          SHA_Array[sw + SHA_data] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= SHA_CBLOCK)		// only for full blocks
  {
    j = SHA_data;			// index to Stored data
    for(sw=(SHA_BLOCK/4);sw != 0; sw--)	// full long copy loop
    {
      BIGchar2longn(data,l,i);    SHA_Array[j]   = l;
      BIGchar2longn(data,l,(i+4));  SHA_Array[j+1] = l;
      BIGchar2longn(data,l,(i+8));  SHA_Array[j+2] = l;
      BIGchar2longn(data,l,(i+12)); SHA_Array[j+3] = l;
      i += 16;
      j += 4;
    }
    sha1_block((unsigned int *) SHA_Array);	// process Digest
    len -= SHA_CBLOCK;				// subtract blocklength
  }
  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;				// is always < SHA_BLOCK !!
  SHA_Array[SHA_num] = (int) ec;		// save remaining data bytes
  ew = ec >> 2;					// calculate full long count
  ec &= 0x03;					// get last remaining bytes

  sw = 0;					// index data field start
  for (; sw < ew; sw++)				// copy full longs if any
  {
    BIGchar2long(data,l,i);
    SHA_Array[sw + SHA_data] = l;
  }
  // next line was missing in original !!
  if(ec != 0)					// copy remaining bytes if any
  {
    BIGchar2long3n(data,l,ec,i);
    SHA_Array[sw + SHA_data] = l;
  }

}
/****************************************************************/
/* Subroutine SHA1_Final, Hashes remaining buffer data and	*/
/* appends total message bit length (low/high). Processes	*/
/* last block(s) and stores message digest			*/
// obacht: was folgt kommt von MD 5 und ist daher falsch !!!	
// muss daher neu kommentiert werden !!
/*								*/
/* NOTE: by definition of previous functions, the block buffer	*/
/* has at least one free byte (otherwise the blockbuffer would	*/
/* have been processed in the update step !!!)			*/
/*								*/
/* Two distinct cases must be considered:			*/
/*								*/
/* a: Current Block has enough space for padding and length	*/
/*    field							*/
/*    I.   Insert one-Byte padding with bit 7 <> 0 (80h)	*/
/*    II.  Fill Block with zero until Blocklength - LEN Bytes	*/
/*    III. Insert total bit-length (low/high, 8 bytes)		*/
/*    VI.  process last block, store message digest		*/
/*								*/
/* b: Last Block remaining length is > required padding and	*/
/*    size insertion length:					*/
/*    I.   Insert one-Byte padding with bit 7 <> 0 (80h)	*/
/*    II.  Fill Block with zero padding				*/
/*    III. Process block					*/
/*    IV.  Zero next Block until Blocklength - LEN Bytes	*/
/*    V.   Insert total bit-length (low/high, 8 bytes)		*/
/*    VI.  process last block, store message digest		*/
/*								*/
/*								*/
/* Input  Parameters:	BIT32 SHA_Array[]	Pointer to SHA	*/
/*						State structure	*/
/*			BIT8  Digest[]		Digest Buffer	*/
/*			int   Offset		StartIndex into	*/
/*						Digest Buffer	*/
/* Output Parameters:	none					*/
/*								*/
/* Date:  14.10.1998						*/
/* State: 16 Bit: not yet checked				*/
/*        32 Bit: not yet checked				*/
/****************************************************************/
void FAST SHA1_Final(int * SHA_Array, char * Digest, int Offset)
{
  int i,j;
  unsigned int l;

  static unsigned char end[4] = {0x80,0x00,0x00,0x00};	// padding bytes array

  /* Array data should definitly have room for at least one more byte. */

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[SHA_num];		// get stored long count
  i = j >> 2;				// get remaining byte count

  l = SHA_Array[i+SHA_data];		// get last stored long
  BIGchar2longcn(end,l,(j & 0x03));	// insert 1..4 padding bytes
  SHA_Array[i+SHA_data] = l;		// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[SHA_num] >= SHA_LAST_BLOCK)	// not enough room
  {
    for (; i<SHA_LBLOCK; i++) SHA_Array[i+SHA_data] = 0; // zero data
    sha1_block((unsigned int *) SHA_Array);	// generate digest
    i = 0;					// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<(SHA_LBLOCK-2); i++)	SHA_Array[i+SHA_data]=0; // clear

  SHA_Array[SHA_data+(SHA_LBLOCK-2)] = SHA_Array[SHA_Nh]; // set length high
  SHA_Array[SHA_data+(SHA_LBLOCK-1)] = SHA_Array[SHA_Nl]; // dto. low
  sha1_block((unsigned int *) SHA_Array);	// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[SHA_h0]; BIGlong2charn(l,Digest,Offset+0);
  l = SHA_Array[SHA_h1]; BIGlong2charn(l,Digest,Offset+4);
  l = SHA_Array[SHA_h2]; BIGlong2charn(l,Digest,Offset+8);
  l = SHA_Array[SHA_h3]; BIGlong2charn(l,Digest,Offset+12);
  l = SHA_Array[SHA_h4]; BIGlong2charn(l,Digest,Offset+16);


  memset(SHA_Array,0,sizeof(unsigned int) * SHA_ARRAY_SIZE);
}


#undef BIGchar2long
#undef BIGchar2longn
#undef BIGchar2longc
#undef BIGchar2longcn
#undef BIGchar2long3n
#undef BIGlong2charn


#undef ULROT1
#undef ULROT5
#undef URROT2
#undef Xupdate
#undef BODY_00_15
#undef BODY_16_19
#undef BODY_20_39
#undef BODY_40_59
#undef BODY_60_79
#endif // HL_ENCR_SHA
// end of 'hobsha1.c'


#ifdef HL_ENCR_SHA
// hobsha2.c
//===========================================================
//
// This file implements the SHA-256/384/512 message digest (hash)
// algorithms. See US-Standard FIPS PUB 180-2 for description.
//
//===========================================================
#include <hob-encry-1.h>
#include <stdlib.h>
#include <memory.h>

//-----------------------------------------
// Macros
//-----------------------------------------
// from bytes to long

#define BIGchar2long(c,l,i) \
  {\
    l = ((int)  c[i+3] & 0x0FF) | \
        (((int)  c[i+2] & 0x0FF)  <<  8) | \
        (((int)  c[i+1] & 0x0FF)  << 16) | \
        (((int)  c[i]   & 0x0FF)  << 24);\
        i +=4; \
  }

// the same as above, but no pointer increment
#define BIGchar2longn(c,l,i) \
  {\
    l = ((int)  c[i+3] & 0x0FF) | \
        (((int)  c[i+2] & 0x0FF)  <<  8) | \
        (((int)  c[i+1] & 0x0FF)  << 16) | \
        (((int)  c[i]   & 0x0FF)  << 24); \
  }

#define BIGchar2longc(c,l,n,i)\
{ \
  switch (n)\
  { \
    case 0: \
      l =  ((int) c[i++] & 0x0FF)  << 24; \
    case 1: \
      l |= ((int) c[i++] & 0x0FF)  << 16; \
    case 2: \
      l |= ((int) c[i++] & 0x0FF)  <<  8;\
    case 3: \
      l |= ((int) c[i++] & 0x0FF);\
  } \
}

// the same as above, but no pointer is used !!
#define BIGchar2longcn(c,l,n)\
{ \
  switch (n)\
  { \
    case 0: \
      l = ((int)   c[3] & 0x0FF) | \
          (((int)  c[2] & 0x0FF)  <<  8) | \
          (((int)  c[1] & 0x0FF)  << 16) | \
          (((int)  c[0] & 0x0FF)  << 24); \
      break;\
    case 1: \
      l |=((int)   c[2] & 0x0FF) |\
          (((int)  c[1] & 0x0FF)  <<  8) |\
          (((int)  c[0] & 0x0FF)  << 16); \
      break;\
    case 2: \
      l |=((int)   c[1] & 0x0FF) |\
          (((int)  c[0] & 0x0FF)  <<  8);\
      break;\
    case 3: \
      l |=((int)  c[0] & 0x0FF);\
      break;\
  } \
}

#define BIGchar2long3n(c,l,n,i)\
{ \
  l = 0; \
  switch (n)\
  { \
    case 3: \
      l  = ((int) c[i+2] & 0x0FF)  <<  8; \
    case 2: \
      l |= ((int) c[i+1] & 0x0FF)  << 16; \
    case 1: \
      l |= ((int) c[i]   & 0x0FF)  << 24; \
      break;\
  } \
}

#define BIGlong2charn(l,c,i) c[i+3] = (char) (l       & 0x0FF);\
                             c[i+2] = (char) ((l>> 8) & 0x0FF);\
                             c[i+1] = (char) ((l>>16) & 0x0FF);\
                             c[i]   = (char) ((l>>24) & 0x0FF);

#define char2longlong7n(c,l,n,i) \
 { \
   l = 0;\
   switch (n) \
   { \
     case 7: l=  ((long long) c[i+6] & 0x0FF) << 48;\
     case 6: l|= ((long long) c[i+5] & 0x0FF) << 40;\
     case 5: l|= ((long long) c[i+4] & 0x0FF) << 32;\
     case 4: l|= ((long long) c[i+3] & 0x0FF) << 24;\
     case 3: l|= ((long long) c[i+2] & 0x0FF) << 16;\
     case 2: l|= ((long long) c[i+1] & 0x0FF) << 8;\
     case 1: l|= ((long long) c[i]   & 0x0FF);\
   } \
}	

#define BIGchar2longlong(c,l,i) \
  {\
    l = ((long long)  c[i+7] & 0x0FF) | \
        (((long long) c[i+6] & 0x0FF)  <<  8) | \
        (((long long) c[i+5] & 0x0FF)  << 16) | \
        (((long long) c[i+4] & 0x0FF)  << 24) | \
        (((long long) c[i+3] & 0x0FF)  << 32) | \
        (((long long) c[i+2] & 0x0FF)  << 40) | \
        (((long long) c[i+1] & 0x0FF)  << 48) | \
        (((long long) c[i]   & 0x0FF)  << 56);\
        i +=8; \
  }

// the same as above, but no pointer increment

#define BIGchar2longlongn(c,l,i) \
  {\
    l = ((long long)  c[i+7] & 0x0FF) | \
        (((long long) c[i+6] & 0x0FF)  <<  8) | \
        (((long long) c[i+5] & 0x0FF)  << 16) | \
        (((long long) c[i+4] & 0x0FF)  << 24) | \
        (((long long) c[i+3] & 0x0FF)  << 32) | \
        (((long long) c[i+2] & 0x0FF)  << 40) | \
        (((long long) c[i+1] & 0x0FF)  << 48) | \
        (((long long) c[i]   & 0x0FF)  << 56);\
  }

#define BIGchar2longlongc(c,l,n,i)\
{ \
  switch (n)\
  { \
    case 0: \
      l  = ((long long) c[i++] & 0x0FF)  << 56; \
    case 1: \
      l |= ((long long) c[i++] & 0x0FF)  << 48; \
    case 2: \
      l |= ((long long) c[i++] & 0x0FF)  << 40; \
    case 3: \
      l |= ((long long) c[i++] & 0x0FF)  << 32;\
    case 4: \
      l |= ((long long) c[i++] & 0x0FF)  << 24;\
    case 5: \
      l |= ((long long) c[i++] & 0x0FF)  << 16; \
    case 6: \
      l |= ((long long) c[i++] & 0x0FF)  <<  8;\
    case 7: \
      l |= ((long long) c[i++] & 0x0FF);\
  } \
}

#define BIGchar2longlongcn(c,l,n)\
{ \
  switch (n)\
  { \
    case 0: \
      l = ((long long)  c[7] & 0x0FF) | \
          (((long long) c[6] & 0x0FF) <<  8) | \
          (((long long) c[5] & 0x0FF) << 16) | \
          (((long long) c[4] & 0x0FF) << 24) | \
          (((long long) c[3] & 0x0FF) << 32) | \
          (((long long) c[2] & 0x0FF) << 40) | \
          (((long long) c[1] & 0x0FF) << 48) | \
          (((long long) c[0] & 0x0FF) << 56); \
      break;\
    case 1: \
      l |=((long long)  c[6] & 0x0FF) | \
          (((long long) c[5] & 0x0FF) <<  8) | \
          (((long long) c[4] & 0x0FF) << 16) | \
          (((long long) c[3] & 0x0FF) << 24) | \
          (((long long) c[2] & 0x0FF) << 32) | \
          (((long long) c[1] & 0x0FF) << 40) | \
          (((long long) c[0] & 0x0FF) << 48); \
      break;\
    case 2: \
      l |=((long long)  c[5] & 0x0FF) | \
          (((long long) c[4] & 0x0FF) <<  8) | \
          (((long long) c[3] & 0x0FF) << 16) | \
          (((long long) c[2] & 0x0FF) << 24) | \
          (((long long) c[1] & 0x0FF) << 32) | \
          (((long long) c[0] & 0x0FF) << 40); \
      break;\
    case 3: \
      l |=((long long)  c[4] & 0x0FF) | \
          (((long long) c[3] & 0x0FF) <<  8) | \
          (((long long) c[2] & 0x0FF) << 16) | \
          (((long long) c[1] & 0x0FF) << 24) | \
          (((long long) c[0] & 0x0FF) << 32); \
      break;\
    case 4: \
      l |=((long long)  c[3] & 0x0FF) | \
          (((long long) c[2] & 0x0FF) <<  8) | \
          (((long long) c[1] & 0x0FF) << 16) | \
          (((long long) c[0] & 0x0FF) << 24); \
      break;\
    case 5: \
      l |=((long long)  c[2] & 0x0FF) | \
          (((long long) c[1] & 0x0FF) <<  8) | \
          (((long long) c[0] & 0x0FF) << 16); \
      break;\
    case 6: \
      l |=((long long)  c[1] & 0x0FF) | \
          (((long long) c[0] & 0x0FF) <<  8); \
      break;\
    case 7: \
      l |=((long long) c[0] & 0x0FF); \
      break;\
  } \
}

#define BIGchar2longlong7n(c,l,n,i)\
{ \
  l = 0; \
  switch (n)\
  { \
    case 7: \
      l  = ((long long) c[i+6] & 0x0FF)  <<  8; \
    case 6: \
      l |= ((long long) c[i+5] & 0x0FF)  << 16; \
    case 5: \
      l |= ((long long) c[i+4] & 0x0FF)  << 24; \
    case 4: \
      l |= ((long long) c[i+3] & 0x0FF)  << 32; \
    case 3: \
      l |= ((long long) c[i+2] & 0x0FF)  << 40; \
    case 2: \
      l |= ((long long) c[i+1] & 0x0FF)  << 48; \
    case 1: \
      l |= ((long long) c[i]   & 0x0FF)  << 56; \
      break;\
  } \
}

// from longlong to bytes

#define BIGlonglong2char(l,c,i)  c[i+7] = (char) l;\
                             c[i+6] = (char) (l>> 8);\
                             c[i+5] = (char) (l>>16);\
                             c[i+4] = (char) (l>>24);\
                             c[i+3] = (char) (l>>32);\
                             c[i+2] = (char) (l>>40);\
                             c[i+1] = (char) (l>>48);\
                             c[i]   = (char) (l>>56);\
                             i += 8;


// the same as above, but no pointer increment

#define BIGlonglong2charn(l,c,i)  c[i+7] = (char) l;\
                             c[i+6] = (char) (l>> 8);\
                             c[i+5] = (char) (l>>16);\
                             c[i+4] = (char) (l>>24);\
                             c[i+3] = (char) (l>>32);\
                             c[i+2] = (char) (l>>40);\
                             c[i+1] = (char) (l>>48);\
                             c[i]   = (char) (l>>56);

//-----------------------------------------
// Initializer Values for SHA-256/384/512
//-----------------------------------------

#define H0_SHA256	0x6a09e667
#define H1_SHA256	0xbb67ae85
#define H2_SHA256	0x3c6ef372
#define H3_SHA256	0xa54ff53a
#define H4_SHA256	0x510e527f
#define H5_SHA256	0x9b05688c
#define H6_SHA256	0x1f83d9ab
#define H7_SHA256	0x5be0cd19

#define H0_SHA384	0xcbbb9d5dc1059ed8LL
#define H1_SHA384	0x629a292a367cd507LL
#define H2_SHA384	0x9159015a3070dd17LL
#define H3_SHA384	0x152fecd8f70e5939LL
#define H4_SHA384	0x67332667ffc00b31LL
#define H5_SHA384	0x8eb44a8768581511LL
#define H6_SHA384	0xdb0c2e0d64f98fa7LL
#define H7_SHA384	0x47b5481dbefa4fa4LL

#define H0_SHA512	0x6a09e667f3bcc908LL
#define H1_SHA512	0xbb67ae8584caa73bLL
#define H2_SHA512	0x3c6ef372fe94f82bLL
#define H3_SHA512	0xa54ff53a5f1d36f1LL
#define H4_SHA512	0x510e527fade682d1LL
#define H5_SHA512	0x9b05688c2b3e6c1fLL
#define H6_SHA512	0x1f83d9abfb41bd6bLL
#define H7_SHA512	0x5be0cd19137e2179LL

//---------------------------------------
// Constants for SHA-256, 64 32-Bit words
//---------------------------------------

#define K0_SHA256	0x428a2f98
#define K1_SHA256	0x71374491
#define K2_SHA256	0xb5c0fbcf
#define K3_SHA256	0xe9b5dba5
#define K4_SHA256	0x3956c25b
#define K5_SHA256	0x59f111f1
#define K6_SHA256	0x923f82a4
#define K7_SHA256	0xab1c5ed5
#define K8_SHA256	0xd807aa98
#define K9_SHA256	0x12835b01
#define K10_SHA256	0x243185be
#define K11_SHA256	0x550c7dc3
#define K12_SHA256	0x72be5d74
#define K13_SHA256	0x80deb1fe
#define K14_SHA256	0x9bdc06a7
#define K15_SHA256	0xc19bf174
#define K16_SHA256	0xe49b69c1
#define K17_SHA256	0xefbe4786
#define K18_SHA256	0x0fc19dc6
#define K19_SHA256	0x240ca1cc
#define K20_SHA256	0x2de92c6f
#define K21_SHA256	0x4a7484aa
#define K22_SHA256	0x5cb0a9dc
#define K23_SHA256	0x76f988da
#define K24_SHA256	0x983e5152
#define K25_SHA256	0xa831c66d
#define K26_SHA256	0xb00327c8
#define K27_SHA256	0xbf597fc7
#define K28_SHA256	0xc6e00bf3
#define K29_SHA256	0xd5a79147
#define K30_SHA256	0x06ca6351
#define K31_SHA256	0x14292967
#define K32_SHA256	0x27b70a85
#define K33_SHA256	0x2e1b2138
#define K34_SHA256	0x4d2c6dfc
#define K35_SHA256	0x53380d13
#define K36_SHA256	0x650a7354
#define K37_SHA256	0x766a0abb
#define K38_SHA256	0x81c2c92e
#define K39_SHA256	0x92722c85
#define K40_SHA256	0xa2bfe8a1
#define K41_SHA256	0xa81a664b
#define K42_SHA256	0xc24b8b70
#define K43_SHA256	0xc76c51a3
#define K44_SHA256	0xd192e819
#define K45_SHA256	0xd6990624
#define K46_SHA256	0xf40e3585
#define K47_SHA256	0x106aa070
#define K48_SHA256	0x19a4c116
#define K49_SHA256	0x1e376c08
#define K50_SHA256	0x2748774c
#define K51_SHA256	0x34b0bcb5
#define K52_SHA256	0x391c0cb3
#define K53_SHA256	0x4ed8aa4a
#define K54_SHA256	0x5b9cca4f
#define K55_SHA256	0x682e6ff3
#define K56_SHA256	0x748f82ee
#define K57_SHA256	0x78a5636f
#define K58_SHA256	0x84c87814
#define K59_SHA256	0x8cc70208
#define K60_SHA256	0x90befffa
#define K61_SHA256	0xa4506ceb
#define K62_SHA256	0xbef9a3f7
#define K63_SHA256	0xc67178f2

//-------------------------------------------
// Constants for SHA-384/512, 80 64-Bit words
//-------------------------------------------

#define K0_SHA512	0x428a2f98d728ae22ULL
#define K1_SHA512	0x7137449123ef65cdULL
#define K2_SHA512	0xb5c0fbcfec4d3b2fULL
#define K3_SHA512	0xe9b5dba58189dbbcULL
#define K4_SHA512	0x3956c25bf348b538ULL
#define K5_SHA512	0x59f111f1b605d019ULL
#define K6_SHA512	0x923f82a4af194f9bULL
#define K7_SHA512	0xab1c5ed5da6d8118ULL
#define K8_SHA512	0xd807aa98a3030242ULL
#define K9_SHA512	0x12835b0145706fbeULL
#define K10_SHA512	0x243185be4ee4b28cULL
#define K11_SHA512	0x550c7dc3d5ffb4e2ULL
#define K12_SHA512	0x72be5d74f27b896fULL
#define K13_SHA512	0x80deb1fe3b1696b1ULL
#define K14_SHA512	0x9bdc06a725c71235ULL
#define K15_SHA512	0xc19bf174cf692694ULL
#define K16_SHA512	0xe49b69c19ef14ad2ULL
#define K17_SHA512	0xefbe4786384f25e3ULL
#define K18_SHA512	0x0fc19dc68b8cd5b5ULL
#define K19_SHA512	0x240ca1cc77ac9c65ULL
#define K20_SHA512	0x2de92c6f592b0275ULL
#define K21_SHA512	0x4a7484aa6ea6e483ULL
#define K22_SHA512	0x5cb0a9dcbd41fbd4ULL
#define K23_SHA512	0x76f988da831153b5ULL
#define K24_SHA512	0x983e5152ee66dfabULL
#define K25_SHA512	0xa831c66d2db43210ULL
#define K26_SHA512	0xb00327c898fb213fULL
#define K27_SHA512	0xbf597fc7beef0ee4ULL
#define K28_SHA512	0xc6e00bf33da88fc2ULL
#define K29_SHA512	0xd5a79147930aa725ULL
#define K30_SHA512	0x06ca6351e003826fULL
#define K31_SHA512	0x142929670a0e6e70ULL
#define K32_SHA512	0x27b70a8546d22ffcULL
#define K33_SHA512	0x2e1b21385c26c926ULL
#define K34_SHA512	0x4d2c6dfc5ac42aedULL
#define K35_SHA512	0x53380d139d95b3dfULL
#define K36_SHA512	0x650a73548baf63deULL
#define K37_SHA512	0x766a0abb3c77b2a8ULL
#define K38_SHA512	0x81c2c92e47edaee6ULL
#define K39_SHA512	0x92722c851482353bULL
#define K40_SHA512	0xa2bfe8a14cf10364ULL
#define K41_SHA512	0xa81a664bbc423001ULL
#define K42_SHA512	0xc24b8b70d0f89791ULL
#define K43_SHA512	0xc76c51a30654be30ULL
#define K44_SHA512	0xd192e819d6ef5218ULL
#define K45_SHA512	0xd69906245565a910ULL
#define K46_SHA512	0xf40e35855771202aULL
#define K47_SHA512	0x106aa07032bbd1b8ULL
#define K48_SHA512	0x19a4c116b8d2d0c8ULL
#define K49_SHA512	0x1e376c085141ab53ULL
#define K50_SHA512	0x2748774cdf8eeb99ULL
#define K51_SHA512	0x34b0bcb5e19b48a8ULL
#define K52_SHA512	0x391c0cb3c5c95a63ULL
#define K53_SHA512	0x4ed8aa4ae3418acbULL
#define K54_SHA512	0x5b9cca4f7763e373ULL
#define K55_SHA512	0x682e6ff3d6b2b8a3ULL
#define K56_SHA512	0x748f82ee5defb2fcULL
#define K57_SHA512	0x78a5636f43172f60ULL
#define K58_SHA512	0x84c87814a1f0ab72ULL
#define K59_SHA512	0x8cc702081a6439ecULL
#define K60_SHA512	0x90befffa23631e28ULL
#define K61_SHA512	0xa4506cebde82bde9ULL
#define K62_SHA512	0xbef9a3f7b2c67915ULL
#define K63_SHA512	0xc67178f2e372532bULL
#define K64_SHA512	0xca273eceea26619cULL
#define K65_SHA512	0xd186b8c721c0c207ULL
#define K66_SHA512	0xeada7dd6cde0eb1eULL
#define K67_SHA512	0xf57d4f7fee6ed178ULL
#define K68_SHA512	0x06f067aa72176fbaULL
#define K69_SHA512	0x0a637dc5a2c898a6ULL
#define K70_SHA512	0x113f9804bef90daeULL
#define K71_SHA512	0x1b710b35131c471bULL
#define K72_SHA512	0x28db77f523047d84ULL
#define K73_SHA512	0x32caab7b40c72493ULL
#define K74_SHA512	0x3c9ebe0a15c9bebcULL
#define K75_SHA512	0x431d67c49c100d4cULL
#define K76_SHA512	0x4cc5d4becb3e42b6ULL
#define K77_SHA512	0x597f299cfc657e2aULL
#define K78_SHA512	0x5fcb6fab3ad6faecULL
#define K79_SHA512	0x6c44198c4a475817ULL

//--------------------------------------------------
// Macros for SHA-256/384/512
//--------------------------------------------------
#define	Ch_SHA(x,y,z)	((x & y)^((~x) & z))
#define	Maj_SHA(x,y,z)	((x & y)^(x & z)^(y & z))

#define S0_256(x)	((((x>> 2) & 0x3FFFFFFF)|(x<<30))^\
			 (((x>>13) & 0x0007FFFF)|(x<<19))^\
			 (((x>>22) & 0x000003FF)|(x<<10)))
#define S1_256(x)	((((x>> 6) & 0x03FFFFFF)|(x<<26))^\
			 (((x>>11) & 0x001FFFFF)|(x<<21))^\
			 (((x>>25) & 0x0000007F)|(x<<7)))
#define s0_256(x)	((((x>> 7) & 0x01FFFFFF)|(x<<25))^\
			 (((x>>18) & 0x00003FFF)|(x<<14))^\
			 (((x>> 3) & 0x1FFFFFFF)))
#define s1_256(x)	((((x>>17) & 0x00007FFF)|(x<<15))^\
			 (((x>>19) & 0x00001FFF)|(x<<13))^\
			 (((x>>10) & 0x003FFFFF)))

#define S0_512(x)	((((x>>28) & 0x0000000FFFFFFFFFLL)|(x<<36))^\
			 (((x>>34) & 0x000000003FFFFFFFLL)|(x<<30))^\
			 (((x>>39) & 0x0000000001FFFFFFLL)|(x<<25)))
#define S1_512(x)	((((x>>14) & 0x0003FFFFFFFFFFFFLL)|(x<<50))^\
			 (((x>>18) & 0x00003FFFFFFFFFFFLL)|(x<<46))^\
			 (((x>>41) & 0x00000000007FFFFFLL)|(x<<23)))
#define s0_512(x)	((((x>> 1) & 0x7FFFFFFFFFFFFFFFLL)|(x<<63))^\
			 (((x>> 8) & 0x00FFFFFFFFFFFFFFLL)|(x<<56))^\
			 (((x>> 7) & 0x01FFFFFFFFFFFFFFLL)))
#define s1_512(x)	((((x>>19) & 0x00001FFFFFFFFFFFLL)|(x<<45))^\
			 (((x>>61) & 0x0000000000000007LL)|(x<<3))^\
			 (((x>> 6) & 0x03FFFFFFFFFFFFFFLL)))

//=================================================================



//===============================================================
// Constant arrays for SHA256 and SHA384/512 for Block operations
//===============================================================
static unsigned int Sha256Const[64] = {
  K0_SHA256,  K1_SHA256,  K2_SHA256,  K3_SHA256,
  K4_SHA256,  K5_SHA256,  K6_SHA256,  K7_SHA256,
  K8_SHA256,  K9_SHA256,  K10_SHA256, K11_SHA256,
  K12_SHA256, K13_SHA256, K14_SHA256, K15_SHA256,
  K16_SHA256, K17_SHA256, K18_SHA256, K19_SHA256,
  K20_SHA256, K21_SHA256, K22_SHA256, K23_SHA256,
  K24_SHA256, K25_SHA256, K26_SHA256, K27_SHA256,
  K28_SHA256, K29_SHA256, K30_SHA256, K31_SHA256,
  K32_SHA256, K33_SHA256, K34_SHA256, K35_SHA256,
  K36_SHA256, K37_SHA256, K38_SHA256, K39_SHA256,
  K40_SHA256, K41_SHA256, K42_SHA256, K43_SHA256,
  K44_SHA256, K45_SHA256, K46_SHA256, K47_SHA256,
  K48_SHA256, K49_SHA256, K50_SHA256, K51_SHA256,
  K52_SHA256, K53_SHA256, K54_SHA256, K55_SHA256,
  K56_SHA256, K57_SHA256, K58_SHA256, K59_SHA256,
  K60_SHA256, K61_SHA256, K62_SHA256, K63_SHA256,
};

static unsigned long long Sha512Const[80] = {
  K0_SHA512,  K1_SHA512,  K2_SHA512,  K3_SHA512,
  K4_SHA512,  K5_SHA512,  K6_SHA512,  K7_SHA512,
  K8_SHA512,  K9_SHA512,  K10_SHA512, K11_SHA512,
  K12_SHA512, K13_SHA512, K14_SHA512, K15_SHA512,
  K16_SHA512, K17_SHA512, K18_SHA512, K19_SHA512,
  K20_SHA512, K21_SHA512, K22_SHA512, K23_SHA512,
  K24_SHA512, K25_SHA512, K26_SHA512, K27_SHA512,
  K28_SHA512, K29_SHA512, K30_SHA512, K31_SHA512,
  K32_SHA512, K33_SHA512, K34_SHA512, K35_SHA512,
  K36_SHA512, K37_SHA512, K38_SHA512, K39_SHA512,
  K40_SHA512, K41_SHA512, K42_SHA512, K43_SHA512,
  K44_SHA512, K45_SHA512, K46_SHA512, K47_SHA512,
  K48_SHA512, K49_SHA512, K50_SHA512, K51_SHA512,
  K52_SHA512, K53_SHA512, K54_SHA512, K55_SHA512,
  K56_SHA512, K57_SHA512, K58_SHA512, K59_SHA512,
  K60_SHA512, K61_SHA512, K62_SHA512, K63_SHA512,
  K64_SHA512, K65_SHA512, K66_SHA512, K67_SHA512,
  K68_SHA512, K69_SHA512, K70_SHA512, K71_SHA512,
  K72_SHA512, K73_SHA512, K74_SHA512, K75_SHA512,
  K76_SHA512, K77_SHA512, K78_SHA512, K79_SHA512,
};

//================================================================
// Subroutine Sha256Block performs SHA-256 block operation
// on a filled SHA block, updates H0..H7
// NOTE: Can be unfolded if needed (much code!)
//
// Input  Parameters:	BIT32  SHA_Array[]	SHA State structure
// Returns: nothing
//================================================================
static void Sha256Block(int * ShaArray)
{
  int a = ShaArray[16+0];		// H0
  int b = ShaArray[16+1];		// H1
  int c = ShaArray[16+2];		// H2
  int d = ShaArray[16+3];		// H3
  int e = ShaArray[16+4];		// H4
  int f = ShaArray[16+5];		// H5
  int g = ShaArray[16+6];		// H6
  int h = ShaArray[16+7];		// H7

  int i;
  int T1,T2,W1,W2;

  //----------------------------------------------------------
  // Generate the SHA-256 Hash for the given Block for 0<=t<64
  //----------------------------------------------------------
  for(i=0;i<16;i++)			// 0<= t <16
  {
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 16<= t <32
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+16] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 32<= t <48
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+32] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 48<= t <64
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_256(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_256(W2) + ShaArray[i];
    T1 = h + S1_256(e) + Ch_SHA(e,f,g) + Sha256Const[i+48] + ShaArray[i];
    T2 = S0_256(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  ShaArray[16+0] += a;		// H0
  ShaArray[16+1] += b;		// H1
  ShaArray[16+2] += c;		// H2
  ShaArray[16+3] += d;		// H3
  ShaArray[16+4] += e;		// H4
  ShaArray[16+5] += f;		// H5
  ShaArray[16+6] += g;		// H6
  ShaArray[16+7] += h;		// H7
}
//======================================================
// Subroutine Sha512Block performs SHA-384/512 block operation
// on a filled SHA block, updates H0..H7
// NOTE: Can be unfolded if needed (much code!)
//
// Input  Parameters:	BIT64  SHA_Array[]	SHA State structure
// Returns: nothing
//================================================================
static void Sha512Block(long long * ShaArray)
{
  long long a = ShaArray[16+0];		// H0
  long long b = ShaArray[16+1];		// H1
  long long c = ShaArray[16+2];		// H2
  long long d = ShaArray[16+3];		// H3
  long long e = ShaArray[16+4];		// H4
  long long f = ShaArray[16+5];		// H5
  long long g = ShaArray[16+6];		// H6
  long long h = ShaArray[16+7];		// H7

  int i;
  long long T1,T2,W1,W2;

  // Generate the SHA-384/512 Hash for the given Block
  for(i=0;i<16;i++)			// 0<= t <16
  {
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 16<= t <32
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+16] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 32<= t <48
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+32] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 48<= t <64
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+48] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  for(i=0;i<16;i++)			// 64<= t <79
  {
    W1 = ShaArray[(i+14) & 0x0F];
    W2 = ShaArray[(i+1) & 0x0F];
    ShaArray[i] = s1_512(W1) + ShaArray[(i+9) & 0x0F] +
                  s0_512(W2) + ShaArray[i];
    T1 = h + S1_512(e) + Ch_SHA(e,f,g) + Sha512Const[i+64] + ShaArray[i];
    T2 = S0_512(a) + Maj_SHA(a,b,c);
    h=g;g=f;f=e;e=d+T1;d=c;c=b;b=a;a=T1+T2;
  }

  ShaArray[16+0] += a;		// H0
  ShaArray[16+1] += b;		// H1
  ShaArray[16+2] += c;		// H2
  ShaArray[16+3] += d;		// H3
  ShaArray[16+4] += e;		// H4
  ShaArray[16+5] += f;		// H5
  ShaArray[16+6] += g;		// H6
  ShaArray[16+7] += h;		// H7
}
//======================================================
// Subroutine SHA256_Init initializes hash array for
// the SHA-256 type hash
//
// Input  Parameters:	BIT32  SHA_Array[]	SHA State structure
// Returns: nothing
//================================================================
void FAST SHA256_Init(int * ShaArray)
{
  ShaArray[16+0] = H0_SHA256;
  ShaArray[16+1] = H1_SHA256;
  ShaArray[16+2] = H2_SHA256;
  ShaArray[16+3] = H3_SHA256;
  ShaArray[16+4] = H4_SHA256;
  ShaArray[16+5] = H5_SHA256;
  ShaArray[16+6] = H6_SHA256;
  ShaArray[16+7] = H7_SHA256;

  ShaArray[16+8+0] = 0;		// clear total length high word
  ShaArray[16+8+1] = 0;		// clear total length low word
  ShaArray[16+8+2] = 0;		// clear saved byte counter
}
//======================================================
// Subroutine SHA384_Init initializes hash array for
// the SHA-384 type hash
//
// Input  Parameters:	BIT64  SHA_Array[]	SHA State structure
// Returns: nothing
//================================================================
void FAST SHA384_Init(long long * ShaArray)
{
  ShaArray[16+0] = H0_SHA384;
  ShaArray[16+1] = H1_SHA384;
  ShaArray[16+2] = H2_SHA384;
  ShaArray[16+3] = H3_SHA384;
  ShaArray[16+4] = H4_SHA384;
  ShaArray[16+5] = H5_SHA384;
  ShaArray[16+6] = H6_SHA384;
  ShaArray[16+7] = H7_SHA384;

  ShaArray[16+8+0] = 0;		// clear total length high long word
  ShaArray[16+8+1] = 0;		// clear total length low long word
  ShaArray[16+8+2] = 0;		// clear saved byte counter
}
//======================================================
// Subroutine SHA512_Init initializes hash array for
// the SHA-512 type hash
//
// Input  Parameters:	BIT64  SHA_Array[]	SHA State structure
// Returns: nothing
//================================================================
void FAST SHA512_Init(long long * ShaArray)
{
  ShaArray[16+0] = H0_SHA512;
  ShaArray[16+1] = H1_SHA512;
  ShaArray[16+2] = H2_SHA512;
  ShaArray[16+3] = H3_SHA512;
  ShaArray[16+4] = H4_SHA512;
  ShaArray[16+5] = H5_SHA512;
  ShaArray[16+6] = H6_SHA512;
  ShaArray[16+7] = H7_SHA512;

  ShaArray[16+8+0] = 0;		// clear total length high long word
  ShaArray[16+8+1] = 0;		// clear total length low long word
  ShaArray[16+8+2] = 0;		// clear saved byte count
}
//================================================================
// Subroutine SHA256_Update, processes given data to generate
// new SHA-256 digest. This is done by loading the data into the
// helper buffer until an entire SHA-256 block is filled and then
// processing that block.
//
// NOTE: length of data must be <= 0x3FFFFFFF to avoid overflow
//
// Input  Parameters:	BIT32  SHA_Array[]	SHA State structure
//			BIT8   data[]		Data Buffer
//			int    offset		Start of data
//			BIT32  len		Length of data
// Returns: nothing
//
//================================================================
void FAST SHA256_Update(int * SHA_Array, char * data, int Offset, int len)
{
  int i,j,ew,ec,sw,sc;
  unsigned int l;

  if(len == 0)				// check zero length
    return;
  //----------------------------------------------------------------
  // calulate new total B I T - length
  //----------------------------------------------------------------
  l = (unsigned int) SHA_Array[25];		// Save for Carry check
  SHA_Array[25] =			// add new length bit count
    (unsigned int) SHA_Array[25] + (unsigned int) (len << 3);

  if(l > (unsigned int) SHA_Array[25])	// had a Carry out
    SHA_Array[24]++;

  i = Offset;				// Data-Array StartIndex
  if(SHA_Array[26] != 0)		// check for saved data in array
  {
    //=================================================================
    // stored data in array, fill up until SHA-Block complete (16 DWORDS)
    // or data exhausted
    //=================================================================
    sw = (int) (SHA_Array[26] >> 2);	 // number of full 4Byte DWORDS
    sc = (int) (SHA_Array[26] & 0x03);	 // remaining bytes

    // NOTE: overflow will occur above 4 GByte - 64 Byte !! (> (2**31-1) - 64)

    if((SHA_Array[26] + len) >= 64)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = SHA_Array[sw];		// get address of next or incomplete
      BIGchar2longc(data,l,sc,i);	// get required bytes
      SHA_Array[sw] = l;		// save to array
      sw++;				// to next location
      for (; sw < 16; sw++)		// continue copying full longs
      {
        BIGchar2long(data,l,i);
        SHA_Array[sw] = l;
      }
      len -= (64 - SHA_Array[26]);	// reduce length

      Sha256Block(SHA_Array);		// get digest
      SHA_Array[26] = 0;		// no data in array
    }
    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      SHA_Array[26] += len;		// remaining bytes, always < 64
      if ((sc + (int) len) < 4)		// cannot fill a full DWORD
      {
        l = SHA_Array[sw];		// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((int) data[i++] & 0x0FF) << 24;	// save byte
            len--;
            if(len == 0)
              break;

          case 1:					// 1 byte saved
            l |= (((int) data[i++] & 0x0FF) << 16);	// insert next
            len--;
            if(len == 0)
              break;

          case 2:					// 2 byte saved
            l |= (((int) data[i++] & 0x0FF) << 8);	// insert next
            len--;
            if(len == 0)
              break;

          case 3:					// 3 byte saved
            l |= ((int) data[i++] & 0x0FF);		// insert next
            break;
        }
        SHA_Array[sw] = l;		// save incomplete DWORD
      }
      else
      {
        ew = (int) SHA_Array[26];	// get ending byte count
        ec = ew & 0x03;			// incomplete ending byte count
        ew >>= 2;			// full DWORDS for copy

        l = SHA_Array[sw];		// get saved bytes (if any)
        BIGchar2longc(data,l,sc,i);	// insert bytes or copy full long
  	SHA_Array[sw] = l;		// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          BIGchar2long(data,l,i);
          SHA_Array[sw] = l;
        }
        if(ec != 0)			// remaining bytes to copy into a long
        {
          BIGchar2long3n(data,l,ec,i);
          SHA_Array[sw] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= 64)			// only for full blocks
  {
    j = 0;				// index to Stored data
    for(sw=4;sw != 0; sw--)		// full DWORD copy loop
    {
      BIGchar2longn(data,l,i);    SHA_Array[j]   = l;
      BIGchar2longn(data,l,(i+4));  SHA_Array[j+1] = l;
      BIGchar2longn(data,l,(i+8));  SHA_Array[j+2] = l;
      BIGchar2longn(data,l,(i+12)); SHA_Array[j+3] = l;
      i += 16;
      j += 4;

    }
    Sha256Block(SHA_Array);		// process Digest
    len -= 64;				// subtract blocklength
  }
  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;			// is always < SHA_BLOCK !!

  SHA_Array[26] = (int) ec;		// save remaining data byte count
  ew = ec >> 2;				// calculate full long count
  ec &= 0x03;				// get last remaining bytes

  sw = 0;				// index data field start
  for (; sw < ew; sw++)			// copy full longs if any
  {
    BIGchar2long(data,l,i);
    SHA_Array[sw] = l;
  }

  if(ec != 0)				// copy remaining bytes if any
  {
    BIGchar2long3n(data,l,ec,i);
    SHA_Array[sw] = l;
  }
}
//================================================================
// Subroutine SHA_384_512_Update, processes given data to generate
// new SHA-384/512 digest. This is done by loading the data into the
// helper buffer until an entire SHA-384/512 block is filled and then
// processing that block.
//
// Input  Parameters:	BIT64  SHA_Array[]	SHA State structure
//			BIT8   data[]		Data Buffer
//			int    offset		Start of data
//			BIT32  len		Length of data
// Returns: nothing
//
//================================================================
void FAST SHA384_512_Update(long long * SHA_Array, char * data,
			    int Offset, int len)
{
  int i,j,ew,ec,sw,sc;
  unsigned long long l;

  if(len == 0)				// check zero length
    return;
  //----------------------------------------------------------------
  // calulate new total B I T - length
  // NOTE: only LOW count is calculated, limits size to 2**61 Bytes !!
  //----------------------------------------------------------------
//  l = (unsigned long long) SHA_Array[25];	// Save for Carry check
  SHA_Array[25] =			// add new length bit count
    (unsigned long long) SHA_Array[25] + (unsigned long long) (len << 3);

//  if(l > (unsigned long long) SHA_Array[25])	// had a Carry out
//    SHA_Array[24]++;

  i = Offset;				// Data-Array StartIndex
  if(SHA_Array[26] != 0)		// check for saved data in array
  {
    //=================================================================
    // stored data in array, fill up until SHA-Block complete (16 QWORDS)
    // or data exhausted
    //=================================================================
    sw = (int) (SHA_Array[26] >> 3);	 // number of full 8Byte QWORDS
    sc = (int) (SHA_Array[26] & 0x07);	 // remaining bytes

    if((SHA_Array[26] + len) >= 128)
    {
      //---------------------------------------------------------------
      // enough data to complete array, do copy data to array,
      // generate Digest
      //---------------------------------------------------------------
      l = SHA_Array[sw];		// get address of next or incomplete
      BIGchar2longlongc(data,l,sc,i);	// get required bytes
      SHA_Array[sw] = l;		// save to array
      sw++;				// to next location
      for (; sw < 16; sw++)		// continue copying full longlongs
      {
        BIGchar2longlong(data,l,i);
        SHA_Array[sw] = l;
      }
      len -= (128 - (int) SHA_Array[26]); // reduce length

      Sha512Block(SHA_Array);		// get digest
      SHA_Array[26] = 0;		// no data in array
    }
    else
    {
      //---------------------------------------------------------------
      // not enough data to complete array, do copy data to array only
      // and exit
      //---------------------------------------------------------------
      SHA_Array[26] += len;		// remaining bytes, always < 64
      if ((sc + (int) len) < 8)		// cannot fill a full QWORD
      {
        l = SHA_Array[sw];		// get saved bytes (if any)
        switch(sc)
        {
          case 0:					// no bytes saved
            l = ((long long) data[i++] & 0x0FF) << 56;	// save byte
            len--;
            if(len == 0)
              break;

          case 1:					// 1 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 48);// insert next
            len--;
            if(len == 0)
              break;

          case 2:					// 2 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 40);// insert next
            len--;
            if(len == 0)
              break;

          case 3:					// 3 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 32);// insert next
            len--;
            if(len == 0)
              break;

          case 4:					// 4 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 24);// insert next
            len--;
            if(len == 0)
              break;

          case 5:					// 5 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 16);// insert next
            len--;
            if(len == 0)
              break;

          case 6:					// 6 byte saved
            l |= (((long long) data[i++] & 0x0FF) << 8);// insert next
            len--;
            if(len == 0)
              break;

          case 7:					// 7 byte saved
            l |= ((long long) data[i++] & 0x0FF);	// insert next
            break;
        }
        SHA_Array[sw] = l;		// save incomplete DWORD
      }
      else
      {
        ew = (int) SHA_Array[26];	// get ending byte count
        ec = ew & 0x07;			// incomplete ending byte count
        ew >>= 3;			// full QWORDS for copy

        l = SHA_Array[sw];		// get saved bytes (if any)
        BIGchar2longlongc(data,l,sc,i);	// insert bytes or copy full longlong
  	SHA_Array[sw] = l;		// save full long
        sw++;				// to next long

	for(; sw < ew; sw++)		// copy full longs
        {
          BIGchar2longlong(data,l,i);
          SHA_Array[sw] = l;
        }
        if(ec != 0)			// remaining bytes to copy into longlong
        {
          BIGchar2longlong7n(data,l,ec,i);
          SHA_Array[sw] = l;
        }
      }
      return;				// exit, wait for more data
    }
  } // end of stored data preprocessing
  //=================================================================
  // no stored data in array, start storing data until filled up
  //=================================================================
  while (len >= 128)			// only for full blocks
  {
    j = 0;				// index to Stored data
    for(sw=4;sw != 0; sw--)		// full DWORD copy loop
    {
      BIGchar2longlongn(data,l,i);      SHA_Array[j]   = l;
      BIGchar2longlongn(data,l,(i+8));  SHA_Array[j+1] = l;
      BIGchar2longlongn(data,l,(i+16)); SHA_Array[j+2] = l;
      BIGchar2longlongn(data,l,(i+24)); SHA_Array[j+3] = l;
      i += 32;
      j += 4;

    }
    Sha512Block(SHA_Array);		// process Digest
    len -= 128;				// subtract blocklength
  }


  //
  // calculate remaining longs and rest bytes/long
  //
  ec = (int) len;			// is always < SHA_BLOCK !!

  SHA_Array[26] = (int) ec;		// save remaining data byte count
  ew = ec >> 3;				// calculate full longlong count
  ec &= 0x07;				// get last remaining bytes

  sw = 0;				// index data field start
  for (; sw < ew; sw++)			// copy full longs if any
  {
    BIGchar2longlong(data,l,i);
    SHA_Array[sw] = l;
  }

  if(ec != 0)				// copy remaining bytes if any
  {
    BIGchar2longlong7n(data,l,ec,i);
    SHA_Array[sw] = l;
  }
}

//=======================================
// Padding bytes array for SHA256/384/512
//=======================================
static unsigned char end8[8] = {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

//=================================================================
// Subroutine SHA256_Final, Hashes remaining buffer data and
// appends total message bit length (low/high). Processes
// last block(s) and stores message digest
//
// Input  Parameters:	BIT32 SHA_Array[]	Pointer to SHA State structure
//			BIT8  Digest[]		Digest Buffer
//			int   Offset		StartIndex into	Digest Buffer
// Returns: nothing
//=================================================================
void FAST SHA256_Final(int * SHA_Array, char * Digest, int Offset)
{
  int i,j;
  unsigned int l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 2;				// get remaining byte count


  l = SHA_Array[i];			// get last stored DWORD
  BIGchar2longcn(end8,l,(j & 0x03));	// insert 1..4 padding bytes
  SHA_Array[i] = l;			// save full long
  i++;					// to next long (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (8 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 56)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha256Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low
  Sha256Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlong2charn(l,Digest,Offset+4);
  l = SHA_Array[18]; BIGlong2charn(l,Digest,Offset+8);
  l = SHA_Array[19]; BIGlong2charn(l,Digest,Offset+12);
  l = SHA_Array[20]; BIGlong2charn(l,Digest,Offset+16);
  l = SHA_Array[21]; BIGlong2charn(l,Digest,Offset+20);
  l = SHA_Array[22]; BIGlong2charn(l,Digest,Offset+24);
  l = SHA_Array[23]; BIGlong2charn(l,Digest,Offset+28);

  memset(SHA_Array,0,sizeof(int) * 27);
}
//=================================================================
// Subroutine SHA384_Final, Hashes remaining buffer data and
// appends total message bit length (low/high). Processes
// last block(s) and stores message digest
//
// Input  Parameters:	BIT64 SHA_Array[]	Pointer to SHA State structure
//			BIT8  Digest[]		Digest Buffer
//			int   Offset		StartIndex into	Digest Buffer
// Returns: nothing
//=================================================================
void FAST SHA384_Final(long long * SHA_Array, char * Digest, int Offset)
{
  int i,j;
  long long l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 3;				// get remaining byte count


  l = SHA_Array[i];			// get last stored QWORD
  BIGchar2longlongcn(end8,l,(j & 0x07));// insert 1..7 padding bytes
  SHA_Array[i] = l;			// save full longlong
  i++;					// to next longlong (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (16 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 112)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha512Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low

  Sha512Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlonglong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlonglong2charn(l,Digest,Offset+8);
  l = SHA_Array[18]; BIGlonglong2charn(l,Digest,Offset+16);
  l = SHA_Array[19]; BIGlonglong2charn(l,Digest,Offset+24);
  l = SHA_Array[20]; BIGlonglong2charn(l,Digest,Offset+32);
  l = SHA_Array[21]; BIGlonglong2charn(l,Digest,Offset+40);
//  l = SHA_Array[22]; BIGlonglong2charn(l,Digest,Offset+48);
//  l = SHA_Array[23]; BIGlonglong2charn(l,Digest,Offset+56);

  memset(SHA_Array,0,sizeof(long long) * 27);
}
//=================================================================
// Subroutine SHA512_Final, Hashes remaining buffer data and
// appends total message bit length (low/high). Processes
// last block(s) and stores message digest
//
// Input  Parameters:	BIT64 SHA_Array[]	Pointer to SHA State structure
//			BIT8  Digest[]		Digest Buffer
//			int   Offset		StartIndex into	Digest Buffer
// Returns: nothing
//=================================================================
void FAST SHA512_Final(long long * SHA_Array, char * Digest, int Offset)
{
  int i,j;
  long long l;

  //---------------------------------------------------------------
  // Get stored long and remaining byte counts, append padding bits
  //---------------------------------------------------------------
  j = (int) SHA_Array[26];		// get stored byte count
  i = j >> 3;				// get remaining byte count


  l = SHA_Array[i];			// get last stored QWORD
  BIGchar2longlongcn(end8,l,(j & 0x07));// insert 1..7 padding bytes
  SHA_Array[i] = l;			// save full longlong
  i++;					// to next longlong (not yet loaded)
  //---------------------------------------------------------------
  // check if this block has room for length data (16 bytes)
  // if not fill with zeroes and generate Digest
  //---------------------------------------------------------------
  if (SHA_Array[26] >= 112)		// not enough room
  {
    for (; i<16; i++) SHA_Array[i] = 0;	// zero data
    Sha512Block(SHA_Array);		// generate digest
    i = 0;				// set index back
  }
  //---------------------------------------------------------------
  // fill block with zeroes until position for length reached,
  // insert bitlength, generate final Digest
  //---------------------------------------------------------------
  for (; i<14; i++)	SHA_Array[i]=0;	// clear

  SHA_Array[14] = SHA_Array[24];	// set length high
  SHA_Array[15] = SHA_Array[25];	// dto. low
  Sha512Block(SHA_Array);		// generate final digest
  //---------------------------------------------------------------
  // copy final digest to user buffer, clear SHA Array (safety)
  //---------------------------------------------------------------
  l = SHA_Array[16]; BIGlonglong2charn(l,Digest,Offset+0);
  l = SHA_Array[17]; BIGlonglong2charn(l,Digest,Offset+8);
  l = SHA_Array[18]; BIGlonglong2charn(l,Digest,Offset+16);
  l = SHA_Array[19]; BIGlonglong2charn(l,Digest,Offset+24);
  l = SHA_Array[20]; BIGlonglong2charn(l,Digest,Offset+32);
  l = SHA_Array[21]; BIGlonglong2charn(l,Digest,Offset+40);
  l = SHA_Array[22]; BIGlonglong2charn(l,Digest,Offset+48);
  l = SHA_Array[23]; BIGlonglong2charn(l,Digest,Offset+56);

  memset(SHA_Array,0,sizeof(long long) * 27);
}


#undef BIGchar2long
#undef BIGchar2longn
#undef BIGchar2longc
#undef BIGchar2longcn
#undef BIGchar2long3n
#undef BIGlong2charn
#undef char2longlong7n
#undef BIGchar2longlong
#undef BIGchar2longlongn
#undef BIGchar2longlongc
#undef BIGchar2longlongcn
#undef BIGchar2longlong7n
#undef BIGlonglong2char
#undef BIGlonglong2charn

#undef Ch_SHA
#undef Maj_SHA
#undef S0_256
#undef S1_256
#undef s0_256
#undef s1_256
#undef S0_512
#undef S1_512
#undef s0_512
#undef s1_512
#endif // HL_ENCR_SHA
// end of 'hobsha2.c'


