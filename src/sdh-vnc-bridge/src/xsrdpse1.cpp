// 2017.03.14 DD:
//  If you need to use the old HELP_DEBUG facilities, please uncomment the
//      HL_RDPACC_HELP_DEBUG definition in the header file. This way all compilation units that include this
//      header will have exactly the same definitions.

// ONLY SERVER: Special HOB-Capabilities to make MAC-Gate more efficient. 
#define HOB_CAPS
#define D_CONSOLE_OUT
//*set BNEWACC1=1;
/* end special setting KB 12.09 */
//*set D_TRACE_HL1=0;
//*set try$070518=1;
#define CERTMS01                            /* 20.01.05 KB - certificate Microsoft */
#define PROB_050608
#define PROB_050610
#define PROB_050611
#define PROB_050618
#define PROB_050619
#define PROB_060725
#define PROB_060827
//#define B050514
//#define TRACEHL1
//#define TEMPSCR1                            /* 06.01.05 KB - send screen */
#define D_BUG_HLJWT_INP1                    /* 17.07.07 KB - input from HOBlink JWT not encrypted */
/*+-------------------------------------------------------------------+*/
/*|                                                                   |*/
/*| PROGRAM NAME: xlrdpac1                                            |*/
/*| -------------                                                     |*/
/*|  DLL / Library for WebSecureProxy                                 |*/
/*|  RDP Accelerator                                                  |*/
/*|  KB 01.08.04                                                      |*/
/*|                                                                   |*/
/*| COPYRIGHT:                                                        |*/
/*| ----------                                                        |*/
/*|  Copyright (C) HOB 2004                                           |*/
/*|  Copyright (C) HOB Germany 2005                                   |*/
/*|  Copyright (C) HOB Germany 2006                                   |*/
/*|  Copyright (C) HOB Germany 2007                                   |*/
/*|  Copyright (C) HOB Germany 2008                                   |*/
/*|  Copyright (C) HOB Germany 2009                                   |*/
/*|  Copyright (C) HOB Germany 2010                                   |*/
/*|  Copyright (C) HOB Germany 2012                                   |*/
/*|                                                                   |*/
/*| REQUIRED PROGRAMS:                                                |*/
/*| ------------------                                                |*/
/*|  MS Visual Studio 2005 (VC8)                                      |*/
/*|  GCC all plattforms                                               |*/
/*|                                                                   |*/
/*| FUNCTION:                                                         |*/
/*| ---------                                                         |*/
/*|  generated source from .pre (PRECOMP)                             |*/
/*|  this is the source for little endian                             |*/
/*|                                                                   |*/
/*+-------------------------------------------------------------------+*/

/* #define TRACEHL1 */

/*+-------------------------------------------------------------------+*/
/*| System and library header files.                                  |*/
/*+-------------------------------------------------------------------+*/

#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <string.h>
#ifndef HL_UNIX
#include <conio.h>
#endif
#include <time.h>
#ifndef HL_UNIX
#include <winsock2.h>
//#include <ws2tcpip.h>
#include <windows.h>
#else
//#include <unistd.h>
#include "hob-unix01.h"
#endif
#include "hob-cdrdef1.h"
#include "mppcdef.h"
//#include "rsaraw.h"
//#include "hsha.h"
//#include "hmd5.h"
//#include "hrc4.h"
#include <hob-encry-1.h>
#include <hob-avl03.h>
#include <hob-xslunic1.h>
#include "hob-rdpserver1.h"
#include <hob-bitmap-compr-6.h>
#include "hob-bitmap-compr-1.h"
#include "hob-stor-sdh.h"

#if !defined B140825
    extern "C" int FAST rsa_crypt_raw(HMEM_CTX_DEF
	    unsigned char * aby_rsa_data, int i_rsa_data_len,
  	    unsigned char * aby_rsa_exp,  int i_rsa_exp_len,
	    unsigned char * aby_rsa_modulus, int i_rsa_modulus_len,
	    unsigned char * aby_dst_buf, int * ai_dst_len);
#endif 

#ifndef HL_WCHAR
#ifndef HL_UNIX
#define HL_WCHAR WCHAR
#else
#define HL_WCHAR unsigned short int
#endif
#endif

#define D_AUX_STOR_SIZE      (32 * 1024)    /* size storage element    */
#define DEF_LEN_VIRTCH_STA   12
#define D_MAX_CRYPT_LEN      0X100
// JB: Made this variable, depending on capabilities, JWT can do more. 
#define D_MAX_BMC_MSTSC      (D_ADSL_RCO1->imc_max_ts_fp_update_size - 4 - 22) /* maximum length for bitmap compression */
#define D_USERID_SE2CL       1              /* userid from server to client */
#define D_DISPLAY_CHANNEL    0X03EB         /* default display channel */
#define D_LEN_CLIENT_RAND    32             /* length client random    */
#define D_OFFSCR_B_NO        64             /* number of offscreen buffers */
#define D_CACHE_BMP_NO       3              /* number of Bitmap Cache Stages */
#define D_C_BMP_NO_0         0X78           /* Bitmap Cache Stages 0 entries */
#define D_C_BMP_NO_1         0X78           /* Bitmap Cache Stages 1 entries */
#define D_C_BMP_NO_2         0X1CE          /* Bitmap Cache Stages 2 entries */
#define D_RSA_KEY_SIZE       256            /* compare size RSA key    */
#define D_RSA_KEY_PADDING    8              /* padding of RSA key      */
//#define DEF_NO_COPY          128
#define DEF_CONST_RDP_03     0X03
#define DEF_CONST_ASN1_OS_04 0X04
#define DEF_CONST_ORDSEC_CACHE_GLYPHS_XRDP 0X03
#define DEF_CONST_ORDSEC_BRUSH 0X07
#define DEF_CONST_ORDSEC_MAX   0X05
#define DEF_CONST_ORDSEC_BRUSH_LEN 6        /* length of brush data    */
#define DEF_CONST_O0E_BRUSH_LEN 7           /* length of brush data    */
#define DEF_UPDATE_BITMAP_CO 9              /* number of short update bitmap */
#define D_TYPE_PUB_PAR_DIR   1              /* public parms direct     */
#define D_TYPE_PUB_PAR_CERT  2              /* public parms certificate */
#define D_PPDIR_PUB_VAL      6              /* public parms direct public value */
#define D_PPDIR_SIG          8              /* public parms direct signature */
#define D_GLYCOT1            10             /* glyph coordinates       */
#define D_GLYCOT2            256            /* glyph coordinates       */
#define D_GLYLEFT            0              /* glyph coordinate left   */
#define D_GLYTOP             1              /* glyph coordinate top    */
#define D_GLYWIDTH           2              /* glyph coordinate width  */
#define D_GLYHEIGHT          3              /* glyph coordinate height */
#define D_SIZE_HASH          8              /* size of hash            */
#define D_DEMAND_ACT_PDU     17             /* demand active PDU       */
#define D_XYZ_ERROR          0X17           /* ??? 04.06.11 KB         */
#define PDUTYPE_DATAPDU      7
#define PDUTYPE2_SYNCHRONIZE       0X1F     /* 31                      */
#define PDUTYPE2_REFRESH_RECT      0X21     /* 33                      */
#define PDUTYPE2_SUPPRESS_OUTPUT   0X23     /* 35                      */
#define PDUTYPE2_SHUTDOWN_REQUEST  0X24     /* 36                      */
#define SYNCMSGTYPE_SYNC     1
#define RNS_UD_24BPP_SUPPORT              0X0001
#define RNS_UD_16BPP_SUPPORT              0X0002
#define RNS_UD_15BPP_SUPPORT              0X0004
#define RNS_UD_32BPP_SUPPORT              0X0008
#define RNS_UD_CS_SUPPORT_ERRINFO_PDU     0X0001
#define RNS_UD_CS_WANT_32BPP_SESSION      0X0002
#define RNS_UD_CS_STRONG_ASYMMETRIC_KEYS  0X0008
#define TS_CACHED_BRUSH      0X80
#define BS_SOLID             0X00
#define BS_NULL              0X01
#define BS_HATCHED           0X02
#define BS_PATTERN           0X03
#define HS_HORIZONTAL        0X00
#define HS_VERTICAL          0X01
#define HS_FDIAGONAL         0X02
#define HS_BDIAGONAL         0X03
#define HS_CROSS             0X04
#define HS_DIAGCROSS         0X05
#define SV_SAVEBITS          0X00           /* Save bitmap operation   */
#define SV_RESTOREBITS       0X01           /* Restore bitmap operation */
// JB: Calculating exact lengths for Mac Gate. Request by SM.
#define MAX_PDU_LEN          0X00003FFF
#define MAX_PDU_LEN_HOB      0X00007FFF
#define MAX_FP_HEADER_SIZE   (3 + 8)
#define MAX_TS_FP_UPDATE_SIZE (MAX_PDU_LEN - MAX_FP_HEADER_SIZE)
#define TS_CACHE_BITMAP_UNCOMPRESSED_REV2 0X04
#define TS_CACHE_BITMAP_COMPRESSED_REV2   0X05
#define CBR2_HEIGHT_SAME_AS_WIDTH         0X01
#define CBR2_PERSISTENT_KEY_PRESENT       0X02
#define CBR2_NO_BITMAP_COMPRESSION_HDR    0X08
#define CBR2_DO_NOT_CACHE                 0X10

#define M_ERROR_FRSE_ILLOGIC iml_line_no = __LINE__; goto pfrse96;
#define M_ERROR_TOSE_ILLOGIC iml_line_no = __LINE__; goto ptose96;



/* get a piece of storage                                              */
/* end of macro M_MALLOC()                                             */

/* copy field structure dsd_rdp_co from server to client               */
/* end of macro M_COPY_CO1_SE2CL()                                     */


/* some cryptographical data mixing steps used in key generation       */
/* end of macro M_SALTHASH()                                           */

/* macro to apply order coordinates - absolute                         */
/* end of macro M_APPLY_ORD_ABS()                                      */

/* macro to apply order coordinates - absolute                         */
/* end of macro NEW_APPLY_ORD_ABS()                                      */

//*if def BNEWACC1;
/* macro to continue depending of flag bits                            */
/* end of macro M_CONT_O_COOR_ABS()                                    */

/* macro to apply order coordinates - delta                            */
/* end of macro M_APPLY_ORD_DELTA()                                    */

/* macro to continue depending of flag bits                            */
/* end of macro M_CONT_O_COOR_DELTA()                                  */
//*cend;

/* macro to continue depending of flag bits for bounds absolute or delta */
/* end of macro M_CO_BOUNDS_APPLY()                                    */

/* macro to apply value litle endian                                   */
/* end of macro M_APPLY_LE()                                           */

/* macro to continue depending of flag bits for order 00 / 0X00        */
/* end of macro M_CO_O00_FIELDS()                                      */

/* macro to continue depending of flag bits for order 01 / 0X01        */
/* end of macro M_CO_O01_FIELDS()                                      */

/* macro to continue depending of flag bits for order 10 / 0X0A        */
/* end of macro M_CO_O0A_FIELDS()                                      */

/* macro to continue depending of flag bits for order 11 / 0X0B        */
/* end of macro M_CO_O0B_FIELDS()                                      */

/* macro to continue depending of flag bits for order 13 / 0X0D        */
/* end of macro M_CO_O0D_FIELDS()                                      */

/* macro to continue depending of flag bits for order 14 / 0X0E        */
/* end of macro M_CO_O0E_FIELDS()                                      */

/* macro to continue depending of flag bits for order 18 / 0X12        */
/* end of macro M_CO_O12_FIELDS()                                      */

/* macro to continue depending of flag bits for order 19 / 0X13        */
/* end of macro M_CO_O13_FIELDS()                                      */

/* macro to continue depending of flag bits for order 24 / 0X18        */
/* end of macro M_CO_O18_FIELDS()                                      */

/* macro to check if temporary buffer is big enough                    */
/* end of macro M_TMPBUF_CL_1()                                        */

/* macro to check if temporary buffer is big enough                    */
/* end of macro M_TMPBUF_SE_1()                                        */

/* macro bitmap order 0 fill9                                          */
/* end of macro M_BITMAP_00_1()                                        */

/* macro bitmap order 1 Mix                                            */
/* end of macro M_BITMAP_01_1()                                        */

/* macro make frame buffer                                             */
/* end of macro M_FRAME_BUF_1()                                        */

/* macro make frame buffer                                             */
/* end of macro M_FRAME_BUF_2()                                        */

/* macro make frame buffer                                             */
/* end of macro M_FRAME_BUF_3()                                        */

/* macro make frame buffer                                             */
/* macro get output-area                                               */
/* end of macro M_FRAME_BUF_4()                                        */

/* macro to send bounds to the client, first part                      */
/* end of macro M_SEND_BOUNDS_P1()                                     */

/* macro to send bounds to the client, second part                     */
/* end of macro M_SEND_BOUNDS_P2()                                     */

/* macro to generate prototype statement for ROP2/3                    */
/* end of macro to generate prototype statement for ROP2/3             */
/* macro to generate functions for ROP2/3                              */
/* macro to generate definitions for ROP2/3                            */
/* end of macro to generate definitions for ROP2/3                     */
/* macro to generate functions for ROP2/3                              */
/* end of macro to generate functions for ROP2/3                       */
/* macro to generate LineTo operations, also for Polyline              */
/* end of macro to generate LineTo operations, also for Polyline       */

typedef unsigned int ( * amd_rop2_x_x )( unsigned int, unsigned int );

/* receive block from client, field position                           */
enum ied_fcfp_bl {
   ied_fcfp_invalid,                        /* invalid data received   */
   ied_fcfp_constant,                       /* is in constant          */
   ied_fcfp_x224_p01,                       /* is in x224 header       */
   ied_fcfp_ignore,                         /* ignore data             */
   ied_fcfp_copy_normal,                    /* copy data normal        */
   ied_fcfp_copy_invers,                    /* copy data invers        */
   ied_fcfp_zero_cmp,                       /* compare zeroes          */
   ied_fcfp_rdp5_rc4,                       /* input RC4 encrypted     */
                   ied_fcfp_rec_type,       /* receive record type     */
                   ied_fcfp_byte01,         /* receive byte 01         */
                   ied_fcfp_lencons_2,      /* two bytes length remain */
                   ied_fcfp_lencons_1,      /* one byte length remains */
   ied_fcfp_rdp5_len1,                      /* RDP5 input length 1     */
   ied_fcfp_rdp5_len2,                      /* RDP5 input length 2     */
   ied_fcfp_mcs_c1,                         /* x224 MCS command 1      */
   ied_fcfp_userid,                         /* userid communication    */
   ied_fcfp_chno,                           /* receive channel no      */
   ied_fcfp_prio_seg,                       /* Priority / Segmentation */
   ied_fcfp_rt02,                           /* record type 2           */
   ied_fcfp_rt03,                           /* record type 3           */
#ifdef NOT_VALID_060924
   ied_fcfp_rt04,                           /* record type 4           */
#endif
   ied_fcfp_padd_1,                         /* padding                 */
   ied_fcfp_data_pdu_1,                     /* RDP4 data PDU follows   */
   ied_fcfp_set_display_updates,            /* PDUTYPE2_SUPPRESS_OUTPUT */
   ied_fcfp_refresh_no_areas,               /* PDUTYPE2_REFRESH_RECT   */
                   ied_fcfp_asn1_tag,       /* ASN.1 tag follows       */
                   ied_fcfp_asn1_l1_fi,     /* ASN.1 length field      */
                   ied_fcfp_asn1_l1_p2,     /* ASN.1 length part two   */
                   ied_fcfp_mu_len_1,       /* multi length 1          */
                   ied_fcfp_mu_len_2,       /* multi length 2          */
   ied_fcfp_int_lit_e,                      /* int little endian       */
   ied_fcfp_int_big_e,                      /* int big endian          */
   ied_fcfp_end_com,                        /* end of communication    */
   ied_fcfp_no_session,                     /* no more session         */
                    ied_frclnv_usxx,        /* userid invalid - not fo */
                    ied_frclnv_pasxxord };  /* password invalid        */


/* receive block from client, in block of type                         */
enum ied_frcl_bl { ied_frcl_start,          /* start of communication  */
                   ied_frcl_rec_02,         /* receive block 2         */
                   ied_frcl_r02_x224mcs,    /* proc bl 2 X.224 MCS     */
                   ied_frcl_r02_mcscoen,    /* b2 MCS connect encoding */
                   ied_frcl_r02_mc_cids,    /* b2 MC Calling Domain Selector */
                   ied_frcl_r02_mc_ceds,    /* b2 MC Called Domain Selector */
                   ied_frcl_r02_mc_upwf,    /* b2 MC Upward Flag       */
                   ied_frcl_r02_mc_tdop,    /* b2 MC Target Domain Parameters */
                   ied_frcl_r02_mc_midp,    /* b2 MC Minimum Domain Parameters */
                   ied_frcl_r02_mc_madp,    /* b2 MC Maximum Domain Parameters */
                   ied_frcl_r02_mc_usd1,    /* b2 MC User Data Start   */
                   ied_frcl_r02_mcud_l1,    /* b2 MC Us-Da length 1    */
//                 ied_frcl_r02_mcud_l2,    /* b2 MC Us-Da length 2    */
#ifdef B060907
                   ied_frcl_r02_mcud_dtt,   /* b2 MC Us-Da Desktop Tag */
#endif
#ifdef B060907
   ied_frcl_r02_fie_dtt,                    /* b2 MC Us-Da Desktop Tag */
#endif
//                 ied_frcl_r02_mcud_prv,   /* b2 MC Us-Da Protocol Ve */
   ied_frcl_r02_fietype,                    /* b2 MC Field Type        */
   ied_frcl_r02_fielen,                     /* b2 MC Field Length      */
                   ied_frcl_r02_mcud_c01,   /* b2 MC Us-Da const 01    */
                   ied_frcl_r02_mcud_scw,   /* b2 MC Us-Da scr width   */
                   ied_frcl_r02_mcud_sch,   /* b2 MC Us-Da scr height  */
                   ied_frcl_r02_mcud_c02,   /* b2 MC Us-Da const 02    */
                   ied_frcl_r02_mcud_kbl,   /* b2 MC Us-Da Keyboard La */
                   ied_frcl_r02_mcud_bun,   /* b2 MC Us-Da Build Numb  */
                   ied_frcl_r02_mcud_con,   /* b2 MC Us-Da Computer Na */
                   ied_frcl_r02_mcud_kbt,   /* b2 MC Us-Da Keyboard Ty */
                   ied_frcl_r02_mcud_kbs,   /* b2 MC Us-Da Keyboard ST */
                   ied_frcl_r02_mcud_nfk,   /* b2 MC Us-Da No Func Key */
                   ied_frcl_r02_mcud_ime,   /* b2 MC Us-Da IME Keyb ma */
                   ied_frcl_r02_mcud_c03,   /* b2 MC Us-Da const 03    */
                   ied_frcl_r02_mcud_pv1,   /* b2 MC Us-Da protocol ve */
                   ied_frcl_r02_mcud_cod,   /* b2 MC Us-Da Color Depth */
   ied_frcl_r02_mcud_sup_cod,               /* b2 MC Us-Da supported Color Depth */
   ied_frcl_r02_mcud_early_cf,              /* b2 MC Us-Da early capability flag */
#ifdef B060907
                   ied_frcl_r02_mcud_vc1,   /* b2 MC Us-Da virtual ch  */
#endif
                   ied_frcl_r02_mcud_nvc,   /* b2 MC Us-Da no virt ch  */
                   ied_frcl_r02_mcud_vcn,   /* b2 MC Us-Da virt ch nam */
                   ied_frcl_r02_mcud_vcf,   /* b2 MC Us-Da virt ch fla */
   ied_frcl_rdp5_inp,                       /* RDP5-style input data   */
#ifdef OLD01
                   ied_frcl_rec_03,         /* receive block 3         */
#endif
   ied_frcl_pdu_type_1_l,                   /* get RDP4 PDU type / length */
   ied_frcl_pdu_type_1_t,                   /* get RDP4 PDU type / type */
   ied_frcl_data_pdu_1,                     /* RDP4 data PDU follows   */
   ied_frcl_refresh_no_areas,               /* PDUTYPE2_REFRESH_RECT   */
   ied_frcl_data_pdu_end,                   /* RDP4 data PDU end       */
   ied_frcl_rec_05,                         /* receive block 5         */
   ied_frcl_rec_06,                         /* receive block 6         */
   ied_frcl_cjreq_rec,                      /* receive block channel join request */
   ied_frcl_clrand_rec,   /* ??? */         /* receive client random   */
   ied_frcl_client_rand,                    /* receive client random   */
   ied_frcl_c_logon_info_1,                 /* logon information 1     */
   ied_frcl_c_loinf_options,                /* Options                 */
   ied_frcl_c_loinf_domna_len,              /* Domain Name Length      */
   ied_frcl_c_loinf_userna_len,             /* User Name Length        */
   ied_frcl_c_loinf_pwd_len,                /* Password Length         */
   ied_frcl_c_loinf_altsh_len,              /* Alt Shell Length        */
   ied_frcl_c_loinf_wodir_len,              /* Working Directory Length */
   ied_frcl_c_loinf_domna_val,              /* Domain Name String      */
   ied_frcl_c_loinf_userna_val,             /* User Name String        */
   ied_frcl_c_loinf_pwd_val,                /* Password String         */
   ied_frcl_c_loinf_altsh_val,              /* Alt Shell String        */
   ied_frcl_c_loinf_wodir_val,              /* Working Directory String */
   ied_frcl_c_loinf_no_a_par,               /* number of additional parameters */
   ied_frcl_c_loinf_ineta,                  /* INETA                   */
   ied_frcl_c_loinf_path,                   /* Client Path             */
   ied_frcl_c_loinf_extra,                  /* Extra Parameters        */
   ied_frcl_resp_act_pdu_rec,               /* response block active PDU */
   ied_frcl_rdp4_vch_ulen,                  /* virtual channel uncompressed data length */
   ied_frcl_rec_xyz_01,                     /* ?????nse block active PDU */
   ied_frcl_sharedataheader_compr,          /* TS_SHAREDATAHEADER compressedType and compressedLength */
                    ied_frclnv_user,        /* userid invalid - not fo */
                    ied_frclnv_password };  /* password invalid        */


struct dsd_progaddr_1 {                     /* program addresses       */
   BOOL (* amrc_r5_ord_x[ D_R5_ORD_NO ]) ( struct dsd_call_rdpserv_1 *, char * );
   amd_rop2_x_x amrc_rop2_x_x[ 16 ];        /* ROP2 functions          */
};

struct dsd_tempstor_1 {                     /* temporary storage       */
   struct dsd_tempstor_1 *adsc_next;        /* next in chain           */
   int        imc_len;                      /* length of storage       */
// BOOL       boc_free;                     /* has to free memory      */
};


struct dsd_offscr_b_1 {                     /* offscreen buffer        */
   unsigned short int usc_dim_x;            /* dimension x pixels      */
   unsigned short int usc_dim_y;            /* dimension y pixels      */
   void *     ac_offscr_buffer;             /* offscreen buffer        */
};

struct dsd_bmp_cache_b_1 {                  /* Bitmap Cache Buffer     */
   unsigned short int usc_dim_x;            /* dimension x pixels      */
   unsigned short int usc_dim_y;            /* dimension y pixels      */
   int        imc_no_pixel;                 /* number of pixel in buffer */
   void *     ac_bmp_cache_buffer;          /* Bitmap Cache Buffer     */
};

struct dsd_raord_scr {                      /* RA order screen         */
   struct dsd_raord_scr *adsc_next;         /* next in chain           */
   int        imc_left;                     /* coordinate left         */
   int        imc_top;                      /* coordinate top          */
   int        imc_right;                    /* coordinate right        */
   int        imc_bottom;                   /* coordinate bottom       */
};


//#define D_LOINFO_COMPR_ENA   128            /* compression enabled     */
//#define D_LOINFO_COMPR_LDIC  512            /* use large dictionary    */
#define D_LOINFO_COMPR_ENA   0X0080         /* compression enabled     */
#define D_LOINFO_COMPR_LDIC  0X0200         /* use large dictionary    */
#define D_LOINFO_COMPR_BULK  0X0400         /* use bulk compression    */


struct dsd_rdp_server_1 {                   /* rdp server part         */
   struct dsd_rdp_co dsc_rdp_co_1;          /* rdp communication       */
   ied_fcfp_bl iec_fcfp_bl;                 /* field position          */
   ied_frcl_bl iec_frcl_bl;                 /* receive block from client */
   int        imc_pos_inp_frame;            /* position in input frame */
   int        imc_prot_1;                   /* for protocol decoding   */
   int        imc_prot_2;                   /* for protocol decoding   */
   int        imc_prot_3;                   /* for protocol decoding   */
   int        imc_prot_4;                   /* for protocol decoding   */
   int        imc_prot_chno;                /* for protocol decoding   */
   struct {                                 /* rdp server part         */
     int        imc_bounds_old_left;        /* bounds coordinates      */
     int        imc_bounds_old_top;         /* bounds coordinates      */
     int        imc_bounds_old_right;       /* bounds coordinates      */
     int        imc_bounds_old_bottom;      /* bounds coordinates      */
   } dsc_old_bounds;
   char *     achc_prot_1;                  /* for protocol decoding   */
   char       chrc_prot_1[ D_MAX_CRYPT_LEN ];  /* for protocol decoding */
   char       chc_prot_rt02;                /* for protocol decoding   */
   char       chc_prot_rt03;                /* for protocol decoding   */
   unsigned char ucc_order_flags_1;         /* send order flags        */
   unsigned int umc_vch_ulen;               /* virtual channel length uncompressed */
   char       chrc_vch_segfl[2];            /* virtual channel segmentation flags */
   char       chrc_inp_hash[ D_SIZE_HASH ];  /* input hash             */
   int        imc_len_temp;                 /* length temporary buffer */
   void *     ac_temp_buffer;               /* temporary buffer        */
};


struct dsd_cache_1 {                        /* cache for pixels        */
   struct dsd_cache_1 *adsc_next;           /* next in chain           */
   int        inc_id;                       /* cache id                */
   int        inc_ind;                      /* cache index             */
};

struct dsd_pix_buf_1 {                      /* pixel buffer            */
   struct dsd_pix_buf_1 *adsc_next;         /* next in chain           */
   unsigned short int usc_ind;              /* index of pixel buffer   */
   unsigned short int usc_width;            /* width of buffer         */
   unsigned short int usc_height;           /* height of buffer        */
};

struct dsd_rdpa_f {                         /* rdp accelerator frame   */
// ied_frse_bl iec_frse_bl;                 /* receive block from server */
// ied_frcl_bl iec_frcl_bl;                 /* receive block from client */
   struct dsd_rdp_server_1 dsc_rdp_se_1;    /* rdp server part         */
   char       chrl_server_random[32];       /* specify server-random   */
   void *     ac_screen_buffer;             /* screen buffer           */
   struct dsd_cache_1 *adsc_cache_1;        /* chain of caches         */
   struct dsd_stor_sdh_1 dsc_stor_sdh_1;    /* storage management      */
#ifdef HL_RDPACC_HELP_DEBUG
   BOOL       boc_help_debug_1;             /* stop debugger           */
#endif
#ifdef TEMPSCR1
   BOOL       boc_temp_scr_1;               /* screen buffer send      */
#endif
#ifdef TRACEHL_CL2SE_COM1                   /* 21.09.06 KB - client to server commands */
   int        inc_count_frse;               /* count from server       */
#endif
};

struct dsd_cr_getstorglyph {                /* pass parameters get storage glyph */
   struct dsd_call_rdpserv_1 *adsc_hl_clib_1;      /* call parameters         */
   struct dsd_font *adsc_font;              /* font used               */
// int        imc_unicode;                  /* UTF-32 of character     */
   BOOL       boc_sort;                     /* sort sequence destroyed */
};

struct dsd_bmc_get_wa {                     /* get work area           */
  struct dsd_bitmap_compr_6 dsc_bmc1;       /* Bitmap Compression      */
   struct dsd_call_rdpserv_1 *adsc_hl_clib_1;      /* call parameters         */
};

struct dsd_output_area_1 {                  /* output of subroutine    */
   char       *achc_w1;                     /* lower addr output area  */
   char       *achc_w2;                     /* higher addr output area */
   struct dsd_gather_i_1 *adsc_gai1_o1;     /* output data             */
   struct dsd_raord_scr *adsc_raord_scr;    /* chain of ra orders      */
   struct dsd_tempstor_1 *adsc_tempstor_1;  /* chain of temporary storage */
   struct dsd_cl_co1 *adsc_cl_co1;          /* command from client     */
   struct dsd_gather_i_1 *adsc_gai1_sf;     /* start of current frame  */
// struct dsd_gather_i_1 *adsc_gai1_o1;   /* last gather in chain    */
   char       *achc_start_order;            /* start of current orders */
   int        imc_no_order;                 /* number of orders        */
   int        imc_pdu_len;                  /* length of PDU           */
};

static const unsigned char ucrs_crypt_ini_01[] = {  /* initialize crypto */
   0X41
};

static const unsigned char ucrs_crypt_ini_02[] = {  /* initialize crypto */
   0X42, 0X42
};

static const unsigned char ucrs_crypt_ini_03[] = {  /* initialize crypto */
   0X43, 0X43, 0X43
};

static const unsigned char ucrs_crypt_ini_04[] = {  /* initialize crypto */
   0X58
};

static const unsigned char ucrs_crypt_ini_05[] = {  /* initialize crypto */
   0X59, 0X59
};

static const unsigned char ucrs_crypt_ini_06[] = {  /* initialize crypto */
   0X5A, 0X5A, 0X5A
};

static const unsigned char ucrs_secl_01[] = {  /* send to client - first bl */
   0X03, 0X00, 0X00, 0X0B, 0X06, 0XD0, 0X00, 0X00, 0X12, 0X34, 0X00
};

static const unsigned char ucrs_sese_01[] = {  /* send to server - first bl */
   0X03, 0X00, 0X00, 0X0B, 0X06, 0XE0, 0X00, 0X00, 0X00, 0X00, 0X00
};

static const unsigned char ucrs_x224_mcs[] = {  /* X224 Data plus MCS  */
   0X02, 0XF0, 0X80, 0X7F, 0X65
};

static const unsigned char ucrs_x224_r05_errect[] = {  /* X224 Data MCS Errect Domain Request */
   0X03, 0X00, 0X00, 0X0C, 0X02, 0XF0, 0X80, 0X04
};

static const unsigned char ucrs_x224_r06_attuser[] = {  /* X224 Data MCS Attach User Request */
   0X03, 0X00, 0X00, 0X08, 0X02, 0XF0, 0X80, 0X28
};

static const unsigned char ucrs_x224_r07_aurep[] = {  /* X224 Data MCS Attach User Reply */
   0X03, 0X00, 0X00, 0X0B, 0X02, 0XF0, 0X80, 0X2E
};

static const unsigned char ucrs_x224_cjreq_1[] = {  /* X224 Data MCS Channel Join Request */
   0X03, 0X00, 0X00, 0X0C, 0X02, 0XF0, 0X80, 0X38
};

static const unsigned char ucrs_x224_cjresp_1[] = {  /* X224 Data MCS Channel Join Response */
   0X03, 0X00, 0X00, 0X0F, 0X02, 0XF0, 0X80, 0X3E
};


static const unsigned char ucrs_ks_01[] = {
   0XD1, 0X26, 0X9E
};

static const unsigned char ucrs_x224_p01[] = {  /* X224 Data part 01   */
   0X02, 0XF0, 0X80
};

static const unsigned char ucrs_x224_p02[] = {  /* X224 record 2 part 02 */
   0X04, 0X01, 0X01, 0X04, 0X01,
   0X01, 0X01, 0X01, 0XFF, 0X30, 0X19, 0X02, 0X01,
   0X22, 0X02, 0X01, 0X02, 0X02, 0X01, 0X00, 0X02,
   0X01, 0X01, 0X02, 0X01, 0X00, 0X02, 0X01, 0X01,
   0X02, 0X02, 0XFF, 0XFF, 0X02, 0X01, 0X02, 0X30,
   0X19, 0X02, 0X01, 0X01, 0X02, 0X01, 0X01, 0X02,
   0X01, 0X01, 0X02, 0X01, 0X01, 0X02, 0X01, 0X00,
   0X02, 0X01, 0X01, 0X02, 0X02, 0X04, 0X20, 0X02,
   0X01, 0X02, 0X30, 0X1C, 0X02, 0X02, 0XFF, 0XFF,
   0X02, 0X02, 0XFC, 0X17, 0X02, 0X02, 0XFF, 0XFF,
   0X02, 0X01, 0X01, 0X02, 0X01, 0X00, 0X02, 0X01,
   0X01, 0X02, 0X02, 0XFF, 0XFF, 0X02, 0X01, 0X02
};

static const unsigned char ucrs_x224_p03[] = {  /* X224 record 2 part 03 */
   0X00, 0X05, 0X00, 0X14, 0X7C, 0X00, 0X01
};

static const unsigned char ucrs_x224_p04[] = {  /* X224 record 2 part 04 */
   0X00, 0X08, 0X00, 0X10, 0X00, 0X01, 0XC0, 0X00,
   0X44, 0X75, 0X63, 0X61
};

static const unsigned char ucrs_x224_p05[] = {  /* X224 record 2 part 05 */
   0X01, 0XC0, 0XD4, 0X00, 0X04, 0X00, 0X08, 0X00
};

/* Bitmap Size Tag Present + SAS Sequence                              */
static const unsigned char ucrs_x224_p06[] = {  /* X224 record 2 part 06 */
   0X01, 0XCA, 0X03, 0XAA,
};

static const unsigned char ucrs_x224_buildno[] = {  /* X224 record 2 build number */
#ifdef OLD01
   0XCE, 0X0E, 0X00, 0X00
#else
   0X93, 0X08, 0X00, 0X00
#endif
};


static const unsigned char ucrs_after_logon_01[] = {  /* X224 send after logon */
   0XFF, 0X03, 0X10, 0X00, 0X07, 0X00, 0X00, 0X00,
   0X02, 0X00, 0X00, 0X00, 0X04, 0X00, 0X00, 0X00
};

static const unsigned char ucrs_server_sync_pdu[] = {  /* X224 send server Synchronize PDU */
   0X16, 0X00,                              /* length                  */
   0X10 | PDUTYPE_DATAPDU, 0X00,
   0XFF, 0XFF,
   0XFF, 0XFF,
   0X01, 0X00, 0X04, 0X00, 0X16, 0X00,
   PDUTYPE2_SYNCHRONIZE, 0X00, 0X00, 0X00,
   SYNCMSGTYPE_SYNC, 0X00, 0X00, 0X00
};

static const unsigned char ucrs_server_contr_pdu_coop[] = {  /* X224 send server Control PDU Coordinate */
   0X1A, 0X00,                              /* length                  */
   0X10 | PDUTYPE_DATAPDU, 0X00,
   0XFF, 0XFF,
   0XFF, 0XFF,
   0X01, 0X00,
   0X00, 0X02, 0X1A, 0X00, 0X14, 0X00, 0X00, 0X00,
   0X04, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
};

static const unsigned char ucrs_server_contr_pdu_grco[] = {  /* X224 send server Control PDU Granted Control */
   0X1A, 0X00,                              /* length                  */
   0X10 | PDUTYPE_DATAPDU, 0X00,
   0XFF, 0XFF,
   0XFF, 0XFF,
   0X01, 0X00,
   0X00, 0X02,
   0X1A, 0X00, 0X14, 0X00, 0X00, 0X00, 0X02, 0X00,
   0XFF, 0XFF,
   0XFF, 0XFF,
   0X00, 0X00
};

static const unsigned char ucrs_server_font_map_pdu[] = {  /* X224 send server Font Map PDU */
   0X1A, 0X00,                              /* length                  */
   0X10 | PDUTYPE_DATAPDU, 0X00,
   0XFF, 0XFF,
   0XFF, 0XFF,
   0X01, 0X00,
   0X04, 0X02, 0X1A, 0X00, 0X28, 0X00, 0X00, 0X00,
   0X00, 0X00, 0X00, 0X00, 0X03, 0X00, 0X04, 0X00
};

// SERVER-ONLY: Hob capabilities for communication between MacGate and JWT. 
#ifdef HOB_CAPS
#define IM_HOB_CAPS_ORDER_EXTENSION 0X00
#define IM_FLAG_ORDER_EX_BMP6_UNCOMPRESSED 0X00000001
#define IM_FLAG_ORDER_EX_BRUSH_SIZE_FIELD  0X00000002
#define IM_HOB_CAPS_FASTPATH_EXTENSION 0X01
#define IM_CAPS_FASTPATH_EX_MAX_PDU = 0X00004000
#define IM_HOB_CAPS_ORDER_EX_BRUSH_CACHE 0X02
#define IM_HOB_CAPS_EX_CURSOR 0x3
#define IM_FLAG_EX_CURSOR_32BPP_CURSOR 0x1
#define IM_FLAG_EX_CURSOR_32BPP_CURSOR_NO_AND_MASK 0x2
#define INITIALIZE_UINT16_LE(length) (unsigned char) (length), (unsigned char) ((length) >> 8)
#define INITIALIZE_UINT32_LE(length) (unsigned char) (length), (unsigned char) ((length) >> 8), (unsigned char) ((length) >> 16), (unsigned char) ((length) >> 24)

#define HOB_CAPS_ARR \
   0X04, \
   IM_HOB_CAPS_ORDER_EXTENSION, 0X04, IM_FLAG_ORDER_EX_BMP6_UNCOMPRESSED | IM_FLAG_ORDER_EX_BRUSH_SIZE_FIELD, 0X00, 0X00, 0X00, \
   IM_HOB_CAPS_FASTPATH_EXTENSION, 0X04, INITIALIZE_UINT32_LE(MAX_PDU_LEN_HOB), \
   IM_HOB_CAPS_ORDER_EX_BRUSH_CACHE, 0X04, INITIALIZE_UINT16_LE(0X100), INITIALIZE_UINT16_LE(0X0), \
   IM_HOB_CAPS_EX_CURSOR, 0x8, INITIALIZE_UINT32_LE(IM_FLAG_EX_CURSOR_32BPP_CURSOR | IM_FLAG_EX_CURSOR_32BPP_CURSOR_NO_AND_MASK), INITIALIZE_UINT16_LE(96), INITIALIZE_UINT16_LE(96)
   
   
static const unsigned char UCRS_HOB_CAPS[] = {HOB_CAPS_ARR};
static const int IMC_LENCAPS_HOBCAPS = sizeof(UCRS_HOB_CAPS) + 8;
static const int IMC_LENCAPS_HOBCAPS_ADD = IMC_LENCAPS_HOBCAPS + 0X013E;
#endif 

static const unsigned char ucrs_deactivate_all[] = {  /* deactivate all */
   0x16,                        /* 22 = 0X16 demand active PDU */
   0X00, 0XEA, 0X03, 0XEA, 0X03, 0X01, 0X00,
   0X01, 0X00,                              /* source descriptor length */
   0X00
};

static const unsigned char ucrs_capabilities_01[] = {  /* X224 send capabilities */
   D_DEMAND_ACT_PDU,                        /* 17 = 0X11 demand active PDU */
   0X00, 0XEA, 0X03, 0XEA, 0X03, 0X01, 0X00,
   0X04, 0X00,                              /* source descriptor length */
#ifdef HOB_CAPS
   INITIALIZE_UINT16_LE(IMC_LENCAPS_HOBCAPS_ADD), 
#else
   0X3E, 0X01,                              /* Length capabilities     */
#endif
   0X52, 0X44, 0X50, 0X00,                  /* RDP                     */
#ifdef HOB_CAPS
   0X0C, 0X00,                              /* Number capabilities     */
#else
   0X0B, 0X00,                              /* Number capabilities     */
#endif
   0X00, 0X00,
   0X09, 0X00,                              /* capability index        */
   0X08, 0X00,                              /* capability length       */
   0XEA, 0X03, 0X72, 0XE1,                  /* ShareCapabilitySet      */
   0X01, 0X00,                              /* capability index        */
   0X18, 0X00,                              /* capability length       */
   0X01, 0X00, 0X03, 0X00, 0X00, 0X02, 0X00, 0X00,  /* GeneralCapabilitySet */
   0X00, 0X00, 0X1D, 0X04, 0X00, 0X00, 0X00, 0X00,
   0X00, 0X00, 0X01, 0X01,
   0X14, 0X00,                              /* capability index        */
   0X08, 0X00,                              /* capability length       */
   0X02, 0X00, 0X00, 0X00,                  /* ClipboardCompressionCapabilitySet */
   0X16, 0X00,                              /* capability index        */
   0X28, 0X00,                              /* capability length       */
   0X01, 0X00, 0X00, 0X00, 0XAB, 0XF6, 0XA4, 0X36,
   0X01, 0X00, 0X00, 0X00, 0X92, 0X02, 0X00, 0X00,
   0X00, 0X00, 0X00, 0XFF, 0XFA, 0XD0, 0XA5, 0X00,
   0X00, 0X00, 0X00, 0X36, 0X51, 0X40, 0X00, 0X00,
   0X9F, 0XC0, 0X4E, 0X80,
   0X0E, 0X00,                              /* capability index        */
   0X04, 0X00,                              /* capability length       */
   0X02, 0X00,                              /* capability index        */
   0X1C, 0X00,                              /* capability length       */
   0X10, 0X00, 0X01, 0X00, 0X01, 0X00, 0X01, 0X00,
   0X2C, 0X06, 0X6A, 0X04, 0X00, 0X00, 0X01, 0X00,
   0X01, 0X00, 0X00, 0X0E, 0X01, 0X00, 0X00, 0X00,
   0X03, 0X00,                              /* capability index        */
   0X58, 0X00,                              /* capability length       */
   0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00,
   0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00,
   0X40, 0X42, 0X0F, 0X00, 0X01, 0X00, 0X14, 0X00,
   0X00, 0X00, 0X01, 0X00, 0X00, 0X00, 0X22, 0X00,
   0X01, 0X01, 0X01, 0X01, 0X01, 0X00, 0X00, 0X01,
   0X01, 0X01, 0X01, 0X01, 0X00, 0X00, 0X00, 0X01,
   0X01, 0X01, 0X01, 0X01, 0X01, 0X01, 0X01, 0X00,
   0X01, 0X01, 0X01, 0X01, 0X00, 0X00, 0X00, 0X00,
   0XA1, 0X06, 0X00, 0X00, 0X40, 0X42, 0X0F, 0X00,
   0X40, 0X42, 0X0F, 0X00, 0X01, 0X00, 0X00, 0X00,
   0X00, 0X00, 0X00, 0X00,
   0X0A, 0X00,                              /* capability index        */
   0X08, 0X00,                              /* capability length       */
   0X06, 0X00, 0X00, 0X00,                  /* ColorTableCacheCapabilitySet */
   0X12, 0X00,                              /* capability index        */
   0X08, 0X00,                              /* capability length       */
   0X01, 0X00, 0X00, 0X00,                  /* unknown                 */
   0X08, 0X00,                              /* capability index        */
   0X0A, 0X00,                              /* capability length       */
   0X01, 0X00, 0X19, 0X00, 0X19, 0X00,      /* pointer capability set  */
   0X0D, 0X00,                              /* capability index        */
   0X58, 0X00,                              /* capability length       */
   0X35, 0X00, 0X00, 0X00, 0XA1, 0X06, 0X00, 0X00,  /* InputCodeSelectCapabilitySet */
   0X40, 0X42, 0X0F, 0X00, 0X40, 0X42, 0X0F, 0X00,
   0X44, 0XF6, 0X73, 0XF8, 0X93, 0XE3, 0X9B, 0XF8,
   0X08, 0XE0, 0X0E, 0XE1, 0X6A, 0X95, 0X9C, 0XF8,
   0X4C, 0XF6, 0X73, 0XF8, 0XD4, 0X3E, 0X72, 0XE1,
   0X90, 0X3A, 0X72, 0XE1, 0X01, 0X00, 0X00, 0X00,
   0X90, 0X3A, 0X72, 0XE1, 0X00, 0X00, 0X00, 0X00,
   0X44, 0XF6, 0X73, 0XF8, 0X54, 0X82, 0X9C, 0XF8,
   0X90, 0X3A, 0X72, 0XE1, 0X38, 0XF6, 0X73, 0XF8,
   0X00, 0X00, 0X00, 0X00, 0X08, 0X00, 0X0A, 0X00,
   0X01, 0X00, 0X19, 0X00,
#ifdef HOB_CAPS                             /* Special HOB-Capabilities */  
   0X00, 0X0f,
   INITIALIZE_UINT16_LE(IMC_LENCAPS_HOBCAPS),
   0X48, 0X4F, 0X42, 0X78,                  /* "HOBx": String to make sure, this cap is from us. */
   HOB_CAPS_ARR,
#endif
   0X00, 0X00, 0X00, 0X00                   /* end                     */
};
#define D_CAP_POS_SCR 0X6C
static int imrs_bmc_width[ 5 ] = { 0, 1, 120, 96, 88 };


#ifdef B060907
static const unsigned char ucrs_desktop_tag[] = {  /* Desktop Tag      */
   0X01, 0XC0
};
#endif

#ifndef B060907_XXX
static const unsigned char ucrs_r02c01[] = {  /* record 2 const 1      */
   0X00, 0X08, 0X00
};
#else
static const unsigned char ucrs_r02c01[] = {  /* record 2 const 1      */
   0X04, 0X00, 0X08, 0X00
};
#endif

static const unsigned char ucrs_bitmap_tag[] = {  /* Bitmap Size Tag   */
   0X01, 0XCA
};

static const unsigned char ucrs_r02c02[] = {  /* record 2 const 2      */
   0X01, 0XCA, 0X03, 0XAA
};

#ifdef B060907
static const unsigned char ucrs_virtch_tag[] = {  /* Virtual Channel Tag */
   0X03, 0XC0
};
#endif

static const unsigned char ucrs_source_desc[] = {  /* Source Descriptor */
   0X52, 0X44, 0X50, 0X00                   /* RDP zero-terminated */
};

static const unsigned char ucrs_asn1_prot_id[] = {  /* ASN-1 protocol Id */
   0X00, 0X05, 0X00, 0X14, 0X7C, 0X00, 0X01, 0X2A,
   0X14, 0X76, 0X0A, 0X01, 0X01, 0X00, 0X01, 0XC0,
   0X00, 0X4D, 0X63, 0X44, 0X6E
};

static const unsigned char ucrs_r04_asn1_1[] = {  /* ASN-1 variables   */
   0X0A, 0X01, 0X00,
   0X02, 0X01, 0X00,
   0X30, 0X1A, 0X02, 0X01, 0X22, 0X02, 0X01, 0X03,
   0X02, 0X01, 0X00, 0X02, 0X01, 0X01, 0X02, 0X01,
   0X00, 0X02, 0X01, 0X01, 0X02, 0X03, 0X00, 0XFF,
   0XF8, 0X02, 0X01, 0X02
};

static const unsigned char ucrs_r04_vers_f[] = {  /* version field     */
   0X01, 0X0C, 0X08, 0X00, 0X04, 0X00, 0X08, 0X00
};

#ifdef XYZ1
static const unsigned char ucrs_rdp_version[] = {  /* send RDP version */
   0X01
};
#endif

static const unsigned char ucrs_rdp_pre_cert[] = {
   0X02, 0X00, 0X00, 0X80
};

#ifndef CERTMS01
//#define D_LEN_CERT_PUBLIC_KEY 64
#define D_POS_CERT_PUBLIC_KEY 1214
#define D_LEN_CERT_PUBLIC_KEY 64
//#define D_POS_CERT_EXP        1280
//#define D_LEN_CERT_EXP        3

static const unsigned char ucrs_rdp_cert[] = {
   0X02, 0X00, 0X00, 0X00, 0XCB, 0X02, 0X00, 0X00, 0X30, 0X82, 0X02, 0XC7, 0X30, 0X82, 0X02, 0X71,
   0XA0, 0X03, 0X02, 0X01, 0X02, 0X02, 0X06, 0X00, 0X94, 0X1B, 0X84, 0XA8, 0XD7, 0X30, 0X0D, 0X06,
   0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X01, 0X05, 0X05, 0X00, 0X30, 0X81, 0XD6, 0X31,
   0X0B, 0X30, 0X09, 0X06, 0X03, 0X55, 0X04, 0X06, 0X13, 0X02, 0X44, 0X45, 0X31, 0X13, 0X30, 0X11,
   0X06, 0X03, 0X55, 0X04, 0X07, 0X13, 0X0A, 0X43, 0X61, 0X64, 0X6F, 0X6C, 0X7A, 0X62, 0X75, 0X72,
   0X67, 0X31, 0X0F, 0X30, 0X0D, 0X06, 0X03, 0X55, 0X04, 0X08, 0X13, 0X06, 0X42, 0X61, 0X79, 0X65,
   0X72, 0X6E, 0X31, 0X1F, 0X30, 0X1D, 0X06, 0X03, 0X55, 0X04, 0X09, 0X13, 0X16, 0X53, 0X63, 0X68,
   0X77, 0X61, 0X64, 0X65, 0X72, 0X6D, 0X75, 0X65, 0X68, 0X6C, 0X73, 0X74, 0X72, 0X61, 0X73, 0X73,
   0X65, 0X20, 0X33, 0X31, 0X0C, 0X30, 0X0A, 0X06, 0X03, 0X55, 0X04, 0X0A, 0X13, 0X03, 0X48, 0X4F,
   0X42, 0X31, 0X1B, 0X30, 0X19, 0X06, 0X03, 0X55, 0X04, 0X0B, 0X13, 0X12, 0X52, 0X44, 0X50, 0X20,
   0X43, 0X65, 0X72, 0X74, 0X69, 0X66, 0X69, 0X63, 0X61, 0X74, 0X65, 0X20, 0X43, 0X41, 0X31, 0X0E,
   0X30, 0X0C, 0X06, 0X03, 0X55, 0X04, 0X11, 0X13, 0X05, 0X39, 0X30, 0X35, 0X35, 0X36, 0X31, 0X24,
   0X30, 0X22, 0X06, 0X03, 0X55, 0X04, 0X03, 0X13, 0X1B, 0X52, 0X44, 0X50, 0X20, 0X53, 0X65, 0X72,
   0X76, 0X65, 0X72, 0X20, 0X52, 0X6F, 0X6F, 0X74, 0X20, 0X43, 0X65, 0X72, 0X74, 0X69, 0X66, 0X69,
   0X63, 0X61, 0X74, 0X65, 0X31, 0X1F, 0X30, 0X1D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D,
   0X01, 0X09, 0X01, 0X16, 0X10, 0X6D, 0X61, 0X72, 0X6B, 0X65, 0X74, 0X69, 0X6E, 0X67, 0X40, 0X68,
   0X6F, 0X62, 0X2E, 0X64, 0X65, 0X30, 0X1E, 0X17, 0X0D, 0X30, 0X34, 0X31, 0X32, 0X30, 0X39, 0X30,
   0X37, 0X30, 0X30, 0X30, 0X30, 0X5A, 0X17, 0X0D, 0X34, 0X34, 0X31, 0X32, 0X30, 0X39, 0X30, 0X37,
   0X30, 0X30, 0X30, 0X30, 0X5A, 0X30, 0X81, 0XD6, 0X31, 0X0B, 0X30, 0X09, 0X06, 0X03, 0X55, 0X04,
   0X06, 0X13, 0X02, 0X44, 0X45, 0X31, 0X13, 0X30, 0X11, 0X06, 0X03, 0X55, 0X04, 0X07, 0X13, 0X0A,
   0X43, 0X61, 0X64, 0X6F, 0X6C, 0X7A, 0X62, 0X75, 0X72, 0X67, 0X31, 0X0F, 0X30, 0X0D, 0X06, 0X03,
   0X55, 0X04, 0X08, 0X13, 0X06, 0X42, 0X61, 0X79, 0X65, 0X72, 0X6E, 0X31, 0X1F, 0X30, 0X1D, 0X06,
   0X03, 0X55, 0X04, 0X09, 0X13, 0X16, 0X53, 0X63, 0X68, 0X77, 0X61, 0X64, 0X65, 0X72, 0X6D, 0X75,
   0X65, 0X68, 0X6C, 0X73, 0X74, 0X72, 0X61, 0X73, 0X73, 0X65, 0X20, 0X33, 0X31, 0X0C, 0X30, 0X0A,
   0X06, 0X03, 0X55, 0X04, 0X0A, 0X13, 0X03, 0X48, 0X4F, 0X42, 0X31, 0X1B, 0X30, 0X19, 0X06, 0X03,
   0X55, 0X04, 0X0B, 0X13, 0X12, 0X52, 0X44, 0X50, 0X20, 0X43, 0X65, 0X72, 0X74, 0X69, 0X66, 0X69,
   0X63, 0X61, 0X74, 0X65, 0X20, 0X43, 0X41, 0X31, 0X0E, 0X30, 0X0C, 0X06, 0X03, 0X55, 0X04, 0X11,
   0X13, 0X05, 0X39, 0X30, 0X35, 0X35, 0X36, 0X31, 0X24, 0X30, 0X22, 0X06, 0X03, 0X55, 0X04, 0X03,
   0X13, 0X1B, 0X52, 0X44, 0X50, 0X20, 0X53, 0X65, 0X72, 0X76, 0X65, 0X72, 0X20, 0X52, 0X6F, 0X6F,
   0X74, 0X20, 0X43, 0X65, 0X72, 0X74, 0X69, 0X66, 0X69, 0X63, 0X61, 0X74, 0X65, 0X31, 0X1F, 0X30,
   0X1D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X09, 0X01, 0X16, 0X10, 0X6D, 0X61,
   0X72, 0X6B, 0X65, 0X74, 0X69, 0X6E, 0X67, 0X40, 0X68, 0X6F, 0X62, 0X2E, 0X64, 0X65, 0X30, 0X5C,
   0X30, 0X0D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X01, 0X01, 0X05, 0X00, 0X03,
   0X4B, 0X00, 0X30, 0X48, 0X02, 0X41, 0X00, 0XCB, 0XB5, 0X09, 0X46, 0X90, 0XAA, 0X0E, 0X9E, 0X79,
   0X7D, 0X4B, 0XD1, 0X52, 0XCD, 0X21, 0X88, 0X6C, 0XAA, 0XE8, 0X45, 0X9E, 0XAD, 0XC9, 0XBE, 0X9D,
   0XBC, 0X9F, 0XCA, 0XF2, 0X55, 0XB7, 0XAA, 0X1F, 0X0F, 0X0B, 0X08, 0XA0, 0XA0, 0X0A, 0XE3, 0X50,
   0XCB, 0X2A, 0X99, 0X0D, 0X3B, 0X12, 0X6E, 0X9A, 0XC2, 0X0B, 0X8C, 0X63, 0XB8, 0X9B, 0X2C, 0X19,
   0XAF, 0XF9, 0X86, 0XAD, 0XD8, 0XD1, 0X8F, 0X02, 0X03, 0X01, 0X00, 0X01, 0XA3, 0X23, 0X30, 0X21,
   0X30, 0X0E, 0X06, 0X03, 0X55, 0X1D, 0X0F, 0X01, 0X01, 0XFF, 0X04, 0X04, 0X03, 0X02, 0X02, 0XBC,
   0X30, 0X0F, 0X06, 0X03, 0X55, 0X1D, 0X13, 0X01, 0X01, 0XFF, 0X04, 0X05, 0X30, 0X03, 0X01, 0X01,
   0XFF, 0X30, 0X0D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X01, 0X05, 0X05, 0X00,
   0X03, 0X41, 0X00, 0X5E, 0X38, 0XF8, 0X46, 0X79, 0XC0, 0X21, 0XFA, 0X4D, 0X7D, 0XB0, 0X8F, 0X0A,
   0X55, 0X8F, 0X11, 0XE8, 0X9F, 0X36, 0XCE, 0XD7, 0X91, 0X29, 0X0E, 0XC7, 0X53, 0X9A, 0X80, 0XB7,
   0X78, 0XCE, 0XF7, 0XE0, 0XCA, 0X04, 0X4F, 0XC5, 0X42, 0X25, 0XB7, 0XCD, 0X10, 0XE2, 0XFA, 0X71,
   0X15, 0X39, 0X3F, 0X29, 0X92, 0X31, 0XC0, 0XC2, 0X94, 0X08, 0X11, 0X04, 0X3A, 0X4F, 0XB6, 0X85,
   0X3B, 0X55, 0X9D, 0XA3, 0X02, 0X00, 0X00, 0X30, 0X82, 0X02, 0X9F, 0X30, 0X82, 0X02, 0X49, 0XA0,
   0X03, 0X02, 0X01, 0X02, 0X02, 0X06, 0X00, 0XB4, 0X1B, 0X84, 0XB1, 0XA3, 0X30, 0X0D, 0X06, 0X09,
   0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X01, 0X05, 0X05, 0X00, 0X30, 0X81, 0XD6, 0X31, 0X0B,
   0X30, 0X09, 0X06, 0X03, 0X55, 0X04, 0X06, 0X13, 0X02, 0X44, 0X45, 0X31, 0X13, 0X30, 0X11, 0X06,
   0X03, 0X55, 0X04, 0X07, 0X13, 0X0A, 0X43, 0X61, 0X64, 0X6F, 0X6C, 0X7A, 0X62, 0X75, 0X72, 0X67,
   0X31, 0X0F, 0X30, 0X0D, 0X06, 0X03, 0X55, 0X04, 0X08, 0X13, 0X06, 0X42, 0X61, 0X79, 0X65, 0X72,
   0X6E, 0X31, 0X1F, 0X30, 0X1D, 0X06, 0X03, 0X55, 0X04, 0X09, 0X13, 0X16, 0X53, 0X63, 0X68, 0X77,
   0X61, 0X64, 0X65, 0X72, 0X6D, 0X75, 0X65, 0X68, 0X6C, 0X73, 0X74, 0X72, 0X61, 0X73, 0X73, 0X65,
   0X20, 0X33, 0X31, 0X0C, 0X30, 0X0A, 0X06, 0X03, 0X55, 0X04, 0X0A, 0X13, 0X03, 0X48, 0X4F, 0X42,
   0X31, 0X1B, 0X30, 0X19, 0X06, 0X03, 0X55, 0X04, 0X0B, 0X13, 0X12, 0X52, 0X44, 0X50, 0X20, 0X43,
   0X65, 0X72, 0X74, 0X69, 0X66, 0X69, 0X63, 0X61, 0X74, 0X65, 0X20, 0X43, 0X41, 0X31, 0X0E, 0X30,
   0X0C, 0X06, 0X03, 0X55, 0X04, 0X11, 0X13, 0X05, 0X39, 0X30, 0X35, 0X35, 0X36, 0X31, 0X24, 0X30,
   0X22, 0X06, 0X03, 0X55, 0X04, 0X03, 0X13, 0X1B, 0X52, 0X44, 0X50, 0X20, 0X53, 0X65, 0X72, 0X76,
   0X65, 0X72, 0X20, 0X52, 0X6F, 0X6F, 0X74, 0X20, 0X43, 0X65, 0X72, 0X74, 0X69, 0X66, 0X69, 0X63,
   0X61, 0X74, 0X65, 0X31, 0X1F, 0X30, 0X1D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01,
   0X09, 0X01, 0X16, 0X10, 0X6D, 0X61, 0X72, 0X6B, 0X65, 0X74, 0X69, 0X6E, 0X67, 0X40, 0X68, 0X6F,
   0X62, 0X2E, 0X64, 0X65, 0X30, 0X1E, 0X17, 0X0D, 0X30, 0X34, 0X31, 0X32, 0X30, 0X39, 0X30, 0X37,
   0X30, 0X30, 0X30, 0X30, 0X5A, 0X17, 0X0D, 0X34, 0X34, 0X31, 0X32, 0X30, 0X39, 0X30, 0X37, 0X30,
   0X30, 0X30, 0X30, 0X5A, 0X30, 0X81, 0XAE, 0X31, 0X0B, 0X30, 0X09, 0X06, 0X03, 0X55, 0X04, 0X06,
   0X13, 0X02, 0X44, 0X45, 0X31, 0X13, 0X30, 0X11, 0X06, 0X03, 0X55, 0X04, 0X07, 0X13, 0X0A, 0X43,
   0X61, 0X64, 0X6F, 0X6C, 0X7A, 0X62, 0X75, 0X72, 0X67, 0X31, 0X0F, 0X30, 0X0D, 0X06, 0X03, 0X55,
   0X04, 0X08, 0X13, 0X06, 0X42, 0X61, 0X79, 0X65, 0X72, 0X6E, 0X31, 0X1F, 0X30, 0X1D, 0X06, 0X03,
   0X55, 0X04, 0X09, 0X13, 0X16, 0X53, 0X63, 0X68, 0X77, 0X61, 0X64, 0X65, 0X72, 0X6D, 0X75, 0X65,
   0X68, 0X6C, 0X73, 0X74, 0X72, 0X61, 0X73, 0X73, 0X65, 0X20, 0X33, 0X31, 0X0C, 0X30, 0X0A, 0X06,
   0X03, 0X55, 0X04, 0X0A, 0X13, 0X03, 0X48, 0X4F, 0X42, 0X31, 0X14, 0X30, 0X12, 0X06, 0X03, 0X55,
   0X04, 0X0B, 0X13, 0X0B, 0X45, 0X6E, 0X74, 0X77, 0X69, 0X63, 0X6B, 0X6C, 0X75, 0X6E, 0X67, 0X31,
   0X0E, 0X30, 0X0C, 0X06, 0X03, 0X55, 0X04, 0X11, 0X13, 0X05, 0X39, 0X30, 0X35, 0X35, 0X36, 0X31,
   0X24, 0X30, 0X22, 0X06, 0X03, 0X55, 0X04, 0X03, 0X13, 0X1B, 0X52, 0X44, 0X50, 0X20, 0X53, 0X65,
   0X72, 0X76, 0X65, 0X72, 0X20, 0X54, 0X65, 0X73, 0X74, 0X20, 0X43, 0X65, 0X72, 0X74, 0X69, 0X66,
   0X69, 0X63, 0X61, 0X74, 0X65, 0X30, 0X5C, 0X30, 0X0D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7,
   0X0D, 0X01, 0X01, 0X01, 0X05, 0X00, 0X03, 0X4B, 0X00, 0X30, 0X48, 0X02, 0X41, 0X00, 0XA8, 0X24,
   0X5D, 0X65, 0X3B, 0X7C, 0XD1, 0X62, 0X30, 0XC1, 0X75, 0X83, 0X27, 0X74, 0X8D, 0XD9, 0X88, 0X30,
   0X12, 0XD1, 0XD4, 0X15, 0XD5, 0XB4, 0X4F, 0X3F, 0X28, 0XF8, 0X21, 0XCF, 0X8B, 0X83, 0XB0, 0XB4,
   0X62, 0X93, 0XBF, 0X6B, 0XBF, 0XB1, 0XC8, 0XD6, 0X76, 0X5F, 0X13, 0X4D, 0X54, 0X5C, 0XE8, 0X45,
   0XA1, 0X3E, 0XB3, 0X53, 0X6E, 0XDA, 0X91, 0X0F, 0X5F, 0X27, 0XBC, 0X89, 0X26, 0X93, 0X02, 0X03,
   0X01, 0X00, 0X01, 0XA3, 0X23, 0X30, 0X21, 0X30, 0X0E, 0X06, 0X03, 0X55, 0X1D, 0X0F, 0X01, 0X01,
   0XFF, 0X04, 0X04, 0X03, 0X02, 0X02, 0XBC, 0X30, 0X0F, 0X06, 0X03, 0X55, 0X1D, 0X13, 0X01, 0X01,
   0XFF, 0X04, 0X05, 0X30, 0X03, 0X01, 0X01, 0XFF, 0X30, 0X0D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86,
   0XF7, 0X0D, 0X01, 0X01, 0X05, 0X05, 0X00, 0X03, 0X41, 0X00, 0XB7, 0X9C, 0X12, 0X51, 0X31, 0X9A,
   0X93, 0XE4, 0X87, 0X34, 0X9A, 0X18, 0X19, 0X9A, 0XB0, 0X2D, 0X80, 0XA5, 0X90, 0XB4, 0XCB, 0X0B,
   0XBF, 0XAE, 0XF7, 0X9C, 0XD9, 0XA9, 0X01, 0XDB, 0XCF, 0XBC, 0X66, 0X30, 0X95, 0X3D, 0X13, 0X96,
   0XE7, 0XBC, 0X27, 0X2F, 0X58, 0X61, 0X36, 0X77, 0X91, 0X19, 0X75, 0X53, 0X3B, 0X44, 0X2C, 0XB5,
   0XAA, 0X96, 0XF7, 0X23, 0X33, 0X96, 0X23, 0X98, 0X22, 0XD7,
/* 16 bytes more says Mr. Heinrich, 22.12.04 KB */
   0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00
};

//static const int ins_pos_public_key = 1214;
//static const int ins_pos_public_key = 1230;
/* displacement 0X0500 = e (public exponent) 3 bytes long, 01 00 01 */
/* 0X02, 0X41, 0X00, at position 1227: 02 = int, 41 = length 64 + 1 leading zero */

static const unsigned char ucrs_rdp_private_key[] = {
   0X56, 0X6C, 0XCA, 0XAC, 0XBC, 0X14, 0XFE, 0X32, 0XF0, 0X48, 0XA0, 0X34, 0X57, 0XD5, 0X6B, 0X0C,
   0X03, 0X1A, 0X62, 0XB2, 0X03, 0XC7, 0X6D, 0X5F, 0X0E, 0XD4, 0XB2, 0X24, 0X48, 0X8C, 0XBB, 0X72,
   0X91, 0X55, 0X76, 0XC5, 0XC0, 0XD7, 0X11, 0X34, 0X7E, 0XFF, 0XC8, 0X22, 0XCB, 0X27, 0X4C, 0XEF,
   0XC0, 0X5C, 0X76, 0XFA, 0XC4, 0XA3, 0X72, 0X27, 0X1E, 0X45, 0XD7, 0XB7, 0X27, 0XB1, 0X42, 0X01
};
#else
//#define D_LEN_CERT_PUBLIC_KEY 64
#define D_POS_CERT_PUBLIC_KEY 638
#define D_LEN_CERT_PUBLIC_KEY 64
//#define D_POS_CERT_EXP        704
//#define D_LEN_CERT_EXP        3

static const unsigned char ucrs_rdp_cert[] = {
   0X02, 0X00, 0X00, 0X00, 0X57, 0X01, 0X00, 0X00, 0X30, 0X82, 0X01,
   0X53, 0X30, 0X82, 0X01, 0X01, 0XA0, 0X03, 0X02, 0X01, 0X02, 0X02, 0X08, 0X01, 0X9D, 0XE9, 0XB1,
   0XD3, 0X32, 0X67, 0X80, 0X30, 0X09, 0X06, 0X05, 0X2B, 0X0E, 0X03, 0X02, 0X1D, 0X05, 0X00, 0X30,
   0X28, 0X31, 0X26, 0X30, 0X0D, 0X06, 0X03, 0X55, 0X04, 0X07, 0X1E, 0X06, 0X00, 0X57, 0X00, 0X54,
   0X00, 0X53, 0X30, 0X15, 0X06, 0X03, 0X55, 0X04, 0X03, 0X1E, 0X0E, 0X00, 0X48, 0X00, 0X4F, 0X00,
   0X42, 0X00, 0X5A, 0X00, 0X30, 0X00, 0X31, 0X00, 0X4B, 0X30, 0X1E, 0X17, 0X0D, 0X37, 0X30, 0X30,
   0X33, 0X31, 0X33, 0X30, 0X30, 0X35, 0X38, 0X35, 0X34, 0X5A, 0X17, 0X0D, 0X34, 0X39, 0X30, 0X33,
   0X31, 0X33, 0X30, 0X30, 0X35, 0X38, 0X35, 0X34, 0X5A, 0X30, 0X28, 0X31, 0X26, 0X30, 0X0D, 0X06,
   0X03, 0X55, 0X04, 0X07, 0X1E, 0X06, 0X00, 0X57, 0X00, 0X54, 0X00, 0X53, 0X30, 0X15, 0X06, 0X03,
   0X55, 0X04, 0X03, 0X1E, 0X0E, 0X00, 0X48, 0X00, 0X4F, 0X00, 0X42, 0X00, 0X5A, 0X00, 0X30, 0X00,
   0X31, 0X00, 0X4B, 0X30, 0X5C, 0X30, 0X0D, 0X06, 0X09, 0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01,
   0X01, 0X01, 0X05, 0X00, 0X03, 0X4B, 0X00, 0X30, 0X48, 0X02, 0X41, 0X00, 0XED, 0XFC, 0X0D, 0XCC,
   0XCD, 0X4D, 0X1E, 0X4C, 0X6B, 0XFC, 0X78, 0X8D, 0XED, 0XB3, 0X8F, 0X33, 0XBE, 0X7A, 0XB8, 0X9E,
   0X71, 0XAC, 0X47, 0XEE, 0X9A, 0XF1, 0X87, 0XC4, 0X85, 0X12, 0X40, 0X59, 0X25, 0X50, 0X56, 0X28,
   0XF2, 0X71, 0X49, 0XC6, 0XE2, 0XD5, 0X40, 0X4B, 0X31, 0X6E, 0X93, 0XA2, 0X13, 0X0D, 0X23, 0XE6,
   0XB7, 0X2F, 0XB2, 0X52, 0X41, 0XD6, 0X6D, 0XA3, 0X62, 0XAF, 0X8B, 0X77, 0X02, 0X03, 0X01, 0X00,
   0X01, 0XA3, 0X13, 0X30, 0X11, 0X30, 0X0F, 0X06, 0X03, 0X55, 0X1D, 0X13, 0X04, 0X08, 0X30, 0X06,
   0X01, 0X01, 0XFF, 0X02, 0X01, 0X00, 0X30, 0X09, 0X06, 0X05, 0X2B, 0X0E, 0X03, 0X02, 0X1D, 0X05,
   0X00, 0X03, 0X41, 0X00, 0X27, 0XD1, 0X1E, 0X18, 0X0F, 0X1A, 0XFB, 0X7D, 0XF8, 0XCB, 0X81, 0XA4,
   0XBF, 0XAE, 0X18, 0X3B, 0X3E, 0XAC, 0XE5, 0XD4, 0X00, 0XB6, 0X90, 0XA2, 0XA6, 0XD9, 0XF1, 0X5F,
   0X6B, 0XD7, 0X0B, 0X68, 0XF6, 0X85, 0XD8, 0XD6, 0XC0, 0X68, 0XB9, 0XAA, 0X90, 0X4F, 0X27, 0XE7,
   0X34, 0X8C, 0X06, 0XC0, 0X14, 0X6F, 0X1A, 0XDC, 0XE0, 0X26, 0X30, 0X51, 0X10, 0X54, 0X66, 0X25,
   0XEB, 0X98, 0XB2, 0X07, 0X69, 0X03, 0X00, 0X00, 0X30, 0X82, 0X03, 0X65, 0X30, 0X82, 0X03, 0X13,
   0XA0, 0X03, 0X02, 0X01, 0X02, 0X02, 0X05, 0X01, 0X00, 0X00, 0X00, 0X01, 0X30, 0X09, 0X06, 0X05,
   0X2B, 0X0E, 0X03, 0X02, 0X1D, 0X05, 0X00, 0X30, 0X28, 0X31, 0X26, 0X30, 0X0D, 0X06, 0X03, 0X55,
   0X04, 0X07, 0X1E, 0X06, 0X00, 0X57, 0X00, 0X54, 0X00, 0X53, 0X30, 0X15, 0X06, 0X03, 0X55, 0X04,
   0X03, 0X1E, 0X0E, 0X00, 0X48, 0X00, 0X4F, 0X00, 0X42, 0X00, 0X5A, 0X00, 0X30, 0X00, 0X31, 0X00,
   0X4B, 0X30, 0X1E, 0X17, 0X0D, 0X38, 0X30, 0X30, 0X31, 0X30, 0X31, 0X30, 0X38, 0X30, 0X30, 0X30,
   0X30, 0X5A, 0X17, 0X0D, 0X33, 0X38, 0X30, 0X31, 0X31, 0X39, 0X30, 0X33, 0X31, 0X34, 0X30, 0X37,
   0X5A, 0X30, 0X81, 0X96, 0X31, 0X81, 0X93, 0X30, 0X25, 0X06, 0X03, 0X55, 0X04, 0X03, 0X1E, 0X1E,
   0X00, 0X6E, 0X00, 0X63, 0X00, 0X61, 0X00, 0X6C, 0X00, 0X72, 0X00, 0X70, 0X00, 0X63, 0X00, 0X3A,
   0X00, 0X48, 0X00, 0X4F, 0X00, 0X42, 0X00, 0X5A, 0X00, 0X30, 0X00, 0X31, 0X00, 0X4B, 0X30, 0X25,
   0X06, 0X03, 0X55, 0X04, 0X07, 0X1E, 0X1E, 0X00, 0X6E, 0X00, 0X63, 0X00, 0X61, 0X00, 0X6C, 0X00,
   0X72, 0X00, 0X70, 0X00, 0X63, 0X00, 0X3A, 0X00, 0X48, 0X00, 0X4F, 0X00, 0X42, 0X00, 0X5A, 0X00,
   0X30, 0X00, 0X31, 0X00, 0X4B, 0X30, 0X43, 0X06, 0X03, 0X55, 0X04, 0X05, 0X1E, 0X3C, 0X00, 0X31,
   0X00, 0X42, 0X00, 0X63, 0X00, 0X4B, 0X00, 0X65, 0X00, 0X58, 0X00, 0X61, 0X00, 0X4A, 0X00, 0X66,
   0X00, 0X61, 0X00, 0X57, 0X00, 0X7A, 0X00, 0X39, 0X00, 0X69, 0X00, 0X50, 0X00, 0X50, 0X00, 0X79,
   0X00, 0X37, 0X00, 0X49, 0X00, 0X4C, 0X00, 0X6C, 0X00, 0X6F, 0X00, 0X51, 0X00, 0X64, 0X00, 0X2F,
   0X00, 0X46, 0X00, 0X59, 0X00, 0X3D, 0X00, 0X0D, 0X00, 0X0A, 0X30, 0X5C, 0X30, 0X0D, 0X06, 0X09,
   0X2A, 0X86, 0X48, 0X86, 0XF7, 0X0D, 0X01, 0X01, 0X04, 0X05, 0X00, 0X03, 0X4B, 0X00, 0X30, 0X48,
   0X02, 0X41, 0X00, 0XD1, 0X3A, 0X18, 0X04, 0X6C, 0X54, 0X6F, 0XD2, 0X86, 0XA6, 0XA3, 0XE8, 0X68,
   0XEB, 0XA5, 0X14, 0XF1, 0XB6, 0X20, 0X32, 0X23, 0X9E, 0XFF, 0X72, 0X2F, 0X0C, 0X59, 0XE8, 0X2C,
   0X1D, 0X50, 0XD5, 0X1D, 0X11, 0XEC, 0X39, 0XEB, 0XFA, 0X81, 0X92, 0X28, 0XB2, 0XAA, 0XB4, 0XA0,
   0X30, 0X90, 0XE1, 0X4E, 0X76, 0XD3, 0XD2, 0X5B, 0XE7, 0X3D, 0X1C, 0XBA, 0X69, 0X74, 0XB4, 0X0A,
   0X3B, 0X48, 0X49, 0X02, 0X03, 0X01, 0X00, 0X01, 0XA3, 0X82, 0X01, 0XB7, 0X30, 0X82, 0X01, 0XB3,
   0X30, 0X14, 0X06, 0X09, 0X2B, 0X06, 0X01, 0X04, 0X01, 0X82, 0X37, 0X12, 0X04, 0X01, 0X01, 0XFF,
   0X04, 0X04, 0X01, 0X00, 0X05, 0X00, 0X30, 0X3C, 0X06, 0X09, 0X2B, 0X06, 0X01, 0X04, 0X01, 0X82,
   0X37, 0X12, 0X02, 0X01, 0X01, 0XFF, 0X04, 0X2C, 0X4D, 0X00, 0X69, 0X00, 0X63, 0X00, 0X72, 0X00,
   0X6F, 0X00, 0X73, 0X00, 0X6F, 0X00, 0X66, 0X00, 0X74, 0X00, 0X20, 0X00, 0X43, 0X00, 0X6F, 0X00,
   0X72, 0X00, 0X70, 0X00, 0X6F, 0X00, 0X72, 0X00, 0X61, 0X00, 0X74, 0X00, 0X69, 0X00, 0X6F, 0X00,
   0X6E, 0X00, 0X00, 0X00, 0X30, 0X81, 0XCD, 0X06, 0X09, 0X2B, 0X06, 0X01, 0X04, 0X01, 0X82, 0X37,
   0X12, 0X05, 0X01, 0X01, 0XFF, 0X04, 0X81, 0XBC, 0X00, 0X30, 0X00, 0X00, 0X01, 0X00, 0X00, 0X00,
   0X02, 0X00, 0X00, 0X00, 0X09, 0X04, 0X00, 0X00, 0X1C, 0X00, 0X4A, 0X00, 0X66, 0X00, 0X4A, 0X00,
   0XB0, 0X00, 0X01, 0X00, 0X33, 0X00, 0X64, 0X00, 0X32, 0X00, 0X36, 0X00, 0X37, 0X00, 0X39, 0X00,
   0X35, 0X00, 0X34, 0X00, 0X2D, 0X00, 0X65, 0X00, 0X65, 0X00, 0X62, 0X00, 0X37, 0X00, 0X2D, 0X00,
   0X31, 0X00, 0X31, 0X00, 0X64, 0X00, 0X31, 0X00, 0X2D, 0X00, 0X62, 0X00, 0X39, 0X00, 0X34, 0X00,
   0X65, 0X00, 0X2D, 0X00, 0X30, 0X00, 0X30, 0X00, 0X63, 0X00, 0X30, 0X00, 0X34, 0X00, 0X66, 0X00,
   0X61, 0X00, 0X33, 0X00, 0X30, 0X00, 0X38, 0X00, 0X30, 0X00, 0X64, 0X00, 0X00, 0X00, 0X33, 0X00,
   0X64, 0X00, 0X32, 0X00, 0X36, 0X00, 0X37, 0X00, 0X39, 0X00, 0X35, 0X00, 0X34, 0X00, 0X2D, 0X00,
   0X65, 0X00, 0X65, 0X00, 0X62, 0X00, 0X37, 0X00, 0X2D, 0X00, 0X31, 0X00, 0X31, 0X00, 0X64, 0X00,
   0X31, 0X00, 0X2D, 0X00, 0X62, 0X00, 0X39, 0X00, 0X34, 0X00, 0X65, 0X00, 0X2D, 0X00, 0X30, 0X00,
   0X30, 0X00, 0X63, 0X00, 0X30, 0X00, 0X34, 0X00, 0X66, 0X00, 0X61, 0X00, 0X33, 0X00, 0X30, 0X00,
   0X38, 0X00, 0X30, 0X00, 0X64, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X10, 0X00, 0X80, 0XD4, 0X00,
   0X00, 0X00, 0X00, 0X00, 0X30, 0X64, 0X06, 0X09, 0X2B, 0X06, 0X01, 0X04, 0X01, 0X82, 0X37, 0X12,
   0X06, 0X01, 0X01, 0XFF, 0X04, 0X54, 0X00, 0X30, 0X00, 0X00, 0X00, 0X00, 0X10, 0X00, 0X40, 0X00,
   0X48, 0X00, 0X4F, 0X00, 0X42, 0X00, 0X5A, 0X00, 0X30, 0X00, 0X31, 0X00, 0X4B, 0X00, 0X00, 0X00,
   0X35, 0X00, 0X31, 0X00, 0X38, 0X00, 0X37, 0X00, 0X36, 0X00, 0X2D, 0X00, 0X32, 0X00, 0X37, 0X00,
   0X30, 0X00, 0X2D, 0X00, 0X39, 0X00, 0X30, 0X00, 0X32, 0X00, 0X39, 0X00, 0X31, 0X00, 0X34, 0X00,
   0X33, 0X00, 0X2D, 0X00, 0X35, 0X00, 0X31, 0X00, 0X34, 0X00, 0X37, 0X00, 0X31, 0X00, 0X00, 0X00,
   0X57, 0X00, 0X54, 0X00, 0X53, 0X00, 0X00, 0X00, 0X00, 0X00, 0X30, 0X27, 0X06, 0X03, 0X55, 0X1D,
   0X23, 0X01, 0X01, 0XFF, 0X04, 0X1D, 0X30, 0X1B, 0XA1, 0X12, 0XA4, 0X10, 0X48, 0X00, 0X4F, 0X00,
   0X42, 0X00, 0X5A, 0X00, 0X30, 0X00, 0X31, 0X00, 0X4B, 0X00, 0X00, 0X00, 0X82, 0X05, 0X01, 0X00,
   0X00, 0X00, 0X01, 0X30, 0X09, 0X06, 0X05, 0X2B, 0X0E, 0X03, 0X02, 0X1D, 0X05, 0X00, 0X03, 0X41,
   0X00, 0X2C, 0XB7, 0X0A, 0X4E, 0XF8, 0XAA, 0X43, 0X34, 0X74, 0XA5, 0XA5, 0X63, 0X3F, 0X4E, 0XFE,
   0X2D, 0X40, 0X36, 0X69, 0XA1, 0X11, 0X58, 0XC9, 0X0C, 0X2D, 0XDE, 0XE3, 0XA6, 0XE8, 0XDD, 0XCE,
   0XB6, 0X93, 0XC2, 0XF4, 0X27, 0XAF, 0XA5, 0XF1, 0XD8, 0XCB, 0XC2, 0X41, 0X8E, 0X7B, 0XC9, 0XD2,
   0X68, 0XD8, 0X8C, 0XFD, 0X0F, 0XEF, 0XF0, 0X5B, 0X7B, 0XA9, 0X2E, 0X83, 0XB1, 0XBB, 0X80, 0X6A,
   0X10, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00,
   0X00
};

static const unsigned char ucrs_rdp_private_key[] = {
   0XB8, 0X4B, 0X22, 0XA2, 0XAA, 0XC5, 0X49, 0X66, 0X38, 0X63, 0X0A, 0X57, 0X8A, 0X2B, 0X9E, 0XD2,
   0XAF, 0X02, 0X4C, 0XA3, 0XBD, 0X8A, 0XAC, 0XD9, 0X68, 0X25, 0XC9, 0XFF, 0XDE, 0XF3, 0XC7, 0XA1,
   0X07, 0X12, 0XE8, 0X9F, 0XCA, 0X41, 0X52, 0XA5, 0XCD, 0X51, 0X95, 0XD2, 0X3C, 0XF5, 0XA0, 0X5C,
   0X6D, 0X7A, 0XCE, 0X08, 0X9E, 0XB9, 0X58, 0XC3, 0X19, 0X4B, 0X42, 0X4B, 0X62, 0X23, 0X94, 0X6D
};
#endif

static const int imrs_colour_r_tab[] = {    /* reverse colour table    */
   0, 0X10, 0X30, 0X70, 0XF0
};

#ifdef TRACEHL_COM1
static int ims_no_order = 0;                /* count orders            */
#endif

static BOOL m_send_cl_r04( struct dsd_call_rdpserv_1 *, struct dsd_output_area_1 * );
static void m_gen_keys( struct dsd_call_rdpserv_1 *, char *, struct dsd_rdp_co *, char * );
static BOOL m_prepare_keys( struct dsd_call_rdpserv_1 *, struct dsd_rdp_co * );
static void m_update_keys( struct dsd_rdp_co *, struct dsd_rdp_encry *, char * );
static void m_gen_lic_keys( struct dsd_rdp_lic_d *, char * );
static BOOL m_make_screen( struct dsd_call_rdpserv_1 *, char * );
static struct dsd_cache_1 * m_make_cache( struct dsd_call_rdpserv_1 *, int, int );
static BOOL m_r5order_xx_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_00_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_01_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_09_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_0a_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_0b_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_0d_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_0e_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_12_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_13_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_16_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_r5order_18_s( struct dsd_call_rdpserv_1 *, char * );
static BOOL m_check_hash_inp_rdp5( struct dsd_call_rdpserv_1 *adsp_hl_clib_1, char *achp_data, int imp_len_data );
static BOOL m_send_cl_event_rdp5( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *, char *, int, int );
static void m_send_se2cl_r01( struct dsd_call_rdpserv_1 *,
                              struct dsd_output_area_1 * );
static BOOL m_send_se2cl_after_logon( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 * );
// JB: Included for the server to be able to change screen size. 
static BOOL m_send_se2cl_demand_active( struct dsd_call_rdpserv_1 *,
                                        struct dsd_output_area_1 * );
static BOOL m_send_se2cl_deactivate_all( struct dsd_call_rdpserv_1 *,
                                         struct dsd_output_area_1 * );
static BOOL m_send_se2cl_after_conf_actpdu( struct dsd_call_rdpserv_1 *,
                                            struct dsd_output_area_1 * );
static BOOL m_send_se2cl_end( struct dsd_call_rdpserv_1 *,
                              struct dsd_output_area_1 *, ied_sc_command, char * );
static void m_send_draw_sc_s_normal( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_draw_sc *,
                                     char * );
static BOOL m_send_draw_sc_s_compr( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_draw_sc *,
                                    char * );
static void m_send_draw_sc_24_normal( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 *,
                                      struct dsd_sc_draw_sc *,
                                      char * );
static BOOL m_send_draw_sc_24_compr( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_draw_sc *,
                                     char * );
static void m_send_draw_sc_i_normal( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_draw_sc *,
                                     char * );
static BOOL m_send_draw_sc_i_compr( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_draw_sc *,
                                    char * );
static BOOL m_send_draw_sc_bmc_normal( struct dsd_call_rdpserv_1 *,
                                       struct dsd_output_area_1 *,
                                       struct dsd_sc_draw_sc *,
                                       char * );
static BOOL m_send_draw_sc_bmc_compr( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 *,
                                      struct dsd_sc_draw_sc *,
                                      char * );
static BOOL m_bmc_get_wa( struct dsd_bitmap_compr_1 * );
static struct dsd_sc_co1 * m_send_order_scrblt( struct dsd_call_rdpserv_1 *,
                                                struct dsd_output_area_1 *,
                                                struct dsd_sc_co1 *,
                                                char * );
static void m_send_order_memblt( struct dsd_call_rdpserv_1 *,
                                 struct dsd_output_area_1 *,
                                 struct dsd_sc_order_memblt *,
                                 char * );
static void m_send_order_mem3blt( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *,
                                  struct dsd_sc_order_mem3blt *,
                                  char * );
static void m_send_order_savebitmap( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_order_savebitmap *,
                                     char * );
static void m_send_order_cachebitmap( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 *,
                                      struct dsd_sc_order_cachebitmap *,
                                      char * );
// JB: included for the server, needed by MacGate, SM
static void m_send_order_cachebrush( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_order_cachebrush *,
                                     char * );
static BOOL m_send_order_new_font( struct dsd_call_rdpserv_1 *,
                                   struct dsd_output_area_1 *,
                                   struct dsd_font *,
                                   char * );
static BOOL m_send_order_delete_font( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 *,
                                      struct dsd_font *,
                                      char * );
static BOOL m_send_order_drawstring( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_order_drawstring *,
                                     char * );
static void m_send_mpoi_system( struct dsd_call_rdpserv_1 *,
                                struct dsd_output_area_1 *,
                                struct dsd_sc_mpoi_system *,
                                char * );
static void m_send_mpoi_position( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *,
                                  struct dsd_sc_mpoi_position *,
                                  char * );
static BOOL m_send_mpoi_color( struct dsd_call_rdpserv_1 *,
                               struct dsd_output_area_1 *,
                               struct dsd_sc_mpoi_color *,
                               char * );
static BOOL m_send_mpoi_pointer( struct dsd_call_rdpserv_1 *,
                                 struct dsd_output_area_1 *,
                                 struct dsd_sc_mpoi_pointer *,
                                 char * );
static void m_send_mpoi_cached( struct dsd_call_rdpserv_1 *,
                                struct dsd_output_area_1 *,
                                struct dsd_sc_mpoi_cached *,
                                char * );
static void m_send_error_info( struct dsd_call_rdpserv_1 *,
                               struct dsd_output_area_1 *,
                               struct dsd_sc_error_info *,
                               char * );
static void m_send_shutdown_deny( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *,
                                  char * );
static BOOL m_send_order_patblt( struct dsd_call_rdpserv_1 *,
                                 struct dsd_output_area_1 *,
                                 struct dsd_sc_order_patblt *,
                                 char * );
static void m_send_order_opaquerect( struct dsd_call_rdpserv_1 *,
                                     struct dsd_output_area_1 *,
                                     struct dsd_sc_order_opaquerect *,
                                     char * );
static BOOL m_send_order_lineto( struct dsd_call_rdpserv_1 *,
                                 struct dsd_output_area_1 *,
                                 struct dsd_sc_order_lineto *,
                                 char * );
static BOOL m_send_order_polyline( struct dsd_call_rdpserv_1 *,
                                   struct dsd_output_area_1 *,
                                   struct dsd_sc_order_polyline *,
                                   char * );
static void m_send_order_polygonsc( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_order_polygonsc *,
                                    char * );
static void m_send_order_polygoncb( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_order_polygoncb *,
                                    char * );
static void m_send_order_ellipsesc( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_order_ellipsesc *,
                                    char * );
static void m_send_order_ellipsecb( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    struct dsd_sc_order_ellipsecb *,
                                    char * );
static void m_send_order_createoffbitmap( struct dsd_call_rdpserv_1 *,
                                          struct dsd_output_area_1 *,
                                          struct dsd_sc_order_createoffbitmap *,
                                          char * );
static void m_send_order_switchsurface( struct dsd_call_rdpserv_1 *,
                                        struct dsd_output_area_1 *,
                                        struct dsd_sc_order_switchsurface *,
                                        char * );
// JB: Incuded for SM, MacGate
static void m_send_order_framemarker( struct dsd_call_rdpserv_1 *,
                                      struct dsd_output_area_1 *,
                                      struct dsd_sc_order_framemarker *,
                                      char * );
static void m_send_frame_open( struct dsd_call_rdpserv_1 *,
                               struct dsd_output_area_1 *,
                               char * );
static void m_send_frame_close( struct dsd_call_rdpserv_1 *,
                                struct dsd_output_area_1 *,
                                char * );
static void m_send_frame_order_o( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *,
                                  char * );
static void m_send_frame_order_c( struct dsd_call_rdpserv_1 *,
                                  struct dsd_output_area_1 *,
                                  char * );
// JB: See comment at function
static void m_check_fastpath_frame( struct dsd_call_rdpserv_1 *,
                                    struct dsd_output_area_1 *,
                                    char * );
static BOOL m_send_vch_out( struct dsd_call_rdpserv_1 *,
                            struct dsd_output_area_1 *,
                            struct dsd_sc_vch_out *,
                            char * );
static inline int m_pos_array_glyph( int *, int, int );
static unsigned short int m_rop2_0_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_1_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_2_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_3_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_4_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_5_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_6_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_7_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_8_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_9_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_a_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_b_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_c_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_d_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_e_s( unsigned short int, unsigned short int );
static unsigned short int m_rop2_f_s( unsigned short int, unsigned short int );
static unsigned int m_rop2_0_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_1_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_2_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_3_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_4_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_5_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_6_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_7_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_8_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_9_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_a_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_b_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_c_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_d_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_e_24oi( unsigned int, unsigned int );
static unsigned int m_rop2_f_24oi( unsigned int, unsigned int );
static unsigned short int m_rop3_00_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_01_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_02_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_03_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_04_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_05_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_06_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_07_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_08_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_09_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_0f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_10_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_11_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_12_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_13_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_14_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_15_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_16_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_17_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_18_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_19_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_1f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_20_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_21_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_22_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_23_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_24_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_25_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_26_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_27_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_28_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_29_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_2f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_30_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_31_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_32_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_33_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_34_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_35_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_36_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_37_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_38_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_39_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_3f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_40_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_41_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_42_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_43_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_44_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_45_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_46_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_47_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_48_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_49_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_4f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_50_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_51_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_52_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_53_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_54_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_55_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_56_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_57_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_58_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_59_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_5f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_60_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_61_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_62_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_63_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_64_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_65_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_66_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_67_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_68_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_69_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_6f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_70_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_71_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_72_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_73_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_74_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_75_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_76_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_77_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_78_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_79_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_7f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_80_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_81_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_82_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_83_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_84_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_85_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_86_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_87_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_88_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_89_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_8f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_90_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_91_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_92_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_93_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_94_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_95_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_96_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_97_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_98_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_99_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9a_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9b_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9c_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9d_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9e_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_9f_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_a9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_aa_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ab_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ac_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ad_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ae_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_af_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_b9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ba_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_bb_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_bc_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_bd_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_be_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_bf_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_c9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ca_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_cb_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_cc_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_cd_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ce_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_cf_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_d9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_da_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_db_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_dc_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_dd_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_de_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_df_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_e9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ea_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_eb_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ec_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ed_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ee_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ef_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f0_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f1_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f2_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f3_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f4_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f5_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f6_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f7_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f8_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_f9_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_fa_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_fb_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_fc_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_fd_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_fe_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned short int m_rop3_ff_s( unsigned short int, unsigned short int, unsigned short int );
static unsigned int m_rop3_00_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_01_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_02_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_03_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_04_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_05_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_06_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_07_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_08_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_09_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_0f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_10_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_11_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_12_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_13_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_14_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_15_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_16_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_17_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_18_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_19_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_1f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_20_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_21_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_22_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_23_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_24_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_25_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_26_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_27_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_28_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_29_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_2f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_30_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_31_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_32_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_33_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_34_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_35_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_36_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_37_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_38_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_39_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_3f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_40_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_41_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_42_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_43_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_44_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_45_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_46_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_47_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_48_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_49_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_4f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_50_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_51_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_52_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_53_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_54_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_55_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_56_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_57_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_58_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_59_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_5f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_60_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_61_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_62_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_63_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_64_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_65_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_66_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_67_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_68_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_69_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_6f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_70_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_71_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_72_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_73_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_74_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_75_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_76_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_77_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_78_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_79_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_7f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_80_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_81_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_82_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_83_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_84_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_85_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_86_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_87_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_88_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_89_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_8f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_90_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_91_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_92_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_93_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_94_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_95_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_96_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_97_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_98_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_99_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9a_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9b_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9c_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9d_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9e_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_9f_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_a9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_aa_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ab_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ac_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ad_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ae_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_af_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_b9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ba_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_bb_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_bc_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_bd_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_be_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_bf_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_c9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ca_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_cb_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_cc_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_cd_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ce_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_cf_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_d9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_da_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_db_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_dc_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_dd_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_de_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_df_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_e9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ea_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_eb_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ec_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ed_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ee_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ef_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f0_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f1_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f2_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f3_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f4_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f5_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f6_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f7_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f8_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_f9_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_fa_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_fb_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_fc_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_fd_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_fe_24oi( unsigned int, unsigned int, unsigned int );
static unsigned int m_rop3_ff_24oi( unsigned int, unsigned int, unsigned int );
static inline short int m_get_le2( char * );
static inline int m_get_le4( char * );
static inline void m_put_le2( char *, int );
static inline void m_put_le4( char *, int );
static inline void m_put_be2( char *, int );
// JB: included to parse HOB_CAPS
static inline BOOL m_gather_skip( dsd_gather_i_1** aads_gather, int im_skip, int* aim_counter );
static inline BOOL m_gather_get_byte( dsd_gather_i_1** aads_gather, int* aim_counter, char* ach_retval);
static inline BOOL m_gather_get_le( dsd_gather_i_1** aads_gather, int im_bytes, int* aim_counter, int* aim_retval);
static inline BOOL m_gather_get_hasn( dsd_gather_i_1** aads_gather, int* aim_counter, int* aim_retval );
#ifdef TRACEHL_BMP_060827
#ifndef D_CONSOLE_OUT
#define D_CONSOLE_OUT
#endif
#endif
#ifdef TRACEHL1
#ifndef D_CONSOLE_OUT
#define D_CONSOLE_OUT
#endif
#endif
#ifdef D_CONSOLE_OUT
static void m_console_out( char *achp_buff, int implength );
#else
#endif
static const char chrstrans[]
     = { '0', '1', '2', '3', '4', '5', '6', '7',
         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
static int m_avl_cmp_unicode_char( void *, struct dsd_htree1_avl_entry *, struct dsd_htree1_avl_entry * );
static struct dsd_glyph * m_cr_getstorglyph( void *, int );
static int m_sdh_printf( struct dsd_call_rdpserv_1 *, char *, ... );

static char * m_ret_t_ied_fcfp_bl( ied_fcfp_bl );
static char * m_ret_t_ied_frcl_bl( ied_frcl_bl );


static const struct dsd_progaddr_1 dsrs_progaddr_1[4] = {  /* program addresses */
   {                                        /* char, 8 bits per pixel */
     &m_r5order_00_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
     &m_r5order_00_s,
   &m_rop2_0_24oi,
   &m_rop2_1_24oi,
   &m_rop2_2_24oi,
   &m_rop2_3_24oi,
   &m_rop2_4_24oi,
   &m_rop2_5_24oi,
   &m_rop2_6_24oi,
   &m_rop2_7_24oi,
   &m_rop2_8_24oi,
   &m_rop2_9_24oi,
   &m_rop2_a_24oi,
   &m_rop2_b_24oi,
   &m_rop2_c_24oi,
   &m_rop2_d_24oi,
   &m_rop2_e_24oi,
   &m_rop2_f_24oi,
   },
   {                                        /* short, 15 or 16 bits per pixel */
     &m_r5order_00_s,
     &m_r5order_01_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_09_s,
     &m_r5order_0a_s,
     &m_r5order_0b_s,
     &m_r5order_xx_s,
     &m_r5order_0d_s,
     &m_r5order_0e_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_12_s,
     &m_r5order_13_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_16_s,
     &m_r5order_xx_s,
     &m_r5order_18_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
     &m_r5order_xx_s,
   &m_rop2_0_24oi,
   &m_rop2_1_24oi,
   &m_rop2_2_24oi,
   &m_rop2_3_24oi,
   &m_rop2_4_24oi,
   &m_rop2_5_24oi,
   &m_rop2_6_24oi,
   &m_rop2_7_24oi,
   &m_rop2_8_24oi,
   &m_rop2_9_24oi,
   &m_rop2_a_24oi,
   &m_rop2_b_24oi,
   &m_rop2_c_24oi,
   &m_rop2_d_24oi,
   &m_rop2_e_24oi,
   &m_rop2_f_24oi,
   },
   {                                        /* int, 24 bits per pixel  */
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
   &m_rop2_0_24oi,
   &m_rop2_1_24oi,
   &m_rop2_2_24oi,
   &m_rop2_3_24oi,
   &m_rop2_4_24oi,
   &m_rop2_5_24oi,
   &m_rop2_6_24oi,
   &m_rop2_7_24oi,
   &m_rop2_8_24oi,
   &m_rop2_9_24oi,
   &m_rop2_a_24oi,
   &m_rop2_b_24oi,
   &m_rop2_c_24oi,
   &m_rop2_d_24oi,
   &m_rop2_e_24oi,
   &m_rop2_f_24oi,
   },
   {                                        /* int, 32 bits per pixel  */
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
   &m_rop2_0_24oi,
   &m_rop2_1_24oi,
   &m_rop2_2_24oi,
   &m_rop2_3_24oi,
   &m_rop2_4_24oi,
   &m_rop2_5_24oi,
   &m_rop2_6_24oi,
   &m_rop2_7_24oi,
   &m_rop2_8_24oi,
   &m_rop2_9_24oi,
   &m_rop2_a_24oi,
   &m_rop2_b_24oi,
   &m_rop2_c_24oi,
   &m_rop2_d_24oi,
   &m_rop2_e_24oi,
   &m_rop2_f_24oi,
   }
};
//----- 10.07.09
/* Predefined hatch brush patterns. */
static const unsigned char ucrs_brush_01[ 6 * 8 ] = {
   /* LSB least significant bit is for leftmost pixel                  */
   /* HS_HORIZONTAL                                                    */
   0XFF, 0XFF, 0XFF, 0XFF, 0X00, 0XFF, 0XFF, 0XFF,
   /* HS_VERTICAL                                                      */
   0XEF, 0XEF, 0XEF, 0XEF, 0XEF, 0XEF, 0XEF, 0XEF,
   /* HS_FDIAGONAL                                                     */
   0X7F, 0XBF, 0XDF, 0XEF, 0XF7, 0XFB, 0XFD, 0XFE,
   /* HS_BDIAGONAL                                                     */
   0XFE, 0XFD, 0XFB, 0XF7, 0XEF, 0XDF, 0XBF, 0X7F,
   /* HS_CROSS                                                         */
   0XEF, 0XEF, 0XEF, 0XEF, 0X00, 0XEF, 0XEF, 0XEF,
   /* HS_DIAGCROSS                                                     */
   0X7E, 0XBD, 0XDB, 0XE7, 0XE7, 0XDB, 0XBD, 0X7E
};
//----- 10.07.09
static const unsigned char ucrs_invert_bits[ 256 ] = {
   0,   128, 64,  192, 32,  160, 96,  224,
   16,  144, 80,  208, 48,  176, 112, 240,
   8,   136, 72,  200, 40,  168, 104, 232,
   24,  152, 88,  216, 56,  184, 120, 248,
   4,   132, 68,  196, 36,  164, 100, 228,
   20,  148, 84,  212, 52,  180, 116, 244,
   12,  140, 76,  204, 44,  172, 108, 236,
   28,  156, 92,  220, 60,  188, 124, 252,
   2,   130, 66,  194, 34,  162, 98,  226,
   18,  146, 82,  210, 50,  178, 114, 242,
   10,  138, 74,  202, 42,  170, 106, 234,
   26,  154, 90,  218, 58,  186, 122, 250,
   6,   134, 70,  198, 38,  166, 102, 230,
   22,  150, 86,  214, 54,  182, 118, 246,
   14,  142, 78,  206, 46,  174, 110, 238,
   30,  158, 94,  222, 62,  190, 126, 254,
   1,   129, 65,  193, 33,  161, 97,  225,
   17,  145, 81,  209, 49,  177, 113, 241,
   9,   137, 73,  201, 41,  169, 105, 233,
   25,  153, 89,  217, 57,  185, 121, 249,
   5,   133, 69,  197, 37,  165, 101, 229,
   21,  149, 85,  213, 53,  181, 117, 245,
   13,  141, 77,  205, 45,  173, 109, 237,
   29,  157, 93,  221, 61,  189, 125, 253,
   3,   131, 67,  195, 35,  163, 99,  227,
   19,  147, 83,  211, 51,  179, 115, 243,
   11,  139, 75,  203, 43,  171, 107, 235,
   27,  155, 91,  219, 59,  187, 123, 251,
   7,   135, 71,  199, 39,  167, 103, 231,
   23,  151, 87,  215, 55,  183, 119, 247,
   15,  143, 79,  207, 47,  175, 111, 239,
   31,  159, 95,  223, 63,  191, 127, 255
};
static unsigned char ucrs_send_session_end[] = {
   0X03, 0X00, 0X00, 0X09, 0X02, 0XF0, 0X80, 0X20, 0X80
};


/* subroutine to process the copy library function                     */
extern "C" void m_rdpserv_1( struct dsd_call_rdpserv_1 *adsp_hl_clib_1 ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3, iml4, iml5, iml6;  /* working variables */
   int        iml_rec;                      /* data received remaining */
   int        iml_line_no;                  /* line number for errors  */
   int        iml_source_no;                /* source line no for errors */
   char       *achl1, *achl2;               /* working variables       */
   char       *achl3, *achl4;               /* working variables       */
   BOOL       bol_compressed;               /* save compressed         */
   struct dsd_output_area_1 dsl_output_area_1;  /* output of subroutine */
   struct dsd_gather_i_1 *adsl_gai1_inp_1;  /* input data              */
   struct dsd_gather_i_1 *adsl_gai1_inp_w2;  /* input data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_gather_i_1 dsl_gai1_comp_data;  /* compressed data       */
   struct dsd_cl_vch_in *adsl_cl_vch_in;    /* client sends input from virtual channel */
   union {
     struct dsd_sc_draw_sc dsl_sc_draw_sc;  /* draw on screen          */
   };
   char       *achl_out_1;                  /* output-area             */
   int        iml_out_len;                  /* length output           */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   struct dsd_gather_i_1 *adsl_gai1_out_save;  /* output data          */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_client_1 *D_ADSL_RCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
#endif
#ifdef TRACEHL_CL2SE_COM1                   /* 21.09.06 KB - client to server commands */
   char       *achl_help_sta;
#endif
   char       chrl_work_1[ D_MAX_CRYPT_LEN ];  /* work area            */
   char       chrl_work_2[ 65536 ];         /* work area               */

#ifdef D_FOR_TRACE1                         /* 31.05.05 KB - help in tracing */
   iml1 = 0;
#endif                                      /* 31.05.05 KB - help in tracing */
   iml_line_no = 0;                         /* line number for errors  */
   adsl_gai1_out_save = NULL;               /* clear output data       */
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 (&dsl_output_area_1)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   ADSL_OA1 = &dsl_output_area_1;
#endif
#ifdef HL_RDPACC_HELP_DEBUG
   if (adsp_hl_clib_1->inc_func != DEF_IFUNC_START) {
     if (ADSL_RDPA_F) {                     /* memory defined          */
       if (ADSL_RDPA_F->boc_help_debug_1) {  /* stop debugger          */
         printf( "xlrdpa1 m_hlclib01() called boc_help_debug_1 set\n" );
         int inh1 = 0;
         inh1++;
       }
     }
   }
#endif
   iml_line_no = 0;                         /* line number for errors  */
   iml_source_no = 0;                       /* source line no for errors */
   switch (adsp_hl_clib_1->inc_func) {
     case DEF_IFUNC_START:
       goto pfsta00;                        /* start communication     */
     case DEF_IFUNC_REFLECT:
       goto ptose00;                        /* to server               */
     case DEF_IFUNC_CLOSE:
       if (adsp_hl_clib_1->ac_ext == NULL) return;
       goto p_cleanup_00;                   /* do cleanup now          */
     default:
       m_sdh_printf( adsp_hl_clib_1, "xlrdpa1-l%05d-W m_hlclib01() called inc_func=%d - value invalid",
                     __LINE__, adsp_hl_clib_1->inc_func );
       return;
   }

   pfsta00:                                 /* start communication     */
#ifdef D_FFLUSH                             /* 30.05.05 KB - flush stdout */
   setbuf( stdout, 0 );
#endif                                      /* 30.05.05 KB - flush stdout */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_MEMGET,
                                      &adsp_hl_clib_1->ac_ext,
                                      sizeof(struct dsd_rdpa_f) );
   if (bol1 == FALSE) {                     /* aux returned error      */
     adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
     return;
   }
#ifdef HL_RDPACC_HELP_DEBUG
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
   memset( ADSL_RDPA_F, 0, sizeof(struct dsd_rdpa_f) );
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   ADSL_RDPA_F->dsc_stor_sdh_1.imc_stor_size = D_AUX_STOR_SIZE;  /* size of storage element */
   m_aux_stor_start( &ADSL_RDPA_F->dsc_stor_sdh_1 );
   ADSL_RDPA_F->dsc_rdp_se_1.iec_fcfp_bl = ied_fcfp_rec_type;  /* first record type */
   ADSL_RDPA_F->dsc_rdp_se_1.iec_frcl_bl = ied_frcl_start;  /* receive block from client */
// ADSL_RDPA_F->dsc_rdp_se_1.imc_pos_inp_frame = 0;  /* start of frame */
// ADSL_RDPA_F->iec_frse_bl = ied_frse_start;  /* receive block from server */
// ADSL_RDPA_F->inc_send_client_len = 0;    /* send nothing to client  */
   // SM and JB, Malta 13. Juli 2011:
   // User channel is user-ID + 1001. Because of that the user-ID has to be
   // minimum the number of virtual channels plus three. (Three additional channels,
   // which are always in use. ) Search for 
   // "D_ADSL_RCO1->usc_userid_cl2se = D_ADSL_RCO1->imc_no_virt_ch + 3;"
// UUUU to-do 30.12.08 KB - is this number of virtual channels plus three?  Yes, it is.
// ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_chno_disp = 0X03F1;  /* channel number display  */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_chno_disp = D_DISPLAY_CHANNEL;  /* default display channel */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_chno_cont = 0X0100;  /* channel number control  */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_keytype = 2;
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_sec_level = adsp_hl_clib_1->adsc_conf->imc_sec_level;
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_bounds_left = -1;  /* set bounds coordinates invalid */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_bounds_top = -1;  /* set bounds coordinates invalid */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_bounds_right = -1;  /* set bounds coordinates invalid */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_bounds_bottom = -1;  /* set bounds coordinates invalid */
   memset( &ADSL_RDPA_F->dsc_rdp_se_1.dsc_old_bounds, 0XFF, sizeof(ADSL_RDPA_F->dsc_rdp_se_1.dsc_old_bounds) );
   ADSL_RDPA_F->dsc_rdp_se_1.ucc_order_flags_1 = (unsigned char) 0X01;  /* send order flags */
   adsp_hl_clib_1->adsc_rdp_co = &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1;
   /* get server random                                                */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_RANDOM_RAW,  /* calcalute random */
                                      ADSL_RDPA_F->chrl_server_random,
                                      sizeof(ADSL_RDPA_F->chrl_server_random) );
   if (bol1 == FALSE) {                     /* aux returned error      */
     adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
     return;
   }
// to-do 24.12.09 - check client capabilities
   /* temporary - needs array for glyph entries                        */
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, 10 * sizeof(struct dsd_arr_glyph_e) );
   memset( ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e, 0, 10 * sizeof(struct dsd_arr_glyph_e) );
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_no_arr_glyph_e = 10;  /* number of arrays of glyph entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[0].usc_len_store = 4;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[0].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[0].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[1].usc_len_store = 4;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[1].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[1].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[2].usc_len_store = 8;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[2].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[2].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[3].usc_len_store = 8;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[3].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[3].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[4].usc_len_store = 16;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[4].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[4].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[5].usc_len_store = 32;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[5].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[5].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[6].usc_len_store = 64;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[6].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[6].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[7].usc_len_store = 128;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[7].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[7].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[8].usc_len_store = 256;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[8].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[8].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[9].usc_len_store = 2048;  /* length of storage in bytes */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[9].usc_no_entries = 254;  /* number of entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e[9].usc_entries_filled = 1;   /* number of filled entries */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_max_pdu_length = MAX_PDU_LEN;  /* Maximum PDU-Length, MSTSC=0X4000, JWT=0X8000 */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_max_ts_fp_update_size = MAX_TS_FP_UPDATE_SIZE;  /* Maximum order PDU-Length, MSTSC=0X4000 - 0XB, JWT = 0X8000 - 0XB */ 
// ADSL_RDPA_F->dsc_rdp_cl_1.imc_pos_inp_frame = 0;  /* start of frame */
// ADSL_RDPA_F->iec_frcl_bl = ied_frcl_start;  /* receive block from client */
// ADSL_RDPA_F->inc_send_server_len = 0;    /* send nothing to client  */
   return;



   ptose00:                                 /* to server - from client */
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
#endif

   /* prepare area to send to server                                   */
   ADSL_OA1->achc_w1 = adsp_hl_clib_1->achc_work_area;  /* addr work-area */
   ADSL_OA1->achc_w2 = ADSL_OA1->achc_w1 + adsp_hl_clib_1->inc_len_work_area;  /* length work-area */
   ADSL_OA1->adsc_gai1_o1 = NULL;           /* output data             */
   ADSL_OA1->adsc_cl_co1 = NULL;            /* clear input from client */
   ADSL_OA1->adsc_gai1_sf = NULL;           /* start of current frame  */
   ADSL_OA1->achc_start_order = NULL;       /* JB 21.03.12: EXPR_UNINIT_PTR in m_send_order_opaquerect otherwise */
   if (adsp_hl_clib_1->adsc_gather_i_1_in == NULL) goto ptose80;
   adsl_gai1_inp_1 = adsp_hl_clib_1->adsc_gather_i_1_in;
#ifdef TRACEHL1
   achl_help_sta = adsl_gai1_inp_1->achc_ginp_cur;
#endif

   /* loop to process the input data                                   */
   ptose20:                                 /* process next byte input */
   if (adsl_gai1_inp_1) {                   /* more gather input       */
     iml_rec = adsl_gai1_inp_1->achc_ginp_end
                 - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml_rec > 0) {                     /* data to process         */
       goto ptose24;                        /* data to process found   */
     }
     adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;
#ifndef TRACEHL1
     if (adsl_gai1_inp_1) goto ptose20;
#else
     if (adsl_gai1_inp_1) {
       achl_help_sta = adsl_gai1_inp_1->achc_ginp_cur;
       goto ptose20;
     }
#endif
   }
// goto ptose60;
   goto ptose80;                            /* send to server          */

   ptose24:                                 /* data to process found   */
#ifdef HL_RDPACC_HELP_DEBUG
   if (ADSL_RDPA_F->boc_help_debug_1) {     /* stop debugger          */
     printf( "xlrdpa1 m_hlclib01() ptose24 boc_help_debug_1 set\n" );
     int inh1 = 0;
     inh1++;
   }
#endif
#ifdef TRACEHL_CL2SE_COM1                   /* 21.09.06 KB - client to server commands */
   printf( "ptose24 - iec_frcl_bl=%d iec_fcfp_bl=%d pos=%04X cont=%02X\n",
            ADSL_RDPA_F->dsc_rdp_se_1.iec_frcl_bl,
            ADSL_RDPA_F->dsc_rdp_se_1.iec_fcfp_bl,
            adsl_gai1_inp_1->achc_ginp_cur - achl_help_sta,
            *((unsigned char *) adsl_gai1_inp_1->achc_ginp_cur) );
#endif /* TRACEHL_CL2SE_COM1                21.09.06 KB - client to server commands */
   /*/ Print out States -> just for JB and SM for debug reasons
   //m_console_out(adsl_gai1_inp_1->achc_ginp_cur, adsl_gai1_inp_1->achc_ginp_end-adsl_gai1_inp_1->achc_ginp_cur);         
   switch(D_ADSL_RSE1->iec_fcfp_bl){
   case ied_fcfp_ignore:
   case ied_fcfp_copy_normal:
     printf("fcfp 0x%02x %-23s % 4x    frcl 0x% 2x %-25s\n", 
        D_ADSL_RSE1->iec_fcfp_bl, m_ret_t_ied_fcfp_bl(D_ADSL_RSE1->iec_fcfp_bl),
        D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_2,
        D_ADSL_RSE1->iec_frcl_bl, m_ret_t_ied_frcl_bl(D_ADSL_RSE1->iec_frcl_bl));
     break;
   case ied_fcfp_int_lit_e:
     if((D_ADSL_RSE1->imc_prot_3 == D_ADSL_RSE1->imc_pos_inp_frame) && ((D_ADSL_RSE1->imc_prot_3 - D_ADSL_RSE1->imc_prot_2) <= iml_rec)){
       iml1 = 0;
       iml2 = D_ADSL_RSE1->imc_pos_inp_frame;
       iml3 = 0;
       while (TRUE) {
         iml1 |= ((unsigned char) *(adsl_gai1_inp_1->achc_ginp_cur + iml3++)) 
               << ((D_ADSL_RSE1->imc_prot_3 - iml2) << 3);
         iml2--;
         if (iml2 == D_ADSL_RSE1->imc_prot_2) break;
       }
       printf("fcfp 0x%02x ied_fcfp_int_lit_e % 2x 0x% 4x    frcl 0x% 2x %-25s\n", 
          D_ADSL_RSE1->iec_fcfp_bl,
          D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_2, iml1,
          D_ADSL_RSE1->iec_frcl_bl, m_ret_t_ied_frcl_bl(D_ADSL_RSE1->iec_frcl_bl));
       break;
     }
   default:
     printf("fcfp 0x%02x %-28s    frcl 0x% 2x %-25s\n", 
        D_ADSL_RSE1->iec_fcfp_bl, m_ret_t_ied_fcfp_bl(D_ADSL_RSE1->iec_fcfp_bl),
        D_ADSL_RSE1->iec_frcl_bl, m_ret_t_ied_frcl_bl(D_ADSL_RSE1->iec_frcl_bl));
   } //*/
   switch (D_ADSL_RSE1->iec_fcfp_bl) {      /* field position in rec   */
     case ied_fcfp_invalid:                 /* invalid data received   */
//     goto ptose92;                        /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20118;
         goto ptose92;
     case ied_fcfp_constant:                /* compare with constant   */
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_start:
           achl1 = (char *) ucrs_sese_01;
           iml1 = sizeof(ucrs_sese_01);
           if (D_ADSL_RSE1->imc_pos_inp_frame == 0) {
             D_ADSL_RSE1->imc_pos_inp_frame = iml1;  /* length constant */
             D_ADSL_RSE1->imc_prot_1 = 0;   /* position                */
           }
           break;
         case ied_frcl_r02_x224mcs:         /* proc bl 2 X.224 MCS     */
           achl1 = (char *) ucrs_x224_mcs;
           iml1 = sizeof(ucrs_x224_mcs);
           break;
#ifdef B060907
         case ied_frcl_r02_mcud_dtt:        /* b2 MC Us-Da Desktop Tag */
           achl1 = (char *) ucrs_desktop_tag;
           iml1 = sizeof(ucrs_desktop_tag);
           break;
#endif
         case ied_frcl_r02_mcud_c01:        /* b2 MC Us-Da const 01    */
           achl1 = (char *) ucrs_r02c01;
           iml1 = sizeof(ucrs_r02c01);
           break;
         case ied_frcl_r02_mcud_c02:        /* b2 MC Us-Da const 02    */
           achl1 = (char *) ucrs_r02c02;
           iml1 = sizeof(ucrs_r02c02);
           break;
         case ied_frcl_r02_mcud_c03:        /* b2 MC Us-Da const 03    */
           achl1 = (char *) ucrs_bitmap_tag;  /* Bitmap Size Tag       */
           iml1 = sizeof(ucrs_bitmap_tag);
           break;
#ifdef B060907
         case ied_frcl_r02_mcud_vc1:        /* b2 MC Us-Da virtual ch  */
           achl1 = (char *) ucrs_virtch_tag;  /* Virtual Channel Tag   */
           iml1 = sizeof(ucrs_virtch_tag);
           break;
#endif
         default:
           goto ptose96;                    /* program illogic         */
       }
       iml2 = iml1;                         /* save length             */
       if (iml1 > (D_ADSL_RSE1->imc_prot_1 + iml_rec)) {
         iml1 = D_ADSL_RSE1->imc_prot_1 + iml_rec;
       }
       iml1 -= D_ADSL_RSE1->imc_prot_1;
       if (memcmp( achl1 + D_ADSL_RSE1->imc_prot_1,
                   adsl_gai1_inp_1->achc_ginp_cur,
                   iml1 )) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20169;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_prot_1 += iml1;
       adsl_gai1_inp_1->achc_ginp_cur += iml1;
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant     */
       if (D_ADSL_RSE1->imc_prot_1 < iml2) {
         goto ptose20;                      /* process next data       */
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_x224mcs:         /* proc bl 2 X.224 MCS     */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_l1_fi;  /* ASN.1 length field */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcscoen;  /* MCS connect encoding */
           D_ADSL_RSE1->imc_prot_3 = 0;     /* maybe till end of block */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_c01:        /* b2 MC Us-Da const 01    */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20207;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_scw;  /* b2 MC Us-Da scr width */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_c02:        /* b2 MC Us-Da const 02    */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20218;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_kbl;  /* b2 MC Us-Da Keyboard La */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_c03:        /* b2 MC Us-Da const 03    */
           /* protocol version                                         */
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RSE1->chrc_prot_1;
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 1;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20231;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_pv1;  /* b2 MC Us-Da protocol ve */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
         default:
           goto ptose96;                    /* program illogic         */
       }
     case ied_fcfp_ignore:                  /* ignore this data        */
       /* compute how many to ignore                                   */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       adsl_gai1_inp_1->achc_ginp_cur += iml1;
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant     */
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
         goto ptose20;                      /* needs more data         */
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_start:
           m_send_se2cl_r01( adsp_hl_clib_1, &dsl_output_area_1 );
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_02;
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_cids:         /* b2 MC Calling Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_ceds;  /* b2 MC Called Domain Selector */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_ceds:         /* b2 MC Called Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_upwf;  /* b2 MC Upward Flag       */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_upwf:         /* b2 MC Upward Flag       */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_tdop;  /* b2 MC Target Domain Parameters */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_tdop:         /* b2 MC Target Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_midp;  /* b2 MC Minimum Domain Parameters */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_midp:         /* b2 MC Minimum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_madp;  /* b2 MC Maximum Domain Parameters */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_madp:         /* b2 MC Maximum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_usd1;  /* b2 MC User Data Start   */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_usd1:         /* b2 MC User Data Start   */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_mu_len_1;  /* multi length 1 */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_l1;  /* b2 MC Us-Da length 1 */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_l1:         /* b2 MC Us-Da length 1    */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_mu_len_1;  /* multi length 1 */
#ifdef B060907
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_dtt;  /* b2 MC Us-Da Desktop Tag */
#endif
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_fietype;  /* b2 MC Field Type */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_fietype:         /* b2 MC Field Type        */
           if (D_ADSL_RSE1->imc_pos_inp_frame == 0) {  /* end of block */
         iml_line_no = __LINE__;
         iml_source_no = 20342;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 20346;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;      /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_ime:        /* b2 MC Us-Da IME Keyb ma */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_bitmap_tag)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20355;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_c03;  /* b2 MC Us-Da const 03 */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_pv1:        /* b2 MC Us-Da protocol ve */
           /* if chrc_prot_1[0] == 0: is already at end? 08.08.04 KB */
           if (D_ADSL_RSE1->chrc_prot_1[0] != 0X01) {
             printf( "b2 MC Us-Da protocol v found invalid protocol version %d\n",
                     D_ADSL_RSE1->chrc_prot_1[0] );
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20367;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20372;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;      /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_cod;  /* b2 MC Us-Da Color Depth */
           goto ptose20;                    /* process next data       */
#ifdef B060907
         case ied_frcl_r02_mcud_cod:        /* b2 MC Us-Da Color Depth */
#ifdef B060907
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_virtch_tag)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20384;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_vc1;  /* b2 MC Us-Da virtual ch */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
#endif
           if (D_ADSL_RSE1->imc_pos_inp_frame == 0) {  /* end of block */
         iml_line_no = __LINE__;
         iml_source_no = 20392;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 20396;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;      /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_fietype;  /* b2 MC Field Type */
           goto ptose20;                    /* process next data       */
#endif
         case ied_frcl_c_loinf_options:     /* Options                 */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 20407;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_pdu_type_1_t:        /* get RDP4 PDU type type  */
           bol1 = m_send_se2cl_after_conf_actpdu( adsp_hl_clib_1, &dsl_output_area_1 );
           if (bol1 == FALSE) goto ptose96;  /* program illogic        */
           // 02.06.09 KB - do after packets have been received
           ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1);
           // 03.06.09 KB - check if overflow - achc_w1 - illogic
/* UUUU 03.06.09 KB */
           ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
           if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
             m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                           __LINE__, 20424 );  /* line number for errors */
             goto ptose96;                  /* program illogic         */
           }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
           memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) );
           ADSL_CL_CO1->iec_cl_command = ied_clc_conn_fin;  /* Connection Finalization done */
           if (ADSL_OA1->adsc_cl_co1 == NULL) {
             adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
           } else {
             ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
           }
           ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;  /* save last in chain */
#undef ADSL_CL_CO1
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_xyz_01;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           goto ptose20;                    /* process next data       */
         case ied_frcl_data_pdu_1:          /* RDP4 data PDU follows   */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_data_pdu_1;  /* RDP4 data PDU follows */
           goto ptose20;                    /* process next data       */
         case ied_frcl_refresh_no_areas:    /* PDUTYPE2_REFRESH_RECT   */
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RSE1->chrc_prot_1;
           D_ADSL_RSE1->imc_prot_2 = 0;     /* till end of frame       */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_data_pdu_end:        /* RDP4 data PDU end       */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_xyz_01;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           goto ptose20;                    /* process next data       */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_copy_normal:             /* copy data normal        */
       /* compute how many to copy                                     */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       if (iml1 > 0) {                      /* data to copy            */
         memcpy( D_ADSL_RSE1->achc_prot_1,
                 adsl_gai1_inp_1->achc_ginp_cur,
                 iml1 );
         D_ADSL_RSE1->achc_prot_1 += iml1;
         adsl_gai1_inp_1->achc_ginp_cur += iml1;
         D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant   */
         if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
           goto ptose20;                    /* needs more data         */
         }
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_mcud_c01:        /* b2 MC Us-Da const 01    */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_r02c01)) {
         iml_line_no = __LINE__;
         iml_source_no = 20514;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
//         D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_c01;  /* b2 MC Us-Da const 01 */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_con:        /* b2 MC Us-Da Computer Na */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20524;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_kbt;  /* b2 MC Us-Da Keyboard Ty */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_pv1:        /* b2 MC Us-Da protocol ve */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 5;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20535;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_vcn:        /* b2 MC Us-Da virt ch nam */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_vcf;  /* b2 MC Us-Da virt ch fla */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rec_05:              /* received block 5        */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_06;  /* receive block 6 */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rdp5_inp:            /* RDP5-style input data   */
/* 04.09.06 KB UUUU */
//           *M_ERROR_TOSE_PROT;            /* protocoll error          */
       /* generated from macro M_TMPBUF_SE_1()                         */
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_len_temp) {
         D_ADSL_RSE1->imc_len_temp = D_ADSL_RSE1->imc_pos_inp_frame;
         ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
         ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
         if (D_ADSL_RSE1->ac_temp_buffer) {  /* buffer already allocated */
           m_aux_stor_free( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->ac_temp_buffer );
         }
         D_ADSL_RSE1->ac_temp_buffer
           = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->imc_len_temp );
       }
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RSE1->ac_temp_buffer;  /* temporary buffer */
           D_ADSL_RSE1->imc_prot_2 = 0;     /* till end of frame       */
           if (D_ADSL_RSE1->imc_prot_3) {   /* input encrypted         */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rdp5_rc4;  /* input RC4 encrypted */
           }
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_logon_info_1:      /* logon information 1     */
         case ied_frcl_resp_act_pdu_rec:    /* response block active PDU */
         case ied_frcl_rec_xyz_01:
           /* check if all data of this frame have been received       */
           iml1 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
           adsl_gai1_inp_w2 = adsl_gai1_inp_1;  /* get gather          */
           while (TRUE) {                   /* loop over all gather structures input */
             iml1 -= adsl_gai1_inp_w2->achc_ginp_end - adsl_gai1_inp_w2->achc_ginp_cur;
             if (iml1 <= 0) break;          /* enough data found       */
             adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;  /* get next gather */
             if (adsl_gai1_inp_w2 == NULL) {  /* already end of chain  */
               /* wait for more data                                   */
               goto ptose80;                /* check orders for RDPACC */
             }
           }
           if ((D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent & (4096 - 1)) == 0){
             if (D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent) {
               m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_cl2se, NULL );
             }
           }
           /* decrypt the data where they are                          */
           iml1 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
           adsl_gai1_inp_w2 = adsl_gai1_inp_1;  /* get gather          */
           while (TRUE) {                   /* loop over all gather structures input */
             iml2 = adsl_gai1_inp_w2->achc_ginp_end - adsl_gai1_inp_w2->achc_ginp_cur;
             if (iml2 > iml1) iml2 = iml1;  /* only data in this frame */
             RC4( adsl_gai1_inp_w2->achc_ginp_cur, 0, iml2,
                  adsl_gai1_inp_w2->achc_ginp_cur, 0,
                  D_ADSL_RCO1->dsc_encry_cl2se.chrc_rc4_state );
             iml1 -= iml2;                  /* subtract data decyrpted */
             if (iml1 <= 0) break;          /* all data decrypted      */
             adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;  /* get next gather */
             if (adsl_gai1_inp_w2 == NULL) {  /* already end of chain  */
               goto ptose96;                /* program illogic         */
             }
           }
           /* check the hash now                                       */
#define ACHL_WORK_SHA1 ((int *) chrl_work_2)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
           memcpy( ACHL_WORK_SHA1,
                   D_ADSL_RCO1->imrc_sha1_state,
                   sizeof(D_ADSL_RCO1->imrc_sha1_state) );
           memcpy( ACHL_WORK_MD5,
                   D_ADSL_RCO1->imrc_md5_state,
                   sizeof(D_ADSL_RCO1->imrc_md5_state) );
           m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RSE1->imc_pos_inp_frame );
           SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
           iml1 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
           adsl_gai1_inp_w2 = adsl_gai1_inp_1;  /* get gather          */
           while (TRUE) {                   /* loop over all gather structures input */
             iml2 = adsl_gai1_inp_w2->achc_ginp_end - adsl_gai1_inp_w2->achc_ginp_cur;
             if (iml2 > iml1) iml2 = iml1;  /* only data in this frame */
             SHA1_Update( ACHL_WORK_SHA1,
                          adsl_gai1_inp_w2->achc_ginp_cur, 0, iml2 );
             iml1 -= iml2;                  /* subtract data processed */
             if (iml1 <= 0) break;          /* all data processed      */
             adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;  /* get next gather */
             if (adsl_gai1_inp_w2 == NULL) {  /* already end of chain  */
               goto ptose96;                /* program illogic         */
             }
           }
           if (D_ADSL_RSE1->chc_prot_rt03 & 0X08) {  /* flag for block count */
             m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent );
             SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
           }
           SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
           MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
           MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
           if (memcmp( D_ADSL_RSE1->chrc_prot_1, ACHL_WORK_UTIL_01, D_SIZE_HASH )) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 20853;
         goto ptose92;
           }
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
           D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent++;  /* count blocks client has sent */
           if (D_ADSL_RSE1->iec_frcl_bl == ied_frcl_c_logon_info_1) {  /* logon information 1 */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 20915;
         goto ptose92;
             }
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore next bytes */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_options;  /* Options */
             goto ptose20;                  /* process next data       */
           }
           if (D_ADSL_RSE1->imc_prot_chno == D_ADSL_RCO1->usc_chno_disp) {  /* channel number display  */
//           *M_ERROR_TOSE_PROT;            /* protocoll error          */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
             D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
             D_ADSL_RSE1->imc_prot_1 = 0;   /* clear value             */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_pdu_type_1_l;  /* get RDP4 PDU type */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 20957;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rdp4_vch_ulen;  /* virtual channel uncompressed data length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_domna_val:   /* Domain Name String      */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 20980;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_userna_val:  /* User Name String        */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 20987;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_pwd_val:     /* Password String         */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 20994;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_altsh_val:   /* Alt Shell String        */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 21001;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_wodir_val:   /* Working Directory String */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 21008;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_ineta:       /* INETA                   */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 21015;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_path;  /* Client Path */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_path:        /* Client Path             */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {  /* nothing left */
         iml_line_no = __LINE__;
         iml_source_no = 21024;
         goto ptose92;
           }
           D_ADSL_RCO1->usc_loinf_extra_len = D_ADSL_RSE1->imc_pos_inp_frame;  /* Extra Parameters Length */
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_extra_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->imc_pos_inp_frame );
           D_ADSL_RSE1->imc_prot_2 = 0;     /* copy till end of frame  */
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_extra_a;  /* Extra Parameters */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_extra;  /* Extra Parameters */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_extra:       /* Extra Parameters        */
           /* start compression, if required                           */
           if (   (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA)  /* compression enabled */
               || (D_ADSL_RCO1->boc_always_compr_vc)) {  /* TRUE, if there is a virtual channel, which is always compressed */
//           D_ADSL_RCO1->dsc_cdrf_dec.imc_func = DEF_IFUNC_START;
             D_ADSL_RCO1->dsc_cdrf_dec.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
             D_ADSL_RCO1->dsc_cdrf_dec.amc_aux = adsp_hl_clib_1->amc_aux;
             D_ADSL_RCO1->dsc_cdrf_dec.imc_param_1 = MPPC_SMALL_DICT_SIZE_ID;
             D_ADSL_RCO1->dsc_cdrf_dec.imc_param_2 = MPPC_SMALL_HASHTAB_SIZE;
             m_cdr_dec( &D_ADSL_RCO1->dsc_cdrf_dec );
             if (D_ADSL_RCO1->dsc_cdrf_dec.imc_return != DEF_IRET_NORMAL) {  /* continue processing */
               m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d de-compression error %d.",
                             __LINE__, 21326,  /* line number for errors */
                             D_ADSL_RCO1->dsc_cdrf_dec.imc_return );
               goto p_cleanup_00;           /* do cleanup now          */
             }
//           D_ADSL_RCO1->dsc_cdrf_enc.imc_func = DEF_IFUNC_START;
             D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
             D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
             if (   (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_LDIC)  /* use large dictionary */
                 || (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_BULK)) {  /* use bulk dictionary */
               D_ADSL_RCO1->dsc_cdrf_enc.imc_param_1 = MPPC_LARGE_DICT_SIZE_ID;
             }
             D_ADSL_RCO1->dsc_cdrf_enc.imc_param_2 = MPPC_SMALL_HASHTAB_SIZE;
             m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
             if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
               m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                             __LINE__, 21356,  /* line number for errors */
                             D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
               goto p_cleanup_00;           /* do cleanup now          */
             }
           }
           ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1);
/* UUUU 31.01.06 KB */
           ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
           if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
             m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                           __LINE__, 21380 );  /* line number for errors */
             goto ptose96;                  /* program illogic         */
           }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
           memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) );
           ADSL_CL_CO1->iec_cl_command = ied_clc_capabilities;  /* received capabilities */
           if (ADSL_OA1->adsc_cl_co1 == NULL) {
             adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
           } else {
             ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
           }
           ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;  /* save last in chain */
#undef ADSL_CL_CO1
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_resp_act_pdu_rec;  /* response block active PDU */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           goto ptose80;                    /* end of input processing */
         case ied_frcl_refresh_no_areas:    /* PDUTYPE2_REFRESH_RECT   */
//         memset( &dsl_sc_draw_sc, 0, sizeof(struct dsd_sc_draw_sc) );  /* draw on screen */
           dsl_sc_draw_sc.imc_left          /* coordinate left         */
             = *((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 0)
                 | (*((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 1) << 8);
           dsl_sc_draw_sc.imc_top           /* coordinate top          */
             = *((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 2)
                 | (*((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 3) << 8);
           dsl_sc_draw_sc.imc_right         /* coordinate right        */
             = *((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 4)
                 | (*((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 5) << 8);
           dsl_sc_draw_sc.imc_bottom        /* coordinate bottom       */
             = *((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 6)
                 | (*((unsigned char *) D_ADSL_RSE1->chrc_prot_1 + 7) << 8);
           if (dsl_sc_draw_sc.imc_right <= dsl_sc_draw_sc.imc_left) {
         iml_line_no = __LINE__;
         iml_source_no = 21426;
         goto ptose92;
           }
           if (dsl_sc_draw_sc.imc_bottom <= dsl_sc_draw_sc.imc_top) {
         iml_line_no = __LINE__;
         iml_source_no = 21429;
         goto ptose92;
           }
           if (dsl_sc_draw_sc.imc_right > D_ADSL_RCO1->imc_dim_x) {  /* dimension x pixels */
         iml_line_no = __LINE__;
         iml_source_no = 21432;
         goto ptose92;
           }
           if (dsl_sc_draw_sc.imc_bottom > D_ADSL_RCO1->imc_dim_y) {  /* dimension y pixels */
         iml_line_no = __LINE__;
         iml_source_no = 21435;
         goto ptose92;
           }
           // Included SM's color compression for 32 bit now. JB 20.02.12
           if ((D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA) == 0) {  /* compression not enabled */
             bol1 = m_send_draw_sc_bmc_normal( adsp_hl_clib_1,
                                               ADSL_OA1,
                                               &dsl_sc_draw_sc,
                                               chrl_work_2 );
           } else {
             bol1 = m_send_draw_sc_bmc_compr( adsp_hl_clib_1,
                                              ADSL_OA1,
                                              &dsl_sc_draw_sc,
                                              chrl_work_2 );
           }
           if (bol1 == FALSE) goto p_cleanup_00;  /* do cleanup now      */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_xyz_01;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rdp4_vch_ulen:       /* virtual channel uncompressed data length */
           goto ptose_vch_00;               /* virtual channel data received */
       }
       goto ptose96;                        /* program illogic         */
     case ied_fcfp_copy_invers:             /* copy data invers        */
       /* compute how many to copy                                     */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       /* compute end of source area                                   */
       achl1 = adsl_gai1_inp_1->achc_ginp_cur + iml1;
       /* compute target address                                       */
       achl2 = D_ADSL_RSE1->achc_prot_1
               + (D_ADSL_RSE1->imc_prot_3 - D_ADSL_RSE1->imc_prot_2)
               - D_ADSL_RSE1->imc_prot_1;
       do {
         *(--achl2) = *adsl_gai1_inp_1->achc_ginp_cur++;
       } while (adsl_gai1_inp_1->achc_ginp_cur < achl1);
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant     */
       D_ADSL_RSE1->imc_prot_1 += iml1;     /* add displacement output */
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
         goto ptose20;                      /* needs more data         */
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_client_rand:         /* receive client random   */
           if (D_ADSL_RSE1->imc_pos_inp_frame) {  /* more in block     */
         iml_line_no = __LINE__;
         iml_source_no = 21576;
         goto ptose92;
           }
           iml1 = sizeof(chrl_work_1);
           {
             unsigned char *auch1, *auch2;

             auch1 = (unsigned char *) D_ADSL_RSE1->chrc_prot_1;
             auch2 = auch1 + D_ADSL_RSE1->imc_prot_3 - D_ADSL_RSE1->imc_prot_2;
             while ((auch1 < auch2) && (*auch1 == 0X00)) auch1++;
#ifdef XH_INTERFACE
			  ds__hmem dsl_new_struct;
			  memset(&dsl_new_struct, 0, sizeof(ds__hmem));
			  dsl_new_struct.in__aux_up_version = 1;
			  dsl_new_struct.am__aux2 = adsp_hl_clib_1->amc_aux;
			  dsl_new_struct.in__flags = 0;
			  dsl_new_struct.vp__context = adsp_hl_clib_1->vpc_userfld;
#endif
#ifdef __INSURE__
              // rsa_crypt_raw uses lnum, which causes an Insure-error. 
              _Insure_checking_enable(0);
#endif
              iml2 = rsa_crypt_raw( 
#ifdef XH_INTERFACE
                                   &dsl_new_struct,
#endif
				                   auch1, auch2 - auch1,
                                   (unsigned char *) ucrs_rdp_private_key,
                                   sizeof(ucrs_rdp_private_key),
                                   (unsigned char *) ucrs_rdp_cert + D_POS_CERT_PUBLIC_KEY,
                                   D_LEN_CERT_PUBLIC_KEY,
                                   (unsigned char *) chrl_work_1,
                                   &iml1 );
#ifdef __INSURE__
               _Insure_checking_enable(1);
#endif
#ifdef XH_INTERFACE
			   HMemMgrFree(&dsl_new_struct);
#endif
           }
#ifdef TRACEHL1
           printf( "l%05d s%05d rsa_crypt_raw() server returned %d length %d.\n",
                   __LINE__, 21616,
                   iml2, iml1 );
#ifdef D_FFLUSH                             /* 30.05.05 KB - flush stdout */
           fflush( stdout );
#endif                                      /* 30.05.05 KB - flush stdout */
#endif
           iml_line_no = __LINE__;
           iml_source_no = 21630;
           if (iml2) goto ptose92;          /* protocoll error          */
           if (iml1 == 0) goto ptose92;     /* protocoll error          */
#define ACHL_CLIENT_RANDOM_SE (chrl_work_2)
#define ACHL_CLIENT_RANDOM_CL (chrl_work_2)
#define ACHL_CL_RAND_ENCRY (ACHL_CLIENT_RANDOM_CL + 32)
#define ACHL_WORK_AREA (ACHL_CL_RAND_ENCRY + 72)
#define ACHL_WORK_SHA1 (ACHL_CL_RAND_ENCRY + 72)
#define ACHL_WORK_MD5 (ACHL_WORK_SHA1 + 40)
           /* 32 bytes of client random as server                      */
           achl1 = chrl_work_1;             /* start input             */
           achl2 = chrl_work_1 + iml1;      /* end input               */
           achl3 = ACHL_CLIENT_RANDOM_SE + 32;  /* target to here      */
           achl4 = ACHL_CLIENT_RANDOM_SE;   /* target up to this       */
           do {
             *achl4++ = *(--achl2);
           } while ((achl2 > achl1) && (achl4 < achl3));
           if (achl3 > achl4) {
             memset( achl4, 0, achl3 - achl4 );
           }
           m_gen_keys( adsp_hl_clib_1, ACHL_CLIENT_RANDOM_SE, D_ADSL_RCO1, ACHL_WORK_AREA );
           /* shorten the keys                                         */
           bol1 = m_prepare_keys( adsp_hl_clib_1, D_ADSL_RCO1 );
           if (bol1 == FALSE) {             /* subroutine reported error */
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 21677;
         goto ptose92;
           }
           RC4_SetKey( D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state,
                       D_ADSL_RCO1->dsc_encry_se2cl.chrc_cl_pkd,
                       0, D_ADSL_RCO1->imc_used_keylen );
           RC4_SetKey( D_ADSL_RCO1->dsc_encry_cl2se.chrc_rc4_state,
                       D_ADSL_RCO1->dsc_encry_cl2se.chrc_cl_pkd,
                       0, D_ADSL_RCO1->imc_used_keylen );
           memset( ACHL_WORK_SHA1, 0X36, 40 );
           memset( ACHL_WORK_MD5, 0X5C, 48 );
           SHA1_Init( D_ADSL_RCO1->imrc_sha1_state );
           SHA1_Update( D_ADSL_RCO1->imrc_sha1_state, D_ADSL_RCO1->chrc_sig,
                        0, D_ADSL_RCO1->imc_used_keylen );
           SHA1_Update( D_ADSL_RCO1->imrc_sha1_state, ACHL_WORK_SHA1, 0, 40 );
           MD5_Init( D_ADSL_RCO1->imrc_md5_state );
           MD5_Update( D_ADSL_RCO1->imrc_md5_state, D_ADSL_RCO1->chrc_sig,
                       0, D_ADSL_RCO1->imc_used_keylen );
           MD5_Update( D_ADSL_RCO1->imrc_md5_state, ACHL_WORK_MD5, 0, 48 );
#undef ACHL_CLIENT_RANDOM_SE
#undef ACHL_CLIENT_RANDOM_CL
#undef ACHL_CL_RAND_ENCRY
#undef ACHL_WORK_AREA
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
           /* continue communication                                   */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_logon_info_1;  /* logon information 1 */
           goto ptose20;                    /* process next data       */
       }
       goto ptose96;                        /* program illogic         */
     case ied_fcfp_zero_cmp:                /* compare zeroes          */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       do {                                 /* loop over input data    */
         if (*adsl_gai1_inp_1->achc_ginp_cur++) {  /* value not zero   */
         iml_line_no = __LINE__;
         iml_source_no = 22031;
         goto ptose92;
         }
         D_ADSL_RSE1->imc_pos_inp_frame--;  /* length processed        */
         iml1--;                            /* decrement index         */
       } while (iml1 > 0);
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
         goto ptose20;                      /* needs more data         */
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_c_loinf_domna_val:   /* Domain Name String      */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_userna_val;  /* User Name String */
           if (D_ADSL_RCO1->usc_loinf_userna_len) {  /* User Name Length */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RCO1->usc_loinf_userna_len;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 22045;
         goto ptose92;
             }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_userna_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->usc_loinf_userna_len );
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_userna_a;  /* User Name */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 22054;
         goto ptose92;
           }
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_userna_val:  /* User Name String        */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_pwd_val;  /* Password String */
           if (D_ADSL_RCO1->usc_loinf_pwd_len) {  /* Password Length   */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RCO1->usc_loinf_pwd_len;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 22062;
         goto ptose92;
             }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_pwd_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->usc_loinf_pwd_len );
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_pwd_a;  /* Password */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 22071;
         goto ptose92;
           }
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_pwd_val:     /* Password String         */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_altsh_val;  /* Alt Shell String */
           if (D_ADSL_RCO1->usc_loinf_altsh_len) {  /* Alt Shell Length */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RCO1->usc_loinf_altsh_len;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 22079;
         goto ptose92;
             }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_altsh_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->usc_loinf_altsh_len );
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_altsh_a;  /* Alt Shell */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 22088;
         goto ptose92;
           }
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_altsh_val:   /* Alt Shell String        */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_wodir_val;  /* Working Directory String */
           if (D_ADSL_RCO1->usc_loinf_wodir_len) {  /* Working Directory Length */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RCO1->usc_loinf_wodir_len;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 22096;
         goto ptose92;
             }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_wodir_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->usc_loinf_wodir_len );
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_wodir_a;  /* Working Directory */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 22105;
         goto ptose92;
           }
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_wodir_val:   /* Working Directory String */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 22111;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_no_a_par;  /* number of additional parameters */
           goto ptose20;                    /* process next data       */
         case ied_frcl_sharedataheader_compr:  /* TS_SHAREDATAHEADER compressedType and compressedLength */
           switch (D_ADSL_RSE1->imc_prot_1) {  /* PDUTYPE2             */
             case PDUTYPE2_REFRESH_RECT:    /* 0X21 == 33              */
               if (D_ADSL_RSE1->imc_pos_inp_frame < 1) {  /* longer as frame */
         iml_line_no = __LINE__;
         iml_source_no = 22123;
         goto ptose92;
               }
               D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_refresh_no_areas;  /* PDUTYPE2_REFRESH_RECT */
               goto ptose20;                /* process next data       */
             case PDUTYPE2_SUPPRESS_OUTPUT:  /* 0X23 == 35             */
               if (D_ADSL_RSE1->imc_pos_inp_frame < 1) {  /* longer as frame */
         iml_line_no = __LINE__;
         iml_source_no = 22129;
         goto ptose92;
               }
               D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_set_display_updates;  /* PDUTYPE2_SUPPRESS_OUTPUT */
               goto ptose20;                /* process next data       */
             case PDUTYPE2_SHUTDOWN_REQUEST:  /* 0X24 == 36            */
               /* ignore remaining part                                */
               D_ADSL_RSE1->iec_frcl_bl = ied_frcl_data_pdu_end;  /* RDP4 data PDU end */
               D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
               D_ADSL_RSE1->imc_prot_2 = 0;  /* till end of block      */
               goto ptose20;                /* process next data       */
           }
         iml_line_no = __LINE__;
         iml_source_no = 22140;
         goto ptose96;
       }
       M_ERROR_TOSE_ILLOGIC                 /* programm illogic        */
     case ied_fcfp_rdp5_rc4:                /* input RC4 encrypted     */
       /* compute how many to decrypt                                  */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       if ((D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent & (4096 - 1)) == 0){
         if (D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent) {
           m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_cl2se, NULL );
         }
       }
       RC4( adsl_gai1_inp_1->achc_ginp_cur, 0, iml1,
            D_ADSL_RSE1->achc_prot_1, 0,
            D_ADSL_RCO1->dsc_encry_cl2se.chrc_rc4_state );
       D_ADSL_RSE1->achc_prot_1 += iml1;
       adsl_gai1_inp_1->achc_ginp_cur += iml1;
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length processed    */
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
         goto ptose20;                      /* needs more data         */
       }
       bol1 = m_check_hash_inp_rdp5( adsp_hl_clib_1,
                                     (char *) D_ADSL_RSE1->ac_temp_buffer,
                                     D_ADSL_RSE1->achc_prot_1 - (char *) D_ADSL_RSE1->ac_temp_buffer );
       if (bol1 == FALSE) {                 /* hash does not match     */
         iml_line_no = __LINE__;
         iml_source_no = 22182;
         goto ptose92;
       }
       D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent++;  /* count blocks client has sent */
       bol1 = m_send_cl_event_rdp5( adsp_hl_clib_1, &dsl_output_area_1,
                                    (char *) D_ADSL_RSE1->ac_temp_buffer,
                                    D_ADSL_RSE1->achc_prot_1 - (char *) D_ADSL_RSE1->ac_temp_buffer,
                                    D_ADSL_RSE1->imc_prot_4 );
       if (bol1 == FALSE) {                 /* returned error          */
         adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
         goto p_cleanup_20;                 /* do cleanup now          */
       }
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_xyz_01;
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_x224_p01:                /* is in x224 header       */
       iml1 = sizeof(ucrs_x224_p01);        /* get length              */
       if (iml1 > (D_ADSL_RSE1->imc_prot_1 + iml_rec)) {
         iml1 = D_ADSL_RSE1->imc_prot_1 + iml_rec;
       }
       iml1 -= D_ADSL_RSE1->imc_prot_1;
       if (memcmp( ucrs_x224_p01 + D_ADSL_RSE1->imc_prot_1,
                   adsl_gai1_inp_1->achc_ginp_cur,
                   iml1 )) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22250;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_prot_1 += iml1;
       adsl_gai1_inp_1->achc_ginp_cur += iml1;
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant     */
       if (D_ADSL_RSE1->imc_prot_1 < sizeof(ucrs_x224_p01)) {
         goto ptose20;                      /* process next data       */
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_mcs_c1;  /* MCS command 1   */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_rec_type:                /* get type of record      */
       /* check input RDP5-style                                       */
       if ((((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) & 0X03) == 0) {
         /* save encrypted                                             */
         D_ADSL_RSE1->imc_prot_3 = ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) & 0X80;
         /* save number of events                                      */
         D_ADSL_RSE1->imc_prot_4 = (((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) & 0X3F) >> 2;
         // Can be 0. If 0, length is send later in a second numberEvents.
         // @see [MS-RDPBCGR] 2.2.8.1.2 Client Fast-Path Input Event PDU (TS_FP_INPUT_PDU)
         //if (D_ADSL_RSE1->imc_prot_4 == 0) {  /* no event              */
         //  M_ERROR_TOSE_PROT;              /* protocoll error          */
         //}
         /* save flag for block count into hash                        */
         D_ADSL_RSE1->chc_prot_rt03 = ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) & 0X40;
         adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input         */
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rdp5_len1;  /* RDP5 input length 1 */
         goto ptose20;                      /* process next data       */
       }
       if (*adsl_gai1_inp_1->achc_ginp_cur != 0X03) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22299;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;    /* next byte input         */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_byte01;  /* receive byte 01 */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_byte01:                  /* receive byte 01         */
       if (*adsl_gai1_inp_1->achc_ginp_cur) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22316;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;    /* next byte input         */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_lencons_2;  /* receive len c */
       D_ADSL_RSE1->imc_prot_1 = 0;         /* clear length field      */
       D_ADSL_RSE1->imc_pos_inp_frame = 0;  /* no length frame yet     */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_lencons_2:               /* two bytes length remain */
       D_ADSL_RSE1->imc_prot_1 <<= 8;
       D_ADSL_RSE1->imc_prot_1
         |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_lencons_1;  /* receive len c */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_lencons_1:               /* one byte length remains */
       D_ADSL_RSE1->imc_prot_1 <<= 8;
       D_ADSL_RSE1->imc_prot_1
         |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
#ifdef TRACEHL1
       printf( "ied_fcfp_lencons_1 received len=%d\n",
               D_ADSL_RSE1->imc_prot_1 );
#endif
       if (D_ADSL_RSE1->imc_pos_inp_frame == 0) {  /* no len frame yet */
         D_ADSL_RSE1->imc_pos_inp_frame = D_ADSL_RSE1->imc_prot_1 - 4;
         if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {
//         goto ptose92;                    /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22371;
         goto ptose92;
         }
#ifdef HL_RDPACC_HELP_DEBUG
         D_ADSL_RCO1->imc_debug_reclen = D_ADSL_RSE1->imc_prot_1;
#endif
       } else {
         D_ADSL_RSE1->imc_pos_inp_frame -= 2;  /* adjust length remaining */
         if (D_ADSL_RSE1->imc_pos_inp_frame < 0) {
//         goto ptose92;                    /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22384;
         goto ptose92;
         }
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_start:
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_l1_fi;  /* ASN.1 length field */
           D_ADSL_RSE1->imc_prot_3 = 0;     /* maybe till end of block */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rec_02:
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_x224_mcs)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22395;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_x224mcs;
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_usd1:         /* b2 MC User Data Start   */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - D_ADSL_RSE1->imc_prot_1;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22406;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rec_05:              /* received block 5        */
         case ied_frcl_rec_06:              /* received block 6        */
         case ied_frcl_cjreq_rec:           /* receive block channel join request */
         case ied_frcl_c_logon_info_1:      /* logon information 1     */
         case ied_frcl_resp_act_pdu_rec:    /* response block active PDU */
         case ied_frcl_rec_xyz_01:
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_x224_p01)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22418;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_x224_p01;  /* is in x224 header */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
//       default:
//         goto ptose96;                    /* program illogic         */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_rdp5_len1:               /* RDP5 input length 1     */
       /* check two bytes len                                          */
       if (((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) & 0X80) {
         D_ADSL_RSE1->imc_pos_inp_frame
           = (((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++) & 0X7F) << 8;
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rdp5_len2;  /* RDP5 input length 2 */
         goto ptose20;                        /* process next data       */
       }
       D_ADSL_RSE1->imc_pos_inp_frame
         = ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur) - 2;
       adsl_gai1_inp_1->achc_ginp_cur++;    /* next character input    */
       /* next is hash                                                 */
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_SIZE_HASH;
       if (D_ADSL_RSE1->imc_prot_2 <= 0) {  /* length after hash       */
         iml_line_no = __LINE__;
         iml_source_no = 22535;
         goto ptose92;
       }
       D_ADSL_RSE1->achc_prot_1 = D_ADSL_RSE1->chrc_inp_hash;  /* input hash */
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rdp5_inp;  /* RDP5-style input data */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data  */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_rdp5_len2:               /* RDP5 input length 2     */
       D_ADSL_RSE1->imc_pos_inp_frame
         |= ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++);
       D_ADSL_RSE1->imc_pos_inp_frame -= 3;
       /* next is hash                                                 */
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_SIZE_HASH;
       if (D_ADSL_RSE1->imc_prot_2 <= 0) {  /* length after hash       */
         iml_line_no = __LINE__;
         iml_source_no = 22548;
         goto ptose92;
       }
       D_ADSL_RSE1->achc_prot_1 = D_ADSL_RSE1->chrc_inp_hash;  /* input hash */
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rdp5_inp;  /* RDP5-style input data */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data  */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_mcs_c1:                  /* MCS command 1           */
       switch (*adsl_gai1_inp_1->achc_ginp_cur) {
         case 0X04:                         /* MCS Errect Domain Request */
           if (D_ADSL_RSE1->iec_frcl_bl != ied_frcl_rec_05) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22559;
         goto ptose92;
           }
           adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input       */
           D_ADSL_RSE1->imc_pos_inp_frame--;  /* length constant       */
           if (D_ADSL_RSE1->imc_pos_inp_frame != 4) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22565;
         goto ptose92;
           }
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RSE1->chrc_prot_1;
#ifdef XYZ1
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
             goto ptose92;                  /* protocoll error          */
           }
#endif
           D_ADSL_RSE1->imc_prot_2 = 0;     /* copy all bytes          */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
//       case 0X20:                         /* MCS end of comm - machine down ???? UUUU */
         case 0X21:                         /* MCS end of comm ???? UUUU */
           if (D_ADSL_RSE1->iec_frcl_bl != ied_frcl_rec_xyz_01) {  /* ????ive block active PDU */
         iml_line_no = __LINE__;
         iml_source_no = 22580;
         goto ptose92;
           }
           adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input       */
           D_ADSL_RSE1->imc_pos_inp_frame--;  /* length constant       */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {
         iml_line_no = __LINE__;
         iml_source_no = 22585;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_end_com;  /* end of communication */
           goto ptose20;                    /* process next data       */
         case 0X28:                         /* MCS Attach User Request */
           if (D_ADSL_RSE1->iec_frcl_bl != ied_frcl_rec_06) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22592;
         goto ptose92;
           }
           adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input       */
           D_ADSL_RSE1->imc_pos_inp_frame--;  /* length constant       */
           if (D_ADSL_RSE1->imc_pos_inp_frame) {  /* more data to follow */
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22598;
         goto ptose92;
           }
           ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
           if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
             goto ptose96;                  /* program illogic         */
           }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
           ADSL_GAI1_OUT_G->adsc_next = NULL;
           ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
           memcpy( ADSL_OA1->achc_w1, ucrs_x224_r07_aurep, sizeof(ucrs_x224_r07_aurep) );
           ADSL_OA1->achc_w1 += sizeof(ucrs_x224_r07_aurep);
           *ADSL_OA1->achc_w1++ = 0;              /* status success          */
           m_put_be2( ADSL_OA1->achc_w1, ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_userid_cl2se );
           ADSL_OA1->achc_w1 += 2;
           ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
           if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
             adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
             adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
           } else {
             ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
           }
           ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one */
#undef ADSL_GAI1_OUT_G
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_cjreq_rec;  /* receive block channel join request */
           goto ptose20;                    /* process next data       */
         case 0X38:                         /* MCS Channel Join Request */
           if (D_ADSL_RSE1->iec_frcl_bl != ied_frcl_cjreq_rec) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22669;
         goto ptose92;
           }
           adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input       */
           D_ADSL_RSE1->imc_pos_inp_frame--;  /* length constant       */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22676;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_userid;  /* userid communication follows */
           goto ptose20;                    /* process next data       */
         case 0X64:                         /* MCS Send Data Request   */
           if (D_ADSL_RSE1->iec_frcl_bl == ied_frcl_cjreq_rec) {
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_clrand_rec;
           }
           adsl_gai1_inp_1->achc_ginp_cur++;  /* next byte input       */
           D_ADSL_RSE1->imc_pos_inp_frame--;  /* length constant       */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22712;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_userid;  /* userid communication follows */
           goto ptose20;                    /* process next data       */
       }
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22719;
         goto ptose92;
     case ied_fcfp_userid:                  /* userid communication follows */
       while (TRUE) {
         D_ADSL_RSE1->imc_prot_1 <<= 8;
         D_ADSL_RSE1->imc_prot_1
           |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->imc_pos_inp_frame--;
         if (D_ADSL_RSE1->imc_pos_inp_frame == D_ADSL_RSE1->imc_prot_2) break;
         if (adsl_gai1_inp_1->achc_ginp_cur
               >= adsl_gai1_inp_1->achc_ginp_end) {
           goto ptose20;                    /* needs more data         */
         }
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_userid found int=%d D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
       if (D_ADSL_RSE1->imc_prot_1 != D_ADSL_RCO1->usc_userid_cl2se) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22739;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
       if (D_ADSL_RSE1->imc_prot_2 < 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22744;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_prot_chno = 0;      /* clear value             */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_chno;  /* channel no follows */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_chno:                    /* channel number follows  */
       while (TRUE) {
         D_ADSL_RSE1->imc_prot_chno <<= 8;
         D_ADSL_RSE1->imc_prot_chno
           |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->imc_pos_inp_frame--;
         if (D_ADSL_RSE1->imc_pos_inp_frame == D_ADSL_RSE1->imc_prot_2) break;
         if (adsl_gai1_inp_1->achc_ginp_cur
               >= adsl_gai1_inp_1->achc_ginp_end) {
           goto ptose20;                    /* needs more data         */
         }
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_chno found int=%d D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_chno,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
//     switch (D_ADSL_RSE1->iec_frcl_bl) {
//     }
       if (D_ADSL_RSE1->iec_frcl_bl == ied_frcl_cjreq_rec) {
         do {
           if (D_ADSL_RSE1->imc_pos_inp_frame) {  /* more data to follow */
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22777;
         goto ptose92;
           }
           iml1 = -1;                       /* set display channel     */
           if (D_ADSL_RSE1->imc_prot_chno == D_ADSL_RCO1->usc_chno_disp) {  /* channel number display */
             break;
           }
           iml1 = D_ADSL_RCO1->imc_no_virt_ch;  /* number of virtual channels */
           while (iml1) {
#define D_ADSL_VCH (D_ADSL_RCO1->adsrc_vc_1 + (D_ADSL_RCO1->imc_no_virt_ch - iml1))
             /* compare virtual channel no                             */
             if (D_ADSL_RSE1->imc_prot_chno == D_ADSL_VCH->usc_vch_no) {
               break;
             }
#undef D_ADSL_VCH
             iml1--;                        /* number before           */
           }
           if (iml1 > 0) break;             /* channel found           */
           /* channel number control                                   */
           if (D_ADSL_RCO1->dtc_rdpfl_1.ibc_contchno) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22797;
         goto ptose92;
           }
           D_ADSL_RCO1->usc_chno_cont = (unsigned short int) D_ADSL_RSE1->imc_prot_chno;
           D_ADSL_RCO1->dtc_rdpfl_1.ibc_contchno = 1;
         } while (FALSE);
         /* send response to client                                    */
         ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
         if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
           goto ptose96;                    /* program illogic         */
         }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
         ADSL_GAI1_OUT_G->adsc_next = NULL;
         ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
         memcpy( ADSL_OA1->achc_w1, ucrs_x224_cjresp_1, sizeof(ucrs_x224_cjresp_1) );
         ADSL_OA1->achc_w1 += sizeof(ucrs_x224_cjresp_1);
         *ADSL_OA1->achc_w1++ = 0;          /* status success          */
         m_put_be2( ADSL_OA1->achc_w1, ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_userid_cl2se );
         ADSL_OA1->achc_w1 += 2;
         m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RSE1->imc_prot_chno );
         ADSL_OA1->achc_w1 += 2;
         m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RSE1->imc_prot_chno );
         ADSL_OA1->achc_w1 += 2;
         ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
         if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
           adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
           adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
         } else {
           ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
         }
         ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one       */
#undef ADSL_GAI1_OUT_G
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
         goto ptose20;                      /* process next data       */
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_clrand_rec:          /* receive client random   */
         case ied_frcl_c_logon_info_1:      /* logon information 1     */
         case ied_frcl_resp_act_pdu_rec:    /* response block active PDU */
         case ied_frcl_rec_xyz_01:
           if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22891;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_prio_seg;  /* Priority / Segmentation */
           goto ptose20;                    /* process next data       */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_prio_seg:                /* Priority / Segmentation */
       if (*adsl_gai1_inp_1->achc_ginp_cur != 0X70) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22900;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22906;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_mu_len_1;  /* multi length 1 */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_rt02:                    /* record type 2           */
       D_ADSL_RSE1->chc_prot_rt02 = *adsl_gai1_inp_1->achc_ginp_cur++;
#ifdef XYZ1
       adsl_gai1_inp_1->achc_ginp_cur++;
#endif
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22918;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rt03;  /* record type 3     */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_rt03:                    /* record type 3           */
#ifdef HL_RDPACC_HELP_DEBUG
     if (ADSL_RDPA_F) {                     /* memory defined          */
       if (ADSL_RDPA_F->boc_help_debug_1) {  /* stop debugger          */
         printf( "xlrdpa1 m_hlclib01() called boc_help_debug_1 set\n" );
         int inh1 = 0;
         inh1++;
       }
     }
#endif
       D_ADSL_RSE1->chc_prot_rt03 = *adsl_gai1_inp_1->achc_ginp_cur++;
#ifdef XYZ1
       if (*adsl_gai1_inp_1->achc_ginp_cur) {  /* contents not zero    */
         goto ptose92;                      /* protocoll error          */
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
#endif
       D_ADSL_RSE1->imc_pos_inp_frame--;
       /* two bytes padding follow - to be ignored                     */
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;
       if (D_ADSL_RSE1->imc_prot_2 < 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22944;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_padd_1;  /* padding         */
#ifdef NOT_VALID_060924
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rt04;  /* record type 4     */
#endif
       goto ptose20;                        /* process next data       */
#ifdef NOT_VALID_060924
     case ied_fcfp_rt04:                    /* record type 4           */
       D_ADSL_RSE1->chc_prot_rt04 = *adsl_gai1_inp_1->achc_ginp_cur++;
#ifndef B060924
       printf( "l%05d s%05d case ied_fcfp_rt04: D_ADSL_RSE1->chc_prot_rt04 = 0X%02X\n",
           __LINE__, 22956, (unsigned char) D_ADSL_RSE1->chc_prot_rt04 );
#endif
       D_ADSL_RSE1->imc_pos_inp_frame--;
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_padd_1;  /* padding         */
       goto ptose20;                        /* process next data       */
#endif
     case ied_fcfp_padd_1:                  /* padding                 */
       /* compute how many to ignore                                   */
       iml1 = D_ADSL_RSE1->imc_pos_inp_frame
                - D_ADSL_RSE1->imc_prot_2;
       if (iml1 > iml_rec) iml1 = iml_rec;
       adsl_gai1_inp_1->achc_ginp_cur += iml1;
       D_ADSL_RSE1->imc_pos_inp_frame -= iml1;  /* length constant     */
       if (D_ADSL_RSE1->imc_pos_inp_frame > D_ADSL_RSE1->imc_prot_2) {
         goto ptose20;                      /* needs more data         */
       }
#ifdef NOT_VALID_060924
       /* one byte to be ignored                                       */
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
#endif
       switch (D_ADSL_RSE1->chc_prot_rt02 & 0XC7) {
         case 0X01:                         /* client random           */
           if (D_ADSL_RSE1->iec_frcl_bl != ied_frcl_clrand_rec) {  /* receive client random */
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22988;
         goto ptose92;
           }
           if (D_ADSL_RSE1->chc_prot_rt02 & 0X08) {  /* block encrypted */
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 22992;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_client_rand;  /* receive client random   */
           goto ptose20;                    /* process next data       */
         case 0X40:                         /* logon information 1     */
           switch (D_ADSL_RSE1->iec_frcl_bl) {
             case ied_frcl_c_logon_info_1:  /* logon information 1     */
               break;
             default:                       /* other values            */
//             goto ptose92;                /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23006;
         goto ptose92;
           }
           break;
         case 0X00:                         /* response block active PDU */
           switch (D_ADSL_RSE1->iec_frcl_bl) {
             case ied_frcl_resp_act_pdu_rec:  /* response block active PDU */
// new 24.05.07 KB
             case ied_frcl_rec_xyz_01:
               break;
             default:                       /* other values            */
//             goto ptose92;                /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23021;
         goto ptose92;
           }
           break;
         case 0X80:                         /* SEC_LICENSE_PKT         */
           switch (D_ADSL_RSE1->iec_frcl_bl) {
             case ied_frcl_rec_xyz_01:
             case ied_frcl_resp_act_pdu_rec:  /* response block active PDU */
               break;
             default:                       /* other values            */
//             goto ptose92;                /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23044;
         goto ptose92;
           }
           break;
         default:
            printf( "padding case %02X received from client iec_frcl_bl=%d iec_fcfp_bl=%d l%d s%d\n",
                    (unsigned char) D_ADSL_RSE1->chc_prot_rt02,
                    ADSL_RDPA_F->dsc_rdp_se_1.iec_frcl_bl,
                    ADSL_RDPA_F->dsc_rdp_se_1.iec_fcfp_bl,
                    __LINE__,               /* line number for errors  */
                    23053 );       /* source line no for errors */
           goto ptose96;                    /* program illogic         */
       }
#ifdef TRACEHL1
       printf( "28.12.04 KB - encrypted part follows\n" );
#endif
       if ((D_ADSL_RSE1->chc_prot_rt02 & 0X08) == 0) {  /* block not encrypted */
#ifndef D_BUG_HLJWT_INP1                    /* 17.07.07 KB - input from HOBlink JWT not encrypted */
         iml_line_no = __LINE__;
         iml_source_no = 23061;
         goto ptose92;
#else
           /* check if all data of this frame have been received       */
           iml1 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
           adsl_gai1_inp_w2 = adsl_gai1_inp_1;  /* get gather          */
           while (TRUE) {                   /* loop over all gather structures input */
             iml1 -= adsl_gai1_inp_w2->achc_ginp_end - adsl_gai1_inp_w2->achc_ginp_cur;
             if (iml1 <= 0) break;          /* enough data found       */
             adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;  /* get next gather */
             if (adsl_gai1_inp_w2 == NULL) {  /* already end of chain  */
               /* wait for more data                                   */
               goto ptose80;               /* check how to return     */
             }
           }
           if (D_ADSL_RSE1->iec_frcl_bl == ied_frcl_c_logon_info_1) {  /* logon information 1 */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 23147;
         goto ptose92;
             }
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore next bytes */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_options;  /* Options */
             goto ptose20;                  /* process next data       */
           }
           if (D_ADSL_RSE1->imc_prot_chno == D_ADSL_RCO1->usc_chno_disp) {  /* channel number display  */
//           *M_ERROR_TOSE_PROT;            /* protocoll error          */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
             D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
             D_ADSL_RSE1->imc_prot_1 = 0;   /* clear value             */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_pdu_type_1_l;  /* get RDP4 PDU type */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 23189;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rdp4_vch_ulen;  /* virtual channel uncompressed data length */
           goto ptose20;                    /* process next data       */
#endif
       }
       /* next receive the hash of this frame                          */
       D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RSE1->chrc_prot_1;
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_SIZE_HASH;
       if (D_ADSL_RSE1->imc_prot_2 <= 0) {  /* shorter than hash length? */
         iml_line_no = __LINE__;
         iml_source_no = 23215;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data  */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_data_pdu_1:              /* RDP4 data PDU follows   */
       D_ADSL_RSE1->imc_prot_1 = 0;         /* do not read compressedType and compressedLength */
       switch (*adsl_gai1_inp_1->achc_ginp_cur) {
         case PDUTYPE2_REFRESH_RECT:        /* 0X21 == 33              */
           D_ADSL_RSE1->imc_prot_1 = *adsl_gai1_inp_1->achc_ginp_cur;  /* do read compressedType and compressedLength */
           break;
         case PDUTYPE2_SUPPRESS_OUTPUT:     /* 0X23 == 35              */
           D_ADSL_RSE1->imc_prot_1 = *adsl_gai1_inp_1->achc_ginp_cur;  /* do read compressedType and compressedLength */
           break;
         case PDUTYPE2_SHUTDOWN_REQUEST:    /* 0X24 == 36              */
           ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1);
           ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
           if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
             m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                           __LINE__, 23548 );  /* line number for errors */
             goto ptose96;                  /* program illogic         */
           }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
           memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) );
           ADSL_CL_CO1->iec_cl_command = ied_clc_shutdown_requ;  /* shutdown request from client side */
           if (ADSL_OA1->adsc_cl_co1 == NULL) {
             adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
           } else {
             ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
           }
           ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;  /* save last in chain */
#undef ADSL_CL_CO1
           D_ADSL_RSE1->imc_prot_1 = *adsl_gai1_inp_1->achc_ginp_cur;  /* do read compressedType and compressedLength */
           break;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_prot_1) {       /* do read compressedType and compressedLength */
         D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 3;  /* number of bytes */
         if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame        */
         iml_line_no = __LINE__;
         iml_source_no = 23571;
         goto ptose92;
         }
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
         D_ADSL_RSE1->iec_frcl_bl = ied_frcl_sharedataheader_compr;  /* TS_SHAREDATAHEADER compressedType and compressedLength */
         goto ptose20;                      /* process next data       */
       }
       /* ignore remaining part                                        */
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_data_pdu_end;  /* RDP4 data PDU end */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data     */
       D_ADSL_RSE1->imc_prot_2 = 0;         /* till end of block       */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_set_display_updates:     /* PDUTYPE2_SUPPRESS_OUTPUT */
       switch (*adsl_gai1_inp_1->achc_ginp_cur) {
         case SV_SAVEBITS:                  /* 0X00 Save bitmap operation */
           D_ADSL_RCO1->boc_suppress_display_updates = TRUE;  /* RDP client is minimized */
           break;
         case SV_RESTOREBITS:               /* 0X01 Restore bitmap operation */
           D_ADSL_RCO1->boc_suppress_display_updates = FALSE;  /* RDP client is not minimized */
           break;
         default:
         iml_line_no = __LINE__;
         iml_source_no = 23592;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       /* ignore remaining part                                        */
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_data_pdu_end;  /* RDP4 data PDU end */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data     */
       D_ADSL_RSE1->imc_prot_2 = 0;         /* till end of block       */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_refresh_no_areas:        /* PDUTYPE2_REFRESH_RECT   */
       if (*adsl_gai1_inp_1->achc_ginp_cur != 1) {
         iml_line_no = __LINE__;
         iml_source_no = 23603;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_pos_inp_frame != (3 + 8)) {  /* pad3Octects + TS_RECTANGLE16 */
         iml_line_no = __LINE__;
         iml_source_no = 23608;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_prot_2 = 8;         /* till TS_RECTANGLE16 follows */
       D_ADSL_RSE1->iec_frcl_bl = ied_frcl_refresh_no_areas;  /* PDUTYPE2_REFRESH_RECT */
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data     */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_asn1_tag:                /* ASN.1 tag follows       */
       adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_pos_inp_frame < D_ADSL_RSE1->imc_prot_3) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23620;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_l1_fi;  /* ASN.1 length field */
       goto ptose20;                        /* process next data       */
     case ied_fcfp_asn1_l1_fi:              /* ASN.1 length field 1    */
       D_ADSL_RSE1->imc_prot_1
         = *adsl_gai1_inp_1->achc_ginp_cur & 0X7F;
       if (D_ADSL_RSE1->imc_prot_1 == 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23629;
         goto ptose92;
       }
       D_ADSL_RSE1->imc_pos_inp_frame--;
       /* compute how many remain after this length                    */
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                  - D_ADSL_RSE1->imc_prot_1;
       if (D_ADSL_RSE1->imc_prot_2 < 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23637;
         goto ptose92;
       }
       /* check ASN-1 length in more than one byte                     */
       if (*adsl_gai1_inp_1->achc_ginp_cur & 0X80) {
         if (D_ADSL_RSE1->imc_prot_1 > 4) {
//         goto ptose92;                    /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23643;
         goto ptose92;
         }
         adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->imc_prot_1 = 0;        /* length comes to this    */
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_l1_p2;  /* ASN.1 length part two */
         goto ptose20;                      /* process next data       */
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_asn1_l1_fi found len=%d till=%d D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->imc_prot_2,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
       adsl_gai1_inp_1->achc_ginp_cur++;
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_start:
           if (D_ADSL_RSE1->imc_prot_2) {
             printf( "ied_frcl_start found end invalid %d / %d\n",
                     D_ADSL_RSE1->imc_prot_2, D_ADSL_RSE1->imc_pos_inp_frame );
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23663;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcscoen:         /* MCS connect encoding    */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_prot_2;  /* save end data */
           /* protocol error 07.08.04 KB ??? */
           if (D_ADSL_RSE1->imc_prot_3 > 0) {
             printf( "ied_frcl_r02_mcscoen found end too early %d\n",
                     D_ADSL_RSE1->imc_prot_3 );
             D_ADSL_RSE1->imc_prot_3 = 0;   /* save end data all block */
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_cids;  /* b2 MC Calling Domain Selector */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_cids:         /* b2 MC Calling Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_ceds:         /* b2 MC Called Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_upwf:         /* b2 MC Upward Flag       */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_tdop:         /* b2 MC Target Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_midp:         /* b2 MC Minimum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_madp:         /* b2 MC Maximum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_usd1:         /* b2 MC User Data Start   */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_lencons_2;  /* rec len c */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear length field      */
           goto ptose20;                    /* process next data       */
         default:
           goto ptose96;                    /* program illogic         */
       }
     case ied_fcfp_asn1_l1_p2:              /* ASN.1 length part two   */
       while (TRUE) {
         D_ADSL_RSE1->imc_prot_1 <<= 8;
         D_ADSL_RSE1->imc_prot_1
           |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->imc_pos_inp_frame--;
         if (D_ADSL_RSE1->imc_pos_inp_frame == D_ADSL_RSE1->imc_prot_2) break;
         if (adsl_gai1_inp_1->achc_ginp_cur
               >= adsl_gai1_inp_1->achc_ginp_end) {
           goto ptose20;                    /* needs more data         */
         }
       }
       /* compute how many remain after this length                    */
       D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                  - D_ADSL_RSE1->imc_prot_1;
       if (D_ADSL_RSE1->imc_prot_2 < D_ADSL_RSE1->imc_prot_3) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23720;
         goto ptose92;
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_asn1_l1_p2 found len=%d till=%d D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->imc_prot_2,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_mcscoen:         /* MCS connect encoding    */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_prot_2;  /* save end data */
           /* protocol error 07.08.04 KB ??? */
           if (D_ADSL_RSE1->imc_prot_3 > 0) {
             printf( "ied_frcl_r02_mcscoen found end too early %d\n",
                     D_ADSL_RSE1->imc_prot_3 );
             D_ADSL_RSE1->imc_prot_3 = 0;    /* save end data all block */
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_asn1_tag;  /* ASN.1 tag follows */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mc_cids;  /* b2 MC Calling Domain Selector */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_cids:         /* b2 MC Calling Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_ceds:         /* b2 MC Called Domain Selector */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_upwf:         /* b2 MC Upward Flag       */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_tdop:         /* b2 MC Target Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_midp:         /* b2 MC Minimum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_madp:         /* b2 MC Maximum Domain Parameters */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mc_usd1:         /* b2 MC User Data Start   */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_lencons_2;  /* rec len c */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear length field      */
           goto ptose20;                    /* process next data       */
//       default:
//         goto ptose96;                    /* program illogic         */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_mu_len_1:                /* multi length 1          */
       D_ADSL_RSE1->imc_prot_1
         = *adsl_gai1_inp_1->achc_ginp_cur & 0X7F;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (*adsl_gai1_inp_1->achc_ginp_cur & 0X80) {  /* second byte follows */
         adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_mu_len_2;  /* multi length 2 follows */
         goto ptose20;                      /* process next data       */
       }
       adsl_gai1_inp_1->achc_ginp_cur++;
       if (D_ADSL_RSE1->imc_prot_1 == 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23778;
         goto ptose92;
       }
       if (D_ADSL_RSE1->imc_pos_inp_frame < D_ADSL_RSE1->imc_prot_1) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23782;
         goto ptose92;
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_mcud_l1:         /* b2 MC Us-Da length 1    */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - 12;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23790;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
#ifdef B060907
         case ied_frcl_r02_mcud_dtt:        /* b2 MC Us-Da Desktop Tag */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_desktop_tag)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23798;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
#endif
         case ied_frcl_r02_fietype:         /* b2 MC Us-Da Record Type */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_clrand_rec:          /* receive client random   */
         case ied_frcl_c_logon_info_1:      /* logon information 1     */
         case ied_frcl_rec_xyz_01:
           /* compute where end of this field                          */
           D_ADSL_RSE1->imc_prot_4
             = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_1;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rt02;  /* record type 2 */
           goto ptose20;                    /* process next data       */
//       default:
//         goto ptose96;                    /* program illogic         */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_mu_len_2:                /* multi length 2          */
       D_ADSL_RSE1->imc_prot_1 <<= 8;       /* shift old value         */
       D_ADSL_RSE1->imc_prot_1
         |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
       D_ADSL_RSE1->imc_pos_inp_frame--;
       if (D_ADSL_RSE1->imc_prot_1 == 0) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23829;
         goto ptose92;
       }
       if (D_ADSL_RSE1->imc_pos_inp_frame < D_ADSL_RSE1->imc_prot_1) {
//       goto ptose92;                      /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23833;
         goto ptose92;
       }
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_mcud_l1:         /* b2 MC Us-Da length 1    */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - 12;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23841;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data  */
           goto ptose20;                    /* process next data       */
#ifdef B060907
         case ied_frcl_r02_mcud_dtt:        /* b2 MC Us-Da Desktop Tag */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_desktop_tag)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23849;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
#endif
         case ied_frcl_r02_fietype:         /* b2 MC Us-Da Record Type */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_clrand_rec:          /* receive client random   */
         case ied_frcl_c_logon_info_1:      /* logon information 1     */
         case ied_frcl_resp_act_pdu_rec:    /* response block active PDU */
         case ied_frcl_rec_xyz_01:
           /* compute where end of this field                          */
           D_ADSL_RSE1->imc_prot_4
             = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_1;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rt02;  /* record type 2 */
           goto ptose20;                    /* process next data       */
//       default:
//         goto ptose96;                    /* program illogic         */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_int_lit_e:               /* int little endian       */
       while (TRUE) {
         D_ADSL_RSE1->imc_prot_1
           |= ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++)
                << ((D_ADSL_RSE1->imc_prot_3 - D_ADSL_RSE1->imc_pos_inp_frame)
                      << 3);
         D_ADSL_RSE1->imc_pos_inp_frame--;
         if (D_ADSL_RSE1->imc_pos_inp_frame == D_ADSL_RSE1->imc_prot_2) break;
         if (adsl_gai1_inp_1->achc_ginp_cur
               >= adsl_gai1_inp_1->achc_ginp_end) {
           goto ptose20;                    /* needs more data         */
         }
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_int_lit_e found int=%d/0X%08X D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
       switch (D_ADSL_RSE1->iec_frcl_bl) {
         case ied_frcl_r02_fietype:         /* b2 MC Field Type        */
           D_ADSL_RSE1->imc_prot_4 = D_ADSL_RSE1->imc_prot_1;  /* save field type */
           if ((D_ADSL_RSE1->imc_prot_4 & 0XFF00) != 0XC000) {  /* check value */
         iml_line_no = __LINE__;
         iml_source_no = 23897;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 23901;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_fielen;  /* b2 MC Field Length */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_fielen:          /* b2 MC Field Length      */
           if (D_ADSL_RSE1->imc_prot_1 < 4) {  /* check value minimum length field */
         iml_line_no = __LINE__;
         iml_source_no = 23910;
         goto ptose92;
           }
           /* compute end of this field                                */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - (D_ADSL_RSE1->imc_prot_1 - 4);
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* more than frame?     */
         iml_line_no = __LINE__;
         iml_source_no = 23915;
         goto ptose92;
           }
           switch (D_ADSL_RSE1->imc_prot_4) {
             case 0XC001:                   /* field user data         */
               D_ADSL_RSE1->imc_prot_4 = D_ADSL_RSE1->imc_prot_2;  /* save end of this field */
#ifdef B060907
               D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
               D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_c01;  /* b2 MC Us-Da const 01 */
               D_ADSL_RSE1->imc_prot_1 = 0;  /* position               */
               goto ptose20;                /* process next data       */
#endif
               /* protocol version                                     */
               D_ADSL_RSE1->achc_prot_1 = (char *) &D_ADSL_RCO1->ucc_prot_vers;
               D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                          - sizeof(D_ADSL_RCO1->ucc_prot_vers);
               if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* more than frame? */
         iml_line_no = __LINE__;
         iml_source_no = 23931;
         goto ptose92;
               }
               D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
               D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_c01;  /* b2 MC Us-Da const 01 */
               goto ptose20;                /* process next data       */
             case 0XC003:                   /* virtual channels        */
//             D_ADSL_RSE1->imc_prot_4 = D_ADSL_RSE1->imc_prot_2;  /* save end of this field */
               if (D_ADSL_RSE1->imc_prot_2 != 0) {  /* not till end of frame */
         iml_line_no = __LINE__;
         iml_source_no = 23939;
         goto ptose92;
               }
               /* get number of virtual channels                       */
               D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
               if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* more than frame? */
         iml_line_no = __LINE__;
         iml_source_no = 23944;
         goto ptose92;
               }
               D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
               D_ADSL_RSE1->imc_prot_1 = 0;      /* clear value             */
//             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
               D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_nvc;  /* b2 MC Us-Da no virt ch */
               goto ptose20;                /* process next data       */
           }
           // Problem, solved by SM:
           // If this is the end of the frame, we have to set the right states
           // for the next packet. Protocoll error otherwise.
           if(D_ADSL_RSE1->imc_prot_2 == 0) {
              m_send_cl_r04( adsp_hl_clib_1, ADSL_OA1 );  /* send block 04 to client */
              adsl_gai1_inp_1->achc_ginp_cur += D_ADSL_RSE1->imc_pos_inp_frame;
              D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
              D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_05;  /* receive block 5 */
              goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* default ignore data */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_fietype;  /* b2 MC Field Type */
           goto ptose20;                    /* process next data       */
#ifdef B060907
         case ied_frcl_r02_mcud_dtt:        /* b2 MC Us-Da Desktop Tag */
/* what for imc_prot_1 length? 07.08.04 KB */
           /* protocol version                                         */
           D_ADSL_RSE1->achc_prot_1 = (char *) &D_ADSL_RCO1->ucc_prot_vers;
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - sizeof(D_ADSL_RCO1->ucc_prot_vers);
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23976;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
#endif
         case ied_frcl_r02_mcud_scw:        /* b2 MC Us-Da scr width   */
           D_ADSL_RCO1->imc_dim_x = D_ADSL_RSE1->imc_prot_1;  /* dimension x pixels */
//         D_ADSL_RCL1->imc_cmp_dim_x = D_ADSL_RSE1->imc_prot_1;  /* dimension x pixels */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23987;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_sch;  /* b2 MC Us-Da scr height */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_sch:        /* b2 MC Us-Da scr height  */
           D_ADSL_RCO1->imc_dim_y = D_ADSL_RSE1->imc_prot_1;  /* dimension y pixels */
//         D_ADSL_RCL1->imc_cmp_dim_y = D_ADSL_RSE1->imc_prot_1;  /* dimension y pixels */
           if (D_ADSL_RSE1->imc_pos_inp_frame <= sizeof(ucrs_r02c02)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 23999;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_constant;  /* compare with constant */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_c02;  /* b2 MC Us-Da const 02 */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* position                */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_kbl:        /* b2 MC Us-Da Keyboard La */
           D_ADSL_RCO1->imc_keyboard_layout = D_ADSL_RSE1->imc_prot_1;  /* Keyboard Layout */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24010;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_bun;  /* b2 MC Us-Da Build Numb */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_bun:        /* b2 MC Us-Da Build Numb  */
           D_ADSL_RCO1->imc_build_number = D_ADSL_RSE1->imc_prot_1;  /* dimension y pixels */
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->wcrc_computer_name;
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - sizeof(D_ADSL_RCO1->wcrc_computer_name);
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24024;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_con;  /* b2 MC Us-Da Computer Na */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_kbt:        /* b2 MC Us-Da Keyboard Ty */
           D_ADSL_RCO1->imc_keyboard_type = D_ADSL_RSE1->imc_prot_1;  /* Type of Keyboard / 102 */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24034;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_kbs;  /* b2 MC Us-Da Keyboard ST */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_kbs:        /* b2 MC Us-Da Keyboard ST */
           D_ADSL_RCO1->imc_keyboard_subtype = D_ADSL_RSE1->imc_prot_1;  /* Subtype of Keyboard */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24046;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_nfk;  /* b2 MC Us-Da No Func Key */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_nfk:        /* b2 MC Us-Da No Func Key */
           D_ADSL_RCO1->imc_no_func_keys = D_ADSL_RSE1->imc_prot_1;  /* Number of Function Keys */
#ifdef TRACEHL1
           printf( "08.08.04 target 01 reached\n" );
#endif
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - 64;
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24062;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_ime;  /* b2 MC Us-Da IME Keyb ma */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_cod:        /* b2 MC Us-Da Color Depth */
           D_ADSL_RCO1->imc_cl_coldep = D_ADSL_RSE1->imc_prot_1;  /* client capabilities colour depth */
// to be removed
//         D_ADSL_RCO1->imc_color_depth = D_ADSL_RSE1->imc_prot_1;  /* Bits Color Depth */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 24091;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_sup_cod;  /* b2 MC Us-Da supported Color Depth */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_sup_cod:    /* b2 MC Us-Da supported Color Depth */
           D_ADSL_RCO1->usc_cl_supported_color_depth = D_ADSL_RSE1->imc_prot_1;  /* client capabilities */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 24102;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_early_cf;  /* b2 MC Us-Da early capability flag */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_early_cf:   /* b2 MC Us-Da early capability flag */
           D_ADSL_RCO1->usc_cl_early_capability_flag = D_ADSL_RSE1->imc_prot_1;  /* client capabilities */
           /* ignore remaining part                                    */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_prot_4;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_fietype;  /* b2 MC Field Type */
           goto ptose20;                    /* process next data       */
#ifdef B060907
         case ied_frcl_r02_mcud_vc1:        /* b2 MC Us-Da virtual ch  */
           if (D_ADSL_RSE1->imc_prot_1 != (D_ADSL_RSE1->imc_pos_inp_frame + 4)) {
             printf( "ied_frcl_r02_mcud_vc1 remaining length invalid\n" );
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 4;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24124;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_nvc;  /* b2 MC Us-Da no virt ch */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
//         D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_int_lit_e;  /* int little endian */
           goto ptose20;                    /* process next data       */
#endif
         case ied_frcl_r02_mcud_nvc:        /* b2 MC Us-Da no virt ch  */
           D_ADSL_RCO1->imc_no_virt_ch = D_ADSL_RSE1->imc_prot_1;  /* number of virtual channels */
           D_ADSL_RCO1->usc_userid_cl2se = D_ADSL_RCO1->imc_no_virt_ch + 3; /* SM/JB, Malta 13.07.11: User channel is 1001 + userID. Because of that the user-ID has to be minimum 3 + number of virtual channels. */
#ifdef TRACEHL1
           printf( "client imc_no_virt_ch=%d imc_pos_inp_frame=%d / pos=%d/0X%08X\n",
                   D_ADSL_RCO1->imc_no_virt_ch, D_ADSL_RSE1->imc_pos_inp_frame,
                   adsl_gai1_inp_1->achc_ginp_cur - achl_help_sta,
                   adsl_gai1_inp_1->achc_ginp_cur - achl_help_sta );
#endif
           if (D_ADSL_RCO1->imc_no_virt_ch == 0) {
             if (D_ADSL_RSE1->imc_pos_inp_frame) {
               printf( "ied_frcl_r02_mcud_nvc no channels - data in record remaining %d\n",
                       D_ADSL_RSE1->imc_pos_inp_frame );
//             goto ptose92;                /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24148;
         goto ptose92;
             }
             m_send_cl_r04( adsp_hl_clib_1, ADSL_OA1 );  /* send block 04 to client */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_05;  /* receive block 5 */
             goto ptose20;                  /* process next data       */
           }
           if (D_ADSL_RSE1->imc_pos_inp_frame
                 != (D_ADSL_RCO1->imc_no_virt_ch * DEF_LEN_VIRTCH_STA)) {
             printf( "ied_frcl_r02_mcud_nvc %d channels - data in record remaining %d\n",
                     D_ADSL_RCO1->imc_no_virt_ch,
                     D_ADSL_RSE1->imc_pos_inp_frame );
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24171;
         goto ptose92;
           }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->adsrc_vc_1) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->imc_no_virt_ch * sizeof(struct dsd_rdp_vc_1) );
           memset( D_ADSL_RCO1->adsrc_vc_1, 0, D_ADSL_RCO1->imc_no_virt_ch * sizeof(struct dsd_rdp_vc_1) );
           /* give numbers to the virtual channels                     */
           iml1 = 0;
#define D_ADSL_VCH (D_ADSL_RCO1->adsrc_vc_1 + iml1)
           while (iml1 < D_ADSL_RCO1->imc_no_virt_ch) {
//           D_ADSL_VCH->usc_vch_no = 0X03EB + iml1;
             D_ADSL_VCH->usc_vch_no
               = ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.usc_chno_disp
                   + 1 + iml1;
             iml1++;                        /* next virtual channel    */
           }
#undef D_ADSL_VCH
           D_ADSL_RSE1->imc_prot_4 = 0;     /* start with first channel */
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->adsrc_vc_1->byrc_name;
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - sizeof(D_ADSL_RCO1->adsrc_vc_1->byrc_name);
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_vcn;  /* b2 MC Us-Da virt ch name */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_r02_mcud_vcf:        /* b2 MC Us-Da virt ch fla */
           D_ADSL_RCO1->adsrc_vc_1[ D_ADSL_RSE1->imc_prot_4++ ].imc_flags
             = D_ADSL_RSE1->imc_prot_1;     /* set flags               */
		   
           if(D_ADSL_RSE1->imc_prot_1 & 0x00400000)
              D_ADSL_RCO1->boc_always_compr_vc = TRUE; /* [MS-RDPBCGR].pds 2.2.1.3.4.1 Channel Definition Structure (CHANNEL_DEF) */

           /* check if was last channel                                */
           if (D_ADSL_RSE1->imc_prot_4 == D_ADSL_RCO1->imc_no_virt_ch) {
             m_send_cl_r04( adsp_hl_clib_1, ADSL_OA1 );  /* send block 04 to client */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_05;  /* receive block 5 */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->adsrc_vc_1[ D_ADSL_RSE1->imc_prot_4 ].byrc_name;
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame
                                      - sizeof(D_ADSL_RCO1->adsrc_vc_1->byrc_name);
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_r02_mcud_vcn;  /* b2 MC Us-Da virt ch name */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
         case ied_frcl_client_rand:         /* receive client random   */
           if (D_ADSL_RSE1->imc_prot_1 > (D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_4)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24286;
         goto ptose92;
           }
           if (D_ADSL_RSE1->imc_prot_1 > sizeof(D_ADSL_RSE1->chrc_prot_1)) {
//           goto ptose92;                  /* protocoll error          */
         iml_line_no = __LINE__;
         iml_source_no = 24293;
         goto ptose92;
           }
           D_ADSL_RSE1->achc_prot_1 = D_ADSL_RSE1->chrc_prot_1;
           D_ADSL_RSE1->imc_prot_2
             = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_1;  /* number of bytes */
#ifdef XYZ1
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
             goto ptose92;                  /* protocoll error          */
           }
#endif
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear position          */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_invers;  /* copy data invers */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_options:     /* Options                 */
           D_ADSL_RCO1->umc_loinf_options = D_ADSL_RSE1->imc_prot_1;  /* Logon Info Options */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24311;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_domna_len;  /* Domain Name Length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_domna_len:   /* Domain Name Length      */
           D_ADSL_RCO1->usc_loinf_domna_len = D_ADSL_RSE1->imc_prot_1;  /* Domain Name Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24321;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_userna_len;  /* User Name Length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_userna_len:  /* User Name Length       */
           D_ADSL_RCO1->usc_loinf_userna_len = D_ADSL_RSE1->imc_prot_1;  /* User Name Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24331;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_pwd_len;  /* Password Length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_pwd_len:     /* Password Length         */
           D_ADSL_RCO1->usc_loinf_pwd_len = D_ADSL_RSE1->imc_prot_1;  /* Password Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24341;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_altsh_len;  /* Alt Shell Length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_altsh_len:   /* Alt Shell Length        */
           D_ADSL_RCO1->usc_loinf_altsh_len = D_ADSL_RSE1->imc_prot_1;  /* Alt Shell Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24351;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_wodir_len;  /* Working Directory Length */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_wodir_len:   /* Working Directory Length */
           D_ADSL_RCO1->usc_loinf_wodir_len = D_ADSL_RSE1->imc_prot_1;  /* Working Directory Length */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_domna_val;  /* Domain Name String */
           if (D_ADSL_RCO1->usc_loinf_domna_len) {  /* Domain Name Length */
             D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RCO1->usc_loinf_domna_len;  /* number of bytes */
             if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame    */
         iml_line_no = __LINE__;
         iml_source_no = 24363;
         goto ptose92;
             }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_domna_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RCO1->usc_loinf_domna_len );
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_domna_a;  /* Domain Name */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24372;
         goto ptose92;
           }
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_zero_cmp;  /* compare zeroes */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_no_a_par:    /* number of additional parameters */
           D_ADSL_RCO1->usc_loinf_no_a_par = D_ADSL_RSE1->imc_prot_1;  /* number of additional parameters */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24380;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_ineta;  /* INETA */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_ineta:       /* INETA                   */
           if (D_ADSL_RSE1->imc_prot_1 == 0) {  /* length zero         */
         iml_line_no = __LINE__;
         iml_source_no = 24388;
         goto ptose92;
           }
           D_ADSL_RCO1->usc_loinf_ineta_len = D_ADSL_RSE1->imc_prot_1;  /* INETA Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_1;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24393;
         goto ptose92;
           }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_ineta_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->imc_prot_1 );
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_ineta_a;  /* INETA */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
           goto ptose20;                    /* process next data       */
         case ied_frcl_c_loinf_path:        /* Client Path             */
           if (D_ADSL_RSE1->imc_prot_1 == 0) {  /* length zero         */
             if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) {  /* nothing left */
         iml_line_no = __LINE__;
         iml_source_no = 24405;
         goto ptose92;
             }
             D_ADSL_RCO1->usc_loinf_extra_len = D_ADSL_RSE1->imc_pos_inp_frame;  /* Extra Parameters Length */
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_extra_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->imc_pos_inp_frame );
             D_ADSL_RSE1->imc_prot_2 = 0;   /* copy till end of frame  */
             D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_extra_a;  /* Extra Parameters */
             D_ADSL_RSE1->iec_frcl_bl = ied_frcl_c_loinf_extra;  /* Extra Parameters */
             D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RCO1->usc_loinf_path_len = D_ADSL_RSE1->imc_prot_1;  /* Client Path Length */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - D_ADSL_RSE1->imc_prot_1;  /* number of bytes */
           if (D_ADSL_RSE1->imc_prot_2 < 0) {  /* longer as frame      */
         iml_line_no = __LINE__;
         iml_source_no = 24421;
         goto ptose92;
           }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   *((void **) &D_ADSL_RCO1->awcc_loinf_path_a) = m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1, D_ADSL_RSE1->imc_prot_1 );
           D_ADSL_RSE1->achc_prot_1 = (char *) D_ADSL_RCO1->awcc_loinf_path_a;  /* Client Path */
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data normal */
           goto ptose20;                    /* process next data       */
         case ied_frcl_pdu_type_1_l:        /* get RDP4 PDU type length */
           if (D_ADSL_RSE1->imc_prot_1 < 4) {  /* check minimum value  */
         iml_line_no = __LINE__;
         iml_source_no = 24430;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_4
             = (D_ADSL_RSE1->imc_pos_inp_frame + 2) - D_ADSL_RSE1->imc_prot_1;  /* length after this sequence */
           if (D_ADSL_RSE1->imc_prot_4 < 0) {  /* longer than frame    */
         iml_line_no = __LINE__;
         iml_source_no = 24440;
         goto ptose92;
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 2;  /* number of bytes */
           D_ADSL_RSE1->imc_prot_3 = D_ADSL_RSE1->imc_pos_inp_frame;  /* here first byte */
           D_ADSL_RSE1->imc_prot_1 = 0;     /* clear value             */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_pdu_type_1_t;  /* get RDP4 PDU type */
           goto ptose20;                    /* process next data       */
         case ied_frcl_pdu_type_1_t:        /* get RDP4 PDU type type  */
#ifdef TRACEHL1
           printf( "l%05d s%05d ied_frcl_pdu_type_1_t type=%d/0X%X length=%d/0X%X remaining after this=%d\n",
                   __LINE__, 24451,
                   D_ADSL_RSE1->imc_prot_1,
                   D_ADSL_RSE1->imc_prot_1,
                   D_ADSL_RSE1->imc_prot_4 + D_ADSL_RSE1->imc_pos_inp_frame + 4,
                   D_ADSL_RSE1->imc_prot_4 + D_ADSL_RSE1->imc_pos_inp_frame + 4,
                   D_ADSL_RSE1->imc_prot_4 );
#endif
// JB: Parse HOB_CAPS for MacGate
           /* This is a confirm active PDU! */
           if (D_ADSL_RSE1->imc_prot_1 == 0X13){
#ifdef _DEBUG
             printf("PDU 0x%02X\n", D_ADSL_RSE1->imc_prot_1);
             m_console_out(adsl_gai1_inp_1->achc_ginp_cur, adsl_gai1_inp_1->achc_ginp_end-adsl_gai1_inp_1->achc_ginp_cur);
#endif
#define GATHER_SKIP(IM_SKIP, IM_COUNTER) if(m_gather_skip(&adsl_gai1_inp_1, IM_SKIP, &(IM_COUNTER) ) == FALSE) { \
                                           iml_line_no = __LINE__;                                             \
                                           iml_source_no = 24467;                                      \
                                           goto ptose92;                                                       \
                                         }
#define GATHER_LE(IM_BYTES, IM_COUNTER, IM_RETVAL) if(m_gather_get_le(&adsl_gai1_inp_1, IM_BYTES, &(IM_COUNTER), &(IM_RETVAL)) == FALSE) {\
                                                     iml_line_no = __LINE__;                                             \
                                                     iml_source_no = 24472;                                      \
                                                     goto ptose92;                                                       \
                                                   }
             char ch_1;
#define GATHER_BYTE(IM_COUNTER, IM_RETVAL) if(m_gather_get_byte(&adsl_gai1_inp_1, &(IM_COUNTER), &(ch_1)) == FALSE) { \
                                             iml_line_no = __LINE__;                                                  \
                                             iml_source_no = 24478;                                           \
                                             goto ptose92;                                                            \
                                           }                                                                          \
                                           IM_RETVAL = (unsigned char) ch_1; 
#define GATHER_HASN(IM_COUNTER, IM_RETVAL) if(m_gather_get_hasn(&adsl_gai1_inp_1, &(IM_COUNTER), &(IM_RETVAL)) == FALSE) {\
                                             iml_line_no = __LINE__;                                             \
                                             iml_source_no = 24484;                                      \
                                             goto ptose92;                                                       \
                                           }

             /* Parse the capabilities of the client.                                          */
             /* Note: Data is (if originally encrypted) already decrypted and present.         */
             /* The presence of the data was made sure, regardless if it was encrypted or not. */
             /* Search for String: "check if all data of this frame have been received"        */
             memset(&D_ADSL_RCO1->dsc_caps, 0, sizeof(dsd_rdp_caps));
             GATHER_SKIP(2 /*PDUSource*/ + 4 /*shareId*/ + 2 /*originatorId*/, D_ADSL_RSE1->imc_pos_inp_frame);        
             GATHER_LE(2, D_ADSL_RSE1->imc_pos_inp_frame, iml1); /* lengthSourceDescriptor */
             GATHER_LE(2, D_ADSL_RSE1->imc_pos_inp_frame, iml4); /* lengthCombinedCapabilities */
             GATHER_SKIP(iml1, D_ADSL_RSE1->imc_pos_inp_frame ); /* sourceDescriptor */
             D_ADSL_RSE1->imc_pos_inp_frame -= iml4; /* iml4 bytes left in whole caps. iml4 is counter now */
             if(D_ADSL_RSE1->imc_pos_inp_frame < 0){
         iml_line_no = __LINE__;
         iml_source_no = 24499;
         goto ptose92;
             }
             GATHER_LE(2, iml4, iml3); /* numberCapabilities */
             GATHER_SKIP(2, iml4);  /* pad2Octets */ 
      
             while(iml3 > 0){ /* go through all the capabilities */
               iml3--;
               GATHER_LE(2, iml4, iml2); /* capabilitySetType */
               GATHER_LE(2, iml4, iml1); /* lengthCapability */
               iml1 -= 4;
               iml4 -= iml1; /* iml1 bytes left in this single cap. iml1 is counter now */
               if(iml4 < 0){
         iml_line_no = __LINE__;
         iml_source_no = 24511;
         goto ptose92;
               }
               switch(iml2){

                 case 0X0001: /* 2.2.7.1.1 General Capability Set (TS_GENERAL_CAPABILITYSET) */
                   GATHER_SKIP( 10, iml1 );
                   GATHER_LE( 2, iml1, iml5 );
                   D_ADSL_RCO1->dsc_caps.dsc_general.boc_fastpath_output            = ( iml5 & 0X0001 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_general.boc_long_credentials           = ( iml5 & 0X0004 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_general.boc_autoreconnect              = ( iml5 & 0X0008 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_general.boc_salted_checksum            = ( iml5 & 0X0010 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_general.boc_no_bitmap_compreession_hdr = ( iml5 & 0X0400 ) != 0;
#ifdef _DEBUG                   
                   printf("Check BU/LE extraflags:\n fastpath_output=%i\n long_credentials=%i\n autoreconnect=%i\n salted_checksum=%i\n no_bitmap_compreession_hdr=%i\n",
                      D_ADSL_RCO1->dsc_caps.dsc_general.boc_fastpath_output,
                      D_ADSL_RCO1->dsc_caps.dsc_general.boc_long_credentials,
                      D_ADSL_RCO1->dsc_caps.dsc_general.boc_autoreconnect,
                      D_ADSL_RCO1->dsc_caps.dsc_general.boc_salted_checksum,
                      D_ADSL_RCO1->dsc_caps.dsc_general.boc_no_bitmap_compreession_hdr
                      );
#endif                      
                   break;

                 case 0X0002: /* 2.2.7.1.2 Bitmap Capability Set (TS_BITMAP_CAPABILITYSET) */
                   GATHER_SKIP( 7 * 2, iml1 ); /* Skip the first 7 fields */
                   GATHER_LE(2, iml1, iml5);
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_desktop_resize_flag = (iml5 == 1);
                   GATHER_SKIP( 2 + 1, iml1 ); /* Skip the next 2 fields */
                   GATHER_BYTE( iml1, iml5 ); /* drawingFlags */
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_allow_dynamic_color_fidelity = ( iml5 & 0X02 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_allow_color_subsampling = ( iml5 & 0X04 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_allow_skip_alpha = ( iml5 & 0X08 ) != 0;
                   break;

                 case 0X0003: /* 2.2.7.1.3 Order Capability Set (TS_ORDER_CAPABILITYSET) */
                   GATHER_SKIP( 16 + 4, iml1 ); /* Skip the first 2 fields */
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_orders.imc_desktop_save_x_gran ); /* desktopSaveXGranularity */
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_orders.imc_desktop_save_y_gran ); /* desktopSaveYGranularity */
                   GATHER_SKIP( 2 + 2 + 2 + 2, iml1 ); /* Skip the first 8 fields */
#define GATHER_READ_ORDER(ORDER) GATHER_BYTE( iml1, iml5 ); D_ADSL_RCO1->dsc_caps.dsc_orders.ORDER = ( iml5 == 1 );
                   GATHER_READ_ORDER( boc_dstblt );             /* 0X00 TS_NEG_DSTBLT_INDEX             */
                   GATHER_READ_ORDER( boc_patblt );             /* 0X01 TS_NEG_PATBLT_INDEX             */
                   GATHER_READ_ORDER( boc_scrblt );             /* 0X02 TS_NEG_SCRBLT_INDEX             */
                   GATHER_READ_ORDER( boc_memblt );             /* 0X03 TS_NEG_MEMBLT_INDEX             */
                   GATHER_READ_ORDER( boc_mem3blt );            /* 0X04 TS_NEG_MEM3BLT_INDEX            */
                   GATHER_SKIP( 2, iml1 );                      /* 0X05 - 0X06 unused 1 - 2             */
                   GATHER_READ_ORDER( boc_drawninegrid );       /* 0X07 TS_NEG_DRAWNINEGRID_INDEX       */
                   GATHER_READ_ORDER( boc_lineto );             /* 0X08 TS_NEG_LINETO_INDEX             */
                   GATHER_READ_ORDER( boc_multi_drawninegrid ); /* 0X09 TS_NEG_MULTI_DRAWNINEGRID_INDEX */
                   GATHER_SKIP( 1, iml1 );                      /* 0X0A unused 3                        */
                   GATHER_READ_ORDER( boc_savebitmap );         /* 0X0B TS_NEG_SAVEBITMAP_INDEX         */
                   GATHER_SKIP( 3, iml1 );                      /* 0X0C - 0XE unused 4 - 6              */
                   GATHER_READ_ORDER( boc_multidstblt );        /* 0x0F TS_NEG_MULTIDSTBLT_INDEX        */
                   GATHER_READ_ORDER( boc_multipatblt );        /* 0X10 TS_NEG_MULTIPATBLT_INDEX        */
                   GATHER_READ_ORDER( boc_multiscrblt );        /* 0X11 TS_NEG_MULTISCRBLT_INDEX        */
                   GATHER_READ_ORDER( boc_multiopaquerect );    /* 0X12 TS_NEG_MULTIOPAQUERECT_INDEX    */
                   GATHER_READ_ORDER( boc_fast_index );         /* 0X13 TS_NEG_FAST_INDEX_INDEX         */
                   GATHER_READ_ORDER( boc_polygon_sc );         /* 0X14 TS_NEG_POLYGON_SC_INDEX         */
                   GATHER_READ_ORDER( boc_polygon_cb );         /* 0X15 TS_NEG_POLYGON_CB_INDEX         */
                   GATHER_READ_ORDER( boc_polyline );           /* 0X16 TS_NEG_POLYLINE_INDEX           */
                   GATHER_SKIP( 1, iml1 );                      /* 0X17 unused 7                        */
                   GATHER_READ_ORDER( boc_fast_glyph );         /* 0X18 TS_NEG_FAST_GLYPH_INDEX         */
                   GATHER_READ_ORDER( boc_ellipse_sc );         /* 0X19 TS_NEG_ELLIPSE_SC_INDEX         */
                   GATHER_READ_ORDER( boc_ellipse_cb );         /* 0X1A TS_NEG_ELLIPSE_CB_INDEX         */
                   GATHER_READ_ORDER( boc_glyph_index );        /* 0X1B TS_NEG_INDEX_INDEX              */
                   GATHER_SKIP( 4, iml1 );                      /* 0X1C - 0X1F unused 8 - 11            */
#undef GATHER_READ_ORDER
                   GATHER_SKIP( 2, iml1 ); /* textFlags */
                   GATHER_LE( 2, iml1, iml5 );   /* orderSupportExFlags */
                   D_ADSL_RCO1->dsc_caps.dsc_orders.boc_cache_bitmap_rev3_support   = ( iml5 & 0X0002 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_orders.boc_altsec_frame_marker_support = ( iml5 & 0X0004 ) != 0;
                   GATHER_SKIP( 4, iml1 ); /* pad4octetsB */
                   GATHER_LE( 4, iml1, D_ADSL_RCO1->dsc_caps.dsc_orders.imc_desktop_save_size );   /* desktopSaveSize */
                   break;

                 case 0X0004: /* 2.2.7.1.4.1 Revision 1 (TS_BITMAPCACHE_CAPABILITYSET) */
                   GATHER_SKIP( 6 * 4, iml1 ); /* pad 1 - pad 6 */
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.imc_cache_numcaches = 3;
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_bitmap.imcr_cache_numentries[0] ); /* Cache1Entries */
                   GATHER_SKIP( 2, iml1 ); /* Cache1MaximumCellSize */
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_bitmap.imcr_cache_numentries[1] ); /* Cache2Entries */
                   GATHER_SKIP( 2, iml1 ); /* Cache2MaximumCellSize */
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_bitmap.imcr_cache_numentries[2] ); /* Cache3Entries */
                   break;
                 
                 case 0X0008: /* 2.2.7.1.5 Pointer Capability Set (TS_POINTER_CAPABILITYSET) */
                   GATHER_LE( 2, iml1, iml5 );
                   if( iml5 == 1 ) 
                     D_ADSL_RCO1->dsc_caps.dsc_pointer.boc_color_pointer_supported = TRUE;
                   GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_pointer.imc_color_pointer_cache_size ); /* colorPointerCacheSize */
                   if(iml1 > 0)
                     GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_pointer.imc_pointer_cache_size );        /* pointerCacheSize */
                   break;
                   
                 case 0X000F: /* 2.2.7.1.7 Brush Capability Set (TS_BRUSH_CAPABILITYSET) */
                   GATHER_LE( 4, iml1, D_ADSL_RCO1->dsc_caps.dsc_general.imc_brush_support_level );
                   break;
                   
                 case 0X0011: /* 2.2.7.1.9 Offscreen Bitmap Cache Capability Set (TS_OFFSCREEN_CAPABILITYSET) */
                   GATHER_LE( 4, iml1, iml2 ); /* offscreenSupportLevel */
                   if(iml2 == 0x00000001){ /* Offscreen bitmap cache is supported. */
                     GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_offscreen_cache.imc_size ); /* offscreenCacheSize    */
                     GATHER_LE( 2, iml1, D_ADSL_RCO1->dsc_caps.dsc_offscreen_cache.imc_entries ); /* offscreenCacheEntries */
                   }
                   break;
                   
                 case 0X0013: /* 2.2.7.1.4.2 Revision 2 (TS_BITMAPCACHE_CAPABILITYSET_REV2) */
                   GATHER_LE( 2, iml1, iml5 ); /* CacheFlags */
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_persistend_keys_expected = ( iml5 & 0X0001 ) != 0;
                   D_ADSL_RCO1->dsc_caps.dsc_bitmap.boc_allow_cache_waiting_list = ( iml5 & 0X0002 ) != 0;
                   GATHER_SKIP( 1, iml1 );                                                 /* pad2 */
                   GATHER_BYTE( iml1, D_ADSL_RCO1->dsc_caps.dsc_bitmap.imc_cache_numcaches ); /* NumCellCaches        */
                   for(iml2 = 0; iml2 < 5; iml2++){
                     GATHER_LE( 4, iml1, iml5 ); /* BitmapCacheXCellInfo */
                     D_ADSL_RCO1->dsc_caps.dsc_bitmap.bocr_cache_persistant[iml2] = ((iml5 & 0x80000000) != 0);
                     D_ADSL_RCO1->dsc_caps.dsc_bitmap.imcr_cache_numentries[iml2] = iml5 & 0x7FFFFFFF;
                   }
                   break;

                 case 0X0014: /* 2.2.7.1.10 Virtual Channel Capability Set (TS_VIRTUALCHANNEL_CAPABILITYSET) */
                   GATHER_LE( 4, iml1, iml2 ); /* flags */
                   if((iml2 & 0x00000001) > 0)
                     D_ADSL_RCO1->dsc_caps.dsc_general.boc_vch_supp_compr_se_to_cl = TRUE; /* VCCAPS_COMPR_SC */
                   if((iml2 & 0x00000002) > 0)
                     D_ADSL_RCO1->dsc_caps.dsc_general.boc_vch_supp_compr_cl_to_se = TRUE; /* VCCAPS_COMPR_CS */
                   break;
                   
                 case 0X001A: /* 2.2.7.2.6 Multifragment Update Capability Set (TS_MULTIFRAGMENTUPDATE_CAPABILITYSET) */
                   GATHER_LE( 4, iml1, D_ADSL_RCO1->dsc_caps.dsc_general.imc_multifragmentupdate_maxrequestsize ); /* MaxRequestSize */
                   break;
                 
                 case 0X001B: /* 2.2.7.2.7 Large Pointer Capability Set (TS_LARGE_POINTER_CAPABILITYSET) */
                   GATHER_LE( 2, iml1, iml2 );
                   if((iml2 & 0X0001) == 1) 
                     D_ADSL_RCO1->dsc_caps.dsc_pointer.boc_large_pointer_supported = TRUE;
                   break; 
#ifdef HOB_CAPS
                 case 0X0F00: /*special HOB-caps */
                   GATHER_LE( 4, iml1, iml2);
                   if(iml2 == 0X78424F48){
                     D_ADSL_RCO1->dsc_caps.dsc_hob.boc_hob_caps_received=TRUE;
                     GATHER_HASN( iml1, iml2 ); /* get number of tags */
                     while(iml2 > 0){
                       iml2--;
                       GATHER_HASN( iml1, iml5 ); /* Tag identifier */
                       GATHER_HASN( iml1, iml6 ); /* Len tag */
                       iml1 -= iml6; /* iml6 bytes left in this tag. iml6 is counter now */
                       if(iml1 < 0){
         iml_line_no = __LINE__;
         iml_source_no = 24659;
         goto ptose92;
                       }
                       switch(iml5){
                       case IM_HOB_CAPS_ORDER_EXTENSION:
                         GATHER_LE(4, iml6, iml5);
                         if((iml5 & IM_FLAG_ORDER_EX_BMP6_UNCOMPRESSED) > 0)
                           D_ADSL_RCO1->dsc_caps.dsc_hob.boc_order_ex_bmp6_uncompressed = TRUE;
                         if((iml5 & IM_FLAG_ORDER_EX_BRUSH_SIZE_FIELD) > 0)
                           D_ADSL_RCO1->dsc_caps.dsc_hob.boc_order_ex_brush_size_field = TRUE;
                         break;
                       case IM_HOB_CAPS_FASTPATH_EXTENSION:
                         GATHER_LE(2, iml6, iml5);
                         if(iml5 > MAX_PDU_LEN_HOB)
                           iml5 = MAX_PDU_LEN_HOB;
                         D_ADSL_RCO1->imc_max_pdu_length = iml5;
                         D_ADSL_RCO1->imc_max_ts_fp_update_size = iml5 - MAX_FP_HEADER_SIZE;
                         break;
                       case IM_HOB_CAPS_ORDER_EX_BRUSH_CACHE:
                         GATHER_LE(2, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.imc_order_ex_mono_brush_size_cache);
                         GATHER_LE(2, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.imc_order_ex_color_brush_size_cache);
                         if(iml6 >= 2){
                           GATHER_LE(2, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.imc_order_ex_brush_cache_flags);
                         }
                         break;
                       case IM_HOB_CAPS_EX_CURSOR:
                         D_ADSL_RCO1->dsc_caps.dsc_hob.bo_cursor_caps = TRUE;
                         GATHER_LE(4, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.in_ext_cursor_flags);
                         GATHER_LE(2, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.in_max_width_cursor);
                         GATHER_LE(2, iml6, D_ADSL_RCO1->dsc_caps.dsc_hob.in_max_height_cursor);
                         break;
                       }
                       GATHER_SKIP( iml6, iml6 );
                     }
                   }
                   break;
#endif 
               }
               GATHER_SKIP( iml1, iml1 ); /* skip rest of capability */
             }
           }
#undef GATHER_SKIP
#undef GATHER_LE
#undef GATHER_HASN
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_ignore;  /* ignore data */
           if (D_ADSL_RSE1->imc_prot_1 != 0X17) {  /* is not data PDU  */
             /* ignore remaining part                                  */
             D_ADSL_RSE1->imc_prot_2 = 0;   /* till end of block       */
             goto ptose20;                  /* process next data       */
           }
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - 10;  /* ignore some fields */
           D_ADSL_RSE1->iec_frcl_bl = ied_frcl_data_pdu_1;  /* RDP4 PDU data follow */
           goto ptose20;                    /* process next data       */
         case ied_frcl_rdp4_vch_ulen:       /* virtual channel uncompressed data length */
           D_ADSL_RSE1->umc_vch_ulen = D_ADSL_RSE1->imc_prot_1;  /* virtual channel length uncompressed */
           D_ADSL_RSE1->imc_prot_2 = D_ADSL_RSE1->imc_pos_inp_frame - sizeof(D_ADSL_RSE1->chrc_vch_segfl);
           if (D_ADSL_RSE1->imc_prot_2 < 0) {
         iml_line_no = __LINE__;
         iml_source_no = 24720;
         goto ptose92;
           }
           D_ADSL_RSE1->achc_prot_1 = D_ADSL_RSE1->chrc_vch_segfl;
           D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_copy_normal;  /* copy data */
           goto ptose20;                    /* process next data       */
       }
           goto ptose96;                    /* program illogic         */
     case ied_fcfp_int_big_e:               /* int big endian          */
       while (TRUE) {
         D_ADSL_RSE1->imc_prot_1 <<= 8;
         D_ADSL_RSE1->imc_prot_1
           |= (unsigned char) *adsl_gai1_inp_1->achc_ginp_cur++;
         D_ADSL_RSE1->imc_pos_inp_frame--;
         if (D_ADSL_RSE1->imc_pos_inp_frame == D_ADSL_RSE1->imc_prot_2) break;
         if (adsl_gai1_inp_1->achc_ginp_cur
               >= adsl_gai1_inp_1->achc_ginp_end) {
           goto ptose20;                    /* needs more data         */
         }
       }
#ifdef TRACEHL1
       printf( "ied_fcfp_int_big_e found int=%d D_ADSL_RSE1->iec_frcl_bl=%d\n",
               D_ADSL_RSE1->imc_prot_1,
               D_ADSL_RSE1->iec_frcl_bl );
#endif
       goto ptose96;                        /* program illogic         */
     case ied_fcfp_end_com:                 /* end of communication    */
       if ((unsigned char) *adsl_gai1_inp_1->achc_ginp_cur != (unsigned char) 0X80) {
         iml_line_no = __LINE__;
         iml_source_no = 24878;
         goto ptose92;
       }
       adsl_gai1_inp_1->achc_ginp_cur++;    /* next byte input         */
       D_ADSL_RSE1->imc_pos_inp_frame--;    /* length constant         */
       if (D_ADSL_RSE1->imc_pos_inp_frame != 0) {
         iml_line_no = __LINE__;
         iml_source_no = 24883;
         goto ptose92;
       }
       D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_no_session;  /* no more session */
       ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1);
/* UUUU 31.01.06 KB */
       ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
       if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
         printf( "output-area too small\n" );
#ifndef HL_UNIX
         ExitProcess( 1 );
#else
         exit( 1 );
#endif
       }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
       memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) );
       ADSL_CL_CO1->iec_cl_command = ied_clc_end_session;  /* end of session client side */
       if (ADSL_OA1->adsc_cl_co1 == NULL) {
         adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
       } else {
         ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
       }
       ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;  /* save last in chain     */
#undef ADSL_CL_CO1
       goto ptose20;                        /* process next data       */
     case ied_fcfp_no_session:              /* no more session         */
         iml_line_no = __LINE__;
         iml_source_no = 24919;
         goto ptose92;
//   default:                               /* other value set         */
//     goto ptose96;                        /* program illogic         */
   }
   goto ptose96;                            /* program illogic         */

// ptose04:                                 /* to server - from client */
// adsl_gai1_inp_1->achc_ginp_cur++;
// goto ptose20;


   ptose_vch_00:                            /* virtual channel data received */
   while (adsl_gai1_inp_1->achc_ginp_cur >= adsl_gai1_inp_1->achc_ginp_end) {
     adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;  /* get next in chain */
     if (adsl_gai1_inp_1 == NULL) return;   /* wait for more data      */
   }
   /* check if all data of this frame have been received               */
   iml1 = D_ADSL_RSE1->imc_pos_inp_frame;   /* remaining data in frame */
   adsl_gai1_inp_w2 = adsl_gai1_inp_1;      /* get gather              */
   while (TRUE) {                           /* loop over all gather structures input */
     iml1 -= adsl_gai1_inp_w2->achc_ginp_end - adsl_gai1_inp_w2->achc_ginp_cur;
     if (iml1 <= 0) break;                  /* enough data found       */
     adsl_gai1_inp_w2 = adsl_gai1_inp_w2->adsc_next;  /* get next gather */
     if (adsl_gai1_inp_w2 == NULL) {        /* already end of chain    */
#ifdef TRACEHL1
     printf( "s%05d l%05d received from client need more data %d\n",
             25521,                /* source line no for errors */
             __LINE__,                      /* line number for errors  */
             iml1 );                        /* length of data needed   */
#endif
       /* wait for more data                                           */
       goto ptose80;                       /* check if there are orders for RDPACC */
     }
   }
   if (D_ADSL_RSE1->imc_pos_inp_frame < (2 + 1)) {
         iml_line_no = __LINE__;
         iml_source_no = 25524;
         goto ptose92;
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_vch_in))) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       goto p_cleanup_20;                   /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_vch_in);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     goto ptose96;                          /* program illogic         */
   }
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_vch_in) );
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
   adsl_cl_vch_in = (struct dsd_cl_vch_in *) (ADSL_CL_CO1 + 1);
   ADSL_CL_CO1->iec_cl_command = ied_clc_vch_in;  /* input from virtual channel */
   if (ADSL_OA1->adsc_cl_co1 == NULL) {
     adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
   } else {
     ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
   }
   ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;     /* save last in chain      */
#undef ADSL_CL_CO1
   adsl_cl_vch_in->umc_vch_ulen = D_ADSL_RSE1->umc_vch_ulen;  /* virtual channel length uncompressed */
   /* virtual channel segmentation flags                               */
   memcpy( adsl_cl_vch_in->chrc_vch_segfl,
           D_ADSL_RSE1->chrc_vch_segfl,
           sizeof(adsl_cl_vch_in->chrc_vch_segfl) );
   if (*adsl_gai1_inp_1->achc_ginp_cur & 0X20) {  /* data compressed   */
     goto ptose_vch_20;                     /* virtual channel data compressed */
   }
   bol_compressed = FALSE;                  /* save not compressed     */
   /* remove two bytes of compression flags                            */
   iml1 = 2;                                /* bytes to remove         */
   D_ADSL_RSE1->imc_pos_inp_frame -= iml1;
   while (TRUE) {
     iml_rec = adsl_gai1_inp_1->achc_ginp_end
                 - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml_rec > iml1) iml_rec = iml1;
     adsl_gai1_inp_1->achc_ginp_cur += iml_rec;
     iml1 -= iml_rec;
     if (adsl_gai1_inp_1->achc_ginp_cur < adsl_gai1_inp_1->achc_ginp_end) break;
     adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;
     if (iml1 == 0) break;
   }
   adsl_gai1_inp_w2 = adsl_gai1_inp_1;      /* save input data         */
   iml1 = D_ADSL_RSE1->imc_pos_inp_frame;   /* length of data          */
   adsl_gai1_out_save = NULL;               /* start of chain          */
   while (TRUE) {                           /* loop over all gather structures input */
     iml2 = adsl_gai1_inp_1->achc_ginp_end - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml2 > D_ADSL_RSE1->imc_pos_inp_frame) iml2 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
     if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < sizeof(struct dsd_gather_i_1)) {  /* get new area */
       memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
       bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                          DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                          &dsl_aux_get_workarea,
                                          sizeof(struct dsd_aux_get_workarea) );
       if (bol1 == FALSE) {                 /* aux returned error      */
         adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
         goto p_cleanup_20;                 /* do cleanup now          */
       }
       ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
       ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     }
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       goto ptose96;                        /* program illogic         */
     }
     memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_gather_i_1) );
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     if (adsl_gai1_out_save == NULL) {      /* is first in chain       */
       adsl_cl_vch_in->adsc_gai1_in = ADSL_GAI1_OUT_G;
     } else {                               /* middle in chain         */
       adsl_gai1_out_save->adsc_next = ADSL_GAI1_OUT_G;
     }
     adsl_gai1_out_save = ADSL_GAI1_OUT_G;  /* save start output data  */
     ADSL_GAI1_OUT_G->achc_ginp_cur = adsl_gai1_inp_1->achc_ginp_cur;
     D_ADSL_RSE1->imc_pos_inp_frame -= iml2;  /* compute remainling length compressed data */
     adsl_gai1_inp_1->achc_ginp_cur += iml2;
     ADSL_GAI1_OUT_G->achc_ginp_end = adsl_gai1_inp_1->achc_ginp_cur;
#undef ADSL_GAI1_OUT_G
     if (adsl_gai1_inp_1->achc_ginp_cur >= adsl_gai1_inp_1->achc_ginp_end) {
       adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;  /* get next gather */
     }
     if (D_ADSL_RSE1->imc_pos_inp_frame <= 0) break;  /* end of copying */
     if (adsl_gai1_inp_1 == NULL) {         /* already end of chain    */
       M_ERROR_TOSE_ILLOGIC
     }
   }
   goto ptose_vch_40;                       /* send virtual channel to client */

   ptose_vch_20:                            /* virtual channel data compressed */
   if (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA) {  /* compression enabled */
     goto ptose_vch_22;                     /* virtual channel compression valid */
   }
   iml1 = D_ADSL_RCO1->imc_no_virt_ch;      /* number of virtual channels */
   while (iml1) {                           /* loop over all virtual channels */
     iml1--;                                /* decrement index         */
     if (D_ADSL_RCO1->adsrc_vc_1[ iml1 ].usc_vch_no == D_ADSL_RSE1->imc_prot_chno) {  /* virtual channel no com */
       if (D_ADSL_RCO1->adsrc_vc_1[ iml1 ].imc_flags & 0X00400000) {
         goto ptose_vch_22;                 /* virtual channel compression valid */
       }
       break;
     }
   }
         iml_line_no = __LINE__;
         iml_source_no = 25669;
         goto ptose92;

   ptose_vch_22:                            /* virtual channel compression valid */
   bol_compressed = TRUE;                   /* save compressed         */
   /* decompress data                                                  */
   D_ADSL_RCO1->dsc_cdrf_dec.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_dec.amc_aux = adsp_hl_clib_1->amc_aux;
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       goto p_cleanup_20;                   /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   D_ADSL_RCO1->dsc_cdrf_dec.achc_outa = ADSL_OA1->achc_w1;  /* address act output-data */
   D_ADSL_RCO1->dsc_cdrf_dec.achc_oute = ADSL_OA1->achc_w2;  /* address end output-data */
   /* first decompress compression flags                           */
   D_ADSL_RCO1->dsc_cdrf_dec.achc_inpa = adsl_gai1_inp_1->achc_ginp_cur;  /* address act input-data */
   D_ADSL_RCO1->dsc_cdrf_dec.achc_inpe = adsl_gai1_inp_1->achc_ginp_cur + sizeof(char);  /* address end input-data */
   D_ADSL_RCO1->dsc_cdrf_dec.boc_mp_flush = FALSE;  /* not yet end-of-record input */
   D_ADSL_RCO1->dsc_cdrf_dec.boc_sr_flush = FALSE;  /* not yet end of output reached */
   m_cdr_dec( &D_ADSL_RCO1->dsc_cdrf_dec );
   if (D_ADSL_RCO1->dsc_cdrf_dec.imc_return != DEF_IRET_NORMAL) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d de-compression error %d.",
                   __LINE__, 25723,  /* line number for errors */
                   D_ADSL_RCO1->dsc_cdrf_dec.imc_return );
         iml_line_no = __LINE__;
         iml_source_no = 25725;
         goto ptose92;
   }
   /* remove two bytes of compression flags                            */
   iml1 = 2;                                /* bytes to remove         */
   D_ADSL_RSE1->imc_pos_inp_frame -= iml1;
   while (TRUE) {
     iml_rec = adsl_gai1_inp_1->achc_ginp_end
                 - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml_rec > iml1) iml_rec = iml1;
     adsl_gai1_inp_1->achc_ginp_cur += iml_rec;
     iml1 -= iml_rec;
     if (adsl_gai1_inp_1->achc_ginp_cur < adsl_gai1_inp_1->achc_ginp_end) break;
     adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;
     if (iml1 == 0) break;
   }
   adsl_gai1_out_save = NULL;               /* start of chain          */
   while (TRUE) {                           /* loop over all gather structures input */
     D_ADSL_RCO1->dsc_cdrf_dec.achc_inpa = D_ADSL_RCO1->dsc_cdrf_dec.achc_inpe = NULL;
     if (adsl_gai1_inp_1) {
     iml1 = adsl_gai1_inp_1->achc_ginp_end - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml1 > D_ADSL_RSE1->imc_pos_inp_frame) iml1 = D_ADSL_RSE1->imc_pos_inp_frame;  /* remaining data in frame */
     if (iml1 == D_ADSL_RSE1->imc_pos_inp_frame) {  /* now last part   */
       D_ADSL_RCO1->dsc_cdrf_dec.boc_mp_flush = TRUE;  /* end-of-record input */
     }
     D_ADSL_RCO1->dsc_cdrf_dec.achc_inpa = adsl_gai1_inp_1->achc_ginp_cur;  /* address act input-data */
     D_ADSL_RCO1->dsc_cdrf_dec.achc_inpe = adsl_gai1_inp_1->achc_ginp_cur + iml1;  /* address end input-data */
     }
     m_cdr_dec( &D_ADSL_RCO1->dsc_cdrf_dec );
     if (D_ADSL_RCO1->dsc_cdrf_dec.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d de-compression error %d.",
                     __LINE__, 25871,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_dec.imc_return );
         iml_line_no = __LINE__;
         iml_source_no = 25873;
         goto ptose92;
     }
     if (adsl_gai1_inp_1) {
     D_ADSL_RSE1->imc_pos_inp_frame
       -= D_ADSL_RCO1->dsc_cdrf_dec.achc_inpa - adsl_gai1_inp_1->achc_ginp_cur;  /* compute remaining length compressed data */
     adsl_gai1_inp_1->achc_ginp_cur = D_ADSL_RCO1->dsc_cdrf_dec.achc_inpa;
     if (adsl_gai1_inp_1->achc_ginp_cur >= adsl_gai1_inp_1->achc_ginp_end) {
       adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;  /* get next gather */
     }
     }
     if (   (D_ADSL_RSE1->imc_pos_inp_frame <= 0)
          && D_ADSL_RCO1->dsc_cdrf_dec.boc_sr_flush) {
       break;                               /* end of decompression    */
     }
     /* check no more space in output area                             */
     if (D_ADSL_RCO1->dsc_cdrf_dec.achc_outa >= ADSL_OA1->achc_w2) {
       memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
       bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                          DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                          &dsl_aux_get_workarea,
                                          sizeof(struct dsd_aux_get_workarea) );
       if (bol1 == FALSE) {                 /* aux returned error      */
         adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
         goto p_cleanup_20;                 /* do cleanup now          */
       }
       achl1 = ADSL_OA1->achc_w1;           /* save start output       */
       ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
       ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
       ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
       if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
         goto ptose96;                      /* program illogic         */
       }
       memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_gather_i_1) );
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
       if (adsl_gai1_out_save == NULL) {    /* is first in chain       */
         adsl_cl_vch_in->adsc_gai1_in = ADSL_GAI1_OUT_G;
       } else {                             /* middle in chain         */
         adsl_gai1_out_save->adsc_next = ADSL_GAI1_OUT_G;
       }
       adsl_gai1_out_save = ADSL_GAI1_OUT_G;  /* save start output data */
       ADSL_GAI1_OUT_G->achc_ginp_cur = achl1;  /* start of output area */
       ADSL_GAI1_OUT_G->achc_ginp_end = D_ADSL_RCO1->dsc_cdrf_dec.achc_outa;
#undef ADSL_GAI1_OUT_G
       D_ADSL_RCO1->dsc_cdrf_dec.achc_outa = ADSL_OA1->achc_w1;  /* address act output-data */
       D_ADSL_RCO1->dsc_cdrf_dec.achc_oute = ADSL_OA1->achc_w2;  /* address end output-data */
     }
   }
   achl1 = ADSL_OA1->achc_w1;               /* save start output       */
   ADSL_OA1->achc_w1 = D_ADSL_RCO1->dsc_cdrf_dec.achc_outa;
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < sizeof(struct dsd_gather_i_1)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       goto p_cleanup_20;                   /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     goto ptose96;                          /* program illogic         */
   }
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_gather_i_1) );
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   if (adsl_gai1_out_save == NULL) {        /* is first in chain       */
     adsl_cl_vch_in->adsc_gai1_in = ADSL_GAI1_OUT_G;
   } else {                                 /* middle in chain         */
     adsl_gai1_out_save->adsc_next = ADSL_GAI1_OUT_G;
   }
   adsl_gai1_out_save = ADSL_GAI1_OUT_G;    /* save start output data  */
   ADSL_GAI1_OUT_G->achc_ginp_cur = achl1;  /* start of output area */
   ADSL_GAI1_OUT_G->achc_ginp_end = D_ADSL_RCO1->dsc_cdrf_dec.achc_outa;
#undef ADSL_GAI1_OUT_G

   ptose_vch_40:                            /* send virtual channel to server */
   /* get pointer to virtual channel structure                         */
   iml1 = D_ADSL_RCO1->imc_no_virt_ch;      /* number of virtual channels */
   while (iml1) {                           /* loop over all virtual channels */
     iml1--;                                /* decrement index         */
     if (D_ADSL_RCO1->adsrc_vc_1[ iml1 ].usc_vch_no == D_ADSL_RSE1->imc_prot_chno) {  /* virtual channel no com */
       adsl_cl_vch_in->adsc_rdp_vc_1 = &D_ADSL_RCO1->adsrc_vc_1[ iml1 ];  /* RDP virtual channel */
       break;
     }
   }
   if (adsl_cl_vch_in->adsc_rdp_vc_1 == NULL) {
         iml_line_no = __LINE__;
         iml_source_no = 26484;
         goto ptose92;
   }
   D_ADSL_RSE1->iec_frcl_bl = ied_frcl_rec_xyz_01;
   D_ADSL_RSE1->iec_fcfp_bl = ied_fcfp_rec_type;  /* receive record type */
   if (D_ADSL_RSE1->imc_pos_inp_frame == 0) goto ptose20;  /* process next data */
   /* remove all input data                                            */
   while (TRUE) {
     iml_rec = adsl_gai1_inp_1->achc_ginp_end
                 - adsl_gai1_inp_1->achc_ginp_cur;
     if (iml_rec > D_ADSL_RSE1->imc_pos_inp_frame) iml_rec = D_ADSL_RSE1->imc_pos_inp_frame;
     adsl_gai1_inp_1->achc_ginp_cur += iml_rec;
     D_ADSL_RSE1->imc_pos_inp_frame -= iml_rec;
     if (adsl_gai1_inp_1->achc_ginp_cur < adsl_gai1_inp_1->achc_ginp_end) break;
     adsl_gai1_inp_1 = adsl_gai1_inp_1->adsc_next;
     if (D_ADSL_RSE1->imc_pos_inp_frame == 0) break;
   }
   goto ptose20;                            /* process next data       */

   ptose80:                                 /* send to server          */
   if (adsp_hl_clib_1->adsc_sc_co1_ch == NULL) {
     m_send_frame_close( adsp_hl_clib_1, ADSL_OA1, chrl_work_2 );
     goto p_ret_00;                         /* check how to return     */
   }
   switch (adsp_hl_clib_1->adsc_sc_co1_ch->iec_sc_command) {  /* command type */
     case ied_scc_d_act_pdu:                /* send demand active PDU  */
       D_ADSL_RCO1->imc_dim_x = ((struct dsd_d_act_pdu *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_dim_x;
       D_ADSL_RCO1->imc_dim_y = ((struct dsd_d_act_pdu *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_dim_y;
       D_ADSL_RCO1->imc_s_coldep = ((struct dsd_d_act_pdu *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_coldep;
       ADSL_RDPA_F->ac_screen_buffer = adsp_hl_clib_1->ac_screen_buffer;
       bol1 = m_send_se2cl_after_logon( adsp_hl_clib_1, &dsl_output_area_1 );
       // JB: included this to be able to change screen size. 
       if (bol1 == FALSE)
         goto ptose96;                      /* program illogic         */
       bol1 = m_send_se2cl_demand_active( adsp_hl_clib_1, &dsl_output_area_1 );
       if (bol1) break;
       goto ptose96;                        /* program illogic         */
     // JB: included change of screen size for MacGate. 
     case ied_scc_change_screen:            /* screen parameters changed */
       D_ADSL_RCO1->imc_dim_x = ((struct dsd_change_screen *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_dim_x;
       D_ADSL_RCO1->imc_dim_y = ((struct dsd_change_screen *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_dim_y;
       D_ADSL_RCO1->imc_s_coldep = ((struct dsd_change_screen *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->imc_coldep;
       ADSL_RDPA_F->ac_screen_buffer = ((struct dsd_change_screen *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->ac_screen_buffer;
       adsp_hl_clib_1->ac_screen_buffer = ((struct dsd_change_screen *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))->ac_screen_buffer;
       bol1 = m_send_se2cl_deactivate_all( adsp_hl_clib_1, &dsl_output_area_1 );
       bol1 &= m_send_se2cl_demand_active( adsp_hl_clib_1, &dsl_output_area_1 );
       if (bol1) break;
       goto ptose96;                        /* program illogic         */
       break;
     case ied_scc_draw_sc:                  /* draw screen-buffer      */
       if (D_ADSL_RCO1->boc_suppress_display_updates) break;  /* RDP client is minimized */
       // Included SM's color compression for 32 bit now. JB 20.02.12
       if ((D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA) == 0) {  /* compression not enabled */
         bol1 = m_send_draw_sc_bmc_normal( adsp_hl_clib_1,
                                           ADSL_OA1,
                                           (struct dsd_sc_draw_sc *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                           chrl_work_2 );
       } else {
         bol1 = m_send_draw_sc_bmc_compr( adsp_hl_clib_1,
                                          ADSL_OA1,
                                          (struct dsd_sc_draw_sc *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                          chrl_work_2 );
       }
       if (bol1 == FALSE) goto p_cleanup_00;  /* do cleanup now      */
       break;
       break;
     case ied_scc_order_scrblt:             /* screen blt primary drawing order. */
       adsp_hl_clib_1->adsc_sc_co1_ch
         = m_send_order_scrblt( adsp_hl_clib_1,
                                ADSL_OA1,
                                adsp_hl_clib_1->adsc_sc_co1_ch,
                                chrl_work_2 );
       goto ptose80;                        /* check next command      */
     case ied_scc_order_memblt:             /* copy cached bitmap to screen */
       m_send_order_memblt( adsp_hl_clib_1,
                            ADSL_OA1,
                            (struct dsd_sc_order_memblt *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                            chrl_work_2 );
       break;
     case ied_scc_order_mem3blt:            /* copy cached bitmap to screen, 3-way raster operation */
       m_send_order_mem3blt( adsp_hl_clib_1,
                             ADSL_OA1,
                             (struct dsd_sc_order_mem3blt *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                             chrl_work_2 );
       break;
     case ied_scc_order_savebitmap:         /* save and restore bitmap */
       m_send_order_savebitmap( adsp_hl_clib_1,
                                ADSL_OA1,
                                (struct dsd_sc_order_savebitmap *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                chrl_work_2 );
       break;
     case ied_scc_order_cachebitmap:        /* cache bitmap in bitmap cache */
       m_send_order_cachebitmap( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 (struct dsd_sc_order_cachebitmap *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                 chrl_work_2 );
       break;
     // JB: Included for Mac Gate and X11-Gate
     case ied_scc_order_cachebrush:        /* cache brush in brush cache */
       m_send_order_cachebrush( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 (struct dsd_sc_order_cachebrush *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                 chrl_work_2 );
       break;
     case ied_scc_order_new_font:           /* apply a new font        */
       m_send_order_new_font( adsp_hl_clib_1,
                              ADSL_OA1,
                              (struct dsd_font *) *((void **) (adsp_hl_clib_1->adsc_sc_co1_ch + 1)),
                              chrl_work_2 );
       break;
     case ied_scc_order_delete_font:        /* delete a font           */
       bol1 = m_send_order_delete_font( adsp_hl_clib_1,
                                        ADSL_OA1,
                                        (struct dsd_font *) *((void **) (adsp_hl_clib_1->adsc_sc_co1_ch + 1)),
                                        chrl_work_2 );
       if (bol1) break;                     /* all done                */
       goto p_cleanup_00;                   /* do cleanup now          */
     case ied_scc_order_drawstring:         /* draw a string           */
       bol1 = m_send_order_drawstring( adsp_hl_clib_1,
                                       ADSL_OA1,
                                       (struct dsd_sc_order_drawstring *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                       chrl_work_2 );
       if (bol1) break;                     /* all done                */
       goto p_cleanup_00;                   /* do cleanup now          */
     case ied_scc_mpoi_system:              /* pointer system          */
       m_send_mpoi_system( adsp_hl_clib_1,
                           ADSL_OA1,
                           (struct dsd_sc_mpoi_system *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                           chrl_work_2 );
       break;
     case ied_scc_mpoi_position:            /* position pointer update pdu */
       m_send_mpoi_position( adsp_hl_clib_1,
                             ADSL_OA1,
                             (struct dsd_sc_mpoi_position *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                             chrl_work_2 );
       break;
     case ied_scc_mpoi_color:               /* color pointer update pdu */
       bol1 = m_send_mpoi_color( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 (struct dsd_sc_mpoi_color *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                 chrl_work_2 );
       if (bol1 == FALSE) goto p_cleanup_00;  /* do cleanup now        */
       break;
     case ied_scc_mpoi_pointer:             /* new pointer update pdu  */
       bol1 = m_send_mpoi_pointer( adsp_hl_clib_1,
                                   ADSL_OA1,
                                   (struct dsd_sc_mpoi_pointer *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                   chrl_work_2 );
       if (bol1 == FALSE) goto p_cleanup_00;  /* do cleanup now        */
       break;
     case ied_scc_mpoi_cached:              /* cached pointer update pdu */
       m_send_mpoi_cached( adsp_hl_clib_1,
                           ADSL_OA1,
                           (struct dsd_sc_mpoi_cached *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                           chrl_work_2 );
       break;
     case ied_scc_error_info:               /* error info pdu          */
       m_send_error_info( adsp_hl_clib_1,
                          ADSL_OA1,
                          (struct dsd_sc_error_info *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                          chrl_work_2 );
       break;
     case ied_scc_order_shutdown_deny:      /* deny shutdown, no parameter */
       m_send_shutdown_deny( adsp_hl_clib_1,
                             ADSL_OA1,
                             chrl_work_2 );
       break;
     case ied_scc_order_setbounds:          /* set bounds of primary drawing order */
#define ADSL_SC_ORDER_SETBOUNDS ((struct dsd_sc_order_setbounds *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1))
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X04;  /* send order flags TS_BOUNDS */
       if (   (D_ADSL_RCO1->imc_bounds_left == ADSL_SC_ORDER_SETBOUNDS->isc_left)
           && (D_ADSL_RCO1->imc_bounds_top == ADSL_SC_ORDER_SETBOUNDS->isc_top)
           && (D_ADSL_RCO1->imc_bounds_right == ADSL_SC_ORDER_SETBOUNDS->isc_right)
           && (D_ADSL_RCO1->imc_bounds_bottom == ADSL_SC_ORDER_SETBOUNDS->isc_bottom)) {
         break;                             /* nothing to do           */
       }
       if (D_ADSL_RSE1->ucc_order_flags_1 & 0X20) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
         D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left = D_ADSL_RCO1->imc_bounds_left;  /* save old bounds coordinates */
         D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top = D_ADSL_RCO1->imc_bounds_top;  /* save old bounds coordinates */
         D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right = D_ADSL_RCO1->imc_bounds_right;  /* save old bounds coordinates */
         D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom = D_ADSL_RCO1->imc_bounds_bottom;  /* save old bounds coordinates */
       }
       D_ADSL_RCO1->imc_bounds_left = ADSL_SC_ORDER_SETBOUNDS->isc_left;  /* apply new bounds coordinates */
       D_ADSL_RCO1->imc_bounds_top = ADSL_SC_ORDER_SETBOUNDS->isc_top;  /* apply new bounds coordinates */
       D_ADSL_RCO1->imc_bounds_right = ADSL_SC_ORDER_SETBOUNDS->isc_right;  /* apply new bounds coordinates */
       D_ADSL_RCO1->imc_bounds_bottom = ADSL_SC_ORDER_SETBOUNDS->isc_bottom;  /* apply new bounds coordinates */
#undef ADSL_SC_ORDER_SETBOUNDS
       D_ADSL_RSE1->ucc_order_flags_1 &= -1 - 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       break;
     case ied_scc_order_clearbounds:        /* stops usage of bounds for primary drawing order */
       D_ADSL_RSE1->ucc_order_flags_1 &= - 1 - 0X04;  /* stop send order flags TS_BOUNDS */
       break;
     case ied_scc_order_patblt:             /* draw a rectangle        */
       bol1 = m_send_order_patblt( adsp_hl_clib_1,
                                   ADSL_OA1,
                                   (struct dsd_sc_order_patblt *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                   chrl_work_2 );
       break;
     case ied_scc_order_opaquerect:         /* draw an opaque rect     */
       m_send_order_opaquerect( adsp_hl_clib_1,
                                ADSL_OA1,
                                (struct dsd_sc_order_opaquerect *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                chrl_work_2 );
       break;
     case ied_scc_order_lineto:             /* draw line to            */
       m_send_order_lineto( adsp_hl_clib_1,
                            ADSL_OA1,
                            (struct dsd_sc_order_lineto *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                            chrl_work_2 );
       break;
     case ied_scc_order_polyline:           /* draw polyline           */
       m_send_order_polyline( adsp_hl_clib_1,
                              ADSL_OA1,
                              (struct dsd_sc_order_polyline *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                              chrl_work_2 );
       break;
     case ied_scc_order_polygonsc:          /* draw a polygon, but just the lines */
       m_send_order_polygonsc( adsp_hl_clib_1,
                               ADSL_OA1,
                               (struct dsd_sc_order_polygonsc *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                               chrl_work_2 );
       break;
     case ied_scc_order_polygoncb:          /* draw a filled polygon   */
       m_send_order_polygoncb( adsp_hl_clib_1,
                               ADSL_OA1,
                               (struct dsd_sc_order_polygoncb *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                               chrl_work_2 );
       break;
     case ied_scc_order_ellipsesc:          /* draw a ellipse          */
       m_send_order_ellipsesc( adsp_hl_clib_1,
                               ADSL_OA1,
                               (struct dsd_sc_order_ellipsesc *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                               chrl_work_2 );
       break;
     case ied_scc_order_ellipsecb:          /* draw a filled ellipse   */
       m_send_order_ellipsecb( adsp_hl_clib_1,
                               ADSL_OA1,
                               (struct dsd_sc_order_ellipsecb *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                               chrl_work_2 );
       break;
     case ied_scc_order_createoffbitmap:    /* create an offscreen bitmap */
       m_send_order_createoffbitmap( adsp_hl_clib_1,
                                     ADSL_OA1,
                                     (struct dsd_sc_order_createoffbitmap *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                     chrl_work_2 );
       break;
     case ied_scc_order_switchsurface:      /* switch the surface, on which is drawn */
       m_send_order_switchsurface( adsp_hl_clib_1,
                                   ADSL_OA1,
                                   (struct dsd_sc_order_switchsurface *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                   chrl_work_2 );
       break;
     // JB: Included for MacGate
     case ied_scc_order_framemarker:      /* Set frame marker */
       m_send_order_framemarker( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 (struct dsd_sc_order_framemarker *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                                 chrl_work_2 );
       break;
     case ied_scc_vch_out:                  /* output to virtual channel */
       bol1 = m_send_vch_out( adsp_hl_clib_1,
                              ADSL_OA1,
                              (struct dsd_sc_vch_out *) (adsp_hl_clib_1->adsc_sc_co1_ch + 1),
                              chrl_work_2 );
       if (bol1 == FALSE) goto p_cleanup_00;  /* do cleanup now        */
       break;
     case ied_scc_end_session:              /* end of session server side */
     case ied_scc_end_shutdown:             /* shutdown of server      */
       bol1 = m_send_se2cl_end( adsp_hl_clib_1,
                                ADSL_OA1,
                                adsp_hl_clib_1->adsc_sc_co1_ch->iec_sc_command,
                                chrl_work_2 );
       if (bol1) goto p_cleanup_00;         /* do cleanup now          */
       goto ptose96;                        /* program illogic         */
     default:
       printf( "l%05d s%05d ptose80 iec_sc_command=%d command unknown\n",
               __LINE__, 26952,
               adsp_hl_clib_1->adsc_sc_co1_ch->iec_sc_command );
       break;
   }
   adsp_hl_clib_1->adsc_sc_co1_ch = adsp_hl_clib_1->adsc_sc_co1_ch->adsc_next;
   goto ptose80;                            /* check next command      */

   ptose92:                                 /* protocoll error          */
   m_sdh_printf( adsp_hl_clib_1, "ptose92 - protocoll error received from client iec_frcl_bl=%d iec_fcfp_bl=%d l%05d s%05d",
                 ADSL_RDPA_F->dsc_rdp_se_1.iec_frcl_bl,
                 ADSL_RDPA_F->dsc_rdp_se_1.iec_fcfp_bl,
                 iml_line_no,               /* line number for errors  */
                 iml_source_no );           /* source line no for errors */
#ifdef TRACEHL1
   if (adsl_gai1_inp_1) {
     printf( "l%05d ptose92 achl_help_sta=%p achc_ginp_cur=%p achc_ginp_end=%p pos=%04X\n",
             __LINE__,
             achl_help_sta,
             adsl_gai1_inp_1->achc_ginp_cur,
             adsl_gai1_inp_1->achc_ginp_end,
             adsl_gai1_inp_1->achc_ginp_cur - achl_help_sta );
     iml1 = adsl_gai1_inp_1->achc_ginp_end - achl_help_sta;
     if ((iml1 > 0) && (iml1 <= 0X4000)) {
       m_console_out( achl_help_sta, iml1 );
     }
   }
#endif
#ifdef D_FFLUSH                             /* 30.05.05 KB - flush stdout */
   fflush( stdout );
#endif                                      /* 30.05.05 KB - flush stdout */
#ifdef TRACE_LOOP_1
   while (ADSL_RDPA_F) {
     Sleep( 2000 );
   }
#endif
   if (adsl_gai1_inp_1) {
     adsl_gai1_inp_1->achc_ginp_cur
       = adsl_gai1_inp_1->achc_ginp_end;
   }
   goto p_cleanup_00;                       /* do cleanup now          */

   ptose96:                                 /* program illogic         */
   m_sdh_printf( adsp_hl_clib_1, "ptose96 - program illogic received from client iec_frcl_bl=%d iec_fcfp_bl=%d",
                 ADSL_RDPA_F->dsc_rdp_se_1.iec_frcl_bl,
                 ADSL_RDPA_F->dsc_rdp_se_1.iec_fcfp_bl );
#ifdef D_FFLUSH                             /* 30.05.05 KB - flush stdout */
   fflush( stdout );
#endif                                      /* 30.05.05 KB - flush stdout */
#ifdef TRACE_LOOP_1
   while (ADSL_RDPA_F) {
     Sleep( 2000 );
   }
#endif
   if (adsl_gai1_inp_1) {
     adsl_gai1_inp_1->achc_ginp_cur
       = adsl_gai1_inp_1->achc_ginp_end;
   }
   goto p_cleanup_00;                       /* do cleanup now          */

#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#else
   D_ADSL_RSE1 = NULL;
   D_ADSL_RCO1 = NULL;
#endif

   p_ret_00:                                /* check how to return     */
   if (adsp_hl_clib_1->boc_eof_client == FALSE) {  /* check End-of-File Client */
     return;
   }

   p_cleanup_00:                            /* do cleanup now          */
   adsp_hl_clib_1->inc_return = DEF_IRET_END;  /* set normal end       */

   p_cleanup_20:                            /* do cleanup now - part two */
   if ((ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.umc_loinf_options & D_LOINFO_COMPR_ENA) || 
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.boc_always_compr_vc) {  /* compression enabled */
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_enc.imc_func = DEF_IFUNC_END;
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
     m_cdr_enc( &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_enc );
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_dec.imc_func = DEF_IFUNC_END;
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_dec.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_dec.amc_aux = adsp_hl_clib_1->amc_aux;
     m_cdr_dec( &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_cdrf_dec );
   }
   ADSL_RDPA_F->dsc_stor_sdh_1.amc_aux = adsp_hl_clib_1->amc_aux;
   ADSL_RDPA_F->dsc_stor_sdh_1.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   m_aux_stor_end( &ADSL_RDPA_F->dsc_stor_sdh_1 );
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_MEMFREE,
                                      &adsp_hl_clib_1->ac_ext,
                                      sizeof(struct dsd_rdpa_f) );
   if (bol1 == FALSE) {                     /* aux returned error      */
     adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
   }
   adsp_hl_clib_1->ac_ext = NULL;           /* no more memory          */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef ADSL_RDPA_F
#undef ADSL_OA1
#endif
} /* end void m_rdpserv_1                                              */

/* send block 04 to client                                             */
static BOOL m_send_cl_r04( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
     struct dsd_output_area_1 *adsp_output_area_1 ) {
   int        iml1;                         /* working variable        */
// char       *achl1, *achl2;               /* working variables       */
   char       *achl1;                       /* working variable        */
   struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
   struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
   struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
// struct dsd_rdp_client_1 *D_ADSL_RCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   /* fill area to send to client                                      */
/* this part already in main program 06.01.05 KB */
   ADSL_OA1->achc_w1 = adsp_hl_clib_1->achc_work_area;  /* addr work-area */
   ADSL_OA1->achc_w2 = ADSL_OA1->achc_w1 + adsp_hl_clib_1->inc_len_work_area;  /* length work-area */
   adsl_gai1_out_2 = NULL;                  /* output data             */
   achl1 = ADSL_OA1->achc_w1;
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 27314 );  /* line number for errors */
     return FALSE;
   }
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) ADSL_OA1->achc_w2;
   adsl_gai1_out_st = adsl_gai1_out_1;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = achl1;
   *achl1 = DEF_CONST_RDP_03;               /* set block type          */
   *(achl1 + 1) = 0;                        /* second byte zero        */
   achl1 += 4;                              /* after length            */
   memcpy( achl1, ucrs_x224_p01, sizeof(ucrs_x224_p01) );
   achl1 += sizeof(ucrs_x224_p01);
   /* MCS Connect Reply from Server                                    */
   *achl1++ = 0X7F;
   *achl1++ = 0X66;
   achl1 += 3;                              /* after length            */
   memcpy( achl1, ucrs_r04_asn1_1, sizeof(ucrs_r04_asn1_1) );
   achl1 += sizeof(ucrs_r04_asn1_1);
   *achl1++ = 0X04;                         /* ASN-1 tag               */
   achl1 += 3;                              /* after length            */
   memcpy( achl1, ucrs_asn1_prot_id, sizeof(ucrs_asn1_prot_id) );
   achl1 += sizeof(ucrs_asn1_prot_id);
   achl1 += 2;                              /* after length            */
   memcpy( achl1, ucrs_r04_vers_f, sizeof(ucrs_r04_vers_f) );
   achl1 += sizeof(ucrs_r04_vers_f);
   m_put_le2( achl1, 0X0C03 );              /* virtual channel tag     */
   achl1 += 2;                              /* after this field        */
   iml1 = 2 + 2 + (D_ADSL_RCO1->imc_no_virt_ch + 2) * 2;  /* length this sequence */
   if (D_ADSL_RCO1->imc_no_virt_ch & 1) {   /* odd number              */
     iml1 += 2;                             /* add length virtual channel delemiter */
   }
   m_put_le2( achl1, iml1 );                /* length this sequence    */
   achl1 += 2;                              /* after this field        */
   m_put_le2( achl1, D_ADSL_RCO1->usc_chno_disp );  /* virtual channel display */
   achl1 += 2;                              /* after this field        */
   iml1 = D_ADSL_RCO1->imc_no_virt_ch;      /* number of virtual channels */
   m_put_le2( achl1, iml1 );                /* output number of virtual channels */
   achl1 += 2;                              /* after this field        */
   while (iml1) {                           /* loop over all virtual channels */
     m_put_le2( achl1,
                (D_ADSL_RCO1->adsrc_vc_1 + (D_ADSL_RCO1->imc_no_virt_ch - iml1))
                   ->usc_vch_no );
     achl1 += 2;                            /* after this field        */
     iml1--;                                /* decrement number        */
   }
   if (D_ADSL_RCO1->imc_no_virt_ch & 1) {   /* odd number              */
     *achl1++ = 0;
     *achl1++ = 0;
   }
   m_put_le2( achl1, 0X0C02 );              /* encryption tag          */
   achl1 += 2;                              /* after this field        */
   m_put_le2( achl1,
              2 + 2 + 4 * 4
              + sizeof(ADSL_RDPA_F->chrl_server_random)
              + sizeof(ucrs_rdp_pre_cert)
              + sizeof(ucrs_rdp_cert) );
   achl1 += 2;                              /* after this field        */
   m_put_le4( achl1, D_ADSL_RCO1->imc_keytype );  /* keytype           */
   achl1 += 4;                              /* after this field        */
   m_put_le4( achl1, D_ADSL_RCO1->imc_sec_level );  /* security level  */
   achl1 += 4;                              /* after this field        */
   m_put_le4( achl1, sizeof(ADSL_RDPA_F->chrl_server_random) );
   achl1 += 4;                              /* after this field        */
   m_put_le4( achl1, sizeof(ucrs_rdp_pre_cert) + sizeof(ucrs_rdp_cert) );  /* length certificate */
   achl1 += 4;                              /* after this field        */
   adsl_gai1_out_1->achc_ginp_end = achl1;
   /* calculate end if all copied                                      */
   achl1 += sizeof(ADSL_RDPA_F->chrl_server_random)
            + sizeof(ucrs_rdp_pre_cert)
            + sizeof(ucrs_rdp_cert);
   m_put_be2( ADSL_OA1->achc_w1 + 2, achl1 - ADSL_OA1->achc_w1 );
   m_put_be2( ADSL_OA1->achc_w1 + 9 + 1, achl1 - (ADSL_OA1->achc_w1 + 9 + 3) );
   *(ADSL_OA1->achc_w1 + 9) = (char) 0X82;
   m_put_be2( ADSL_OA1->achc_w1 + 0X2F + 1, achl1 - (ADSL_OA1->achc_w1 + 0X2F + 3) );
   *(ADSL_OA1->achc_w1 + 0X2F) = (char) 0X82;
   m_put_be2( ADSL_OA1->achc_w1 + 0X47, achl1 - (ADSL_OA1->achc_w1 + 0X47 + 2) );
   *(ADSL_OA1->achc_w1 + 0X47) |= 0X80;
   adsl_gai1_out_2 = adsl_gai1_out_1;       /* save this field         */
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 27422 );  /* line number for errors */
     return FALSE;
   }
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) ADSL_OA1->achc_w2;
   adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = ADSL_RDPA_F->chrl_server_random;
   adsl_gai1_out_1->achc_ginp_end = ADSL_RDPA_F->chrl_server_random
                                    + sizeof(ADSL_RDPA_F->chrl_server_random);
   adsl_gai1_out_2 = adsl_gai1_out_1;       /* save this field         */
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 27443 );  /* line number for errors */
     return FALSE;
   }
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) ADSL_OA1->achc_w2;
   adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = (char *) ucrs_rdp_pre_cert;
   adsl_gai1_out_1->achc_ginp_end = (char *) ucrs_rdp_pre_cert
                                             + sizeof(ucrs_rdp_pre_cert);

   adsl_gai1_out_2 = adsl_gai1_out_1;       /* save this field         */
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 27465 );  /* line number for errors */
     return FALSE;
   }
   adsl_gai1_out_1 = (struct dsd_gather_i_1 *) ADSL_OA1->achc_w2;
   adsl_gai1_out_2->adsc_next = adsl_gai1_out_1;
   adsl_gai1_out_1->adsc_next = NULL;
   adsl_gai1_out_1->achc_ginp_cur = (char *) ucrs_rdp_cert;
   adsl_gai1_out_1->achc_ginp_end = (char *) ucrs_rdp_cert
                                             + sizeof(ucrs_rdp_cert);

#ifndef NEW_WSP_1102
   if (adsp_hl_clib_1->adsc_gather_i_1_out) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_r04() not first record output",
                   __LINE__, 27485 );  /* line number for errors */
     return FALSE;
   }
   adsp_hl_clib_1->adsc_gather_i_1_out = adsl_gai1_out_st;
#else
   if (adsp_hl_clib_1->adsc_gai1_out_to_client) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_r04() not first record output",
                   __LINE__, 27492 );  /* line number for errors */
     return FALSE;
   }
   adsp_hl_clib_1->adsc_gai1_out_to_client = adsl_gai1_out_st;  /* output data to client */
#endif
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_cl_r04()                                               */

/* generate keys for RDP encryption                                    */
static void m_gen_keys( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
     char *achp_client_random,
     struct dsd_rdp_co *adsp_rdp_co,        /* output in RDP communication */
     char *achp_work_area ) {               /* work area               */
   char       *achl1, *achl2, *achl3;       /* working variables       */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#define ACHL_SHA_ARRAY ((int *) (achp_work_area + 0))
#define ACHL_SHA_DIG ((char *) ACHL_SHA_ARRAY + 24 * sizeof(int))
#define ACHL_MD5_ARRAY ((int *) (ACHL_SHA_DIG + 20))
#define ACHL_PRE_HASH ((char *) ACHL_MD5_ARRAY + 24 * sizeof(int))
#define ACHL_MASTER_H_1 (ACHL_PRE_HASH + 16 * 3)
#define ACHL_MASTER_H_2 (ACHL_MASTER_H_1 + 16)
#define ACHL_MASTER_H_3 (ACHL_MASTER_H_2 + 16)
   /* make first pre master hash                                       */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_01, 0, sizeof(ucrs_crypt_ini_01) );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, achp_client_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 0, 0 );
   /* make second pre master hash                                      */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_02, 0, sizeof(ucrs_crypt_ini_02) );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, achp_client_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 16, 0 );
   /* make third pre master hash                                       */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_03, 0, sizeof(ucrs_crypt_ini_03) );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, achp_client_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 24 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 32, 0 );
   /* make first master hash                                           */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_04, 0, sizeof(ucrs_crypt_ini_04) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_PRE_HASH, 0, 48 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 48 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_1, 0 );
   /* make second master hash                                          */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_05, 0, sizeof(ucrs_crypt_ini_05) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_PRE_HASH, 0, 48 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 48 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_2, 0 );
   /* make third master hash                                           */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_06, 0, sizeof(ucrs_crypt_ini_06) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_PRE_HASH, 0, 48 );
   SHA1_Update( ACHL_SHA_ARRAY, achp_client_random, 0, 32 );
   SHA1_Update( ACHL_SHA_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 48 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_3, 0 );
   /* signature                                                        */
   memcpy( adsp_rdp_co->chrc_sig, ACHL_MASTER_H_1, sizeof(adsp_rdp_co->chrc_sig) );
   /* client receive pre key data                                      */
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_MASTER_H_2, 0, 16 );
   MD5_Update( ACHL_MD5_ARRAY, achp_client_random, 0, 32 );
   MD5_Update( ACHL_MD5_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   MD5_Final( ACHL_MD5_ARRAY, adsp_rdp_co->dsc_encry_se2cl.chrc_cl_pkd, 0 );
   /* save original key data for future key update calculations        */
   memcpy( adsp_rdp_co->dsc_encry_se2cl.chrc_orig_pkd,
           adsp_rdp_co->dsc_encry_se2cl.chrc_cl_pkd,
           sizeof(adsp_rdp_co->dsc_encry_se2cl.chrc_orig_pkd) );
#ifdef TRACEHL1
   printf( "receive pre key data :" );
   achl1 = adsp_rdp_co->dsc_encry_se2cl.chrc_cl_pkd;
   achl2 = achl1 + 16;
   achl3 = achl1 + 4;
   do {
     if (achl1 == achl3) {
       printf( " " );
       achl3 = achl1 + 4;
     }
     printf( " %02X", (unsigned char) *achl1++ );
   } while (achl1 < achl2);
   printf( "\n" );
#endif
   /* client transmit pre key data                                     */
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_MASTER_H_3, 0, 16 );
   MD5_Update( ACHL_MD5_ARRAY, achp_client_random, 0, 32 );
   MD5_Update( ACHL_MD5_ARRAY, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   MD5_Final( ACHL_MD5_ARRAY, adsp_rdp_co->dsc_encry_cl2se.chrc_cl_pkd, 0 );
   /* save original key data for future key update calculations        */
   memcpy( adsp_rdp_co->dsc_encry_cl2se.chrc_orig_pkd,
           adsp_rdp_co->dsc_encry_cl2se.chrc_cl_pkd,
           sizeof(adsp_rdp_co->dsc_encry_cl2se.chrc_orig_pkd) );
#ifdef TRACEHL1
   printf( "transmit pre key data:" );
   achl1 = adsp_rdp_co->dsc_encry_cl2se.chrc_cl_pkd;
   achl2 = achl1 + 16;
   achl3 = achl1 + 4;
   do {
     if (achl1 == achl3) {
       printf( " " );
       achl3 = achl1 + 4;
     }
     printf( " %02X", (unsigned char) *achl1++ );
   } while (achl1 < achl2);
   printf( "\n" );
#endif
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef ADSL_RDPA_F
#endif
#undef ACHL_SHA_ARRAY
#undef ACHL_SHA_DIG
#undef ACHL_MD5_ARRAY
#undef ACHL_PRE_HASH
#undef ACHL_MASTER_H_1
#undef ACHL_MASTER_H_2
#undef ACHL_MASTER_H_3
} /* end m_gen_keys()                                                  */

/* prepare keys for RDP encryption                                     */
static BOOL m_prepare_keys( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
     struct dsd_rdp_co *adsp_rdp_co ) {     /* output in RDP communication */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
   /* shorten the keys                                                 */
   switch ( adsp_rdp_co->imc_keytype) {
     case 1:
       memcpy( adsp_rdp_co->dsc_encry_se2cl.chrc_cl_pkd, ucrs_ks_01, sizeof(ucrs_ks_01) );
       memcpy( adsp_rdp_co->dsc_encry_cl2se.chrc_cl_pkd, ucrs_ks_01, sizeof(ucrs_ks_01) );
       adsp_rdp_co->imc_used_keylen = 8;
       break;
     case 2:
       adsp_rdp_co->imc_used_keylen = 16;
       break;
     case 4:
     case 8:
       adsp_rdp_co->dsc_encry_se2cl.chrc_cl_pkd[0] = (char) 0XD1;
       adsp_rdp_co->dsc_encry_cl2se.chrc_cl_pkd[0] = (char) 0XD1;
       adsp_rdp_co->imc_used_keylen = 8;
       break;
     default:
       return FALSE;                        /* protocoll error          */
   }
   return TRUE;                             /* all valid               */
#ifndef HL_RDPACC_HELP_DEBUG
#undef ADSL_RDPA_F
#endif
} /* end m_prepare_keys()                                              */

static void m_update_keys( struct dsd_rdp_co *adsp_rdp_co,
                           struct dsd_rdp_encry *adsp_encry,
                           char *achp_work_area ) {
// char       chrl_work_1[ SHA_ARRAY_SIZE * sizeof(int)
//                         + MD5_ARRAY_SIZE * sizeof(int) ];
   char       chrl_work_1[ 2048 ];

#define ACHL_CONST_SHA1 ((char *) chrl_work_1)
#define ACHL_CONST_MD5 ((char *) chrl_work_1 + 40)
#define ACHL_WORK_SHA1 ((int *) ((char *) chrl_work_1 + 40 + 48))
#define ACHL_WORK_MD5 ((int *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int)))
//#define ACHL_SAVE_SHA1 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
//#define ACHL_SAVE_MD5 ((char *) ACHL_SAVE_SHA1 + MD5_ARRAY_SIZE * sizeof(int) + sizeof(adsp_encry->imrc_sha1_state))
//#define ACHL_WORK_UTIL_01 ((char *) ACHL_SAVE_MD5 + sizeof(adsp_encry->imrc_md5_state))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
#define ACHL_WORK_UTIL_02 ((char *) ACHL_WORK_UTIL_01 + 128)
// memcpy( ACHL_SAVE_SHA1, adsp_encry->imrc_sha1_state, sizeof(adsp_encry->imrc_sha1_state) );  /* save old key */
// memcpy( ACHL_SAVE_MD5, adsp_encry->imrc_md5_state, sizeof(adsp_encry->imrc_md5_state) );  /* save old key */
   memset( ACHL_CONST_SHA1, 0X36, 40 );
   memset( ACHL_CONST_MD5, 0X5C, 48 );
   SHA1_Init( ACHL_WORK_SHA1 );
   SHA1_Update( ACHL_WORK_SHA1, adsp_encry->chrc_orig_pkd,
                0, adsp_rdp_co->imc_used_keylen );
   SHA1_Update( ACHL_WORK_SHA1, ACHL_CONST_SHA1, 0, 40 );
   SHA1_Update( ACHL_WORK_SHA1, adsp_encry->chrc_cl_pkd,
                0, adsp_rdp_co->imc_used_keylen );
   SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
   MD5_Init( ACHL_WORK_MD5 );
   MD5_Update( ACHL_WORK_MD5, adsp_encry->chrc_orig_pkd,
               0, adsp_rdp_co->imc_used_keylen );
   MD5_Update( ACHL_WORK_MD5, ACHL_CONST_MD5, 0, 48 );
   MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
   MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
   switch ( adsp_rdp_co->imc_keytype) {
     case 1:
       memcpy( adsp_encry->chrc_cl_pkd, ACHL_WORK_UTIL_01, 8 );
       RC4_SetKey( ACHL_WORK_UTIL_02,
                   adsp_encry->chrc_cl_pkd, 0,
                   8 );
       RC4( adsp_encry->chrc_cl_pkd, 0, 8, adsp_encry->chrc_cl_pkd, 0, ACHL_WORK_UTIL_02 );
       memcpy( adsp_encry->chrc_cl_pkd, ucrs_ks_01, sizeof(ucrs_ks_01) );
       break;
     case 2:
       memcpy( adsp_encry->chrc_cl_pkd, ACHL_WORK_UTIL_01, 16 );
       RC4_SetKey( ACHL_WORK_UTIL_02,
                   adsp_encry->chrc_cl_pkd, 0,
                   16 );
       RC4( adsp_encry->chrc_cl_pkd, 0, 16, adsp_encry->chrc_cl_pkd, 0, ACHL_WORK_UTIL_02 );
       break;
     case 4:
     case 8:
       memcpy( adsp_encry->chrc_cl_pkd, ACHL_WORK_UTIL_01, 8 );
       RC4_SetKey( ACHL_WORK_UTIL_02,
                   adsp_encry->chrc_cl_pkd, 0,
                   8 );
       RC4( adsp_encry->chrc_cl_pkd, 0, 8, adsp_encry->chrc_cl_pkd, 0, ACHL_WORK_UTIL_02 );
       adsp_encry->chrc_cl_pkd[0] = (char) 0XD1;
       break;
   }
   RC4_SetKey( adsp_encry->chrc_rc4_state,
               adsp_encry->chrc_cl_pkd, 0,
               adsp_rdp_co->imc_used_keylen );
   return;
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
#undef ACHL_WORK_UTIL_02
} /* end m_update_keys()                                               */

/* generate keys for licensing encryption, [MS-RDPELE] 5.1.3 .. 5.1.6  */
static void m_gen_lic_keys( struct dsd_rdp_lic_d* adsp_lic_neg,
     char *achp_work_area ) {               /* work area               */
#define ACHL_SHA_ARRAY ((int *) (achp_work_area + 0))
#define ACHL_SHA_DIG ((char *) ACHL_SHA_ARRAY + 24 * sizeof(int))
#define ACHL_MD5_ARRAY ((int *) (ACHL_SHA_DIG + 20))
#define ACHL_PRE_HASH ((char *) ACHL_MD5_ARRAY + 24 * sizeof(int))
#define ACHL_MASTER_H_1 (ACHL_PRE_HASH + 16 * 3)
#define ACHL_MASTER_H_2 (ACHL_MASTER_H_1 + 16)
#define ACHL_WORK_UTIL_01 (ACHL_MASTER_H_2 + 16)
   /* invert the client premaster to little endian                     */
   char       *achl1, *achl2;               /* working variables       */
   achl1 = ACHL_WORK_UTIL_01 + adsp_lic_neg->dsc_lic_pms.usc_bb_len;
   achl2 = adsp_lic_neg->dsc_lic_pms.achc_bb_data;
   do {
     *(--achl1) = *achl2++;
   } while (achl1 > ACHL_WORK_UTIL_01);
#define CLRAND adsp_lic_neg->chrc_lic_clrand
#define SERAND adsp_lic_neg->chrc_lic_serand
   /* make first pre master hash                                       */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_01, 0, sizeof(ucrs_crypt_ini_01) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   SHA1_Update( ACHL_SHA_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   SHA1_Update( ACHL_SHA_ARRAY, SERAND, 0, sizeof(SERAND) );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 0, 0 );
   /* make second pre master hash                                      */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_02, 0, sizeof(ucrs_crypt_ini_02) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   SHA1_Update( ACHL_SHA_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   SHA1_Update( ACHL_SHA_ARRAY, SERAND, 0, sizeof(SERAND) );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 16, 0 );
   /* make third pre master hash                                       */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_03, 0, sizeof(ucrs_crypt_ini_03) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   SHA1_Update( ACHL_SHA_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   SHA1_Update( ACHL_SHA_ARRAY, SERAND, 0, sizeof(SERAND) );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_WORK_UTIL_01, 0, adsp_lic_neg->dsc_lic_pms.usc_bb_len );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_PRE_HASH + 32, 0 );
   /* make first master hash                                           */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_01, 0, sizeof(ucrs_crypt_ini_01) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_PRE_HASH, 0, 48 );
   SHA1_Update( ACHL_SHA_ARRAY, SERAND, 0, sizeof(SERAND) );
   SHA1_Update( ACHL_SHA_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 48 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_1, 0 );
   /* make second master hash                                          */
   SHA1_Init( ACHL_SHA_ARRAY );
   SHA1_Update( ACHL_SHA_ARRAY, (char *) ucrs_crypt_ini_02, 0, sizeof(ucrs_crypt_ini_02) );
   SHA1_Update( ACHL_SHA_ARRAY, ACHL_PRE_HASH, 0, 48 );
   SHA1_Update( ACHL_SHA_ARRAY, SERAND, 0, sizeof(SERAND) );
   SHA1_Update( ACHL_SHA_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   SHA1_Final( ACHL_SHA_ARRAY, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 48 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_2, 0 );
   /* make third master hash, as part of the spec ...
   *M_SALTHASH( ACHL_PRE_HASH, '48', -, 0, 3, SERAND, 'sizeof(SERAND)', CLRAND, 'sizeof(CLRAND)', 'ACHL_MASTER_H_3' );
      which however seems irrelevant; the last 128 bits are not used   */
#define ACHL_RC4_KEY ACHL_WORK_UTIL_01
#define ACHL_CONST_SIX (ACHL_RC4_KEY + 16)
#define ACHL_CONST_BS (ACHL_CONST_SIX + 40)
   /* encryption key                                                   */
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_MASTER_H_2, 0, 16 );
   MD5_Update( ACHL_MD5_ARRAY, CLRAND, 0, sizeof(CLRAND) );
   MD5_Update( ACHL_MD5_ARRAY, SERAND, 0, sizeof(SERAND) );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_RC4_KEY , 0 );
#undef CLRAND
#undef SERAND
   /* initialise server and client RC4 with the same key               */
   RC4_SetKey( adsp_lic_neg->chrc_rc4_state_se2cl,
               ACHL_RC4_KEY,
               0, 16 );
   memcpy( adsp_lic_neg->chrc_rc4_state_cl2se,
           adsp_lic_neg->chrc_rc4_state_se2cl,
           RC4_STATE_SIZE );
   /* prepare state arrays for hash generation                         */
   memset( ACHL_CONST_SIX, 0X36, 40 );
   memset( ACHL_CONST_BS, 0X5C, 48 );
   SHA1_Init( adsp_lic_neg->imrc_sha1_state );
   SHA1_Update( adsp_lic_neg->imrc_sha1_state, ACHL_MASTER_H_1, 0, 16 );
   SHA1_Update( adsp_lic_neg->imrc_sha1_state, ACHL_CONST_SIX, 0, 40 );
   MD5_Init( adsp_lic_neg->imrc_md5_state );
   MD5_Update( adsp_lic_neg->imrc_md5_state, ACHL_MASTER_H_1, 0, 16 );
   MD5_Update( adsp_lic_neg->imrc_md5_state, ACHL_CONST_BS, 0, 48 );
#undef ACHL_RC4_KEY
#undef ACHL_CONST_SIX
#undef ACHL_CONST_BS
#undef ACHL_WORK_UTIL_01
#undef ACHL_SHA_ARRAY
#undef ACHL_SHA_DIG
#undef ACHL_MD5_ARRAY
#undef ACHL_PRE_HASH
#undef ACHL_MASTER_H_1
#undef ACHL_MASTER_H_2
} /* end m_gen_lic_keys()                                              */

/* prepare a screen buffer                                             */
static BOOL m_make_screen( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
     char *achp_param ) {                   /* parameters are here     */
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   int        iml_width, iml_height, iml_coldep, iml_bpp;
   struct dsd_progaddr_1 *adsl_progaddr_1;  /* program addresses       */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
   return TRUE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef ADSL_RDPA_F
#endif
} /* end m_make_screen()                                               */


static BOOL m_r5order_xx_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   return FALSE;
} /* end m_r5order_00_s()                                              */

static BOOL m_r5order_00_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
// struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o00 *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#else
#endif
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_G
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
//#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_00_s()                                              */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.3 PatBlt (PATBLT_ORDER)                  */
static BOOL m_r5order_01_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml1;                         /* working variable        */
   unsigned short usrl_colour[2];           /* colours to be applied   */
   unsigned char ucl_br_mask;               /* brush mask              */
   int        iml_left_p;                   /* position left           */
   unsigned short int *ausl_screen_line;    /* address of line in screen buffer */
   unsigned char *aucl_a_br_mask;           /* address of brush mask   */
   struct dsd_rectrb dsl_rect_target;       /* target rectangle        */
   amd_rop2_x_x aml_rop2_x_x;               /* function ROP2           */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSEOCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
// struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o01 *D_ADSL_ORD_CO_O01;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_O01 (&D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o01)
#else
   D_ADSL_RSEOCL1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSEOCL1->dsc_rdp_co_1;
   D_ADSL_ORD_CO_O01 = &D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o01;
#endif
   if (D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushstyle > BS_PATTERN) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_r5order_01_s - D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushstyle=0X%02X invalid",
                   28367,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   (unsigned char) D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushstyle );
     return FALSE;
   }
   dsl_rect_target.isc_left = D_ADSL_ORD_CO_O01->dsc_rect.isc_left;
   dsl_rect_target.isc_top = D_ADSL_ORD_CO_O01->dsc_rect.isc_top;
   dsl_rect_target.isc_right = D_ADSL_ORD_CO_O01->dsc_rect.isc_left + D_ADSL_ORD_CO_O01->dsc_rect.isc_width;
   dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O01->dsc_rect.isc_top + D_ADSL_ORD_CO_O01->dsc_rect.isc_height;
// 12.07.09 KB to Johannes Bauer               - instead of + ???
   /* apply bounds                                                     */
   if (D_ADSL_RSEOCL1->ucc_order_flags_1 & 0X04) {
     if (D_ADSL_RCO1->imc_bounds_left > dsl_rect_target.isc_left) {
       dsl_rect_target.isc_left = D_ADSL_RCO1->imc_bounds_left;
     }
     if (D_ADSL_RCO1->imc_bounds_top > dsl_rect_target.isc_top) {
       dsl_rect_target.isc_top = D_ADSL_RCO1->imc_bounds_top;
     }
     iml1 = D_ADSL_RCO1->imc_bounds_right + 1;
     if (iml1 < dsl_rect_target.isc_right) {
       dsl_rect_target.isc_right = iml1;
     }
     if (dsl_rect_target.isc_right <= dsl_rect_target.isc_left) return TRUE;
     iml1 = D_ADSL_RCO1->imc_bounds_bottom + 1;
     if (iml1 < dsl_rect_target.isc_bottom) {
       dsl_rect_target.isc_bottom = iml1;
     }
     if (dsl_rect_target.isc_bottom <= dsl_rect_target.isc_top) return TRUE;
   }
   aml_rop2_x_x = dsrs_progaddr_1[ 1 ].amrc_rop2_x_x[ ((D_ADSL_ORD_CO_O01->ucc_brop3 & 0X30) >> 2) | (D_ADSL_ORD_CO_O01->ucc_brop3 & 0X03) ];
   if (D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushstyle < BS_HATCHED) goto p_no_brush;  /* without brush */
   usrl_colour[0] = D_ADSL_ORD_CO_O01->dsc_brush.umc_forecolor;  /* colour to be applied */
   usrl_colour[1] = D_ADSL_ORD_CO_O01->dsc_brush.umc_backcolor;  /* colour to be applied */
   aucl_a_br_mask = (unsigned char *) &ucrs_brush_01[ (D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushhatch << 3) ];  /* address of brush mask */
   if (D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushstyle == BS_PATTERN) {
     aucl_a_br_mask = (unsigned char *) achp_work_area;
     iml1 = 0;
     do {                                   /* generate pattern as we need it */
       *(aucl_a_br_mask + iml1) = ucrs_invert_bits[ (unsigned char) D_ADSL_ORD_CO_O01->dsc_brush.chrc_brushextra[ iml1 ] ];
       iml1++;                              /* increment index         */
     } while (iml1 < 7);
     *(aucl_a_br_mask + 7) = ucrs_invert_bits[ (unsigned char) D_ADSL_ORD_CO_O01->dsc_brush.ucc_brushhatch ];
   }
   while (dsl_rect_target.isc_top < dsl_rect_target.isc_bottom) {
     /* brush mask                                                     */
     ucl_br_mask = *(aucl_a_br_mask + 7 - ((dsl_rect_target.isc_top -
                                             D_ADSL_ORD_CO_O01->dsc_brush.scc_brushorgy) & 7) );
     iml_left_p = dsl_rect_target.isc_left;  /* position left          */
     ausl_screen_line = ((unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
                            + (dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x));
     while (iml_left_p < dsl_rect_target.isc_right) {
       *(ausl_screen_line + iml_left_p)
         = (unsigned short int) aml_rop2_x_x( *(ausl_screen_line + iml_left_p),
                                              usrl_colour[ (ucl_br_mask >> ((iml_left_p - ((unsigned char) D_ADSL_ORD_CO_O01->dsc_brush.scc_brushorgx)) & 7)) & 1 ] );
       iml_left_p++;                        /* next horizontal position */
     }
     dsl_rect_target.isc_top++;             /* move to next line       */
   }
   return TRUE;

   p_no_brush:                              /* without brush           */
   usrl_colour[0] = D_ADSL_ORD_CO_O01->dsc_brush.umc_forecolor;  /* colour to be applied */
   while (dsl_rect_target.isc_top < dsl_rect_target.isc_bottom) {
     iml_left_p = dsl_rect_target.isc_left;  /* position left          */
     ausl_screen_line = ((unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
                            + (dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x));
     while (iml_left_p < dsl_rect_target.isc_right) {
       *(ausl_screen_line + iml_left_p)
         = (unsigned short int) aml_rop2_x_x( *(ausl_screen_line + iml_left_p),
                                              usrl_colour[ 0 ] );
       iml_left_p++;                        /* next horizontal position */
     }
     dsl_rect_target.isc_top++;             /* move to next line       */
   }
   return TRUE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_O01
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
//#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_01_s()                                              */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.11 LineTo (LINETO_ORDER)                 */
static BOOL m_r5order_09_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml1, iml2;                   /* working variables       */
   int        iml_delta_x, iml_delta_y;     /* delta values            */
   int        iml_error;                    /* error value             */
   struct dsd_rectrb dsl_rect_target;       /* target rectangle        */
   unsigned short int *ausl_screen_pos_1, *ausl_screen_pos_2;  /* address of pixel in screen buffer */
   unsigned short int *ausl_screen_pos_s, *ausl_screen_pos_e;  /* address of pixel in screen buffer */
   amd_rop2_x_x aml_rop2_x_x;               /* function ROP2           */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSEOCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
// struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o09 *D_ADSL_ORD_CO_O09;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_O09 (&D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o09)
#else
   D_ADSL_RSEOCL1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSEOCL1->dsc_rdp_co_1;
   D_ADSL_ORD_CO_O09 = &D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o09;
#endif
   printf( "l%05d m_r5order_09_s() called nXStart=%d nYStart=%d nXEnd=%d nYEnd=%d\n",
           __LINE__,
           D_ADSL_ORD_CO_O09->isc_nxstart, D_ADSL_ORD_CO_O09->isc_nystart,
           D_ADSL_ORD_CO_O09->isc_nxend, D_ADSL_ORD_CO_O09->isc_nyend );
   if (   (D_ADSL_ORD_CO_O09->iec_backmode != ied_scc_transparent)
       && (D_ADSL_ORD_CO_O09->iec_backmode != ied_scc_opaque)) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_r5order_09_s - D_ADSL_ORD_CO_O09->iec_backmode=0X%04X invalid",
                   28521,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   (unsigned short int) D_ADSL_ORD_CO_O09->iec_backmode );
     return FALSE;
   }
   if (   (D_ADSL_ORD_CO_O09->ucc_brop2 == 0)
       || (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) > 0X10)) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_r5order_09_s - D_ADSL_ORD_CO_O09->iec_brop2=0X%02X invalid",
                   28529,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   (unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2 );
     return FALSE;
   }
   dsl_rect_target.isc_left = 0;
   dsl_rect_target.isc_top = 0;
   dsl_rect_target.isc_right = D_ADSL_RCO1->imc_dim_x;
   dsl_rect_target.isc_bottom = D_ADSL_RCO1->imc_dim_y;
   /* apply bounds                                                     */
   if (D_ADSL_RSEOCL1->ucc_order_flags_1 & 0X04) {
     if (D_ADSL_RCO1->imc_bounds_left > 0) {
       dsl_rect_target.isc_left = D_ADSL_RCO1->imc_bounds_left;
     }
     if (D_ADSL_RCO1->imc_bounds_top > 0) {
       dsl_rect_target.isc_top = D_ADSL_RCO1->imc_bounds_top;
     }
     iml1 = D_ADSL_RCO1->imc_bounds_right + 1;
     if (iml1 < D_ADSL_RCO1->imc_dim_x) {
       dsl_rect_target.isc_right = iml1;
     }
     iml1 = D_ADSL_RCO1->imc_bounds_bottom + 1;
     if (iml1 < D_ADSL_RCO1->imc_dim_y) {
       dsl_rect_target.isc_bottom = iml1;
     }
   }
   aml_rop2_x_x = dsrs_progaddr_1[ 1 ].amrc_rop2_x_x[ ((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) - 1 ];
   iml_delta_x = D_ADSL_ORD_CO_O09->isc_nxend - D_ADSL_ORD_CO_O09->isc_nxstart;
   if (iml_delta_x == 0) goto p_li_vert_00;  /* draw vertical line     */
   iml_delta_y = D_ADSL_ORD_CO_O09->isc_nyend - D_ADSL_ORD_CO_O09->isc_nystart;
   if (iml_delta_y == 0) goto p_li_hori_00;  /* draw horizontal line   */
   if (iml_delta_x < 0) goto p_li_rile_00;   /* from right to left      */
   if (iml_delta_y < 0) goto p_li_lebo_00;   /* from left bottom to right top */
   if (iml_delta_x < iml_delta_y) goto p_li_leto_y_00;  /* starts left top, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nystart;
   if (dsl_rect_target.isc_left > D_ADSL_ORD_CO_O09->isc_nxstart) {
     iml_error -= (dsl_rect_target.isc_left - D_ADSL_ORD_CO_O09->isc_nxstart) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxstart;
   }
   if (dsl_rect_target.isc_top > iml1) {
     iml2 = ((dsl_rect_target.isc_top - iml1) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_left += iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_top = iml1;
   }
   if (dsl_rect_target.isc_right > D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_bottom > D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_leto_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_left;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   return TRUE;

   p_li_leto_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_left) = D_ADSL_ORD_CO_O09->umc_pencolor;
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   return TRUE;

   p_li_leto_y_00:                          /* starts left top, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nxstart;
   if (dsl_rect_target.isc_top > D_ADSL_ORD_CO_O09->isc_nystart) {
     iml_error -= (dsl_rect_target.isc_top - D_ADSL_ORD_CO_O09->isc_nystart) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_top = D_ADSL_ORD_CO_O09->isc_nystart;
   }
   if (dsl_rect_target.isc_left > iml1) {
     iml2 = ((dsl_rect_target.isc_left - iml1) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_left = iml1;
   }
   if (dsl_rect_target.isc_right > D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_bottom > D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_left;        /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_leto_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   return TRUE;

   p_li_leto_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   return TRUE;

   p_li_lebo_00:                            /* from left bottom to right top */
   iml_delta_y = D_ADSL_ORD_CO_O09->isc_nystart - D_ADSL_ORD_CO_O09->isc_nyend;
   if (iml_delta_x < iml_delta_y) goto p_li_lebo_y_00;  /* starts left bottom, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nystart;
   if (dsl_rect_target.isc_left > D_ADSL_ORD_CO_O09->isc_nxstart) {
     iml_error -= (dsl_rect_target.isc_left - D_ADSL_ORD_CO_O09->isc_nxstart) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxstart;
   }
   if (dsl_rect_target.isc_bottom < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_bottom) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_left += iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_bottom = iml1;
   }
   if (dsl_rect_target.isc_right > D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_top < D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_top = D_ADSL_ORD_CO_O09->isc_nyend;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_lebo_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_left;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   return TRUE;

   p_li_lebo_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_left) = D_ADSL_ORD_CO_O09->umc_pencolor;
     iml1++;                                /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   return TRUE;

   p_li_lebo_y_00:                          /* starts left bottom, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nxstart;
   if (dsl_rect_target.isc_bottom < D_ADSL_ORD_CO_O09->isc_nyend) {
     iml_error -= (D_ADSL_ORD_CO_O09->isc_nystart - dsl_rect_target.isc_bottom) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend;
   }
   if (dsl_rect_target.isc_left > iml1) {
     iml2 = ((dsl_rect_target.isc_left - iml1) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_left = iml1;
   }
   if (dsl_rect_target.isc_right > D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_top < D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_top = D_ADSL_ORD_CO_O09->isc_nyend;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_left;        /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_leto_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   return TRUE;

   p_li_lebo_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   return TRUE;

   p_li_rile_00:                            /* from right to left      */
   iml_delta_x = D_ADSL_ORD_CO_O09->isc_nxstart - D_ADSL_ORD_CO_O09->isc_nxend;
   if (iml_delta_y < 0) goto p_li_ribo_00;  /* starts right bottom     */
   if (iml_delta_x < iml_delta_y) goto p_li_rito_y_00;  /* starts right top, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nystart;
   if (dsl_rect_target.isc_right < D_ADSL_ORD_CO_O09->isc_nxstart) {
     iml_error -= (D_ADSL_ORD_CO_O09->isc_nxstart - dsl_rect_target.isc_right) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxstart;
   }
   if (dsl_rect_target.isc_top > iml1) {
     iml2 = ((dsl_rect_target.isc_top - iml1) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_right -= iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_top = iml1;
   }
   if (dsl_rect_target.isc_left < D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_bottom > D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_rito_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_right;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   return TRUE;

   p_li_rito_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_right) = D_ADSL_ORD_CO_O09->umc_pencolor;
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   return TRUE;

   p_li_rito_y_00:                          /* starts right top, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nxstart;
   if (dsl_rect_target.isc_top > D_ADSL_ORD_CO_O09->isc_nystart) {
     iml_error -= (dsl_rect_target.isc_top - D_ADSL_ORD_CO_O09->isc_nystart) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_top = D_ADSL_ORD_CO_O09->isc_nystart;
   }
   if (dsl_rect_target.isc_right < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_right) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_right = iml1;
   }
   if (dsl_rect_target.isc_left < D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_bottom > D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_right;       /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_rito_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   return TRUE;

   p_li_rito_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   return TRUE;

   p_li_ribo_00:                            /* starts right bottom     */
   iml_delta_y = D_ADSL_ORD_CO_O09->isc_nystart - D_ADSL_ORD_CO_O09->isc_nyend;
   if (iml_delta_x < iml_delta_y) goto p_li_ribo_y_00;  /* starts right bottom, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nystart;
   if (dsl_rect_target.isc_right < D_ADSL_ORD_CO_O09->isc_nxstart) {
     iml_error -= (D_ADSL_ORD_CO_O09->isc_nxstart - dsl_rect_target.isc_right) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 += iml2;
   } else {
     dsl_rect_target.isc_right = D_ADSL_ORD_CO_O09->isc_nxstart;
   }
   if (dsl_rect_target.isc_bottom < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_bottom) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_right -= iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_bottom = iml1;
   }
   if (dsl_rect_target.isc_left < D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_bottom > D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nyend + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_ribo_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_right;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   return TRUE;

   p_li_ribo_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_right) = D_ADSL_ORD_CO_O09->umc_pencolor;
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   return TRUE;

   p_li_ribo_y_00:                          /* starts right bottom, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = D_ADSL_ORD_CO_O09->isc_nxstart;
   if (dsl_rect_target.isc_bottom < D_ADSL_ORD_CO_O09->isc_nystart) {
     iml_error -= (D_ADSL_ORD_CO_O09->isc_nystart - dsl_rect_target.isc_bottom) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 += iml2;
   } else {
     dsl_rect_target.isc_bottom = D_ADSL_ORD_CO_O09->isc_nystart;
   }
   if (dsl_rect_target.isc_right < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_right) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_bottom -= iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_right = iml1;
   }
   if (dsl_rect_target.isc_left < D_ADSL_ORD_CO_O09->isc_nxend) {
     dsl_rect_target.isc_left = D_ADSL_ORD_CO_O09->isc_nxend;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) return TRUE;
   if (dsl_rect_target.isc_top < D_ADSL_ORD_CO_O09->isc_nyend) {
     dsl_rect_target.isc_top = D_ADSL_ORD_CO_O09->isc_nyend;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) return TRUE;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_right;       /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_ribo_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   return TRUE;

   p_li_ribo_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   return TRUE;

   p_li_vert_00:                            /* draw vertical line      */
   if (D_ADSL_ORD_CO_O09->isc_nxstart < dsl_rect_target.isc_left) return TRUE;
   if (D_ADSL_ORD_CO_O09->isc_nxstart >= dsl_rect_target.isc_right) return TRUE;
   iml1 = D_ADSL_ORD_CO_O09->isc_nystart;                    /* get y start             */
   iml2 = D_ADSL_ORD_CO_O09->isc_nyend;                    /* get y end               */
   if (iml1 > iml2) {                       /* from bottom to top      */
     iml1 = D_ADSL_ORD_CO_O09->isc_nyend + 1;              /* get y end               */
     iml2 = D_ADSL_ORD_CO_O09->isc_nystart + 1;              /* get y start             */
   }
   if (iml1 < dsl_rect_target.isc_top) iml1 = dsl_rect_target.isc_top;
   if (iml2 > dsl_rect_target.isc_bottom) iml2 = dsl_rect_target.isc_bottom;
   if (iml1 > iml2) return TRUE;            /* nothing to draw         */
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + D_ADSL_ORD_CO_O09->isc_nxstart
         + iml1 * D_ADSL_RCO1->imc_dim_x;   /* address of pixel in screen buffer */
   ausl_screen_pos_2 = ausl_screen_pos_1 + (iml2 - iml1) * D_ADSL_RCO1->imc_dim_x;
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_vert_20;
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   return TRUE;

   p_li_vert_20:                            /* set only pen            */
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   return TRUE;

   p_li_hori_00:                            /* draw horizontal line    */
   if (D_ADSL_ORD_CO_O09->isc_nystart < dsl_rect_target.isc_top) return TRUE;
   if (D_ADSL_ORD_CO_O09->isc_nystart >= dsl_rect_target.isc_bottom) return TRUE;
   iml1 = D_ADSL_ORD_CO_O09->isc_nxstart;                    /* get x start             */
   iml2 = D_ADSL_ORD_CO_O09->isc_nxend;                    /* get x end               */
   if (iml1 > iml2) {                       /* from right to left      */
     iml1 = D_ADSL_ORD_CO_O09->isc_nxend + 1;              /* get x end               */
     iml2 = D_ADSL_ORD_CO_O09->isc_nxstart + 1;              /* get x start             */
   }
   if (iml1 < dsl_rect_target.isc_left) iml1 = dsl_rect_target.isc_left;
   if (iml2 > dsl_rect_target.isc_right) iml2 = dsl_rect_target.isc_right;
   if (iml1 > iml2) return TRUE;           /* nothing to draw         */
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + D_ADSL_ORD_CO_O09->isc_nystart * D_ADSL_RCO1->imc_dim_x
         + iml1;                            /* address of pixel in screen buffer */
   ausl_screen_pos_2 = ausl_screen_pos_1 + iml2 - iml1;
   if (((unsigned char) D_ADSL_ORD_CO_O09->ucc_brop2) == 0X0D) goto p_li_hori_20;
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O09->umc_pencolor );
     ausl_screen_pos_1++;                   /* go to next pixel        */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   return TRUE;

   p_li_hori_20:                            /* set only pen            */
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) D_ADSL_ORD_CO_O09->umc_pencolor;
     ausl_screen_pos_1++;                   /* go to next pixel        */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   return TRUE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_O09
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
//#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_09_s()                                              */

static BOOL m_r5order_0a_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml_cur_line;                 /* current line            */
   int        iml_end_line;                 /* end of lines            */
   unsigned short int *ausl_current;        /* current position        */
   unsigned short int *ausl_end_line;       /* end in this line        */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
// struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o0a *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_cl_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_G (&D_ADSL_RCO1->dsc_ord_co_o0a)
#else
#endif
#ifdef TRACEHL1
   printf( "l%05d m_r5order_0a_s() called left=%d top=%d width=%d height=%d\n",
           __LINE__,
           D_ADSL_ORD_CO_1->imc_left, D_ADSL_ORD_CO_1->imc_top,
           D_ADSL_ORD_CO_1->imc_dim_x_2, D_ADSL_ORD_CO_1->imc_dim_y_2 );
   if (D_ADSL_ORD_CO_1->imc_dim_x_2 <= 0) return FALSE;
   if (D_ADSL_ORD_CO_1->imc_dim_y_2 <= 0) return FALSE;
#endif
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_G
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
//#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_0a_s()                                              */

static BOOL m_r5order_0b_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o0b *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_cl_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_G (&D_ADSL_RCO1->dsc_ord_co_o0b)
#else
#endif
#ifdef TRACEHL1
   printf( "l%05d m_r5order_0B_s() called left=%d top=%d right=%d bottom=%d\n",
           __LINE__,
           D_ADSL_ORD_CO_1->imc_left, D_ADSL_ORD_CO_1->imc_top,
           D_ADSL_ORD_CO_1->imc_dim_x_2, D_ADSL_ORD_CO_1->imc_dim_y_2 );
#endif
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_G
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_0B_s()                                              */

/* memory build 16 bit                                                 */
static BOOL m_r5order_0d_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int iml1, iml2, iml3;                    /* working-variables       */
   unsigned char ucl_ind_col_tab;           /* index of the color table entry to use */
   unsigned char ucl_bitmap_cache_id;       /* ID of the bitmap cache in which the source bitmap is stored */
   unsigned short int *ausl_current;        /* current position        */
   struct dsd_bmp_cache_b_1 *adsl_bmpc_b_1;  /* Bitmap Cache Buffer    */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o0d *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_cl_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_G (&D_ADSL_RCO1->dsc_ord_co_o0d)
#else
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ISL_BP0 D_ADSL_ORD_CO_G->usc_cacheindex
#else
#endif
   return TRUE;

#ifndef HL_RDPACC_HELP_DEBUG
#undef ADSL_RDPA_F
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
#undef D_ADSL_ORD_CO_G
#endif
// return FALSE;
} /* end m_r5order_0d_s()                                              */

static BOOL m_r5order_0e_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_output_area_1 *ADSL_OA1;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RCL1 (&ADSL_RDPA_F->dsc_rdp_cl_1)
#define D_ADSL_RCO1 (&D_ADSL_RCL1->dsc_rdp_co_1)
#else
#endif
#ifdef TRACEHL1
   printf( "l%05d m_r5order_0e_s() called left=%d top=%d width=%d height=%d\n",
           __LINE__,
           D_ADSL_ORD_CO_1->imc_left, D_ADSL_ORD_CO_1->imc_top,
           D_ADSL_ORD_CO_1->imc_dim_x_2, D_ADSL_ORD_CO_1->imc_dim_y_2 );
#endif
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_1
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_0e_s()                                              */

static BOOL m_r5order_12_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
/* UUUU MISSING 28.12.06 KB */
   return TRUE;
// return FALSE;
} /* end m_r5order_12_s()                                              */

static BOOL m_r5order_13_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml1, iml2, iml3, iml4;       /* working variables       */
   int        iml_r1_left;                  /* rectangle 1 left        */
   int        iml_r1_top;                   /* rectangle 1 top         */
   int        iml_r1_right;                 /* rectangle 1 right       */
   int        iml_r1_bottom;                /* rectangle 1 bottom      */
   int        iml_rf_left;                  /* rectangle foregr left   */
   int        iml_rf_top;                   /* rectangle foregr top    */
   int        iml_rf_right;                 /* rectangle foregr right  */
   int        iml_rf_bottom;                /* rectangle foregr bottom */
   int        iml_pos_glyph;                /* position in glyph - 0 till 8 */
   int        iml_delta_xy;                 /* delta                   */
   char *     achl_pos_glyph;               /* position in glyph - pointer */
   struct dsd_arr_glyph_e *adsl_arr_glyph_e;  /* array of glyph entries */
   struct dsd_glyph *adsl_glyph_w1;
   unsigned short int *ausl_current;        /* current position        */
   unsigned short int *ausl_end_line;       /* end in this line        */
   unsigned short int *ausl_cur_2;          /* current position        */
   signed char chl_shift;                   /* for shift operations    */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSEOCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o13 *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_G (&D_ADSL_RCO1->dsc_ord_co_o13)
#else
   D_ADSL_RSEOCL1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSEOCL1->dsc_rdp_co_1;
   D_ADSL_ORD_CO_G = &D_ADSL_RCO1->dsc_ord_co_o13;
#endif
   adsl_arr_glyph_e = &D_ADSL_RCO1->adsrc_arr_glyph_e[ D_ADSL_RSEOCL1->imc_prot_2 ];  /* array of glyph entries */
   iml_r1_left = D_ADSL_ORD_CO_G->dsc_backrect.isc_left;  /* rectangle 1 left */
   iml_r1_top = D_ADSL_ORD_CO_G->dsc_backrect.isc_top;  /* rectangle 1 top */
   iml_r1_right = D_ADSL_ORD_CO_G->dsc_backrect.isc_right;  /* rectangle 1 right */
   iml_r1_bottom = D_ADSL_ORD_CO_G->dsc_backrect.isc_bottom;  /* rectangle 1 bottom */
   if (((unsigned short int) D_ADSL_ORD_CO_G->isc_start_x) != 0X8000) {
     iml_r1_left = D_ADSL_ORD_CO_G->isc_start_x;  /* rectangle foregr left */
   }
   iml1 = 0;
   while (iml1 < D_ADSL_RSEOCL1->imc_prot_1) {
     /* get Cache Index                                                */
     iml2 = *((unsigned char *) D_ADSL_RSEOCL1->achc_prot_1 + iml1++);
     adsl_glyph_w1 = adsl_arr_glyph_e->adsc_glyph_last;  /* last glyph in chain */
     while ((adsl_glyph_w1) && (adsl_glyph_w1->ucc_char_inc != iml2)) {
       adsl_glyph_w1 = adsl_glyph_w1->adsc_rem_ch_prev;  /* previous in remove chain */
     }
     if (adsl_glyph_w1 == NULL) return FALSE;  /* error occured        */
     achl_pos_glyph = (char *) (adsl_glyph_w1 + 1);
     /* HL-JWT Gly_bnospacingbyte                                      */
     if (((D_ADSL_ORD_CO_G->usc_fdrawing >> 8) & 0X20) == 0) {
       if (*((signed char *) D_ADSL_RSEOCL1->achc_prot_1 + iml1) >= 0) {
         iml_delta_xy = *((unsigned char *) D_ADSL_RSEOCL1->achc_prot_1 + iml1);
         iml1++;
       } else {
         iml_delta_xy = *((unsigned char *) D_ADSL_RSEOCL1->achc_prot_1 + iml1 + 1)
                          | (*((unsigned char *) D_ADSL_RSEOCL1->achc_prot_1 + iml1 + 2) << 8);
         /* sign-extend integer                                        */
         iml_delta_xy <<= 16;
         iml_delta_xy >>= 16;
         iml1 += 3;
       }
       if ((D_ADSL_ORD_CO_G->usc_fdrawing >> 8) & 0X02) {
         iml_r1_left += iml_delta_xy;
       } else {
         iml_r1_top += iml_delta_xy;
       }
     }
     iml_rf_left = iml_r1_left;             /* rectangle foregr left   */
     iml_rf_top = iml_r1_top;               /* rectangle foregr top    */
     iml_rf_right = iml_r1_right;           /* rectangle foregr right  */
     iml_rf_bottom = iml_r1_bottom;         /* rectangle foregr bottom */
     if (((unsigned short int) D_ADSL_ORD_CO_G->isc_start_y) != 0X8000) {
       iml_rf_top = D_ADSL_ORD_CO_G->isc_start_y;
     }
     iml_rf_top += adsl_glyph_w1->usc_y;
     iml4 = iml_rf_top + adsl_glyph_w1->usc_cy;
     if (iml_rf_bottom > iml4) iml_rf_bottom = iml4;
     iml_rf_left += adsl_glyph_w1->usc_x;
//   iml_pos_glyph = 0;                     /* needs new byte          */
     while (iml_rf_top < iml_rf_bottom) {
       ausl_current = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
                        + iml_rf_top * D_ADSL_RCO1->imc_dim_x
                        + iml_rf_left;
       iml3 = iml_rf_right - iml_rf_left;
       if (iml3 > adsl_glyph_w1->usc_cx) {
         iml3 = adsl_glyph_w1->usc_cx;
       }
       ausl_end_line = ausl_current + iml3;
       iml_pos_glyph = 0;                   /* needs new byte          */
       while (ausl_current < ausl_end_line) {
         if (iml_pos_glyph == 0) {          /* needs new byte          */
           chl_shift = *achl_pos_glyph++;   /* get new byte = 8 bits   */
           iml_pos_glyph = 8;               /* position in glyph - 0 till 8 */
         }
         if (chl_shift < 0) {               /* MSB set                 */
           *ausl_current = (unsigned short int) D_ADSL_ORD_CO_G->umc_backcolor;
         }
         ausl_current++;                    /* next position on screen buffer */
         iml_pos_glyph--;                   /* decrement position in glyph - 0 till 8 */
         chl_shift <<= 1;                   /* shift bit out           */
       }
       iml_rf_top++;                        /* this line done          */
     }
   }
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_G
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_13_s()                                              */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.18 Polyline (POLYLINE_ORDER)             */
static BOOL m_r5order_16_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml1, iml2;                   /* working variables       */
   int        iml_num_delta_entries;        /* current number of points along the polyline path */
   int        iml_delta_x, iml_delta_y;     /* delta values            */
   int        iml_po_cur_x, iml_po_cur_y;   /* current points          */
   int        iml_po_pre_x, iml_po_pre_y;   /* previous points         */
   int        iml_error;                    /* error value             */
   struct dsd_rectrb dsl_rect_all;          /* rectangle over all command */
   struct dsd_rectrb dsl_rect_target;       /* target rectangle        */
   unsigned short int *ausl_screen_pos_1, *ausl_screen_pos_2;  /* address of pixel in screen buffer */
   unsigned short int *ausl_screen_pos_s, *ausl_screen_pos_e;  /* address of pixel in screen buffer */
   amd_rop2_x_x aml_rop2_x_x;               /* function ROP2           */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSEOCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o16 *D_ADSL_ORD_CO_O16;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_O16 (&D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o16)
#else
   D_ADSL_RSEOCL1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSEOCL1->dsc_rdp_co_1;
   D_ADSL_ORD_CO_O16 = &D_ADSL_RSEOCL1->dsc_rdp_co_1.dsc_ord_co_o16;
#endif
   printf( "l%05d m_r5order_16_s() called XStart=%d YStart=%d ucc_num_delta_entries=%d\n",
           __LINE__,
           D_ADSL_ORD_CO_O16->isc_xstart, D_ADSL_ORD_CO_O16->isc_ystart,
           D_ADSL_ORD_CO_O16->ucc_num_delta_entries );
   if (D_ADSL_ORD_CO_O16->ucc_num_delta_entries == 0) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_r5order_16_s - D_ADSL_ORD_CO_O16->ucc_num_delta_entries=zero invalid",
                   29784,          /* source line no for errors */
                   __LINE__ );              /* line number for errors  */
     return FALSE;
   }
   if (D_ADSL_ORD_CO_O16->ucc_num_delta_entries > 32) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_r5order_16_s - D_ADSL_ORD_CO_O16->ucc_num_delta_entries=%d invalid",
                   29790,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   D_ADSL_ORD_CO_O16->ucc_num_delta_entries );
     return FALSE;
   }
   dsl_rect_all.isc_left = 0;
   dsl_rect_all.isc_top = 0;
   dsl_rect_all.isc_right = D_ADSL_RCO1->imc_dim_x;
   dsl_rect_all.isc_bottom = D_ADSL_RCO1->imc_dim_y;
   /* apply bounds                                                     */
   if (D_ADSL_RSEOCL1->ucc_order_flags_1 & 0X04) {
     if (D_ADSL_RCO1->imc_bounds_left > 0) {
       dsl_rect_all.isc_left = D_ADSL_RCO1->imc_bounds_left;
     }
     if (D_ADSL_RCO1->imc_bounds_top > 0) {
       dsl_rect_all.isc_top = D_ADSL_RCO1->imc_bounds_top;
     }
     iml1 = D_ADSL_RCO1->imc_bounds_right + 1;
     if (iml1 < D_ADSL_RCO1->imc_dim_x) {
       dsl_rect_all.isc_right = iml1;
     }
     iml1 = D_ADSL_RCO1->imc_bounds_bottom + 1;
     if (iml1 < D_ADSL_RCO1->imc_dim_y) {
       dsl_rect_all.isc_bottom = iml1;
     }
   }
   aml_rop2_x_x = dsrs_progaddr_1[ 1 ].amrc_rop2_x_x[ ((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) - 1 ];
   iml_num_delta_entries = 0;               /* current number of points along the polyline path */
   iml_po_pre_x = D_ADSL_ORD_CO_O16->isc_xstart;
   iml_po_pre_y = D_ADSL_ORD_CO_O16->isc_ystart;
   iml_po_cur_x = ((struct dsd_short_point *) D_ADSL_RSEOCL1->achc_prot_1)->isc_x;
   iml_po_cur_y = ((struct dsd_short_point *) D_ADSL_RSEOCL1->achc_prot_1)->isc_y;

   p_li_start:                              /* start the line          */
   memcpy( &dsl_rect_target, &dsl_rect_all, sizeof(struct dsd_rectrb) );
   iml_delta_x = iml_po_cur_x - iml_po_pre_x;
   if (iml_delta_x == 0) goto p_li_vert_00;  /* draw vertical line     */
   iml_delta_y = iml_po_cur_y - iml_po_pre_y;
   if (iml_delta_y == 0) goto p_li_hori_00;  /* draw horizontal line   */
   if (iml_delta_x < 0) goto p_li_rile_00;   /* from right to left      */
   if (iml_delta_y < 0) goto p_li_lebo_00;   /* from left bottom to right top */
   if (iml_delta_x < iml_delta_y) goto p_li_leto_y_00;  /* starts left top, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = iml_po_pre_y;
   if (dsl_rect_target.isc_left > iml_po_pre_x) {
     iml_error -= (dsl_rect_target.isc_left - iml_po_pre_x) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_left = iml_po_pre_x;
   }
   if (dsl_rect_target.isc_top > iml1) {
     iml2 = ((dsl_rect_target.isc_top - iml1) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_left += iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_top = iml1;
   }
   if (dsl_rect_target.isc_right > iml_po_cur_x) {
     dsl_rect_target.isc_right = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_bottom > iml_po_cur_y) {
     dsl_rect_target.isc_bottom = iml_po_cur_y + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_leto_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_left;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   goto p_li_end;

   p_li_leto_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_left) = D_ADSL_ORD_CO_O16->umc_pencolor;
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   goto p_li_end;

   p_li_leto_y_00:                          /* starts left top, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = iml_po_pre_x;
   if (dsl_rect_target.isc_top > iml_po_pre_y) {
     iml_error -= (dsl_rect_target.isc_top - iml_po_pre_y) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_top = iml_po_pre_y;
   }
   if (dsl_rect_target.isc_left > iml1) {
     iml2 = ((dsl_rect_target.isc_left - iml1) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_left = iml1;
   }
   if (dsl_rect_target.isc_right > iml_po_cur_x) {
     dsl_rect_target.isc_right = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_bottom > iml_po_cur_y) {
     dsl_rect_target.isc_bottom = iml_po_cur_y + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_left;        /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_leto_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   goto p_li_end;

   p_li_leto_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   goto p_li_end;

   p_li_lebo_00:                            /* from left bottom to right top */
   iml_delta_y = iml_po_pre_y - iml_po_cur_y;
   if (iml_delta_x < iml_delta_y) goto p_li_lebo_y_00;  /* starts left bottom, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = iml_po_pre_y;
   if (dsl_rect_target.isc_left > iml_po_pre_x) {
     iml_error -= (dsl_rect_target.isc_left - iml_po_pre_x) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_left = iml_po_pre_x;
   }
   if (dsl_rect_target.isc_bottom < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_bottom) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_left += iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_bottom = iml1;
   }
   if (dsl_rect_target.isc_right > iml_po_cur_x) {
     dsl_rect_target.isc_right = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_top < iml_po_cur_y) {
     dsl_rect_target.isc_top = iml_po_cur_y;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_lebo_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_left;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     dsl_rect_target.isc_left++;            /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   goto p_li_end;

   p_li_lebo_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_left) = D_ADSL_ORD_CO_O16->umc_pencolor;
     iml1++;                                /* next x position         */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_left < dsl_rect_target.isc_right);
   goto p_li_end;

   p_li_lebo_y_00:                          /* starts left bottom, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = iml_po_pre_x;
   if (dsl_rect_target.isc_bottom < iml_po_cur_y) {
     iml_error -= (iml_po_pre_y - dsl_rect_target.isc_bottom) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_bottom = iml_po_cur_y;
   }
   if (dsl_rect_target.isc_left > iml1) {
     iml2 = ((dsl_rect_target.isc_left - iml1) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_left = iml1;
   }
   if (dsl_rect_target.isc_right > iml_po_cur_x) {
     dsl_rect_target.isc_right = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_top < iml_po_cur_y) {
     dsl_rect_target.isc_top = iml_po_cur_y;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_left;        /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_leto_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   goto p_li_end;

   p_li_lebo_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1++;                 /* next x position         */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   goto p_li_end;

   p_li_rile_00:                            /* from right to left      */
   iml_delta_x = iml_po_pre_x - iml_po_cur_x;
   if (iml_delta_y < 0) goto p_li_ribo_00;  /* starts right bottom     */
   if (iml_delta_x < iml_delta_y) goto p_li_rito_y_00;  /* starts right top, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = iml_po_pre_y;
   if (dsl_rect_target.isc_right < iml_po_pre_x) {
     iml_error -= (iml_po_pre_x - dsl_rect_target.isc_right) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_right = iml_po_pre_x;
   }
   if (dsl_rect_target.isc_top > iml1) {
     iml2 = ((dsl_rect_target.isc_top - iml1) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_right -= iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_top = iml1;
   }
   if (dsl_rect_target.isc_left < iml_po_cur_x) {
     dsl_rect_target.isc_left = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_bottom > iml_po_cur_y) {
     dsl_rect_target.isc_bottom = iml_po_cur_y + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_rito_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_right;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   goto p_li_end;

   p_li_rito_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_right) = D_ADSL_ORD_CO_O16->umc_pencolor;
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line */
       if (ausl_screen_pos_1 >= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   goto p_li_end;

   p_li_rito_y_00:                          /* starts right top, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = iml_po_pre_x;
   if (dsl_rect_target.isc_top > iml_po_pre_y) {
     iml_error -= (dsl_rect_target.isc_top - iml_po_pre_y) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 -= iml2;
   } else {
     dsl_rect_target.isc_top = iml_po_pre_y;
   }
   if (dsl_rect_target.isc_right < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_right) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_top += iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_right = iml1;
   }
   if (dsl_rect_target.isc_left < iml_po_cur_x) {
     dsl_rect_target.isc_left = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_bottom > iml_po_cur_y) {
     dsl_rect_target.isc_bottom = iml_po_cur_y + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_right;       /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_rito_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   goto p_li_end;

   p_li_rito_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 < ausl_screen_pos_e);
   goto p_li_end;

   p_li_ribo_00:                            /* starts right bottom     */
   iml_delta_y = iml_po_pre_y - iml_po_cur_y;
   if (iml_delta_x < iml_delta_y) goto p_li_ribo_y_00;  /* starts right bottom, y greater */
   iml_error = iml_delta_x >> 1;            /* error value             */
   iml1 = iml_po_pre_y;
   if (dsl_rect_target.isc_right < iml_po_pre_x) {
     iml_error -= (iml_po_pre_x - dsl_rect_target.isc_right) * iml_delta_y;
     iml2 = iml_error / iml_delta_x - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_x;
     iml1 += iml2;
   } else {
     dsl_rect_target.isc_right = iml_po_pre_x;
   }
   if (dsl_rect_target.isc_bottom < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_bottom) * iml_delta_x) / iml_delta_y;
     dsl_rect_target.isc_right -= iml2;
     iml_error -= iml2 * iml_delta_y;
     iml_error %= iml_delta_x;
     iml_error += iml_delta_x;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_bottom = iml1;
   }
   if (dsl_rect_target.isc_left < iml_po_cur_x) {
     dsl_rect_target.isc_left = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_bottom > iml_po_cur_y) {
     dsl_rect_target.isc_bottom = iml_po_cur_y + 1;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_ribo_x_20;
   do {                                     /* loop to draw pixels     */
     ausl_screen_pos_2 = ausl_screen_pos_1 + dsl_rect_target.isc_right;
     *ausl_screen_pos_2 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_2,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   goto p_li_end;

   p_li_ribo_x_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *(ausl_screen_pos_1 + dsl_rect_target.isc_right) = D_ADSL_ORD_CO_O16->umc_pencolor;
     dsl_rect_target.isc_right--;           /* previous x position     */
     iml_error -= iml_delta_y;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
       if (ausl_screen_pos_1 <= ausl_screen_pos_e) break;
       iml_error += iml_delta_x;            /* error value             */
     }
   } while (dsl_rect_target.isc_right > dsl_rect_target.isc_left);
   goto p_li_end;

   p_li_ribo_y_00:                          /* starts right bottom, y greater */
   iml_error = iml_delta_y >> 1;            /* error value             */
   iml1 = iml_po_pre_x;
   if (dsl_rect_target.isc_bottom < iml_po_pre_y) {
     iml_error -= (iml_po_pre_y - dsl_rect_target.isc_bottom) * iml_delta_x;
     iml2 = iml_error / iml_delta_y - 1;    /* value is still negative */
     iml_error -= iml2 * iml_delta_y;
     iml1 += iml2;
   } else {
     dsl_rect_target.isc_bottom = iml_po_pre_y;
   }
   if (dsl_rect_target.isc_right < iml1) {
     iml2 = ((iml1 - dsl_rect_target.isc_right) * iml_delta_y) / iml_delta_x;
     dsl_rect_target.isc_bottom -= iml2;
     iml_error -= iml2 * iml_delta_x;
     iml_error %= iml_delta_y;
     iml_error += iml_delta_y;              /* error gets positive again */
   } else {
     dsl_rect_target.isc_right = iml1;
   }
   if (dsl_rect_target.isc_left < iml_po_cur_x) {
     dsl_rect_target.isc_left = iml_po_cur_x;
   }
   if (dsl_rect_target.isc_left > dsl_rect_target.isc_right) goto p_li_end;
   if (dsl_rect_target.isc_top < iml_po_cur_y) {
     dsl_rect_target.isc_top = iml_po_cur_y;
   }
   if (dsl_rect_target.isc_top > dsl_rect_target.isc_bottom) goto p_li_end;
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x
         + dsl_rect_target.isc_right;       /* address of pixel in screen buffer */
   ausl_screen_pos_e
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x;  /* address of pixel in screen buffer */
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_ribo_y_20;
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   goto p_li_end;

   p_li_ribo_y_20:                          /* set only pen            */
   do {                                     /* loop to draw pixels     */
     *ausl_screen_pos_1 = D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1 -= D_ADSL_RCO1->imc_dim_x;  /* go to previous line */
     iml_error -= iml_delta_x;              /* error value             */
     if (iml_error < 0) {
       ausl_screen_pos_1--;                 /* previous x position     */
       iml_error += iml_delta_y;            /* error value             */
     }
   } while (ausl_screen_pos_1 > ausl_screen_pos_e);
   goto p_li_end;

   p_li_vert_00:                            /* draw vertical line      */
   if (iml_po_pre_x < dsl_rect_target.isc_left) goto p_li_end;
   if (iml_po_pre_x >= dsl_rect_target.isc_right) goto p_li_end;
   iml1 = iml_po_pre_y;                    /* get y start             */
   iml2 = iml_po_cur_y;                    /* get y end               */
   if (iml1 > iml2) {                       /* from bottom to top      */
     iml1 = iml_po_cur_y + 1;              /* get y end               */
     iml2 = iml_po_pre_y + 1;              /* get y start             */
   }
   if (iml1 < dsl_rect_target.isc_top) iml1 = dsl_rect_target.isc_top;
   if (iml2 > dsl_rect_target.isc_bottom) iml2 = dsl_rect_target.isc_bottom;
   if (iml1 > iml2) goto p_li_end;            /* nothing to draw         */
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + iml_po_pre_x
         + iml1 * D_ADSL_RCO1->imc_dim_x;   /* address of pixel in screen buffer */
   ausl_screen_pos_2 = ausl_screen_pos_1 + (iml2 - iml1) * D_ADSL_RCO1->imc_dim_x;
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_vert_20;
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   goto p_li_end;

   p_li_vert_20:                            /* set only pen            */
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1 += D_ADSL_RCO1->imc_dim_x;  /* go to next line  */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   goto p_li_end;

   p_li_hori_00:                            /* draw horizontal line    */
   if (iml_po_pre_y < dsl_rect_target.isc_top) goto p_li_end;
   if (iml_po_pre_y >= dsl_rect_target.isc_bottom) goto p_li_end;
   iml1 = iml_po_pre_x;                    /* get x start             */
   iml2 = iml_po_cur_x;                    /* get x end               */
   if (iml1 > iml2) {                       /* from right to left      */
     iml1 = iml_po_cur_x + 1;              /* get x end               */
     iml2 = iml_po_pre_x + 1;              /* get x start             */
   }
   if (iml1 < dsl_rect_target.isc_left) iml1 = dsl_rect_target.isc_left;
   if (iml2 > dsl_rect_target.isc_right) iml2 = dsl_rect_target.isc_right;
   if (iml1 > iml2) goto p_li_end;           /* nothing to draw         */
   ausl_screen_pos_1
     = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
         + iml_po_pre_y * D_ADSL_RCO1->imc_dim_x
         + iml1;                            /* address of pixel in screen buffer */
   ausl_screen_pos_2 = ausl_screen_pos_1 + iml2 - iml1;
   if (((unsigned char) D_ADSL_ORD_CO_O16->ucc_brop2) == 0X0D) goto p_li_hori_20;
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) aml_rop2_x_x( *ausl_screen_pos_1,
                                                             D_ADSL_ORD_CO_O16->umc_pencolor );
     ausl_screen_pos_1++;                   /* go to next pixel        */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);
   goto p_li_end;

   p_li_hori_20:                            /* set only pen            */
   do {                                     /* loop to draw the line   */
     *ausl_screen_pos_1 = (unsigned short int) D_ADSL_ORD_CO_O16->umc_pencolor;
     ausl_screen_pos_1++;                   /* go to next pixel        */
   } while (ausl_screen_pos_1 < ausl_screen_pos_2);

   p_li_end:                                /* end of line             */
   iml_num_delta_entries++;                 /* current number of points along the polyline path */
   if (iml_num_delta_entries >= D_ADSL_ORD_CO_O16->ucc_num_delta_entries) return TRUE;
   iml_po_pre_x = iml_po_cur_x;             /* get previous coordinate */
   iml_po_pre_y = iml_po_cur_y;             /* get previous coordinate */
   iml_po_cur_x = ((struct dsd_short_point *) D_ADSL_RSEOCL1->achc_prot_1 + iml_num_delta_entries)->isc_x;
   iml_po_cur_y = ((struct dsd_short_point *) D_ADSL_RSEOCL1->achc_prot_1 + iml_num_delta_entries)->isc_y;
   goto p_li_start;                         /* start the line          */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_O16
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_16_s()                                              */

static BOOL m_r5order_18_s( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            char *achp_work_area ) {
   int        iml1, iml2, iml3, iml4;       /* working variables       */
   int        iml_r1_left;                  /* rectangle 1 left        */
   int        iml_r1_top;                   /* rectangle 1 top         */
   int        iml_r1_right;                 /* rectangle 1 right       */
   int        iml_r1_bottom;                /* rectangle 1 bottom      */
   int        iml_rf_left;                  /* rectangle foregr left   */
   int        iml_rf_top;                   /* rectangle foregr top    */
   int        iml_rf_right;                 /* rectangle foregr right  */
   int        iml_rf_bottom;                /* rectangle foregr bottom */
   int        iml_pos_glyph;                /* position in glyph - 0 till 8 */
   char *     achl_pos_glyph;               /* position in glyph - pointer */
   struct dsd_glyph *adsl_glyph_w1;
   unsigned short int *ausl_current;        /* current position        */
   unsigned short int *ausl_end_line;       /* end in this line        */
   unsigned short int *ausl_cur_2;          /* current position        */
   signed char chl_shift;                   /* for shift operations    */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSEOCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
   struct dsd_ord_co_o18 *D_ADSL_ORD_CO_G;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSEOCL1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSEOCL1->dsc_rdp_co_1)
#define D_ADSL_ORD_CO_G (&D_ADSL_RCO1->dsc_ord_co_o18)
#else
   D_ADSL_RSEOCL1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSEOCL1->dsc_rdp_co_1;
   D_ADSL_ORD_CO_G = &D_ADSL_RCO1->dsc_ord_co_o18;
#endif
   adsl_glyph_w1 = (struct dsd_glyph *) D_ADSL_RSEOCL1->achc_prot_1;  /* pass parameter */
   iml_r1_left = D_ADSL_ORD_CO_G->dsc_backrect.isc_left;  /* rectangle 1 left */
   iml_r1_top = D_ADSL_ORD_CO_G->dsc_backrect.isc_top;  /* rectangle 1 top */
   iml_r1_right = D_ADSL_ORD_CO_G->dsc_backrect.isc_right;  /* rectangle 1 right */
   iml_r1_bottom = D_ADSL_ORD_CO_G->dsc_backrect.isc_bottom;  /* rectangle 1 bottom */
   ausl_current = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
                    + iml_r1_top * D_ADSL_RCO1->imc_dim_x
                    + iml_r1_left;
   ausl_cur_2 = ausl_current;
   iml1 = iml_r1_right - iml_r1_left;
   ausl_end_line = ausl_current + iml1;
// to-do 02.01.10 KB draw background - or not ???
   iml1 = 0;
   achl_pos_glyph = (char *) (adsl_glyph_w1 + 1);
   iml_rf_left = iml_r1_left;             /* rectangle foregr left   */
   iml_rf_top = iml_r1_top;               /* rectangle foregr top    */
   iml_rf_right = iml_r1_right;           /* rectangle foregr right  */
   iml_rf_bottom = iml_r1_bottom;         /* rectangle foregr bottom */
   if (((unsigned short int) D_ADSL_ORD_CO_G->isc_start_x) != 0X8000) {
     iml_rf_left = D_ADSL_ORD_CO_G->isc_start_x;  /* rectangle foregr left */
   }
   if (((unsigned short int) D_ADSL_ORD_CO_G->isc_start_y) != 0X8000) {
     iml_rf_top = D_ADSL_ORD_CO_G->isc_start_y;
   }
   iml_rf_left += adsl_glyph_w1->usc_x;
   iml_rf_top += adsl_glyph_w1->usc_y;
   iml4 = iml_rf_top + adsl_glyph_w1->usc_cy;
   if (iml_rf_bottom > iml4) iml_rf_bottom = iml4;
// iml_pos_glyph = 0;                     /* needs new byte          */
   while (iml_rf_top < iml_rf_bottom) {
     ausl_current = (unsigned short int *) ADSL_RDPA_F->ac_screen_buffer
                      + iml_rf_top * D_ADSL_RCO1->imc_dim_x
                      + iml_rf_left;
     iml3 = iml_rf_right - iml_rf_left;
     if (iml3 > adsl_glyph_w1->usc_cx) {
       iml3 = adsl_glyph_w1->usc_cx;
     }
     ausl_end_line = ausl_current + iml3;
     iml_pos_glyph = 0;                   /* needs new byte          */
     while (ausl_current < ausl_end_line) {
       if (iml_pos_glyph == 0) {          /* needs new byte          */
         chl_shift = *achl_pos_glyph++;   /* get new byte = 8 bits   */
         iml_pos_glyph = 8;               /* position in glyph - 0 till 8 */
       }
       if (chl_shift < 0) {               /* MSB set                 */
         *ausl_current = (unsigned short int) D_ADSL_ORD_CO_G->umc_backcolor;
       }
       ausl_current++;                    /* next position on screen buffer */
       iml_pos_glyph--;                   /* decrement position in glyph - 0 till 8 */
       chl_shift <<= 1;                   /* shift bit out           */
     }
     iml_rf_top++;                        /* this line done          */
   }
   return TRUE;
// return FALSE;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_ORD_CO_1
#undef D_ADSL_RSEOCL1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_r5order_18_s()                                              */


/* check the hash of RDP5-style input                                  */
static BOOL m_check_hash_inp_rdp5( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                   char *achp_data, int imp_len_data ) {
// int        iml1;                         /* working-variables       */
   int        imrl_sha1_state[ SHA_ARRAY_SIZE ];  /* SHA1 state array  */
   int        imrl_md5_state[ MD5_ARRAY_SIZE ];  /* MD5 state array    */
   char       chrl_work1[20];               /* work-area               */
// int        imrl_sha1_array[ 24 ];
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
// ADSL_OA1 = adsp_output_area_1;
#endif
   /* first, do SHA1                                                   */
   memcpy( imrl_sha1_state, D_ADSL_RCO1->imrc_sha1_state, sizeof(D_ADSL_RCO1->imrc_sha1_state) );
   m_put_le4( chrl_work1, imp_len_data );
   SHA1_Update( imrl_sha1_state, chrl_work1, 0, sizeof(int) );
   SHA1_Update( imrl_sha1_state, achp_data, 0, imp_len_data );
   if (D_ADSL_RSE1->chc_prot_rt03) {        /* flag for block count    */
     m_put_le4( chrl_work1, D_ADSL_RCO1->dsc_encry_cl2se.imc_count_sent );
     SHA1_Update( imrl_sha1_state, chrl_work1, 0, sizeof(int) );
   }
   SHA1_Final( imrl_sha1_state, chrl_work1, 0 );
   /* second, do MD5                                                   */
   memcpy( imrl_md5_state, D_ADSL_RCO1->imrc_md5_state, sizeof(D_ADSL_RCO1->imrc_md5_state) );
   MD5_Update( imrl_md5_state, chrl_work1, 0, 20 );
   MD5_Final( imrl_md5_state, chrl_work1, 0 );
   if (!memcmp( chrl_work1, D_ADSL_RSE1->chrc_inp_hash, sizeof(D_ADSL_RSE1->chrc_inp_hash) )) {
     return TRUE;
   }
   printf( "l%05d s%05d m_check_hash_inp_rdp5() hash invalid\n",
           __LINE__, 31396 );
   return FALSE;
#ifdef OLD01
// SHA1_Init( imrl_sha1_array );
// SHA1_Update( imrl_sha1_array, D_ADSL_RCO1->chrc_sig, 0, sizeof(D_ADSL_RCO1->chrc_sig) );
   SHA1_Update( imrl_sha1_array, ACHL_PRE_HASH, 0, 16 * 3 );
   SHA1_Update( imrl_sha1_array, achp_client_random, 0, 32 );
   SHA1_Update( imrl_sha1_array, ADSL_RDPA_F->chrl_server_random, 0, 32 );
   SHA1_Final( imrl_sha1_array, ACHL_SHA_DIG, 0 );
   MD5_Init( ACHL_MD5_ARRAY );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_PRE_HASH, 0, 16 * 3 );
   MD5_Update( ACHL_MD5_ARRAY, ACHL_SHA_DIG, 0, 20 );
   MD5_Final( ACHL_MD5_ARRAY, ACHL_MASTER_H_3, 0 );
   return TRUE;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_check_hash_inp_rdp5()                                       */

/* RDP5-style event from client                                        */
static BOOL m_send_cl_event_rdp5( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  char *achp_data, int imp_len_data,
                                  int imp_no_order ) {
   char       *achl_pos_i;                  /* position input          */
   char       *achl_pos_n;                  /* position next           */
   char       *achl_end;                    /* end input               */
   char       chl1; 
   int        iml_c_order;                  /* count orders            */
   char        *ach_w2_tmp;
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
// struct dsd_rdp_client_1 *D_ADSL_RCL1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* RDP communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_cl_event_rdp5() send len=%d ADSL_OA1->achc_w1=%p ADSL_OA1->achc_w2=%p\n",
           __LINE__, 32418, imp_len_data, ADSL_OA1->achc_w1, ADSL_OA1->achc_w2 );
   m_console_out( achp_data, imp_len_data );
#endif
   iml_c_order = 0;                         /* reset count orders      */
   achl_pos_n = achp_data;
   achl_end = achp_data + imp_len_data;     /* end input               */

   // parse second numberEvents-field, if first one is zero.
   if(imp_no_order == 0) {
      if (achl_pos_n >= achl_end) return FALSE;
      // JB 21.01.2013: Error, found by KB, see Mail from today. 
      imp_no_order = *((unsigned char *) achl_pos_n);
      achl_pos_n++;
   }

   p_inp_20:                                /* next order              */
// to-do 07.04.10 KB + JB compare imp_no_order and iml_c_order
   if (achl_pos_n >= achl_end) return TRUE;
   achl_pos_i = achl_pos_n;                 /* position input          */
   achl_pos_n++;                            /* minimum length          */
   if (achl_pos_n > achl_end) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid length received",
                   __LINE__, 32452 );  /* line number for errors */
     return FALSE;
   }
   iml_c_order++;                           /* increment count orders  */
   // Check, if enough space on workarea
   union dsd_cl_events_all {
      struct dsd_cl_keyb_eve dsc_keyb_eve;
      struct dsd_cl_sync_eve dsc_sync_eve;
      struct dsd_cl_mouse_eve dsc_mouse_eve;
      struct dsd_cl_unicode_eve dsc_unicode_eve;
   };
   ach_w2_tmp = ADSL_OA1->achc_w2 - (sizeof(struct dsd_cl_co1) + sizeof(union dsd_cl_events_all));
   ach_w2_tmp = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
   if (ach_w2_tmp < ADSL_OA1->achc_w1) {
      struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
      /* needs more buffers                                             */
      memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
      BOOL bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                              DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                              &dsl_aux_get_workarea,
                                              sizeof(struct dsd_aux_get_workarea) );
      if (bol1 == FALSE) return FALSE;       /* aux returned error      */
      char* al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
      ADSL_OA1->achc_w1 = al_buffer_1;
      ADSL_OA1->achc_w2 = al_buffer_1 + dsl_aux_get_workarea.imc_len_work_area;
   }   
   // [MS-RDPBCGR].pdf 2.2.8.1.2.2 Fast-Path Input Event (TS_FP_INPUT_EVENT)
   // JB 21.03.12: Change for events was necessary, as session crashed in SE-meeting today,
   // when one of the extended mouse-keys was pressed. 
   switch((*achl_pos_i >> 5) & 0x7){
     case 0: goto p_inp_scancode;           /* FASTPATH_INPUT_EVENT_SCANCODE */
     case 1: goto p_inp_mouse;              /* FASTPATH_INPUT_EVENT_MOUSE */
     case 2: goto p_inp_mousex;             /* FASTPATH_INPUT_EVENT_MOUSEX */
     case 3: goto p_inp_sync;               /* FASTPATH_INPUT_EVENT_SYNC */
     case 4: goto p_inp_unicode;            /* FASTPATH_INPUT_EVENT_UNICODE */
     default: 
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid fastpath inputevent ",
                     __LINE__, 32489, *achl_pos_i >> 5 );  /* line number for errors */
     return FALSE;
   }
p_inp_scancode: 
   // [MS-RDPBCGR].pdf 2.2.8.1.1.3.1.1.1 Keyboard Event (TS_KEYBOARD_EVENT)
   achl_pos_n++;                            /* minimum length          */
   if (achl_pos_n > achl_end) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid length received",
                   __LINE__, 32498 );  /* line number for errors */
     return FALSE;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_keyb_eve);
   ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32506 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_keyb_eve) );
   ADSL_CL_CO1->iec_cl_command = ied_clc_key_ud;  /* key up or down    */
#define ADSL_CL_KEYB_EVE_G ((struct dsd_cl_keyb_eve *) (ADSL_CL_CO1 + 1))
   ADSL_CL_KEYB_EVE_G->ucc_keyboard_status = D_ADSL_RCO1->ucc_keyboard_status;  /* last keyboard status */
   ADSL_CL_KEYB_EVE_G->chc_flags = *((unsigned char *) achl_pos_i + 0);  /* flags */
   ADSL_CL_KEYB_EVE_G->chc_keycode = *((unsigned char *) achl_pos_i + 1);  /* key code */
   if ((ADSL_CL_KEYB_EVE_G->chc_flags & 1) == 0) {  /* only change state, when lock-keys are pressed down */
     switch (ADSL_CL_KEYB_EVE_G->chc_keycode) {
      case 0X3A:                            /* caps lock               */
        D_ADSL_RCO1->ucc_keyboard_status ^= 0X04;
        break;
      case 0X45:                            /* num lock                */
        D_ADSL_RCO1->ucc_keyboard_status ^= 0X02;
        break;
      case 0X46:                            /* scroll lock             */
        D_ADSL_RCO1->ucc_keyboard_status ^= 0X01;
        break;
     }
   }
#undef ADSL_CL_KEYB_EVE_G
   if (ADSL_OA1->adsc_cl_co1 == NULL) {
     adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
   } else {
     ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
   }
   ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;     /* save last in chain      */
   goto p_inp_20;                           /* next order              */
#undef ADSL_CL_CO1

   p_inp_sync:                              /* mouse event             */
   // [MS-RDPBCGR].pdf 2.2.8.1.1.3.1.1.5 Synchronize Event (TS_SYNC_EVENT)
     D_ADSL_RCO1->ucc_keyboard_status = *achl_pos_i & 0X1F;  /* last keyboard status */
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_sync_eve);
     ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                     __LINE__, 32559 );  /* line number for errors */
       return FALSE;
     }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
     memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_sync_eve) );
     ADSL_CL_CO1->iec_cl_command = ied_clc_sync;  /* mouse event        */
     ((struct dsd_cl_sync_eve *) (ADSL_CL_CO1 + 1))->chc_flags = *achl_pos_i & 0X1F;  /* last keyboard status */

     if (ADSL_OA1->adsc_cl_co1 == NULL) {
       adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
     } else {
       ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
     }
#undef ADSL_CL_CO1
     achl_pos_n = achl_pos_i + 1;           /* end of this command     */
     goto p_inp_20;                         /* next order              */

p_inp_mouse: 
   // [MS-RDPBCGR].pdf 2.2.8.1.1.3.1.1.3 Mouse Event (TS_POINTER_EVENT)
   achl_pos_n += 6;                         /* minimum length          */
   if (achl_pos_n > achl_end) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid length mouse-event",
                   __LINE__, 32587 );  /* line number for errors */
     return FALSE;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_mouse_eve);
   ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32594 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_mouse_eve) );
   ADSL_CL_CO1->iec_cl_command = ied_clc_mouse;  /* mouse event        */
#define ADSL_CL_MEVE ((struct dsd_cl_mouse_eve *) (ADSL_CL_CO1 + 1))
   ADSL_CL_MEVE->chc_flags = *(achl_pos_i + 2);  /* flags              */
   ADSL_CL_MEVE->isc_coord_x = m_get_le2( achl_pos_i + 3 );  /* x coordinate */
   ADSL_CL_MEVE->isc_coord_y = m_get_le2( achl_pos_i + 5 );  /* y coordinate */
   if (ADSL_OA1->adsc_cl_co1 == NULL) {
     adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
   } else {
     ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
   }
   ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;     /* save last in chain      */

   // new button flags, which can also be used for ext-button 1 and 2
   chl1 = *(achl_pos_i + 2);
   if(chl1 & 0x2){                         /* mouse wheel              */
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_wheel;
     ADSL_CL_MEVE->boc_button_pressed = ((chl1 & 0x1) != 0);
     ADSL_CL_MEVE->isc_mousewheel_value = ((m_get_le2(achl_pos_i + 1) & 0x1ff) << 23 ) >> 23;
     goto p_inp_20;                           /* next order              */
   }
   ADSL_CL_MEVE->boc_button_pressed = ((chl1 & 0x80) != 0);
   if(chl1 & 0x10){
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_button_left;
     goto p_inp_20;                           /* next order              */
   }
   if(chl1 & 0x20){
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_button_right;
     goto p_inp_20;                           /* next order              */
   }
   if(chl1 & 0x40){
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_button_middle;
     goto p_inp_20;                           /* next order              */
   }
   ADSL_CL_MEVE->iec_type = ied_cl_mouse_moved;
   goto p_inp_20;                           /* next order              */
#undef ADSL_CL_CO1

p_inp_mousex:
   // [MS-RDPBCGR].pdf 2.2.8.1.1.3.1.1.4 Extended Mouse Event (TS_POINTERX_EVENT)

   achl_pos_n += 6;                         /* minimum length          */
   if (achl_pos_n > achl_end) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid length mouse-event",
                   __LINE__, 32642 );  /* line number for errors */
     return FALSE;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_mouse_eve);
   ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32649 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_mouse_eve) );
   ADSL_CL_CO1->iec_cl_command = ied_clc_mouse;  /* mouse event        */
   ADSL_CL_MEVE->boc_button_pressed = ((*(achl_pos_i + 2) & 0x80) != 0);
   if(*(achl_pos_i + 1) & 0x01){
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_button_x1;
   } else if(*(achl_pos_i + 1) & 0x02){
     ADSL_CL_MEVE->iec_type = ied_cl_mouse_button_x2;
   }
   ADSL_CL_MEVE->isc_coord_x = m_get_le2( achl_pos_i + 3 );  /* x coordinate */
   ADSL_CL_MEVE->isc_coord_y = m_get_le2( achl_pos_i + 5 );  /* y coordinate */
   if (ADSL_OA1->adsc_cl_co1 == NULL) {
     adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
   } else {
     ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
   }
   ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;     /* save last in chain      */
   goto p_inp_20;                           /* next order              */
#undef ADSL_CL_CO1

p_inp_unicode:
   // [MS-RDPBCGR].pdf 2.2.8.1.1.3.1.1.2 Unicode Keyboard Event (TS_UNICODE_KEYBOARD_EVENT)
   achl_pos_n += 2;                         /* minimum length          */
   if (achl_pos_n > achl_end) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_cl_event_rdp5() invalid length mouse-event",
                   __LINE__, 32677 );  /* line number for errors */
     return FALSE;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_unicode_eve);
   ADSL_OA1->achc_w2 = (char *) (((long long int) ADSL_OA1->achc_w2) & (0 - sizeof(void *)));
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32684 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_CL_CO1 ((struct dsd_cl_co1 *) ADSL_OA1->achc_w2)
   memset( ADSL_OA1->achc_w2, 0, sizeof(struct dsd_cl_co1) + sizeof(struct dsd_cl_unicode_eve) );
   ADSL_CL_CO1->iec_cl_command = ied_clc_unicode;  /* unicode event        */
   ((struct dsd_cl_unicode_eve *) (ADSL_CL_CO1 + 1))->usc_unicode = 
     m_get_le2(achl_pos_i + 1);
   if (ADSL_OA1->adsc_cl_co1 == NULL) {
     adsp_hl_clib_1->adsc_cl_co1_ch = ADSL_CL_CO1;
   } else {
     ADSL_OA1->adsc_cl_co1->adsc_next = ADSL_CL_CO1;
   }
   ADSL_OA1->adsc_cl_co1 = ADSL_CL_CO1;     /* save last in chain      */
   goto p_inp_20;                           /* next order              */

#undef ADSL_CL_MEVE
#undef ADSL_CL_CO1
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_cl_event_rdp5()                                        */
static void m_send_se2cl_r01( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                              struct dsd_output_area_1 *adsp_output_area_1 ) {
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication cli   */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RCL1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_se2cl_r01() ADSL_OA1->achc_w1=%p ADSL_OA1->achc_w2=%p\n",
           __LINE__, 32736, ADSL_OA1->achc_w1, ADSL_OA1->achc_w2 );
#endif
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     printf( "output-area too small\n" );
#ifndef HL_UNIX
     ExitProcess( 1 );
#else
     exit( 1 );
#endif
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = (char *) ucrs_secl_01;
   ADSL_GAI1_OUT_G->achc_ginp_end = (char *) ucrs_secl_01 + sizeof(ucrs_secl_01);
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_r01()                                            */

static BOOL m_send_se2cl_after_logon( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1 ) {
   char       *achl_out_p;                  /* position output         */
   char       *achl_out_s1;                 /* save output position    */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_se2cl_after_logon() ADSL_OA1->achc_w1=%p ADSL_OA1->achc_w2=%p\n",
           __LINE__, 32798, ADSL_OA1->achc_w1, ADSL_OA1->achc_w2 );
#endif
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32811 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   *ADSL_OA1->achc_w1++ = 4 + sizeof(ucrs_after_logon_01);  /* size of following part */
   *ADSL_OA1->achc_w1++ = 0X80;             /* record type 2           */
   *ADSL_OA1->achc_w1++ = 0X00;             /* record type 3           */
   *ADSL_OA1->achc_w1++ = 0X10;             /* padding                 */
   *ADSL_OA1->achc_w1++ = 0X00;             /* padding                 */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_s1 + 0) = 4 + D_SIZE_HASH + sizeof(ucrs_after_logon_01);  /* size of following part */
     *(achl_out_s1 + 1) = 0X88;             /* output encrypted        */
     *(achl_out_s1 + 3) = 0X00;             /* padding                 */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   memcpy( ADSL_OA1->achc_w1,
           ucrs_after_logon_01,
           sizeof(ucrs_after_logon_01) );
   ADSL_OA1->achc_w1 += sizeof(ucrs_after_logon_01);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, sizeof(ucrs_after_logon_01) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_after_logon_01) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_after_logon_01), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2,
              ADSL_OA1->achc_w1 - ADSL_GAI1_OUT_G->achc_ginp_cur );

   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   return TRUE;                             /* all done                */
#undef ADSL_GAI1_OUT_G   
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_after_logon()                                    */
static BOOL m_send_se2cl_demand_active( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                        struct dsd_output_area_1 *adsp_output_area_1 ) {
   int        iml1;                         /* working-variables       */
   char       *achl_out_p;                  /* position output         */
   char       *achl_out_s1;                 /* save output position    */
   char       chrl_work_1[ 512 ];           /* work area               */
   struct dsd_glyph *adsl_glyph_w1;
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   /* initialize everything */
   D_ADSL_RSE1->ucc_order_flags_1 = (unsigned char) 0X01;  /* send order flags */
   memset(  D_ADSL_RCO1->dsrc_ord_co_1,      0x00, offsetof(dsd_rdp_co, imc_bounds_left)      - offsetof(dsd_rdp_co, dsrc_ord_co_1));
   memset( &D_ADSL_RCO1->imc_bounds_left,    0xFF, offsetof(dsd_rdp_co, imc_o01_col_backgr)   - offsetof(dsd_rdp_co, imc_bounds_left));
   memset( &D_ADSL_RCO1->imc_o01_col_backgr, 0x00, offsetof(dsd_rdp_co, umc_loinf_options) - offsetof(dsd_rdp_co, imc_o01_col_backgr));
   memset( &D_ADSL_RSE1->dsc_old_bounds, 0XFF, sizeof(D_ADSL_RSE1->dsc_old_bounds) );
   /* free glyphs */
#define ADSRL_ARR_GLYPH_E ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e
   iml1 = 0;                                /* clear index             */
   while (TRUE) {
     if (iml1 >= D_ADSL_RSE1->dsc_rdp_co_1.imc_no_arr_glyph_e) {  /* number of arrays of glyph entries */
       break;
     }
     adsl_glyph_w1 = ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first;  /* reuse this glyph */
     while(adsl_glyph_w1){
       adsl_glyph_w1->adsc_font = NULL;
       adsl_glyph_w1 = adsl_glyph_w1->adsc_rem_ch_next;
     }
     ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_deleted = ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_filled - 1;
     iml1++;
   }

#undef ADSRL_ARR_GLYPH_E
   /* now send demand active PDU */
   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 32984 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
   m_put_be2( ADSL_OA1->achc_w1, 4 + 2 + sizeof(ucrs_capabilities_01) );
   *ADSL_OA1->achc_w1 |= 0X80;              /* length in two bytes     */
   ADSL_OA1->achc_w1 += 2;                  /* after length            */
   *ADSL_OA1->achc_w1++ = 0X00;             /* protocol 2              */
   *ADSL_OA1->achc_w1++ = 0X00;             /* protocol 3              */
   *ADSL_OA1->achc_w1++ = 0X10;
   *ADSL_OA1->achc_w1++ = 0X00;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     m_put_be2( achl_out_p, 4 + D_SIZE_HASH + 2 + sizeof(ucrs_capabilities_01) );
     *achl_out_p |= 0X80;                   /* length in two bytes     */
     *(achl_out_p + 2) = 0X08;              /* output encrypted        */
     *(achl_out_p + 4) = 0X00;              /* padding                 */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   m_put_le2( ADSL_OA1->achc_w1, 2 + sizeof(ucrs_capabilities_01) );
   ADSL_OA1->achc_w1 += 2;
   memcpy( ADSL_OA1->achc_w1,
           ucrs_capabilities_01,
           sizeof(ucrs_capabilities_01) );
/* UUUU 13.10.06 KB - get from client! */
// D_ADSL_RCO1->imc_coldep = 16;
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR, D_ADSL_RCO1->imc_s_coldep );
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR + 8, D_ADSL_RCO1->imc_dim_x );
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR + 10, D_ADSL_RCO1->imc_dim_y );
   ADSL_OA1->achc_w1 += sizeof(ucrs_capabilities_01);
   m_put_be2( achl_out_s1 + 2,
              ADSL_OA1->achc_w1 - achl_out_s1 );
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 2 + sizeof(ucrs_capabilities_01) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, 2 + sizeof(ucrs_capabilities_01) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, 2 + sizeof(ucrs_capabilities_01), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   switch (D_ADSL_RCO1->imc_s_coldep) {
     case 8:
       D_ADSL_RCO1->imc_bpp = 1;
       break;
     case 15:
     case 16:
       D_ADSL_RCO1->imc_bpp = 2;
       break;
     case 24:
//     D_ADSL_RCO1->imc_bpp = 4;
       D_ADSL_RCO1->imc_bpp = 3;
       break;
     case 32:
       D_ADSL_RCO1->imc_bpp = 4;
       break;
//   default:
//     return FALSE;
   }
   m_make_screen( adsp_hl_clib_1, NULL );
   adsp_hl_clib_1->ac_screen_buffer = ADSL_RDPA_F->ac_screen_buffer;
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_after_logon()                                    */
static BOOL m_send_se2cl_deactivate_all( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                         struct dsd_output_area_1 *adsp_output_area_1 ) {
   int        iml1;                         /* working-variables       */
   char       *achl_out_p;                  /* position output         */
   char       *achl_out_s1;                 /* save output position    */
   char       chrl_work_1[ 512 ];           /* work area               */
   struct dsd_glyph *adsl_glyph_w1;
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 33158 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
   m_put_be2( ADSL_OA1->achc_w1, 4 + 2 + sizeof(ucrs_deactivate_all) );
   *ADSL_OA1->achc_w1 |= 0X80;              /* length in two bytes     */
   ADSL_OA1->achc_w1 += 2;                  /* after length            */
   *ADSL_OA1->achc_w1++ = 0X00;             /* protocol 2              */
   *ADSL_OA1->achc_w1++ = 0X00;             /* protocol 3              */
   *ADSL_OA1->achc_w1++ = 0X10;
   *ADSL_OA1->achc_w1++ = 0X00;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     m_put_be2( achl_out_p, 4 + D_SIZE_HASH + 2 + sizeof(ucrs_deactivate_all) );
     *achl_out_p |= 0X80;                   /* length in two bytes     */
     *(achl_out_p + 2) = 0X08;              /* output encrypted        */
     *(achl_out_p + 4) = 0X00;              /* padding                 */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   m_put_le2( ADSL_OA1->achc_w1, 2 + sizeof(ucrs_deactivate_all) );
   ADSL_OA1->achc_w1 += 2;
   memcpy( ADSL_OA1->achc_w1,
           ucrs_deactivate_all,
           sizeof(ucrs_deactivate_all) );
/* UUUU 13.10.06 KB - get from client! */
// D_ADSL_RCO1->imc_coldep = 16;
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR, D_ADSL_RCO1->imc_s_coldep );
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR + 8, D_ADSL_RCO1->imc_dim_x );
   m_put_le2( ADSL_OA1->achc_w1 + D_CAP_POS_SCR + 10, D_ADSL_RCO1->imc_dim_y );
   ADSL_OA1->achc_w1 += sizeof(ucrs_deactivate_all);
   m_put_be2( achl_out_s1 + 2,
              ADSL_OA1->achc_w1 - achl_out_s1 );
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_SHA1 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 2 + sizeof(ucrs_deactivate_all) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, 2 + sizeof(ucrs_deactivate_all) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, 2 + sizeof(ucrs_deactivate_all), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_server = ADSL_GAI1_OUT_G;  /* output data to server */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   switch (D_ADSL_RCO1->imc_s_coldep) {
     case 8:
       D_ADSL_RCO1->imc_bpp = 1;
       break;
     case 15:
     case 16:
       D_ADSL_RCO1->imc_bpp = 2;
       break;
     case 24:
//     D_ADSL_RCO1->imc_bpp = 4;
       D_ADSL_RCO1->imc_bpp = 3;
       break;
     case 32:
       D_ADSL_RCO1->imc_bpp = 4;
       break;
//   default:
//     return FALSE;
   }
   m_make_screen( adsp_hl_clib_1, NULL );
   adsp_hl_clib_1->ac_screen_buffer = ADSL_RDPA_F->ac_screen_buffer;
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_after_logon()                                    */

static BOOL m_send_se2cl_after_conf_actpdu( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                            struct dsd_output_area_1 *adsp_output_area_1 ) {
   char       *achl_out_p;                  /* position output         */
   char       *achl_out_s1;                 /* save output position    */
   char       *achl_out_s2;                 /* save output position    */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_se2cl_after_conf_actpdu() ADSL_OA1->achc_w1=%p ADSL_OA1->achc_w2=%p\n",
           __LINE__, 33325, ADSL_OA1->achc_w1, ADSL_OA1->achc_w2 );
#endif
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 33330 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_s2 = ADSL_OA1->achc_w1;         /* save output position    */
   *ADSL_OA1->achc_w1++ = 4 + sizeof(ucrs_server_sync_pdu);  /* size of following part */
   memset( ADSL_OA1->achc_w1, 0, 4 );       /* record type 2 + 3 + padding */
   ADSL_OA1->achc_w1 += 4;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_s2 + 0) = 4 + D_SIZE_HASH + sizeof(ucrs_server_sync_pdu);  /* size of following part */
     *(achl_out_s2 + 1) = 0X08;             /* output encrypted        */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   memcpy( ADSL_OA1->achc_w1,
           ucrs_server_sync_pdu,
           sizeof(ucrs_server_sync_pdu) );
   m_put_le2( ADSL_OA1->achc_w1 + 4, D_DISPLAY_CHANNEL - 1 );
   memcpy( ADSL_OA1->achc_w1 + 6, ADSL_OA1->achc_w1 + 4, 2 );
   ADSL_OA1->achc_w1 += sizeof(ucrs_server_sync_pdu);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, sizeof(ucrs_server_sync_pdu) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_sync_pdu) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_sync_pdu), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2,
              ADSL_OA1->achc_w1 - ADSL_GAI1_OUT_G->achc_ginp_cur );
   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   /* output next record - Control PDU Cooperate                       */
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_s2 = ADSL_OA1->achc_w1;         /* save output position    */
   *ADSL_OA1->achc_w1++ = 4 + sizeof(ucrs_server_contr_pdu_coop);  /* size of following part */
   memset( ADSL_OA1->achc_w1, 0, 4 );       /* record type 2 + 3 + padding */
   ADSL_OA1->achc_w1 += 4;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_s2 + 0) = 4 + D_SIZE_HASH + sizeof(ucrs_server_contr_pdu_coop);  /* size of following part */
     *(achl_out_s2 + 1) = 0X08;             /* output encrypted        */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   memcpy( ADSL_OA1->achc_w1,
           ucrs_server_contr_pdu_coop,
           sizeof(ucrs_server_contr_pdu_coop) );
   m_put_le2( ADSL_OA1->achc_w1 + 4, D_DISPLAY_CHANNEL - 1 );
   memcpy( ADSL_OA1->achc_w1 + 6, ADSL_OA1->achc_w1 + 4, 2 );
   ADSL_OA1->achc_w1 += sizeof(ucrs_server_contr_pdu_coop);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, sizeof(ucrs_server_contr_pdu_coop) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_contr_pdu_coop) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_contr_pdu_coop), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   m_put_be2( achl_out_s1 + 2, ADSL_OA1->achc_w1 - achl_out_s1 );
   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   /* output next record - Control PDU Granted Control                 */
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_s2 = ADSL_OA1->achc_w1;         /* save output position    */
   *ADSL_OA1->achc_w1++ = 4 + sizeof(ucrs_server_contr_pdu_grco);  /* size of following part */
   memset( ADSL_OA1->achc_w1, 0, 4 );       /* record type 2 + 3 + padding */
   ADSL_OA1->achc_w1 += 4;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_s2 + 0) = 4 + D_SIZE_HASH + sizeof(ucrs_server_contr_pdu_grco);  /* size of following part */
     *(achl_out_s2 + 1) = 0X08;             /* output encrypted        */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   memcpy( ADSL_OA1->achc_w1,
           ucrs_server_contr_pdu_grco,
           sizeof(ucrs_server_contr_pdu_grco) );
   m_put_le2( ADSL_OA1->achc_w1 + 4, D_DISPLAY_CHANNEL - 1 );
   memcpy( ADSL_OA1->achc_w1 + 6, ADSL_OA1->achc_w1 + 4, 2 );
   memcpy( ADSL_OA1->achc_w1 + 22, ADSL_OA1->achc_w1 + 4, 2 );
// 03.06.09 KB - is this number correct ??? UUUU
   m_put_le2( ADSL_OA1->achc_w1 + 20, D_ADSL_RCO1->usc_chno_cont );
   ADSL_OA1->achc_w1 += sizeof(ucrs_server_contr_pdu_grco);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, sizeof(ucrs_server_contr_pdu_grco) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_contr_pdu_grco) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_contr_pdu_grco), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   m_put_be2( achl_out_s1 + 2, ADSL_OA1->achc_w1 - achl_out_s1 );
   achl_out_s1 = ADSL_OA1->achc_w1;         /* save output position    */
   /* output next record - Font Map PDU                                */
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( ADSL_OA1->achc_w1, D_USERID_SE2CL );
   ADSL_OA1->achc_w1 += 2;
   m_put_be2( ADSL_OA1->achc_w1, D_ADSL_RCO1->usc_chno_disp );
   ADSL_OA1->achc_w1 += 2;
   *ADSL_OA1->achc_w1++ = 0X70;             /* priority / segmentation */
   achl_out_s2 = ADSL_OA1->achc_w1;         /* save output position    */
   *ADSL_OA1->achc_w1++ = 4 + sizeof(ucrs_server_font_map_pdu);  /* size of following part */
   memset( ADSL_OA1->achc_w1, 0, 4 );       /* record type 2 + 3 + padding */
   ADSL_OA1->achc_w1 += 4;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_s2 + 0) = 4 + D_SIZE_HASH + sizeof(ucrs_server_font_map_pdu);  /* size of following part */
     *(achl_out_s2 + 1) = 0X08;             /* output encrypted        */
     achl_out_p = ADSL_OA1->achc_w1;        /* current position output */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   memcpy( ADSL_OA1->achc_w1,
           ucrs_server_font_map_pdu,
           sizeof(ucrs_server_font_map_pdu) );
   m_put_le2( ADSL_OA1->achc_w1 + 4, D_DISPLAY_CHANNEL - 1 );
   memcpy( ADSL_OA1->achc_w1 + 6, ADSL_OA1->achc_w1 + 4, 2 );
   ADSL_OA1->achc_w1 += sizeof(ucrs_server_font_map_pdu);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, sizeof(ucrs_server_font_map_pdu) );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_font_map_pdu) );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_p, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_p + D_SIZE_HASH, 0, sizeof(ucrs_server_font_map_pdu), achl_out_p + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   m_put_be2( achl_out_s1 + 2, ADSL_OA1->achc_w1 - achl_out_s1 );
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 33635 );  /* line number for errors */
     return FALSE;
   }
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_after_conf_actpdu()                              */

static BOOL m_send_se2cl_end( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                              struct dsd_output_area_1 *adsp_output_area_1,
                              ied_sc_command iep_sc_command,
                              char *chrp_work ) {
/* has to be encrypted ??? 16.06.07 KB UUUU */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication client */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
#endif
#ifndef HL_RDPACC_HELP_DEBUG
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_se2cl_end() ADSL_OA1->achc_w1=%p ADSL_OA1->achc_w2=%p\n",
           __LINE__, 33687, ADSL_OA1->achc_w1, ADSL_OA1->achc_w2 );
#endif
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d output-area too small",
                   __LINE__, 33692 );  /* line number for errors */
     return FALSE;
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
   *ADSL_OA1->achc_w1 = DEF_CONST_RDP_03;
   *(ADSL_OA1->achc_w1 + 1) = 0;            /* second byte zero        */
   memcpy( ADSL_OA1->achc_w1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01) + 0) = 0X21;  /* Send End Session */
   if (iep_sc_command == ied_scc_end_shutdown) {  /* shutdown of server */
     *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01) + 0) = 0X20;  /* Send Shutdown */
   }
   *(ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01) + 1) = 0X80;  /* only to verify */
   ADSL_OA1->achc_w1 += 4 + sizeof(ucrs_x224_p01) + 2;
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2,
              ADSL_OA1->achc_w1 - ADSL_GAI1_OUT_G->achc_ginp_cur );
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   return TRUE;                             /* all done                */
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_se2cl_end()                                            */

/* draw bitmap, send to server                                         */
static void m_send_draw_sc_s_normal( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                     char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   int        iml_width_bytes;              /* width in bytes          */
   int        iml_padded_width_all;         /* padded width all        */
   int        iml_padded_width_clear;       /* padded width to clear   */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_draw_sc_s_normal() left=%d top=%d right=%d bottom=%d\n",
           __LINE__, 34028,
           adsp_sc_draw_sc->imc_left,
           adsp_sc_draw_sc->imc_top,
           adsp_sc_draw_sc->imc_right,
           adsp_sc_draw_sc->imc_bottom );
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   iml_width_bytes = (adsp_sc_draw_sc->imc_right - adsp_sc_draw_sc->imc_left) * 2;  /* width in bytes */
   iml_padded_width_all = (iml_width_bytes + 3) & (0 - 4);  /* padded width all */
   iml_padded_width_clear = iml_padded_width_all - iml_width_bytes;  /* padded width to clear */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return;               /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
   iml_this_height = (dsl_aux_get_workarea.imc_len_work_area
                        - (sizeof(struct dsd_tempstor_1)
                             + sizeof(struct dsd_gather_i_1)
                             + 6 + 2 + 2 + 6 * 2 + 6
                             + D_SIZE_HASH))
                      / iml_padded_width_all;
   if (iml_this_height == 0) return;        /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
#define ACHL_BUFFER_C ((char *) al_buffer_1\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
   ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   iml1 = 6 + 2 + 2 + 6 * 2 + 6
            + iml_this_height * iml_padded_width_all;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   m_put_be2( ACHL_BUFFER_C + 1, iml1 );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   *achl_out = 0X01;                        /* PDU type                */
   /* two bytes PDU length little endian                               */
   m_put_le2( achl_out + 1,
              2 + 2 + 6 * 2 + 6
              + iml_this_height * iml_padded_width_all );
   /* UPDATETYPE_BITMAP                                                */
   *(achl_out + 3) = 0X01;
   *(achl_out + 4) = 0;
   /* number of bitmaps, little endian                                 */
   *(achl_out + 5) = 1;
   *(achl_out + 6) = 0;
   /* output left                                                      */
   m_put_le2( achl_out + 7, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( achl_out + 9, iml_cur_height );
   /* output right                                                     */
   m_put_le2( achl_out + 11, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( achl_out + 13, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( achl_out + 15,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( achl_out + 17, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( achl_out + 19, D_ADSL_RCO1->imc_s_coldep );
   *(achl_out + 21) = 0;                    /* not compressed          */
   *(achl_out + 22) = 0;                    /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( achl_out + 23,
              iml_this_height * iml_padded_width_all );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 2;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 2;
   achl3 = achl_out + 25;                   /* here is target          */
   /* compute length of one row                                        */
   iml2 = D_ADSL_RCO1->imc_dim_x * 2;
#ifdef OLD01
   if (   (adsp_sc_draw_sc->imc_left == 0)
       && (adsp_sc_draw_sc->imc_right == D_ADSL_RCO1->imc_dim_x)) {
     iml1 = achl2 - achl1;                  /* only one copy operation */
     iml2 = iml1;                           /* also input              */
   }
#endif
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml_width_bytes );
     achl3 += iml_padded_width_all;         /* end of output           */
     if (iml_padded_width_clear) {          /* padded width to clear   */
       memset( achl3 - iml_padded_width_clear, 0, iml_padded_width_clear );
     }
   } while (achl2 > achl1);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, achl3 - achl_out );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out, 0, achl3 - achl_out );
     if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out, 0, achl3 - achl_out, achl_out, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
#undef ACHL_BUFFER_C
   ADSL_GAI1_OUT_G->achc_ginp_end = achl3;  /* set end of output       */
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return;                                  /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_s_normal()                                     */

static BOOL m_send_draw_sc_s_compr( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   int        iml_width_bytes;              /* width in bytes          */
   int        iml_padded_width_all;         /* padded width all        */
   int        iml_padded_width_clear;       /* padded width to clear   */
   int        iml_compr_len;                /* length compressed       */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_first;              /* first buffer            */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_draw_sc_s_compr() left=%d top=%d right=%d bottom=%d\n",
           __LINE__, 34300,
           adsp_sc_draw_sc->imc_left,
           adsp_sc_draw_sc->imc_top,
           adsp_sc_draw_sc->imc_right,
           adsp_sc_draw_sc->imc_bottom );
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;

   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   iml_width_bytes = (adsp_sc_draw_sc->imc_right - adsp_sc_draw_sc->imc_left) * 2;  /* width in bytes */
   iml_padded_width_all = (iml_width_bytes + 3) & (0 - 4);  /* padded width all */
   iml_padded_width_clear = iml_padded_width_all - iml_width_bytes;  /* padded width to clear */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return FALSE;         /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
   iml_this_height = D_MAX_BMC_MSTSC / iml_padded_width_all;
   if (iml_this_height == 0) return FALSE;  /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
   al_buffer_first = al_buffer_1;           /* save first buffer       */
#define ACHL_BUFFER_C ((char *) al_buffer_first\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
#define ADSL_GAI1_OUT_FI ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_first + 1))
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
// ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
   }
   *achl_out++ = (unsigned char) 0X81;      /* PDU type, compressed    */
//*set PROBL_COMPR_01=1;
   achl_out += 2;                           /* leave space for length  */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out;  /* address act output-data */
   /* address end output-data                                          */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute
     = dsl_aux_get_workarea.achc_work_area  /* addr work-area returned */
     + dsl_aux_get_workarea.imc_len_work_area;  /* length work-area returned */
   /* two bytes padding                                                */
   *(chrp_work + 0) = 0;
   *(chrp_work + 1) = 0;
   /* number of bitmaps, little endian                                 */
   *(chrp_work + 2) = 1;
   *(chrp_work + 3) = 0;
   /* output left                                                      */
   m_put_le2( chrp_work + 4, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( chrp_work + 6, iml_cur_height );
   /* output right                                                     */
   m_put_le2( chrp_work + 8, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( chrp_work + 10, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( chrp_work + 12,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( chrp_work + 14, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( chrp_work + 16, D_ADSL_RCO1->imc_s_coldep );
   *(chrp_work + 18) = 0;                    /* not compressed          */
   *(chrp_work + 19) = 0;                    /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( chrp_work + 20,
              iml_this_height * iml_padded_width_all );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 2;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 2;
   achl3 = chrp_work + 22;                  /* here is target          */
   iml2 = D_ADSL_RCO1->imc_dim_x * 2;
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml_width_bytes );
     achl3 += iml_padded_width_all;         /* end of output           */
     if (iml_padded_width_clear) {          /* padded width to clear   */
       memset( achl3 - iml_padded_width_clear, 0, iml_padded_width_clear );
     }
   } while (achl2 > achl1);
   /* do compression now                                               */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = chrp_work;  /* address act input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = achl3;  /* address end input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
   iml_compr_len = 0;                       /* clear length compressed */
   while (TRUE) {                           /* loop over output buffers */
     ADSL_GAI1_OUT_G->achc_ginp_cur = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 34466,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_GAI1_OUT_G->achc_ginp_end = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     iml_compr_len += ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur;
     if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break;  /* all data compressed */
     /* needs more buffers                                             */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) return FALSE;       /* aux returned error      */
     al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
     memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
     al_buffer_last = al_buffer_1;          /* this is last buffer now */
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = ((char*) al_buffer_last) + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1);
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   /* output length compressed data                                    */
   *(achl_out - 2) = *achl_out;             /* copy compression header */
   m_put_le2( achl_out - 1, iml_compr_len - 1 );
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 3 + iml_compr_len );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out - 3, 0, 3 );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       SHA1_Update( ACHL_WORK_SHA1, ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
                    ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out - 3, 0, 3, achl_out - 3, 0, D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       RC4( ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur,
            ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   /* prepare start of buffer                                          */
   m_put_be2( ACHL_BUFFER_C + 1, achl_out - ACHL_BUFFER_C + iml_compr_len );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   ADSL_GAI1_OUT_FI->achc_ginp_cur = ACHL_BUFFER_C;  /* start sending here */
#undef ADSL_GAI1_OUT_G
#undef ADSL_GAI1_OUT_FI
#undef ACHL_BUFFER_C
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_s_compr()                                      */

static void m_send_draw_sc_24_normal( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1,
                                      struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                      char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   int        iml_width_bytes;              /* width in bytes          */
   int        iml_padded_width_all;         /* padded width all        */
   int        iml_padded_width_clear;       /* padded width to clear   */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   iml_width_bytes = (adsp_sc_draw_sc->imc_right - adsp_sc_draw_sc->imc_left) * 3;  /* width in bytes */
   iml_padded_width_all = (iml_width_bytes + 3) & (0 - 4);  /* padded width all */
   iml_padded_width_clear = iml_padded_width_all - iml_width_bytes;  /* padded width to clear */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return;               /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
   iml_this_height = (dsl_aux_get_workarea.imc_len_work_area
                        - (sizeof(struct dsd_tempstor_1)
                             + sizeof(struct dsd_gather_i_1)
                             + 6 + 2 + 2 + 6 * 2 + 6
                             + D_SIZE_HASH))
                      / iml_padded_width_all;
   if (iml_this_height == 0) return;        /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
#define ACHL_BUFFER_C ((char *) al_buffer_1\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
   ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   iml1 = 6 + 2 + 2 + 6 * 2 + 6
            + iml_this_height * iml_padded_width_all;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   m_put_be2( ACHL_BUFFER_C + 1, iml1 );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   *achl_out = 0X01;                        /* PDU type                */
   /* two bytes PDU length little endian                               */
   m_put_le2( achl_out + 1,
              2 + 2 + 6 * 2 + 6
              + iml_this_height * iml_padded_width_all );
   /* two bytes padding                                                */
   *(achl_out + 3) = 0;
   *(achl_out + 4) = 0;
   /* number of bitmaps, little endian                                 */
   *(achl_out + 5) = 1;
   *(achl_out + 6) = 0;
   /* output left                                                      */
   m_put_le2( achl_out + 7, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( achl_out + 9, iml_cur_height );
   /* output right                                                     */
   m_put_le2( achl_out + 11, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( achl_out + 13, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( achl_out + 15,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( achl_out + 17, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( achl_out + 19, D_ADSL_RCO1->imc_s_coldep );
   *(achl_out + 21) = 0;                    /* not compressed          */
   *(achl_out + 22) = 0;                    /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( achl_out + 23,
              iml_this_height * iml_padded_width_all );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 3;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 3;
   achl3 = achl_out + 25;                   /* here is target          */
   /* compute length of one row                                        */
   iml2 = D_ADSL_RCO1->imc_dim_x * 3;
#ifdef OLD01
   if (   (adsp_sc_draw_sc->imc_left == 0)
       && (adsp_sc_draw_sc->imc_right == D_ADSL_RCO1->imc_dim_x)) {
     iml1 = achl2 - achl1;                  /* only one copy operation */
     iml2 = iml1;                           /* also input              */
   }
#endif
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml_width_bytes );
     achl3 += iml_padded_width_all;         /* end of output           */
     if (iml_padded_width_clear) {          /* padded width to clear   */
       memset( achl3 - iml_padded_width_clear, 0, iml_padded_width_clear );
     }
   } while (achl2 > achl1);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, achl3 - achl_out );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out, 0, achl3 - achl_out );
     if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out, 0, achl3 - achl_out, achl_out, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
#undef ACHL_BUFFER_C
   ADSL_GAI1_OUT_G->achc_ginp_end = achl3;  /* set end of output       */
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return;                                  /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_24_normal()                                    */

static BOOL m_send_draw_sc_24_compr( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                     char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   int        iml_width_bytes;              /* width in bytes          */
   int        iml_padded_width_all;         /* padded width all        */
   int        iml_padded_width_clear;       /* padded width to clear   */
   int        iml_compr_len;                /* length compressed       */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_first;              /* first buffer            */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
#ifdef TRACEHL1
   printf( "l%05d s%05d m_send_draw_sc_24_compr() left=%d top=%d right=%d bottom=%d\n",
           __LINE__, 34949,
           adsp_sc_draw_sc->imc_left,
           adsp_sc_draw_sc->imc_top,
           adsp_sc_draw_sc->imc_right,
           adsp_sc_draw_sc->imc_bottom );
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;

   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   iml_width_bytes = (adsp_sc_draw_sc->imc_right - adsp_sc_draw_sc->imc_left) * 3;  /* width in bytes */
   iml_padded_width_all = (iml_width_bytes + 3) & (0 - 4);  /* padded width all */
   iml_padded_width_clear = iml_padded_width_all - iml_width_bytes;  /* padded width to clear */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return FALSE;         /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
// to-do 28.02.09 KB - invalid
   iml_this_height = D_MAX_BMC_MSTSC / iml_padded_width_all;
   if (iml_this_height == 0) return FALSE;  /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
   al_buffer_first = al_buffer_1;           /* save first buffer       */
#define ACHL_BUFFER_C ((char *) al_buffer_first\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
#define ADSL_GAI1_OUT_FI ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_first + 1))
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
// ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
   }
   *achl_out++ = (unsigned char) 0X81;      /* PDU type, compressed    */
//*set PROBL_COMPR_01=1;
   achl_out += 2;                           /* leave space for length  */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out;  /* address act output-data */
   /* address end output-data                                          */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute
     = dsl_aux_get_workarea.achc_work_area  /* addr work-area returned */
     + dsl_aux_get_workarea.imc_len_work_area;  /* length work-area returned */
   /* two bytes padding                                                */
   *(chrp_work + 0) = 0;
   *(chrp_work + 1) = 0;
   /* number of bitmaps, little endian                                 */
   *(chrp_work + 2) = 1;
   *(chrp_work + 3) = 0;
   /* output left                                                      */
   m_put_le2( chrp_work + 4, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( chrp_work + 6, iml_cur_height );
   /* output right                                                     */
   m_put_le2( chrp_work + 8, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( chrp_work + 10, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( chrp_work + 12,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( chrp_work + 14, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( chrp_work + 16, D_ADSL_RCO1->imc_s_coldep );
   *(chrp_work + 18) = 0;                   /* not compressed          */
   *(chrp_work + 19) = 0;                   /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( chrp_work + 20,
              iml_this_height * iml_padded_width_all );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 3;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 3;
   achl3 = chrp_work + 22;                  /* here is target          */
   iml2 = D_ADSL_RCO1->imc_dim_x * 3;
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml_width_bytes );
     achl3 += iml_padded_width_all;         /* end of output           */
     if (iml_padded_width_clear) {          /* padded width to clear   */
       memset( achl3 - iml_padded_width_clear, 0, iml_padded_width_clear );
     }
   } while (achl2 > achl1);
   /* do compression now                                               */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = chrp_work;  /* address act input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = achl3;  /* address end input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
   iml_compr_len = 0;                       /* clear length compressed */
   while (TRUE) {                           /* loop over output buffers */
     ADSL_GAI1_OUT_G->achc_ginp_cur = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 35122,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_GAI1_OUT_G->achc_ginp_end = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     iml_compr_len += ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur;
     if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break;  /* all data compressed */
     /* needs more buffers                                             */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) return FALSE;       /* aux returned error      */
     al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
     memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
     al_buffer_last = al_buffer_1;          /* this is last buffer now */
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = ((char*) al_buffer_last) + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1);
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   /* output length compressed data                                    */
   *(achl_out - 2) = *achl_out;             /* copy compression header */
   m_put_le2( achl_out - 1, iml_compr_len - 1 );
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 3 + iml_compr_len );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out - 3, 0, 3 );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       SHA1_Update( ACHL_WORK_SHA1, ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
                    ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out - 3, 0, 3, achl_out - 3, 0, D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       RC4( ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur,
            ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   /* prepare start of buffer                                          */
   m_put_be2( ACHL_BUFFER_C + 1, achl_out - ACHL_BUFFER_C + iml_compr_len );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   ADSL_GAI1_OUT_FI->achc_ginp_cur = ACHL_BUFFER_C;  /* start sending here */
#undef ADSL_GAI1_OUT_G
#undef ADSL_GAI1_OUT_FI
#undef ACHL_BUFFER_C
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_24_compr()                                     */
static void m_send_draw_sc_i_normal( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                     char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return;               /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
   iml_this_height = (dsl_aux_get_workarea.imc_len_work_area
                        - (sizeof(struct dsd_tempstor_1)
                             + sizeof(struct dsd_gather_i_1)
                             + 6 + 2 + 2 + 6 * 2 + 6
                             + D_SIZE_HASH))
                      / (adsp_sc_draw_sc->imc_right
                          - adsp_sc_draw_sc->imc_left)
                      / 4;
   if (iml_this_height == 0) return;        /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
#define ACHL_BUFFER_C ((char *) al_buffer_1\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
   ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   iml1 = 6 + 2 + 2 + 6 * 2 + 6
            + iml_this_height
              * (adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left)
              * 4;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   m_put_be2( ACHL_BUFFER_C + 1, iml1 );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   *achl_out = 0X01;                        /* PDU type                */
   /* two bytes PDU length little endian                               */
   m_put_le2( achl_out + 1,
              2 + 2 + 6 * 2 + 6
              + iml_this_height
                * (adsp_sc_draw_sc->imc_right
                  - adsp_sc_draw_sc->imc_left)
                * 4 );
   /* two bytes padding                                                */
   *(achl_out + 3) = 0;
   *(achl_out + 4) = 0;
   /* number of bitmaps, little endian                                 */
   *(achl_out + 5) = 1;
   *(achl_out + 6) = 0;
   /* output left                                                      */
   m_put_le2( achl_out + 7, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( achl_out + 9, iml_cur_height );
   /* output right                                                     */
   m_put_le2( achl_out + 11, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( achl_out + 13, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( achl_out + 15,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( achl_out + 17, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( achl_out + 19, D_ADSL_RCO1->imc_s_coldep );
   *(achl_out + 21) = 0;                    /* not compressed          */
   *(achl_out + 22) = 0;                    /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( achl_out + 23,
              iml_this_height
              * (adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left)
              * 4 );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 4;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 4;
   achl3 = achl_out + 25;                   /* here is target          */
   /* compute length of one row                                        */
   iml1 = (adsp_sc_draw_sc->imc_right
           - adsp_sc_draw_sc->imc_left)
          * 4;
   iml2 = D_ADSL_RCO1->imc_dim_x * 4;
#ifdef OLD01
   if (   (adsp_sc_draw_sc->imc_left == 0)
       && (adsp_sc_draw_sc->imc_right == D_ADSL_RCO1->imc_dim_x)) {
     iml1 = achl2 - achl1;                  /* only one copy operation */
     iml2 = iml1;                           /* also input              */
   }
#endif
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml1 );
     achl3 += iml1;                         /* end of output           */
   } while (achl2 > achl1);
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, achl3 - achl_out );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out, 0, achl3 - achl_out );
     if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out, 0, achl3 - achl_out, achl_out, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
#undef ACHL_BUFFER_C
   ADSL_GAI1_OUT_G->achc_ginp_end = achl3;  /* set end of output       */
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
#undef ADSL_GAI1_OUT_G
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return;                                  /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_i_normal()                                     */

static BOOL m_send_draw_sc_i_compr( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   char       *achl1, *achl2, *achl3;       /* working variables       */
   char       *achl_out;                    /* position output         */
   int        iml1, iml2;                   /* working variables       */
   int        iml_cur_height;               /* current height of bitmap */
   int        iml_this_height;              /* this height to send     */
   int        iml_compr_len;                /* length compressed       */
   void *     al_buffer_1;                  /* current buffer          */
   void *     al_buffer_first;              /* first buffer            */
   void *     al_buffer_last;               /* last buffer             */
// char       *achl1, *achl2;               /* working variables       */
// char       *achl1;                       /* working variable        */
// struct dsd_gather_i_1 *adsl_gai1_out_st;  /* start output data      */
// struct dsd_gather_i_1 *adsl_gai1_out_1;  /* output data             */
// struct dsd_gather_i_1 *adsl_gai1_out_2;  /* output data             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;

   iml_cur_height = adsp_sc_draw_sc->imc_top;  /* start here           */
   al_buffer_last = NULL;                   /* last buffer             */

   psend20:                                 /* send next part          */
   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) return FALSE;         /* aux returned error      */
   al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
   iml_this_height = 8170
                      / (adsp_sc_draw_sc->imc_right
                          - adsp_sc_draw_sc->imc_left)
                      / 4;
   // UUU: JB 15.03.12: This happened with VNC-Bridge, Multimonitor, as width of screen is 5120.
   // As we are doing Bitmapcompression now, this code is not used any more for now. 
   if (iml_this_height == 0) return FALSE;  /* buffer too small        */
   if (iml_this_height > (adsp_sc_draw_sc->imc_bottom - iml_cur_height)) {
     iml_this_height = adsp_sc_draw_sc->imc_bottom - iml_cur_height;
   }
   memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
   if (al_buffer_last) {                    /* was buffer before       */
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
   }
   al_buffer_last = al_buffer_1;            /* this is last buffer now */
   al_buffer_first = al_buffer_1;           /* save first buffer       */
#define ACHL_BUFFER_C ((char *) al_buffer_first\
 + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1))
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_1 + 1))
#define ADSL_GAI1_OUT_FI ((struct dsd_gather_i_1 *) ((struct dsd_tempstor_1 *) al_buffer_first + 1))
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
// ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
   }
   *achl_out++ = (unsigned char) 0X81;      /* PDU type, compressed    */
//*set PROBL_COMPR_01=1;
   achl_out += 2;                           /* leave space for length  */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out;  /* address act output-data */
   /* address end output-data                                          */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute
     = dsl_aux_get_workarea.achc_work_area  /* addr work-area returned */
     + dsl_aux_get_workarea.imc_len_work_area;  /* length work-area returned */
   /* two bytes padding                                                */
   *(chrp_work + 0) = 0;
   *(chrp_work + 1) = 0;
   /* number of bitmaps, little endian                                 */
   *(chrp_work + 2) = 1;
   *(chrp_work + 3) = 0;
   /* output left                                                      */
   m_put_le2( chrp_work + 4, adsp_sc_draw_sc->imc_left );
   /* output top                                                       */
   m_put_le2( chrp_work + 6, iml_cur_height );
   /* output right                                                     */
   m_put_le2( chrp_work + 8, adsp_sc_draw_sc->imc_right - 1 );
   /* output bottom                                                    */
   m_put_le2( chrp_work + 10, iml_cur_height + iml_this_height - 1 );
   /* output width                                                     */
   m_put_le2( chrp_work + 12,
              adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left );
   /* output height                                                    */
   m_put_le2( chrp_work + 14, iml_this_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( chrp_work + 16, D_ADSL_RCO1->imc_s_coldep );
   *(chrp_work + 18) = 0;                   /* not compressed          */
   *(chrp_work + 19) = 0;                   /* length encoding         */
   /* number of bytes bitmap                                           */
   m_put_le2( chrp_work + 20,
              iml_this_height
              * (adsp_sc_draw_sc->imc_right
                - adsp_sc_draw_sc->imc_left)
              * 4 );
   /* compute start in screen buffer                                   */
   achl1 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + (iml_cur_height * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 4;
   /* compute end in screen buffer                                     */
   achl2 = (char *) ADSL_RDPA_F->ac_screen_buffer
           + ((iml_cur_height + iml_this_height)
                * D_ADSL_RCO1->imc_dim_x
                + adsp_sc_draw_sc->imc_left)
             * 4;
   achl3 = chrp_work + 22;                  /* here is target          */
   /* compute length of one row                                        */
   iml1 = (adsp_sc_draw_sc->imc_right
           - adsp_sc_draw_sc->imc_left)
          * 4;
   iml2 = D_ADSL_RCO1->imc_dim_x * 4;
   do {                                     /* loop over all rows / or only once */
     achl2 -= iml2;                         /* input row before        */
     memcpy( achl3, achl2, iml1 );
     achl3 += iml1;                         /* end of output           */
   } while (achl2 > achl1);
   /* do compression now                                               */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = chrp_work;  /* address act input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = achl3;  /* address end input-data */
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
   iml_compr_len = 0;                       /* clear length compressed */
   while (TRUE) {                           /* loop over output buffers */
     ADSL_GAI1_OUT_G->achc_ginp_cur = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 35772,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_GAI1_OUT_G->achc_ginp_end = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     iml_compr_len += ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur;
     if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break;  /* all data compressed */
     /* needs more buffers                                             */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) return FALSE;       /* aux returned error      */
     al_buffer_1 = dsl_aux_get_workarea.achc_work_area;  /* addr work-area returned */
     memset( al_buffer_1, 0, sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1) );
     ((struct dsd_tempstor_1 *) al_buffer_last)->adsc_next
       = (struct dsd_tempstor_1 *) al_buffer_1;
     al_buffer_last = al_buffer_1;          /* this is last buffer now */
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = ((char*) al_buffer_last) + sizeof(struct dsd_tempstor_1) + sizeof(struct dsd_gather_i_1);
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   /* output length compressed data                                    */
   *(achl_out - 2) = *achl_out;             /* copy compression header */
   m_put_le2( achl_out - 1, iml_compr_len - 1 );
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 3 + iml_compr_len );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out - 3, 0, 3 );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       SHA1_Update( ACHL_WORK_SHA1, ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
                    ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
     if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ACHL_BUFFER_C + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out - 3, 0, 3, achl_out - 3, 0, D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     al_buffer_1 = al_buffer_first;         /* get first buffer        */
     do {                                   /* loop over compressed output */
       RC4( ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            ADSL_GAI1_OUT_G->achc_ginp_end - ADSL_GAI1_OUT_G->achc_ginp_cur,
            ADSL_GAI1_OUT_G->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       al_buffer_1 = ((struct dsd_tempstor_1 *) al_buffer_1)->adsc_next;  /* get next in chain */
     } while (al_buffer_1);
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   /* prepare start of buffer                                          */
   m_put_be2( ACHL_BUFFER_C + 1, achl_out - ACHL_BUFFER_C + iml_compr_len );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   ADSL_GAI1_OUT_FI->achc_ginp_cur = ACHL_BUFFER_C;  /* start sending here */
#undef ADSL_GAI1_OUT_G
#undef ADSL_GAI1_OUT_FI
#undef ACHL_BUFFER_C
   iml_cur_height += iml_this_height;       /* add height this part    */
   if (iml_cur_height < adsp_sc_draw_sc->imc_bottom) {
     goto psend20;                          /* send next part          */
   }
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_i_compr()                                      */

static BOOL m_send_draw_sc_bmc_normal( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                       struct dsd_output_area_1 *adsp_output_area_1,
                                       struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                       char *achp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   int        iml_max_y;                    /* maximum height          */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* chain of data           */
   char       *achl_out;                    /* position output         */
   struct dsd_sc_draw_sc dsl_sc_draw_sc;    /* parameters              */
   struct dsd_bmc_get_wa dsl_get_wa;        /* get work area           */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif
   BOOL bol_compr_6;

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   memcpy( &dsl_sc_draw_sc, adsp_sc_draw_sc, sizeof(struct dsd_sc_draw_sc) );  /* copy parameters */
   dsl_get_wa.dsc_bmc1.ac_screen_buffer = ADSL_RDPA_F->ac_screen_buffer;  /* screen buffer */
   dsl_get_wa.dsc_bmc1.imc_coldep = D_ADSL_RCO1->imc_s_coldep;  /* current colour depth */
   dsl_get_wa.dsc_bmc1.imc_bpp = D_ADSL_RCO1->imc_bpp;  /* bytes per pixel */
   dsl_get_wa.dsc_bmc1.imc_dim_x = D_ADSL_RCO1->imc_dim_x;  /* dimension x pixels */
   dsl_get_wa.dsc_bmc1.imc_dim_y = D_ADSL_RCO1->imc_dim_y;  /* dimension y pixels */
   dsl_get_wa.dsc_bmc1.imc_dest_left = dsl_sc_draw_sc.imc_left;  /* destLeft */
   dsl_get_wa.dsc_bmc1.imc_dest_right = dsl_sc_draw_sc.imc_right - 1;  /* destRight */
   dsl_get_wa.dsc_bmc1.imc_bitmap_width = dsl_sc_draw_sc.imc_right - dsl_sc_draw_sc.imc_left;  /* width of bitmap */
   dsl_get_wa.dsc_bmc1.inc_compression_flags = 0;
   /* number of bytes needs to be a multiple of four                   */
   bol_compr_6 = FALSE;
   switch (dsl_get_wa.dsc_bmc1.imc_bpp) {
     case 2:                                /* two bytes per pixel     */
       iml1 = dsl_get_wa.dsc_bmc1.imc_bitmap_width;  /* save old value */
       dsl_get_wa.dsc_bmc1.imc_bitmap_width++;  /* add one             */
       dsl_get_wa.dsc_bmc1.imc_bitmap_width &= (0 - 4 / 2);
       if (dsl_get_wa.dsc_bmc1.imc_bitmap_width == iml1) break;  /* still old value */
       dsl_get_wa.dsc_bmc1.imc_dest_right++;
       if (dsl_get_wa.dsc_bmc1.imc_dest_right < dsl_get_wa.dsc_bmc1.imc_dim_x) break;
       dsl_get_wa.dsc_bmc1.imc_dest_right--;
       dsl_get_wa.dsc_bmc1.imc_dest_left--;
       break;
     case 3:                                /* three bytes per pixel   */
       iml1 = dsl_get_wa.dsc_bmc1.imc_bitmap_width;  /* save old value */
       dsl_get_wa.dsc_bmc1.imc_bitmap_width += 4 - 1;  /* round up     */
       dsl_get_wa.dsc_bmc1.imc_bitmap_width &= (0 - 4);
       iml1 -= dsl_get_wa.dsc_bmc1.imc_bitmap_width;  /* compute difference */
       if (iml1 == 0) break;                /* still old value         */
       dsl_get_wa.dsc_bmc1.imc_dest_right -= iml1;  /* add difference  */
       iml1 = (dsl_get_wa.dsc_bmc1.imc_dest_right + 1) - dsl_get_wa.dsc_bmc1.imc_dim_x;
       if (iml1 <= 0) break;
       dsl_get_wa.dsc_bmc1.imc_dest_right -= iml1;
       dsl_get_wa.dsc_bmc1.imc_dest_left -= iml1;
       break;
     case 4:
       bol_compr_6 = TRUE; 
       dsl_get_wa.dsc_bmc1.inc_cll = 0;
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_dynamic_color_fidelity)
         dsl_get_wa.dsc_bmc1.inc_cll = 3;
	   /* Is MSTSC? */
	   if(!D_ADSL_RCO1->dsc_caps.dsc_hob.boc_order_ex_bmp6_uncompressed) {
		 // SM: This forces the bitmap compression to avoid the uncompressed mode internally. It uses
		 // the eventually larger RLE compression in all cases.
		 dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_NO_UNCOMPRESSED;
	   }
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_skip_alpha)
         dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_SKIP_ALPHA;
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_color_subsampling){   
         dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_SUBSAMPLING;
         if((dsl_get_wa.dsc_bmc1.imc_dest_left & 0x1) != 0){
            dsl_get_wa.dsc_bmc1.imc_dest_left--;
            dsl_get_wa.dsc_bmc1.imc_bitmap_width++;
         }
         if(((dsl_get_wa.dsc_bmc1.imc_dest_right & 0x1) == 0) && // imc_dest_right is inclusive
             (dsl_get_wa.dsc_bmc1.imc_dest_right < dsl_get_wa.dsc_bmc1.imc_dim_x)){
            dsl_get_wa.dsc_bmc1.imc_dest_right++;
            dsl_get_wa.dsc_bmc1.imc_bitmap_width++;
         }
         if((dsl_sc_draw_sc.imc_top & 0x1) != 0)
            dsl_sc_draw_sc.imc_top--;
         if(((dsl_sc_draw_sc.imc_bottom & 0x1) != 0) &&
             (dsl_sc_draw_sc.imc_bottom < dsl_get_wa.dsc_bmc1.imc_dim_y)){
            dsl_sc_draw_sc.imc_bottom++;
         }
       }
       break; 
   }
   dsl_get_wa.dsc_bmc1.amc_get_workarea = &m_bmc_get_wa;  /* get new work area */
   dsl_get_wa.adsc_hl_clib_1 = adsp_hl_clib_1;  /* call parameters     */
   iml_max_y                                /* maximum height          */
     = D_MAX_BMC_MSTSC
         / (dsl_get_wa.dsc_bmc1.imc_bitmap_width * dsl_get_wa.dsc_bmc1.imc_bpp);
   if((dsl_get_wa.dsc_bmc1.inc_compression_flags & dsd_bitmap_compr_6::FLAG_SUBSAMPLING) != 0){
     iml_max_y &= (0 - 2);
   }

   p_call_20:                               /* call subroutine         */
   dsl_get_wa.dsc_bmc1.imc_dest_top = dsl_sc_draw_sc.imc_top;  /* destTop */
   dsl_get_wa.dsc_bmc1.imc_bitmap_height
     = dsl_sc_draw_sc.imc_bottom - dsl_sc_draw_sc.imc_top;
   if (dsl_get_wa.dsc_bmc1.imc_bitmap_height > iml_max_y) {
     dsl_get_wa.dsc_bmc1.imc_bitmap_height = iml_max_y;
   }
   dsl_get_wa.dsc_bmc1.imc_dest_bottom = dsl_sc_draw_sc.imc_top + dsl_get_wa.dsc_bmc1.imc_bitmap_height - 1;
   dsl_get_wa.dsc_bmc1.adsc_gai1_out = NULL;  /* output data           */
   dsl_get_wa.dsc_bmc1.achc_wa_free_start = ADSL_OA1->achc_w1;  /* start of free part of work area */
   dsl_get_wa.dsc_bmc1.achc_wa_free_end = ADSL_OA1->achc_w2;  /* end of free part of work area */
   if(bol_compr_6 == FALSE)
     bol1 = m_bitmap_compr_1( &dsl_get_wa.dsc_bmc1 );
   else 
     bol1 = m_bitmap_compr_6( &dsl_get_wa.dsc_bmc1 );
   if (bol1 == FALSE) return FALSE;
   ADSL_OA1->achc_w1 = dsl_get_wa.dsc_bmc1.achc_wa_free_start;  /* start of free part of work area */
   ADSL_OA1->achc_w2 = dsl_get_wa.dsc_bmc1.achc_wa_free_end;  /* end of free part of work area */
   adsl_gai1_w1 = dsl_get_wa.dsc_bmc1.adsc_gai1_out;  /* get output data */
   if (adsl_gai1_w1 == NULL) return FALSE;  /* no output data          */
   iml1 = 0;                                /* clear count             */
   while (TRUE) {                           /* loop over output data   */
     iml1 += adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
     if (adsl_gai1_w1->adsc_next == NULL) break;  /* was last gather   */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
   }
   if ( !bol_compr_6 && (iml1 + 32)
            > (dsl_get_wa.dsc_bmc1.imc_bitmap_width
                * dsl_get_wa.dsc_bmc1.imc_bitmap_height
                * dsl_get_wa.dsc_bmc1.imc_bpp)) {
     switch (dsl_get_wa.dsc_bmc1.imc_bpp) {
       case 2:
         m_send_draw_sc_s_normal( adsp_hl_clib_1,
                                  ADSL_OA1,
                                  &dsl_sc_draw_sc,
                                  achp_work );
         return TRUE;
       case 3:
         m_send_draw_sc_24_normal( adsp_hl_clib_1,
                                   ADSL_OA1,
                                   &dsl_sc_draw_sc,
                                   achp_work );
         return TRUE;
       case 4:
         m_send_draw_sc_i_normal( adsp_hl_clib_1,
                                  ADSL_OA1,
                                  &dsl_sc_draw_sc,
                                  achp_work );
         return TRUE;
     }
     return FALSE;
   }
   dsl_sc_draw_sc.imc_top += dsl_get_wa.dsc_bmc1.imc_bitmap_height;  /* current y position */
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_draw_sc_bmc_normal() illogic",
                   __LINE__, 36135);  /* line number for errors */
     return FALSE;                          /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
#define ACHL_BUFFER_C ADSL_OA1->achc_w1
   ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   *(ACHL_BUFFER_C + 0) = 0;
   iml2 = 6 + 2 + 2 + 6 * 2 + 6 + iml1;
   achl_out = ACHL_BUFFER_C + 3;            /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out += D_SIZE_HASH;               /* add length hash         */
     iml2 += D_SIZE_HASH;                   /* add length hash         */
   }
   m_put_be2( ACHL_BUFFER_C + 1, iml2 );
   *(ACHL_BUFFER_C + 1) |= 0X80;            /* length in two bytes     */
   *achl_out = 0X01;                        /* PDU type                */
   /* two bytes PDU length little endian                               */
   m_put_le2( achl_out + 1,
              2 + 2 + 6 * 2 + 6
              + iml1 );
   /* two bytes padding                                                */
   *(achl_out + 3) = 0;
   *(achl_out + 4) = 0;
   /* number of bitmaps, little endian                                 */
   *(achl_out + 5) = 1;
   *(achl_out + 6) = 0;
   /* output left                                                      */
   m_put_le2( achl_out + 7, dsl_get_wa.dsc_bmc1.imc_dest_left );
   /* output top                                                       */
   m_put_le2( achl_out + 9, dsl_get_wa.dsc_bmc1.imc_dest_top );
   /* output right                                                     */
   m_put_le2( achl_out + 11, dsl_get_wa.dsc_bmc1.imc_dest_right );
   /* output bottom                                                    */
   m_put_le2( achl_out + 13, dsl_get_wa.dsc_bmc1.imc_dest_bottom );
   /* output width                                                     */
   m_put_le2( achl_out + 15, dsl_get_wa.dsc_bmc1.imc_bitmap_width );
   /* output height                                                    */
   m_put_le2( achl_out + 17, dsl_get_wa.dsc_bmc1.imc_bitmap_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( achl_out + 19, D_ADSL_RCO1->imc_s_coldep );
   *(achl_out + 21) = 0X01;                 /* compressed              */
   *(achl_out + 22) = 0X04;                 /* special length encoding flag */
   m_put_le2( achl_out + 23, iml1 );
   ADSL_OA1->achc_w1 = ADSL_GAI1_OUT_G->achc_ginp_end = achl_out + 25;
   ADSL_GAI1_OUT_G->adsc_next = dsl_get_wa.dsc_bmc1.adsc_gai1_out;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = adsl_gai1_w1;   /* this is last one        */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) achp_work)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 25 + iml1 );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     adsl_gai1_w1 = ADSL_GAI1_OUT_G;        /* get first gather        */
     SHA1_Update( ACHL_WORK_SHA1, achl_out, 0,
                  adsl_gai1_w1->achc_ginp_end - achl_out );
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
     do {                                   /* loop over output        */
       SHA1_Update( ACHL_WORK_SHA1, adsl_gai1_w1->achc_ginp_cur, 0,
                    adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
     } while (adsl_gai1_w1);
     if (*(ADSL_GAI1_OUT_G->achc_ginp_cur + 0) & 0X40) {  /* flag for block count */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ADSL_GAI1_OUT_G->achc_ginp_cur + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     adsl_gai1_w1 = ADSL_GAI1_OUT_G;        /* get first gather        */
     RC4( achl_out, 0,
          adsl_gai1_w1->achc_ginp_end - achl_out,
          achl_out, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
     do {                                   /* loop over compressed output */
       RC4( adsl_gai1_w1->achc_ginp_cur, 0,
            adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur,
            adsl_gai1_w1->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
     } while (adsl_gai1_w1);
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   if (dsl_sc_draw_sc.imc_top < dsl_sc_draw_sc.imc_bottom) {  /* current y position */
     goto p_call_20;                        /* call subroutine again   */
   }
   return TRUE;
#undef ADSL_GAI1_OUT_G
#undef ACHL_BUFFER_C
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_bmc_normal()                                   */


static BOOL m_send_draw_sc_bmc_compr( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1,
                                      struct dsd_sc_draw_sc *adsp_sc_draw_sc,
                                      char *achp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2;                   /* working variables       */
   int        iml_max_x;                    /* maximum width           */
   int        iml_max_y;                    /* maximum height          */
   int        iml_start_left;               /* save start left         */
   int        iml_compr_len;                /* length compressed       */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* chain of data           */
   struct dsd_gather_i_1 *adsl_gai1_start;  /* start of output data    */
   char       *achl_out_1;                  /* position output         */
   char       *achl_out_2;                  /* position output         */
   struct dsd_sc_draw_sc dsl_sc_draw_sc_r;  /* parameters remaining screen */
   struct dsd_sc_draw_sc dsl_sc_draw_sc_c;  /* parameters call draw    */
   struct dsd_bmc_get_wa dsl_get_wa;        /* get work area           */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   struct dsd_gather_i_1 dsl_gai1_l1;       /* local chain of data     */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   memcpy( &dsl_sc_draw_sc_r, adsp_sc_draw_sc, sizeof(struct dsd_sc_draw_sc) );  /* copy parameters */
   dsl_get_wa.dsc_bmc1.ac_screen_buffer = ADSL_RDPA_F->ac_screen_buffer;  /* screen buffer */
   dsl_get_wa.dsc_bmc1.imc_coldep = D_ADSL_RCO1->imc_s_coldep;  /* current colour depth */
   dsl_get_wa.dsc_bmc1.imc_bpp = D_ADSL_RCO1->imc_bpp;  /* bytes per pixel */
   dsl_get_wa.dsc_bmc1.imc_dim_x = D_ADSL_RCO1->imc_dim_x;  /* dimension x pixels */
   dsl_get_wa.dsc_bmc1.imc_dim_y = D_ADSL_RCO1->imc_dim_y;  /* dimension y pixels */
   dsl_get_wa.dsc_bmc1.inc_compression_flags = 0;
   /* number of bytes needs to be a multiple of four                   */
   BOOL bol_compr_6 = FALSE;
   switch (dsl_get_wa.dsc_bmc1.imc_bpp) {
     case 2:                                /* two bytes per pixel     */
       iml1 = iml2 = dsl_sc_draw_sc_r.imc_right - dsl_sc_draw_sc_r.imc_left;  /* save old value */
       iml1++;                              /* add one             */
       iml1 &= (0 - 4 / 2);
       if (iml1 == iml2) break;             /* still old value */
       dsl_sc_draw_sc_r.imc_right++;
       if (dsl_sc_draw_sc_r.imc_right <= dsl_get_wa.dsc_bmc1.imc_dim_x) break;
       dsl_sc_draw_sc_r.imc_right--;
       dsl_sc_draw_sc_r.imc_left--;
       break;
     case 3:                                /* three bytes per pixel   */
       iml1 = iml2 = dsl_sc_draw_sc_r.imc_right - dsl_sc_draw_sc_r.imc_left;  /* save old value */
       iml1 += 4 - 1;                       /* round up                */
       iml1 &= (0 - 4);
       iml2 -= iml1;                        /* compute difference      */
       if (iml2 == 0) break;                /* still old value         */
       dsl_sc_draw_sc_r.imc_right -= iml2;  /* add difference          */
       iml1 = dsl_sc_draw_sc_r.imc_right - dsl_get_wa.dsc_bmc1.imc_dim_x;
       if (iml1 <= 0) break;
       dsl_sc_draw_sc_r.imc_right -= iml1;
       dsl_sc_draw_sc_r.imc_left -= iml1;
       break;
     case 4:
       bol_compr_6 = TRUE; 
       dsl_get_wa.dsc_bmc1.inc_cll = 0;
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_dynamic_color_fidelity)
         dsl_get_wa.dsc_bmc1.inc_cll = 3;
	   /* Is MSTSC? */
	   if(!D_ADSL_RCO1->dsc_caps.dsc_hob.boc_order_ex_bmp6_uncompressed) {
		 // SM: This forces the bitmap compression to avoid the uncompressed mode internally. It uses
		 // the eventually larger RLE compression in all cases.
		 dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_NO_UNCOMPRESSED;
	   }
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_skip_alpha)
         dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_SKIP_ALPHA;
       if(adsp_hl_clib_1->adsc_rdp_co->dsc_caps.dsc_bitmap.boc_allow_color_subsampling){   
         dsl_get_wa.dsc_bmc1.inc_compression_flags |= dsd_bitmap_compr_6::FLAG_SUBSAMPLING;
         if((dsl_sc_draw_sc_r.imc_left & 0x1) != 0)
            dsl_sc_draw_sc_r.imc_left--;
         if((dsl_sc_draw_sc_r.imc_top & 0x1) != 0)
            dsl_sc_draw_sc_r.imc_top--;
         if(((dsl_sc_draw_sc_r.imc_right & 0x1) != 0) &&
            (dsl_sc_draw_sc_r.imc_right < dsl_get_wa.dsc_bmc1.imc_dim_x)){
               dsl_sc_draw_sc_r.imc_right++;
         }
         if(((dsl_sc_draw_sc_r.imc_bottom & 0x1) != 0) &&
            (dsl_sc_draw_sc_r.imc_bottom < dsl_get_wa.dsc_bmc1.imc_dim_y)){
               dsl_sc_draw_sc_r.imc_bottom++;
         }
       }
       break; 
   }
   iml_start_left = dsl_sc_draw_sc_r.imc_left;  /* save start left     */
   dsl_get_wa.dsc_bmc1.amc_get_workarea = &m_bmc_get_wa;  /* get new work area */
   dsl_get_wa.adsc_hl_clib_1 = adsp_hl_clib_1;  /* call parameters     */
   iml_max_x = dsl_sc_draw_sc_r.imc_right - dsl_sc_draw_sc_r.imc_left;  /* maximum width */
   iml_max_y = dsl_sc_draw_sc_r.imc_bottom - dsl_sc_draw_sc_r.imc_top;  /* compute height */
   if (iml_max_y <= (D_MAX_BMC_MSTSC / (iml_max_x * dsl_get_wa.dsc_bmc1.imc_bpp))) {
     goto p_call_20;                        /* can use these settings  */
   }
   iml1 = imrs_bmc_width[ dsl_get_wa.dsc_bmc1.imc_bpp ];  /* get width if square */
   /* compute width if only one piece in y direction                   */
   iml_max_x = (D_MAX_BMC_MSTSC / (iml_max_y * dsl_get_wa.dsc_bmc1.imc_bpp)) & (0 - 4);
   if (iml_max_x >= iml1) {                 /* wider than square       */
     goto p_call_20;                        /* can use these settings  */
   }
   iml_max_x = iml1;                        /* set width square        */
   iml_max_y                                /* maximum height          */
     = D_MAX_BMC_MSTSC
         / (iml_max_x * dsl_get_wa.dsc_bmc1.imc_bpp);
   if((dsl_get_wa.dsc_bmc1.inc_compression_flags & dsd_bitmap_compr_6::FLAG_SUBSAMPLING) != 0){
     iml_max_y &= (0 - 2);
     iml_max_x &= (0 - 2);
   }

   p_call_20:                               /* call subroutine         */
   dsl_get_wa.dsc_bmc1.imc_dest_left = dsl_sc_draw_sc_r.imc_left;  /* destLeft */
   dsl_get_wa.dsc_bmc1.imc_bitmap_width = dsl_sc_draw_sc_r.imc_right - dsl_sc_draw_sc_r.imc_left;  /* width of bitmap */
   if (dsl_get_wa.dsc_bmc1.imc_bitmap_width > iml_max_x) {
     dsl_get_wa.dsc_bmc1.imc_bitmap_width = iml_max_x;
   }
   dsl_get_wa.dsc_bmc1.imc_dest_right = dsl_sc_draw_sc_r.imc_left + dsl_get_wa.dsc_bmc1.imc_bitmap_width - 1;  /* destRight */
   dsl_get_wa.dsc_bmc1.imc_dest_top = dsl_sc_draw_sc_r.imc_top;  /* destTop */
   dsl_get_wa.dsc_bmc1.imc_bitmap_height
     = dsl_sc_draw_sc_r.imc_bottom - dsl_sc_draw_sc_r.imc_top;
   if (dsl_get_wa.dsc_bmc1.imc_bitmap_height > iml_max_y) {
     dsl_get_wa.dsc_bmc1.imc_bitmap_height = iml_max_y;
   }
   dsl_get_wa.dsc_bmc1.imc_dest_bottom = dsl_sc_draw_sc_r.imc_top + dsl_get_wa.dsc_bmc1.imc_bitmap_height - 1;
   dsl_sc_draw_sc_r.imc_left += dsl_get_wa.dsc_bmc1.imc_bitmap_width;
   if (dsl_sc_draw_sc_r.imc_left >= dsl_sc_draw_sc_r.imc_right) {
     dsl_sc_draw_sc_r.imc_top += dsl_get_wa.dsc_bmc1.imc_bitmap_height;  /* current y position */
     dsl_sc_draw_sc_r.imc_left = iml_start_left;  /* restore start left */
   }
   dsl_get_wa.dsc_bmc1.adsc_gai1_out = NULL;  /* output data           */
   dsl_get_wa.dsc_bmc1.achc_wa_free_start = ADSL_OA1->achc_w1;  /* start of free part of work area */
   dsl_get_wa.dsc_bmc1.achc_wa_free_end = ADSL_OA1->achc_w2;  /* end of free part of work area */
   if(bol_compr_6 == FALSE)
     bol1 = m_bitmap_compr_1( &dsl_get_wa.dsc_bmc1 );
   else 
     bol1 = m_bitmap_compr_6( &dsl_get_wa.dsc_bmc1 );
   if (bol1 == FALSE) return FALSE;
   ADSL_OA1->achc_w1 = dsl_get_wa.dsc_bmc1.achc_wa_free_start;  /* start of free part of work area */
   ADSL_OA1->achc_w2 = dsl_get_wa.dsc_bmc1.achc_wa_free_end;  /* end of free part of work area */
   adsl_gai1_w1 = dsl_get_wa.dsc_bmc1.adsc_gai1_out;  /* get output data */
   if (adsl_gai1_w1 == NULL) return FALSE;  /* no output data          */
   iml1 = 0;                                /* clear count             */
   while (TRUE) {                           /* loop over output data   */
     iml1 += adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
     if (adsl_gai1_w1->adsc_next == NULL) break;  /* was last gather   */
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
   }
   if ( !bol_compr_6 && (iml1 + 32)
            > (dsl_get_wa.dsc_bmc1.imc_bitmap_width
                * dsl_get_wa.dsc_bmc1.imc_bitmap_height
                * dsl_get_wa.dsc_bmc1.imc_bpp)) { /* compressed biggern than uncompressed */
     /* prepare area with the command                                  */
     dsl_sc_draw_sc_c.imc_left = dsl_get_wa.dsc_bmc1.imc_dest_left;
     dsl_sc_draw_sc_c.imc_top = dsl_get_wa.dsc_bmc1.imc_dest_top;
     dsl_sc_draw_sc_c.imc_right
       = dsl_get_wa.dsc_bmc1.imc_dest_left + dsl_get_wa.dsc_bmc1.imc_bitmap_width;
     dsl_sc_draw_sc_c.imc_bottom
       = dsl_get_wa.dsc_bmc1.imc_dest_top + dsl_get_wa.dsc_bmc1.imc_bitmap_height;
     switch (dsl_get_wa.dsc_bmc1.imc_bpp) {
       case 2:
         m_send_draw_sc_s_compr( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 &dsl_sc_draw_sc_c,
                                 achp_work );
         break;
       case 3:
         m_send_draw_sc_24_compr( adsp_hl_clib_1,
                                  ADSL_OA1,
                                  &dsl_sc_draw_sc_c,
                                  achp_work );
         break;
       case 4:
         m_send_draw_sc_i_compr( adsp_hl_clib_1,
                                 ADSL_OA1,
                                 &dsl_sc_draw_sc_c,
                                 achp_work );
         break;
       default:
         return FALSE;
     }
     if (dsl_sc_draw_sc_r.imc_top < dsl_sc_draw_sc_r.imc_bottom) {  /* current y position */
       goto p_call_20;                      /* call subroutine again   */
     }
     return TRUE;                           /* all done                */
   }
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_draw_sc_bmc_compr() illogic",
                   __LINE__, 36853);  /* line number for errors */
     return FALSE;                          /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
#define ACHL_BUFFER_C ADSL_OA1->achc_w1
   adsl_gai1_start = ADSL_GAI1_OUT_G;       /* start of output data    */
   ADSL_GAI1_OUT_G->achc_ginp_cur = ACHL_BUFFER_C;
   ADSL_GAI1_OUT_G->achc_ginp_end = ACHL_BUFFER_C;
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   *(ACHL_BUFFER_C + 0) = 0;
   achl_out_1 = ACHL_BUFFER_C + 3;          /* here starts output      */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ACHL_BUFFER_C + 0) = 0XC0;
     achl_out_1 += D_SIZE_HASH;             /* add length hash         */
   }
#undef ADSL_GAI1_OUT_G
#undef ACHL_BUFFER_C
   *achl_out_1++ = (unsigned char) 0X81;    /* PDU type, compressed    */
   achl_out_1 += 3 - 1;                     /* here starts output      */
   achl_out_2 = achl_out_1;                 /* save position start output */
   /* two bytes padding                                                */
   *(achp_work + 0) = 0;
   *(achp_work + 1) = 0;
   /* number of bitmaps, little endian                                 */
   *(achp_work + 2) = 1;
   *(achp_work + 3) = 0;
   /* output left                                                      */
   m_put_le2( achp_work + 4, dsl_get_wa.dsc_bmc1.imc_dest_left );
   /* output top                                                       */
   m_put_le2( achp_work + 6, dsl_get_wa.dsc_bmc1.imc_dest_top );
   /* output right                                                     */
   m_put_le2( achp_work + 8, dsl_get_wa.dsc_bmc1.imc_dest_right );
   /* output bottom                                                    */
   m_put_le2( achp_work + 10, dsl_get_wa.dsc_bmc1.imc_dest_bottom );
   /* output width                                                     */
   m_put_le2( achp_work + 12, dsl_get_wa.dsc_bmc1.imc_bitmap_width );
   /* output height                                                    */
   m_put_le2( achp_work + 14, dsl_get_wa.dsc_bmc1.imc_bitmap_height );
   /* bits per pixel / colour depth                                    */
   m_put_le2( achp_work + 16, D_ADSL_RCO1->imc_s_coldep );
   *(achp_work + 18) = 0X01;                /* compressed              */
   *(achp_work + 19) = 0X04;                /* special length encoding flag */
   m_put_le2( achp_work + 20, iml1 );
   dsl_gai1_l1.achc_ginp_cur = achp_work;   /* local chain of data start */
   dsl_gai1_l1.achc_ginp_end = achp_work + 22;  /* local chain of data end */
   dsl_gai1_l1.adsc_next = dsl_get_wa.dsc_bmc1.adsc_gai1_out;  /* after this the bitmap data */
   adsl_gai1_w1 = &dsl_gai1_l1;             /* local chain of data */
   /* do compression now                                               */
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = NULL;
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = FALSE;  /* not yet end-of-record input */
   D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush = FALSE;  /* not yet end of output reached */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1;  /* address act output-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   iml_compr_len = 0;                       /* clear length compressed */
   while (TRUE) {                           /* loop over output buffers */
     while (D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa >= D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe) {
       if (adsl_gai1_w1 == NULL) break;     /* all done                */
       D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = adsl_gai1_w1->achc_ginp_cur;  /* address act input-data */
       D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = adsl_gai1_w1->achc_ginp_end;  /* address end input-data */
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
       break;
     }
     if (adsl_gai1_w1 == NULL) {            /* end of input reached    */
       if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break;  /* end of output reached */
       D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
     }
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 36950,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     iml_compr_len += D_ADSL_RCO1->dsc_cdrf_enc.achc_outa - achl_out_1;
     achl_out_1 = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     if (achl_out_1 < ADSL_OA1->achc_w2) continue;  /* still space in output-area */
     if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) continue;  /* end of output reached */
     ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     /* get new block for more output                                  */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
#undef ADSL_GAI1_OUT_G
     achl_out_1 = ADSL_OA1->achc_w1;        /* here is next output     */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1;  /* address act output-data */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   }
   ADSL_OA1->achc_w1 = ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;  /* set end of block */
   /* output length compressed data                                    */
   *(achl_out_2 - 2) = *achl_out_2;         /* copy compression header */
   m_put_le2( achl_out_2 - 1, iml_compr_len - 1 );
   /* output length of RDP-5 packet                                    */
   m_put_be2( adsl_gai1_start->achc_ginp_cur + 1,
              achl_out_2 - adsl_gai1_start->achc_ginp_cur
                + iml_compr_len );
   *(adsl_gai1_start->achc_ginp_cur + 1) |= 0X80;  /* length in two bytes */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     achl_out_2 -= 3;                       /* here starts encryption  */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) achp_work)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01,
                3 + iml_compr_len );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_2, 0,
                  adsl_gai1_start->achc_ginp_end - achl_out_2 );
     adsl_gai1_w1 = adsl_gai1_start->adsc_next;  /* get next in chain  */
     while (adsl_gai1_w1) {                 /* loop over output        */
       SHA1_Update( ACHL_WORK_SHA1, adsl_gai1_w1->achc_ginp_cur, 0,
                    adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
     }
     if (*(adsl_gai1_start->achc_ginp_cur + 0) & 0X40) {  /* flag for block count */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( adsl_gai1_start->achc_ginp_cur + 3, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_2, 0,
          adsl_gai1_start->achc_ginp_end - achl_out_2,
          achl_out_2, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     adsl_gai1_w1 = adsl_gai1_start->adsc_next;  /* get next in chain  */
     while (adsl_gai1_w1) {                 /* loop over compressed output */
       RC4( adsl_gai1_w1->achc_ginp_cur, 0,
            adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur,
            adsl_gai1_w1->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
     }
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
   }
   if (dsl_sc_draw_sc_r.imc_top < dsl_sc_draw_sc_r.imc_bottom) {  /* current y position */
     goto p_call_20;                        /* call subroutine again   */
   }
   return TRUE;
#undef ADSL_GAI1_OUT_G
#undef ACHL_BUFFER_C
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_draw_sc_bmc_compr()                                    */

static BOOL m_bmc_get_wa( struct dsd_bitmap_compr_1 *adsp_bmc1 ) {
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */

#define ADSL_GET_WA ((struct dsd_bmc_get_wa *) ((char *) adsp_bmc1 - offsetof( struct dsd_bmc_get_wa, dsc_bmc1 )))
#define ADSL_HL_CLIB_1 ADSL_GET_WA->adsc_hl_clib_1

   memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
   bol1 = (*ADSL_HL_CLIB_1->amc_aux)( ADSL_HL_CLIB_1->vpc_userfld,
                                      DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                      &dsl_aux_get_workarea,
                                      sizeof(struct dsd_aux_get_workarea) );
   if (bol1 == FALSE) {                     /* aux returned error      */
     ADSL_HL_CLIB_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
     return FALSE;                          /* do cleanup now          */
   }
   adsp_bmc1->achc_wa_free_start = dsl_aux_get_workarea.achc_work_area;
   adsp_bmc1->achc_wa_free_end = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   return TRUE;                             /* all done                */

#undef ADSL_GET_WA
#undef ADSL_HL_CLIB_1
} /* end m_bmc_get_wa()                                                */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.7 ScrBlt (SCRBLT_ORDER)                  */
static struct dsd_sc_co1 * m_send_order_scrblt( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                                struct dsd_output_area_1 *adsp_output_area_1,
                                                struct dsd_sc_co1 *adsp_sc_co1,
                                                char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
   int        iml_bpp;                      /* number of bytes per pixel */
   char       *achl_start;                  /* address start of order  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_s1;                     /* address source          */
   char       *achl_t1;                     /* address target          */
   struct dsd_rectrb dsl_rect_target;       /* target rectangle        */
   struct dsd_rectrb dsl_rect_source;       /* target rectangle        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1  (3 + 9 + 13)
   if ((adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X02;  /* set primary order number */
#define ADSL_O_SCRBLT ((struct dsd_sc_order_scrblt *) (adsp_sc_co1 + 1))
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X09;  /* Flags standard + change, no delta */
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (ADSL_O_SCRBLT->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   *achl_start |= 0X08;                     /* set typechange flag     */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X02;  /* Order-Number     */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X7F;  /* Order-Flags      */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->dsc_rectangle.isc_left );  /* left coordinate of the destination rect */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->dsc_rectangle.isc_top );  /* top coordinate of the destination rect */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->dsc_rectangle.isc_width );  /* width of the destination rect */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->dsc_rectangle.isc_height );  /* height of the destination rect */
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = ADSL_O_SCRBLT->ucc_brop3;  /* index of the ternary raster operation */
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->isc_x_src );  /* X coordinate of the source rectangle */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, ADSL_O_SCRBLT->isc_y_src );  /* Y coordinate of the source rectangle */
   ADSL_OA1->achc_w1 += 2;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
// ADSL_OA1->imc_pdu_len += 16;             /* length of PDU           */
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   if (ADSL_O_SCRBLT->boc_update_scrbuf == FALSE) {  /* Specifies whether the local screen buffer should be changed. */
     return adsp_sc_co1->adsc_next;         /* this order has been processed */
   }
   if (ADSL_O_SCRBLT->ucc_brop3 != 0XCC) {
     printf( "l%05d s%05d m_send_order_scrblt() ROP-code 0X%02X not yet supported\n",
             __LINE__, 37191,      /* line number for errors  */
             (unsigned char) ADSL_O_SCRBLT->ucc_brop3 );
     return adsp_sc_co1->adsc_next;         /* this order has been processed */
   }
   dsl_rect_target.isc_left = ADSL_O_SCRBLT->dsc_rectangle.isc_left;
   dsl_rect_target.isc_top = ADSL_O_SCRBLT->dsc_rectangle.isc_top;
   dsl_rect_target.isc_right = ADSL_O_SCRBLT->dsc_rectangle.isc_left + ADSL_O_SCRBLT->dsc_rectangle.isc_width;
   dsl_rect_target.isc_bottom = ADSL_O_SCRBLT->dsc_rectangle.isc_top + ADSL_O_SCRBLT->dsc_rectangle.isc_height;
   dsl_rect_source.isc_left = ADSL_O_SCRBLT->isc_x_src;
   dsl_rect_source.isc_top = ADSL_O_SCRBLT->isc_y_src;
   dsl_rect_source.isc_right = ADSL_O_SCRBLT->isc_x_src + ADSL_O_SCRBLT->dsc_rectangle.isc_width;
   dsl_rect_source.isc_bottom = ADSL_O_SCRBLT->isc_y_src + ADSL_O_SCRBLT->dsc_rectangle.isc_height;
   /* apply bounds                                                     */
   if (ADSL_O_SCRBLT->boc_has_bounds) {
     if (D_ADSL_RCO1->imc_bounds_left > dsl_rect_target.isc_left) {
       dsl_rect_source.isc_left += D_ADSL_RCO1->imc_bounds_left - dsl_rect_target.isc_left;
       dsl_rect_target.isc_left = D_ADSL_RCO1->imc_bounds_left;
     }
     if (D_ADSL_RCO1->imc_bounds_top > dsl_rect_target.isc_top) {
       dsl_rect_source.isc_top += D_ADSL_RCO1->imc_bounds_top - dsl_rect_target.isc_top;
       dsl_rect_target.isc_top = D_ADSL_RCO1->imc_bounds_top;
     }
     if (D_ADSL_RCO1->imc_bounds_right < dsl_rect_target.isc_right) {
       dsl_rect_source.isc_right += D_ADSL_RCO1->imc_bounds_right - dsl_rect_target.isc_right;
       dsl_rect_target.isc_right = D_ADSL_RCO1->imc_bounds_right;
     }
     if (D_ADSL_RCO1->imc_bounds_bottom < dsl_rect_target.isc_bottom) {
       dsl_rect_source.isc_bottom += D_ADSL_RCO1->imc_bounds_bottom - dsl_rect_target.isc_bottom;
       dsl_rect_target.isc_bottom = D_ADSL_RCO1->imc_bounds_bottom;
     }
   }
   /* check if target in current area                                  */
   if (dsl_rect_target.isc_left < 0) {
     dsl_rect_source.isc_left -= dsl_rect_target.isc_left;
     dsl_rect_target.isc_left = 0;
   }
   if (dsl_rect_target.isc_top < 0) {
     dsl_rect_source.isc_top -= dsl_rect_target.isc_top;
     dsl_rect_target.isc_top = 0;
   }
   if (dsl_rect_target.isc_right > D_ADSL_RCO1->imc_dim_x) {
     dsl_rect_source.isc_right -= dsl_rect_target.isc_right - D_ADSL_RCO1->imc_dim_x;
     dsl_rect_target.isc_right = D_ADSL_RCO1->imc_dim_x;
   }
   if (dsl_rect_target.isc_bottom > D_ADSL_RCO1->imc_dim_y) {
     dsl_rect_source.isc_bottom -= dsl_rect_target.isc_bottom - D_ADSL_RCO1->imc_dim_y;
     dsl_rect_target.isc_bottom = D_ADSL_RCO1->imc_dim_y;
   }
   /* check if source in current area                                  */
   if (dsl_rect_source.isc_left < 0) {
     dsl_rect_target.isc_left -= dsl_rect_source.isc_left;
     dsl_rect_source.isc_left = 0;
   }
   if (dsl_rect_source.isc_top < 0) {
     dsl_rect_target.isc_top -= dsl_rect_source.isc_top;
     dsl_rect_source.isc_top = 0;
   }
   if (dsl_rect_source.isc_right > D_ADSL_RCO1->imc_dim_x) {
     dsl_rect_target.isc_right -= dsl_rect_source.isc_right - D_ADSL_RCO1->imc_dim_x;
     dsl_rect_source.isc_right = D_ADSL_RCO1->imc_dim_x;
   }
   if (dsl_rect_source.isc_bottom > D_ADSL_RCO1->imc_dim_y) {
     dsl_rect_target.isc_bottom -= dsl_rect_source.isc_bottom - D_ADSL_RCO1->imc_dim_y;
     dsl_rect_source.isc_bottom = D_ADSL_RCO1->imc_dim_y;
   }
   iml_bpp = D_ADSL_RCO1->imc_bpp;          /* number of bytes per pixel */
   iml1 = dsl_rect_target.isc_bottom - dsl_rect_target.isc_top;  /* so many lines to copy */
   if (iml1 <= 0) return adsp_sc_co1->adsc_next;  /* nothing to copy   */
   iml2 = (dsl_rect_target.isc_right - dsl_rect_target.isc_left) * iml_bpp;  /* so many to copy in one line */
   if (iml2 <= 0) return adsp_sc_co1->adsc_next;  /* nothing to copy   */
   iml3 = D_ADSL_RCO1->imc_dim_x * iml_bpp;  /* so many bytes in one line */
   if (   (dsl_rect_source.isc_top < dsl_rect_target.isc_top)
       || (   (dsl_rect_source.isc_top == dsl_rect_target.isc_top)
           && (dsl_rect_source.isc_left < dsl_rect_target.isc_left))) {
     /* copy from bottom to top                                        */
     achl_s1 = (char *) ADSL_RDPA_F->ac_screen_buffer
                 + (dsl_rect_source.isc_bottom * D_ADSL_RCO1->imc_dim_x
                      + dsl_rect_source.isc_left)
                   * iml_bpp;
     achl_t1 = (char *) ADSL_RDPA_F->ac_screen_buffer
                 + (dsl_rect_target.isc_bottom * D_ADSL_RCO1->imc_dim_x
                      + dsl_rect_target.isc_left)
                   * iml_bpp;
     do {
       achl_t1 -= iml3;                     /* previous line target    */
       achl_s1 -= iml3;                     /* previous line source    */
       memmove( achl_t1, achl_s1, iml2 );   /* copy in this line       */
       iml1--;                              /* decrement number of lines */
     } while (iml1 > 0);
   } else {
     /* copy from top to bottom                                        */
     achl_s1 = (char *) ADSL_RDPA_F->ac_screen_buffer
                 + (dsl_rect_source.isc_top * D_ADSL_RCO1->imc_dim_x
                      + dsl_rect_source.isc_left)
                   * iml_bpp;
     achl_t1 = (char *) ADSL_RDPA_F->ac_screen_buffer
                 + (dsl_rect_target.isc_top * D_ADSL_RCO1->imc_dim_x
                      + dsl_rect_target.isc_left)
                   * iml_bpp;
     do {
       memcpy( achl_t1, achl_s1, iml2 );    /* copy in this line       */
       achl_t1 += iml3;                     /* next line target        */
       achl_s1 += iml3;                     /* next line source        */
       iml1--;                              /* decrement number of lines */
     } while (iml1 > 0);
   }
#undef ADSL_O_SCRBLT
   return adsp_sc_co1->adsc_next;           /* this order has been processed */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_scrblt()                                         */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.9 MemBlt (MEMBLT_ORDER)                  */
static void m_send_order_memblt( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                 struct dsd_output_area_1 *adsp_output_area_1,
                                 struct dsd_sc_order_memblt *adsp_sc_order_memblt,
                                 char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (4 + 9 + 17)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_memblt->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X0D) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X0D;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X0D;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   *achl_flags = 0X21;                      /* clear encoding bytes    */
   *(achl_flags + 1) = 0X01;                /* clear encoding bytes    */
   ADSL_OA1->achc_w1 += 2;                  /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   iml1 = adsp_sc_order_memblt->ucc_id_bitmapcache
            | (adsp_sc_order_memblt->ucc_index_colortable << 8);
   m_put_le2( ADSL_OA1->achc_w1, iml1 );
   ADSL_OA1->achc_w1 += 2;
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     if (D_ADSL_RCO1->dsc_ord_co_o0d.boc_set == FALSE) break;
     iml1 = adsp_sc_order_memblt->dsc_destination_rec.isc_left - D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X02;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_memblt->dsc_destination_rec.isc_top - D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X04;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_memblt->dsc_destination_rec.isc_width - D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_width;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X08;           /* width set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_memblt->dsc_destination_rec.isc_height - D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_height;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X10;           /* height set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_memblt->ucc_brop3;  /* index of the ternary raster operation */
     iml1 = adsp_sc_order_memblt->isc_x_src - D_ADSL_RCO1->dsc_ord_co_o0d.isc_x_src;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X40;           /* nXSrc set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_memblt->isc_y_src - D_ADSL_RCO1->dsc_ord_co_o0d.isc_y_src;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X80;           /* nYSrc set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_left = adsp_sc_order_memblt->dsc_destination_rec.isc_left;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_top = adsp_sc_order_memblt->dsc_destination_rec.isc_top;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_width = adsp_sc_order_memblt->dsc_destination_rec.isc_width;  /* coordinate width */
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_height = adsp_sc_order_memblt->dsc_destination_rec.isc_height;  /* coordinate height */
     D_ADSL_RCO1->dsc_ord_co_o0d.isc_x_src = adsp_sc_order_memblt->isc_x_src;
     D_ADSL_RCO1->dsc_ord_co_o0d.isc_y_src = adsp_sc_order_memblt->isc_y_src;
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
// *achl_flags = 0;                         /* clear encoding bytes    */
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_left != adsp_sc_order_memblt->dsc_destination_rec.isc_left) {
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_left = adsp_sc_order_memblt->dsc_destination_rec.isc_left;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->dsc_destination_rec.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X02;             /* left set                */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_top != adsp_sc_order_memblt->dsc_destination_rec.isc_top) {
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_top = adsp_sc_order_memblt->dsc_destination_rec.isc_top;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->dsc_destination_rec.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X04;             /* top set                 */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_width != adsp_sc_order_memblt->dsc_destination_rec.isc_width) {
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_width = adsp_sc_order_memblt->dsc_destination_rec.isc_width;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->dsc_destination_rec.isc_width );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X08;             /* width set               */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_height != adsp_sc_order_memblt->dsc_destination_rec.isc_height) {
     D_ADSL_RCO1->dsc_ord_co_o0d.dsc_rect.isc_height = adsp_sc_order_memblt->dsc_destination_rec.isc_height;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->dsc_destination_rec.isc_height );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X10;             /* height set              */
   }
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_memblt->ucc_brop3;  /* index of the ternary raster operation */
   if (   (D_ADSL_RCO1->dsc_ord_co_o0d.isc_x_src != adsp_sc_order_memblt->isc_x_src)
       || (D_ADSL_RCO1->dsc_ord_co_o0d.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0d.isc_x_src = adsp_sc_order_memblt->isc_x_src;
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->isc_x_src );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X40;             /* nXSrc set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0d.isc_y_src != adsp_sc_order_memblt->isc_y_src)
       || (D_ADSL_RCO1->dsc_ord_co_o0d.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0d.isc_y_src = adsp_sc_order_memblt->isc_y_src;
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->isc_y_src );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X80;             /* nYSrc set               */
   }

   p_out_o_40:                              /* delta parameters set    */
   D_ADSL_RCO1->dsc_ord_co_o0d.boc_set = TRUE;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_memblt->usc_cacheindex );
   ADSL_OA1->achc_w1 += 2;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_memblt()                                         */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.10 Mem3Blt (MEM3BLT_ORDER)               */
static void m_send_order_mem3blt( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  struct dsd_sc_order_mem3blt *adsp_sc_order_mem3blt,
                                  char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (4 + 9 + 34)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_mem3blt->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X0E) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X0E;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X0E;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   memset( achl_flags, 0, 3 );
   ADSL_OA1->achc_w1 += 3;                  /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   iml1 = adsp_sc_order_mem3blt->ucc_id_bitmapcache
            | (adsp_sc_order_mem3blt->ucc_index_colortable << 8);
   if (   (iml1 != D_ADSL_RCO1->dsc_ord_co_o0e.usc_cache_id)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     m_put_le2( ADSL_OA1->achc_w1, iml1 );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) = 0X01;
     D_ADSL_RCO1->dsc_ord_co_o0e.usc_cache_id = iml1;
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     if (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE) break;
     iml1 = adsp_sc_order_mem3blt->dsc_destination_rec.isc_left - D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X02;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_mem3blt->dsc_destination_rec.isc_top - D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X04;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_mem3blt->dsc_destination_rec.isc_width - D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_width;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X08;           /* width set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_mem3blt->dsc_destination_rec.isc_height - D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_height;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X10;           /* height set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     if (D_ADSL_RCO1->dsc_ord_co_o0e.ucc_brop3 != adsp_sc_order_mem3blt->ucc_brop3) {
       *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_mem3blt->ucc_brop3;  /* index of the ternary raster operation */
       *(achl_flags + 0) |= 0X20;
       D_ADSL_RCO1->dsc_ord_co_o0e.ucc_brop3 = adsp_sc_order_mem3blt->ucc_brop3;
     }
     iml1 = adsp_sc_order_mem3blt->isc_x_src - D_ADSL_RCO1->dsc_ord_co_o0e.isc_x_src;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X40;           /* nXSrc set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_mem3blt->isc_y_src - D_ADSL_RCO1->dsc_ord_co_o0e.isc_y_src;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X80;           /* nYSrc set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_left = adsp_sc_order_mem3blt->dsc_destination_rec.isc_left;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_top = adsp_sc_order_mem3blt->dsc_destination_rec.isc_top;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_width = adsp_sc_order_mem3blt->dsc_destination_rec.isc_width;  /* coordinate width */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_height = adsp_sc_order_mem3blt->dsc_destination_rec.isc_height;  /* coordinate height */
     D_ADSL_RCO1->dsc_ord_co_o0e.isc_x_src = adsp_sc_order_mem3blt->isc_x_src;
     D_ADSL_RCO1->dsc_ord_co_o0e.isc_y_src = adsp_sc_order_mem3blt->isc_y_src;
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_left != adsp_sc_order_mem3blt->dsc_destination_rec.isc_left) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_left = adsp_sc_order_mem3blt->dsc_destination_rec.isc_left;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_destination_rec.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X02;             /* left set                */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_top != adsp_sc_order_mem3blt->dsc_destination_rec.isc_top) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_top = adsp_sc_order_mem3blt->dsc_destination_rec.isc_top;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_destination_rec.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X04;             /* top set                 */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_width != adsp_sc_order_mem3blt->dsc_destination_rec.isc_width) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_width = adsp_sc_order_mem3blt->dsc_destination_rec.isc_width;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_destination_rec.isc_width );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X08;             /* width set               */
   }
   if (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_height != adsp_sc_order_mem3blt->dsc_destination_rec.isc_height) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_rect.isc_height = adsp_sc_order_mem3blt->dsc_destination_rec.isc_height;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_destination_rec.isc_height );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X10;             /* height set              */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.ucc_brop3 != adsp_sc_order_mem3blt->ucc_brop3)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_mem3blt->ucc_brop3;  /* index of the ternary raster operation */
     *(achl_flags + 0) |= 0X20;
     D_ADSL_RCO1->dsc_ord_co_o0e.ucc_brop3 = adsp_sc_order_mem3blt->ucc_brop3;
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.isc_x_src != adsp_sc_order_mem3blt->isc_x_src)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.isc_x_src = adsp_sc_order_mem3blt->isc_x_src;
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->isc_x_src );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X40;             /* nXSrc set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.isc_y_src != adsp_sc_order_mem3blt->isc_y_src)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.isc_y_src = adsp_sc_order_mem3blt->isc_y_src;
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->isc_y_src );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X80;             /* nYSrc set               */
   }

   p_out_o_40:                              /* delta parameters set    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.umc_backcolor != adsp_sc_order_mem3blt->dsc_brush.umc_backcolor)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_brush.umc_backcolor );  /* background color */
     ADSL_OA1->achc_w1 += 3;
     *(achl_flags + 1) |= 0X01;             /* BackColor set           */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.umc_backcolor = adsp_sc_order_mem3blt->dsc_brush.umc_backcolor;
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.umc_forecolor != adsp_sc_order_mem3blt->dsc_brush.umc_forecolor)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_brush.umc_forecolor );  /* foreground color */
     ADSL_OA1->achc_w1 += 3;
     *(achl_flags + 1) |= 0X02;             /* BackColor set           */
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.umc_forecolor = adsp_sc_order_mem3blt->dsc_brush.umc_forecolor;
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.scc_brushorgx != adsp_sc_order_mem3blt->dsc_brush.scc_brushorgx)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.scc_brushorgx = adsp_sc_order_mem3blt->dsc_brush.scc_brushorgx;
     *(ADSL_OA1->achc_w1)++ = adsp_sc_order_mem3blt->dsc_brush.scc_brushorgx;
     *(achl_flags + 1) |= 0X04;             /* brush org x set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.scc_brushorgy != adsp_sc_order_mem3blt->dsc_brush.scc_brushorgy)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.scc_brushorgy = adsp_sc_order_mem3blt->dsc_brush.scc_brushorgy;
     *(ADSL_OA1->achc_w1)++ = adsp_sc_order_mem3blt->dsc_brush.scc_brushorgy;
     *(achl_flags + 1) |= 0X08;             /* brush org y set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.ucc_brushstyle != adsp_sc_order_mem3blt->dsc_brush.ucc_brushstyle)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.ucc_brushstyle = adsp_sc_order_mem3blt->dsc_brush.ucc_brushstyle;
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_mem3blt->dsc_brush.ucc_brushstyle;
     *(achl_flags + 1) |= 0X10;             /* brush style set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.ucc_brushhatch != adsp_sc_order_mem3blt->dsc_brush.ucc_brushhatch)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.ucc_brushhatch = adsp_sc_order_mem3blt->dsc_brush.ucc_brushhatch;
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_mem3blt->dsc_brush.ucc_brushhatch;
     *(achl_flags + 1) |= 0X20;             /* brush hatch set         */
   }
   if (   (memcmp( D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.chrc_brushextra, adsp_sc_order_mem3blt->dsc_brush.chrc_brushextra, DEF_CONST_O01_BRUSH_LEN ))
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     memcpy( D_ADSL_RCO1->dsc_ord_co_o0e.dsc_brush.chrc_brushextra, adsp_sc_order_mem3blt->dsc_brush.chrc_brushextra, DEF_CONST_O01_BRUSH_LEN );
     memcpy( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->dsc_brush.chrc_brushextra, DEF_CONST_O01_BRUSH_LEN );
     ADSL_OA1->achc_w1 += DEF_CONST_O01_BRUSH_LEN;
     *(achl_flags + 1) |= 0X40;             /* brush extra data set    */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0e.usc_cacheindex != adsp_sc_order_mem3blt->usc_cacheindex)
       || (D_ADSL_RCO1->dsc_ord_co_o0e.boc_set == FALSE)) {
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_mem3blt->usc_cacheindex );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X80;             /* cacheIndex set          */
     D_ADSL_RCO1->dsc_ord_co_o0e.usc_cacheindex = adsp_sc_order_mem3blt->usc_cacheindex;
   }
   D_ADSL_RCO1->dsc_ord_co_o0e.boc_set = TRUE;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_mem3blt()                                        */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.12 SaveBitmap (SAVEBITMAP_ORDER)         */
static void m_send_order_savebitmap( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_order_savebitmap *adsp_sc_order_savebitmap,
                                     char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (4 + 9 + 13)
   if ((adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_savebitmap->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X0B) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X0B;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X0B;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   *(ADSL_OA1->achc_w1)++ = 0;              /* clear encoding bytes    */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.umc_savedbitmappos != adsp_sc_order_savebitmap->umc_savedbitmapposition)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.umc_savedbitmappos = adsp_sc_order_savebitmap->umc_savedbitmapposition;  /* coordinate */
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_savebitmap->umc_savedbitmapposition );
     ADSL_OA1->achc_w1 += 4;
     *(achl_flags + 0) |= 0X01;             /* left set                */
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     if (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE) break;
     iml1 = adsp_sc_order_savebitmap->dsc_rectangle.isc_left - D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X02;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_savebitmap->dsc_rectangle.isc_top - D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X04;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_savebitmap->dsc_rectangle.isc_right - D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_right;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X08;           /* right set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_savebitmap->dsc_rectangle.isc_bottom - D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_bottom;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X10;           /* bottom set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_left = adsp_sc_order_savebitmap->dsc_rectangle.isc_left;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_top = adsp_sc_order_savebitmap->dsc_rectangle.isc_top;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_right = adsp_sc_order_savebitmap->dsc_rectangle.isc_right;  /* coordinate width */
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_bottom = adsp_sc_order_savebitmap->dsc_rectangle.isc_bottom;  /* coordinate height */
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_left != adsp_sc_order_savebitmap->dsc_rectangle.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_left = adsp_sc_order_savebitmap->dsc_rectangle.isc_left;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_savebitmap->dsc_rectangle.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X02;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_top != adsp_sc_order_savebitmap->dsc_rectangle.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_top = adsp_sc_order_savebitmap->dsc_rectangle.isc_top;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_savebitmap->dsc_rectangle.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X04;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_right != adsp_sc_order_savebitmap->dsc_rectangle.isc_right)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_right = adsp_sc_order_savebitmap->dsc_rectangle.isc_right;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_savebitmap->dsc_rectangle.isc_right );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X08;             /* right set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_bottom != adsp_sc_order_savebitmap->dsc_rectangle.isc_bottom)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.dsc_rect.isc_bottom = adsp_sc_order_savebitmap->dsc_rectangle.isc_bottom;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_savebitmap->dsc_rectangle.isc_bottom );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X10;             /* bottom set              */
   }

   p_out_o_40:                              /* delta parameters set    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o0b.ucc_operation != adsp_sc_order_savebitmap->ucc_operation)
       || (D_ADSL_RCO1->dsc_ord_co_o0b.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o0b.ucc_operation = adsp_sc_order_savebitmap->ucc_operation;  /* coordinate */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_savebitmap->ucc_operation;  /* output Operation */
     *(achl_flags + 0) |= 0X20;             /* Operation set           */
   }
   D_ADSL_RCO1->dsc_ord_co_o0b.boc_set = TRUE;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_savebitmap()                                     */

static void m_copy_to_outputarea(struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                 struct dsd_output_area_1 *adsp_output_area_1, 
                                 char* ach_src, int im_len, int iml_padd){
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   while(im_len){
      int iml1 = ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1 - iml_padd;
      if(iml1 <= 0){
         ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
         continue;
      }

      if(iml1 > im_len) 
         iml1 = im_len;

      memcpy(ADSL_OA1->achc_w1, ach_src, iml1);
      ADSL_OA1->achc_w1 += iml1;
      ach_src += iml1;
      im_len -= iml1;

#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
}

/* [MS-RDPEGDI] 2.2.2.2.1.2.3 Cache Bitmap - Revision 2 (CACHE_BITMAP_REV2_ORDER) */
static void m_send_order_cachebitmap( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1,
                                      struct dsd_sc_order_cachebitmap *adsp_sc_order_cachebitmap,
                                      char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3, iml4, iml5;  /* working variables      */
   int        iml_len_bm;                   /* length bitmap           */
   int        iml_width;                    /* width including padding */
   int        iml_padd;                     /* do padding at end of line */
   int        iml_len_line;                 /* length of line in bytes */
   int        iml_bpp;                      /* bytes per pixel         */
   char       *achl1, *achl2;               /* working variables       */
   char       *achl_start;                  /* address start of order  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   // Settings
   iml_bpp = ((int) adsp_sc_order_cachebitmap->iec_bitsperpixelid) - 2;
   iml_width = adsp_sc_order_cachebitmap->dsc_bitmap.usc_width;
   iml_len_line = iml_bpp * iml_width;            /* length of line in bytes, excluding padding */
   // Bitmappadding
   switch(iml_bpp){
   case 2: iml_width = (iml_width + 1) & (0 - 2);break;
   case 3: iml_width = (iml_width + 3) & (0 - 4);break;
   }
   iml_padd = (iml_width - adsp_sc_order_cachebitmap->dsc_bitmap.usc_width)
             * iml_bpp; /* Padding, in bytes. */

   iml_len_bm   = (iml_len_line + iml_padd)
                   * adsp_sc_order_cachebitmap->dsc_bitmap.usc_height;

   BOOL bol_compressed = (adsp_sc_order_cachebitmap->iec_compression != ied_scc_compression_raw);
   if(bol_compressed){
      iml_len_bm = adsp_sc_order_cachebitmap->dsc_bitmap.isc_scanline;
      iml_len_line = iml_len_bm;
      iml_padd = 0;
   }

#define D_OUT_LEN_1 (1 + 20 + iml_len_bm)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }

   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
#undef D_OUT_LEN_1

   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (1 + 20)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   // Beginning of 6 Bytes of Header of seconary drawing order: TS_STANDARD + TS_SECONDARY

   *(ADSL_OA1->achc_w1)++ = 0x03; // secondary drawing order.
   ADSL_OA1->achc_w1+= 2;      // leave space for length

   // two Bytes of extra flags following
   iml1 = CBR2_NO_BITMAP_COMPRESSION_HDR << (3 + 4);
   if (adsp_sc_order_cachebitmap->dsc_bitmap.usc_height
         == iml_width) {
     iml1 |= CBR2_HEIGHT_SAME_AS_WIDTH << (3 + 4);
   }
   if (adsp_sc_order_cachebitmap->boc_bitmapispersistent) {
     iml1 |= CBR2_PERSISTENT_KEY_PRESENT << (3 + 4);
   }
   if (adsp_sc_order_cachebitmap->boc_donotcache) {
     iml1 |= CBR2_DO_NOT_CACHE << (3 + 4);
   }
   m_put_le2( ADSL_OA1->achc_w1,
              (adsp_sc_order_cachebitmap->ucc_cacheid & 0x7)
                | (adsp_sc_order_cachebitmap->iec_bitsperpixelid << 3)
                | iml1 );
   ADSL_OA1->achc_w1 += 2;

   *ADSL_OA1->achc_w1++ = bol_compressed ? 0x05 : 0x04; // Order Type = TS_CACHE_BITMAP_UNCOMPRESSED_REV2
   // End of 6 Bytes Header of Secondary Drawing Order

   if (adsp_sc_order_cachebitmap->boc_bitmapispersistent) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_cachebitmap->umc_key1 );
     ADSL_OA1->achc_w1 += 4;
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_cachebitmap->umc_key2 );
     ADSL_OA1->achc_w1 += 4;
   }
   do {                                     /* pseudo-loop             */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml_width;  /* in one byte */
     if ((iml_width >> 7) == 0) break;      /* remove significant bits, check if fits in one byte */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml_width >> 8) | 0X80);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml_width;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   if (adsp_sc_order_cachebitmap->dsc_bitmap.usc_height != iml_width) {
     do {                                   /* pseudo-loop             */
       iml1 = adsp_sc_order_cachebitmap->dsc_bitmap.usc_height;  /* get parameter */
       *(ADSL_OA1->achc_w1) = (unsigned char) iml1;  /* in one byte    */
       if ((iml1 >> 7) == 0) break;         /* remove significant bits, check if fits in one byte */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml1 >> 8) | 0X80);  /* first byte output */
       *(ADSL_OA1->achc_w1) = (unsigned char) iml1;  /* second byte output */
     } while (FALSE);
     ADSL_OA1->achc_w1++;                   /* one byte length         */
   }
   /* output 2.2.2.2.1.2.1.4 Four-Byte Unsigned Encoding (FOUR_BYTE_UNSIGNED_ENCODING) */
   iml1 = iml_len_bm << 2;
   iml2 = 0;
   do {
     iml2++;
     iml1 >>= 8;
   } while (iml1 > 0);
   ADSL_OA1->achc_w1 += iml2;
   achl1 = ADSL_OA1->achc_w1;
   iml1 = iml_len_bm;
   iml3 = iml2 - 1;
   do {
     *(--achl1) = (unsigned char) iml1;
     iml1 >>= 8;
     iml2--;
   } while (iml2 > 0);
   *achl1 |= iml3 << 6;
   do {                                     /* pseudo-loop             */
     iml1 = adsp_sc_order_cachebitmap->usc_bitmapindex;  /* get parameter */
     iml2 = iml1;
     *(ADSL_OA1->achc_w1) = (unsigned char) iml1;  /* in one byte      */
     iml2 >>= 7;                            /* remove significant bits */
     if (iml2 == 0) break;                  /* fits in one byte      */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml1 >> 8) | 0X80);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml1;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   m_put_le2(achl_start+1, (ADSL_OA1->achc_w1 - achl_start) + iml_len_bm -13); // Order length, secondary drawing order.
   ADSL_OA1->imc_pdu_len += (ADSL_OA1->achc_w1 - achl_start) + iml_len_bm;  /* length of PDU */
   achl1 = (char *) adsp_sc_order_cachebitmap->dsc_bitmap.aucc_buffer;
   while (iml_len_bm > 0){
      m_copy_to_outputarea(adsp_hl_clib_1, ADSL_OA1, achl1, iml_len_line, iml_padd);
      iml_len_bm -= iml_len_line;
      achl1 += adsp_sc_order_cachebitmap->dsc_bitmap.isc_scanline;
      if(iml_padd > 0){                  /* Bitmappadding           */
         memset(ADSL_OA1->achc_w1, 0, iml_padd);
         ADSL_OA1->achc_w1 += iml_padd;
         iml_len_bm -= iml_padd;

      }
   }
/* 14.03.09 KB multiple work-areas */
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_cachebitmap()  */
/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */
static void m_send_order_cachebrush( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_order_cachebrush *adsp_sc_order_cachebrush,
                                     char *chrp_work ) {

   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3, iml4, iml5;  /* working variables      */
   int        iml_bytes;                    /* number of output bytes  */
   int        iml_width;                    /* width including padding */
   int        iml_len_line;                 /* length of line in bytes */
   int        iml_padd;                     /* do padding at end of line */
   char       *achl1, *achl2;               /* working variables       */
   char       *achl_start;                  /* address start of order  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */

#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   iml_bytes = 0;
   iml_padd = 0;
   iml4 = 0;
   iml_width = adsp_sc_order_cachebrush->dsc_bitmap.usc_width;
   ied_sc_bitsperpixel iel_bitsperpixelid;
   switch(adsp_sc_order_cachebrush->dsc_bitmap.isc_cl_coldep){
   case 1:
      iel_bitsperpixelid = ied_scc_cbr2_1bpp;
      iml_len_line = ((iml_width + 7) / 8);
      break;
   case 2:
      iel_bitsperpixelid = ied_scc_cbr2_2bpp;
      iml_len_line = (iml_width + 3) / 4;
      switch(D_ADSL_RCO1->imc_s_coldep){
        case 16:
          iml5 = 2;
          iml4 = 2 * 4;
          iel_bitsperpixelid = ied_scc_cbr2_16bpp;
          break;
        case 24:
          iml5 = 3;
          iml4 = 3 * 4;
          iel_bitsperpixelid = ied_scc_cbr2_24bpp;
          break;
        case 32:
          iml5 = 4;
          iml4 = 4 * 4;
          iel_bitsperpixelid = ied_scc_cbr2_32bpp;
          break;
      }
      break;
   case 8:
      iel_bitsperpixelid = ied_scc_cbr2_8bpp;
      iml_len_line = iml_width;
      break;
   case 16: 
      iel_bitsperpixelid = ied_scc_cbr2_16bpp;
      iml_len_line = iml_width * 2;
      iml_padd = ((iml_len_line + 3) & (0 - 4)) - iml_len_line;
      break;
   case 24:
     iel_bitsperpixelid = ied_scc_cbr2_24bpp;
     iml_len_line = iml_width * 3;
      iml_padd = ((iml_len_line + 3) & (0 - 4)) - iml_len_line;
      break;
   case 32:
     iel_bitsperpixelid = ied_scc_cbr2_32bpp;
      iml_len_line = iml_width * 4;
      break;
   default:
      /* Error! unknown bits per pixels ! */
      return; 
   };
   iml_bytes = (iml_len_line + iml_padd) * adsp_sc_order_cachebrush->dsc_bitmap.usc_height + iml4;

#define D_OUT_LEN_1  (1 + 20)
#define D_OUT_LEN_2  (D_OUT_LEN_1 + iml_bytes)
   if ((adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_2) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }

   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   // Beginning of 6 Bytes of Header of seconary drawing order: TS_STANDARD + TS_SECONDARY

   *(ADSL_OA1->achc_w1)++ = 0x03; // secondary drawing order. 
   ADSL_OA1->achc_w1+= 2;      // leave space for length

   // two Bytes of extra flags following
   m_put_le2( ADSL_OA1->achc_w1, 0);
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1++) = 0x7; // TS_CACHE_BRUSH
   // End of 6 Bytes Header of Secondary Drawing Order

   *(ADSL_OA1->achc_w1++) = adsp_sc_order_cachebrush->ucc_cacheid;
   *(ADSL_OA1->achc_w1++) = iel_bitsperpixelid;
   *(ADSL_OA1->achc_w1++) = adsp_sc_order_cachebrush->dsc_bitmap.usc_width;
   *(ADSL_OA1->achc_w1++) = adsp_sc_order_cachebrush->dsc_bitmap.usc_height;
   if(D_ADSL_RCO1->dsc_caps.dsc_hob.boc_order_ex_brush_size_field){
     m_put_le2( ADSL_OA1->achc_w1, iml_bytes);
     ADSL_OA1->achc_w1 += 2;
   } else {
     *(ADSL_OA1->achc_w1++) = 0;
     *(ADSL_OA1->achc_w1++) = iml_bytes;
   }
   int in_pdu_len = (ADSL_OA1->achc_w1 - achl_start) + iml_bytes;
   achl1 = (char *) adsp_sc_order_cachebrush->dsc_bitmap.aucc_buffer;
   iml1 = adsp_sc_order_cachebrush->dsc_bitmap.usc_height;
   while (iml1){
      m_copy_to_outputarea(adsp_hl_clib_1, ADSL_OA1, achl1, iml_len_line, iml_padd);
      achl1 += adsp_sc_order_cachebrush->dsc_bitmap.isc_scanline;
      if(iml_padd > 0){                  /* Bitmappadding           */
         memset(ADSL_OA1->achc_w1, 0, iml_padd);
         ADSL_OA1->achc_w1 += iml_padd;
      }
      iml1--;
   }
   if(iml4){
     for(iml3 = 0; iml3 < 4; iml3++){
       m_put_le4(ADSL_OA1->achc_w1, adsp_sc_order_cachebrush->aum_colormap[iml3]);
       ADSL_OA1->achc_w1 += iml5;

     }
   }
   m_put_le2(achl_start+1, in_pdu_len -13); // Order length, secondary drawing order. 


#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += in_pdu_len;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_cachebrush()  */

static BOOL m_send_order_new_font( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                   struct dsd_output_area_1 *adsp_output_area_1,
                                   struct dsd_font *adsp_font,
                                   char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */

   /* init AVL Tree functions session                                  */
   bol1 = m_htree1_avl_init( NULL, &adsp_font->dsc_htree1_avl_fo_gl,
                             &m_avl_cmp_unicode_char );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_new_font() m_htree1_avl_init() failed",
                   __LINE__, 38500);  /* line number for errors */
     return FALSE;
   }
   return TRUE;
} /* end m_send_order_new_font()                                       */

static BOOL m_send_order_delete_font( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1,
                                      struct dsd_font *adsp_font,
                                      char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   BOOL       bol_first;                    /* retrieve first entry    */
   struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
#endif

   bol_first = TRUE;                        /* retrieve first entry    */
   while (TRUE) {                           /* loop over all entries AVL-Tree */
     bol1 = m_htree1_avl_getnext( NULL, &adsp_font->dsc_htree1_avl_fo_gl,
                                  &dsl_htree1_work, bol_first );
     if (bol1 == FALSE) {                   /* error occured           */
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_delete_font() m_htree1_avl_getnext() failed",
                     __LINE__, 38535);  /* line number for errors */
       return FALSE;
     }
     if (dsl_htree1_work.adsc_found == NULL) return TRUE;  /* reached end of tree */
#define ADSL_GLYPH_G ((struct dsd_glyph *) ((char *) dsl_htree1_work.adsc_found\
 - (offsetof( struct dsd_glyph, dsc_fo_gl_avl ) + offsetof( struct dsd_fo_gl_avl, dsc_avl_e ))))
     D_ADSL_RCO1->adsrc_arr_glyph_e[ ADSL_GLYPH_G->ucc_arr_glyph_e ].usc_entries_deleted++;  /* number of filled deleted */
     ADSL_GLYPH_G->adsc_font = NULL;        /* font it belongs to or NULL if deleted */
#undef ADSL_GLYPH_G
     bol1 = m_htree1_avl_delete( NULL, &adsp_font->dsc_htree1_avl_fo_gl,
                                 &dsl_htree1_work );
     if (bol1 == FALSE) {                   /* error occured           */
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_delete_font() m_htree1_avl_delete() failed",
                     __LINE__, 38551);  /* line number for errors */
       return FALSE;
     }
     bol_first = FALSE;                     /* do not retrieve first entry */
   }
#undef ADSL_RDPA_F
} /* end m_send_order_delete_font()                                    */

static BOOL m_send_order_drawstring( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_order_drawstring *adsp_sc_order_drawstring,
                                     char *achp_work_area ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_index;                    /* count output index      */
   int        iml_distance;                 /* distance between characters */
   int        iml_bounds;                   /* flag set bounds         */
   int        iml_arr_glyph_e;              /* array glyph entry       */
   char       *achl1;                       /* working variable        */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   unsigned char ucl1;                      /* flag                    */
   signed short int isl_glyph_x_1;
   signed short int isl_glyph_x_2;
   signed short int isl_glyph_y_1;
   struct dsd_glyph *adsl_glyph_w1;
   struct dsd_rectrb dsl_backrect_1;
   struct dsd_rectrb dsl_opaqrect_1;
   struct dsd_cr_getstorglyph dsl_cr_getstorglyph;  /* pass parameters get storage glyph */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   struct dsd_fo_gl_avl dsl_fo_gl_avl;      /* for AVL tree            */
   struct dsd_get_unicode_char dsl_get_unicode_char;  /* retrieve next unicode character */
   struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   dsl_cr_getstorglyph.adsc_hl_clib_1 = adsp_hl_clib_1;  /* call parameters */
   dsl_cr_getstorglyph.adsc_font = adsp_sc_order_drawstring->adsc_font;  /* font used */
   memcpy( &dsl_backrect_1, &adsp_sc_order_drawstring->dsc_backrect, sizeof(struct dsd_rectrb) );
   memcpy( &dsl_opaqrect_1, &adsp_sc_order_drawstring->dsc_opaqrect, sizeof(struct dsd_rectrb) );
   isl_glyph_x_1 = adsp_sc_order_drawstring->isc_glyph_x;
   if (((unsigned short int) isl_glyph_x_1) == (1 << 15)) {
     isl_glyph_x_1 = adsp_sc_order_drawstring->dsc_backrect.isc_left;
   }
   isl_glyph_y_1 = adsp_sc_order_drawstring->isc_glyph_y;
   if (isl_glyph_y_1 == adsp_sc_order_drawstring->dsc_backrect.isc_top) {
     isl_glyph_y_1 = (unsigned short int) (1 << 15);
   }
// achl_start = NULL;                       /* no order yet            */
   iml_index = 0;                           /* count output index      */
   iml_arr_glyph_e = -1;                    /* array glyph entry invalid */
   memset( &dsl_get_unicode_char, 0, sizeof(struct dsd_get_unicode_char) );  /* retrieve next unicode character */
   dsl_get_unicode_char.iec_chs_out = ied_chs_utf_32;  /* character set output */
   dsl_get_unicode_char.ac_out = &dsl_fo_gl_avl.imc_unicode;  /* address of output area */
   dsl_get_unicode_char.adsc_unicode_string = &adsp_sc_order_drawstring->dsc_unicode_string;

   p_out_o_20:                              /* get next character      */
   m_get_unicode_char( &dsl_get_unicode_char );
   if (dsl_get_unicode_char.boc_error) {    /* error occured           */
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_drawstring() m_get_unicode_char() failed",
                   __LINE__, 38629);  /* line number for errors */
     return FALSE;                          /* return error            */
   }
   if (dsl_get_unicode_char.boc_eof) {      /* last unicode character retrieved */
     if (iml_index) {                       /* in output of Glyph Indices */
       goto p_index_20;                     /* close previous command  */
     }
     return TRUE;                           /* all done                */
   }
   isl_glyph_x_2 = isl_glyph_x_1;
   if (isl_glyph_x_1 == adsp_sc_order_drawstring->dsc_backrect.isc_left) {
     isl_glyph_x_2 = (unsigned short int) (1 << 15);
   }
   bol1 = m_htree1_avl_search( NULL, &adsp_sc_order_drawstring->adsc_font->dsc_htree1_avl_fo_gl,
                               &dsl_htree1_work, &dsl_fo_gl_avl.dsc_avl_e );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_drawstring() m_htree1_avl_search() failed",
                   __LINE__, 38646);  /* line number for errors */
     return FALSE;
   }
   if (dsl_htree1_work.adsc_found) {        /* found in tree           */
     goto p_index_00;                       /* output of index         */
   }
// dsl_cr_getstorglyph.imc_unicode = dsl_fo_gl_avl.imc_unicode;  /* UTF-32 of character */
   dsl_cr_getstorglyph.boc_sort = FALSE;    /* sort sequence not destroyed */
   adsl_glyph_w1
     = adsp_sc_order_drawstring->adsc_font->amc_cs_getglyph( adsp_hl_clib_1->vpc_userfld,
                                                             &dsl_cr_getstorglyph,
                                                             adsp_sc_order_drawstring->adsc_font,
                                                             dsl_fo_gl_avl.imc_unicode,
                                                             &m_cr_getstorglyph );
   if (adsl_glyph_w1 == NULL) return FALSE;  /* error occured          */
   adsl_glyph_w1->dsc_fo_gl_avl.imc_unicode = dsl_fo_gl_avl.imc_unicode;
   if (dsl_cr_getstorglyph.boc_sort) {      /* sort sequence destroyed */
     bol1 = m_htree1_avl_search( NULL, &adsp_sc_order_drawstring->adsc_font->dsc_htree1_avl_fo_gl,
                                 &dsl_htree1_work, &dsl_fo_gl_avl.dsc_avl_e );
     if (bol1 == FALSE) {                   /* error occured           */
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_drawstring() m_htree1_avl_search() failed",
                     __LINE__, 38671);  /* line number for errors */
       return FALSE;
     }
     if (dsl_htree1_work.adsc_found) return FALSE;  /* found in tree, program illogic */
   }
   bol1 = m_htree1_avl_insert( NULL, &adsp_sc_order_drawstring->adsc_font->dsc_htree1_avl_fo_gl,
                               &dsl_htree1_work, &adsl_glyph_w1->dsc_fo_gl_avl.dsc_avl_e );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d m_send_order_drawstring() m_htree1_avl_insert() failed",
                   __LINE__, 38680);  /* line number for errors */
     return FALSE;
   }
   if (iml_index) {                         /* in output of Glyph Indices */
     goto p_index_20;                       /* close previous command  */
   }

   p_out_o_24:                              /* continue new Glyph      */
   iml1 = (((adsl_glyph_w1->usc_cx + 7) >> 3) * adsl_glyph_w1->usc_cy + 3)
            & (0 - 4);
   if (iml1 == 0) iml1 = 4;                 /* needs padding           */
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + (4 + 9 + 29 + 1 + 1 + 4 * 2 + iml1)) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (4 + 9 + 29 + 1 + 1 + 4 * 2 + iml1)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_drawstring->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X18) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X18;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X18;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   *achl_flags = 0X00;                      /* clear encoding bytes    */
   *(achl_flags + 1) = 0X40;                /* clear encoding bytes    */
   ADSL_OA1->achc_w1 += 2;                  /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   if (   (adsl_glyph_w1->ucc_arr_glyph_e != D_ADSL_RCO1->dsc_ord_co_o18.ucc_cache_id)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsl_glyph_w1->ucc_arr_glyph_e;  /* array glyph entry */
     D_ADSL_RCO1->dsc_ord_co_o18.ucc_cache_id = adsl_glyph_w1->ucc_arr_glyph_e;
     *(achl_flags + 0) |= 0X01;             /* set encoding byte       */
   }
   iml1 = adsl_glyph_w1->ucc_char_inc | (adsp_sc_order_drawstring->ucc_flaccel << 8);
   if (   (iml1 != D_ADSL_RCO1->dsc_ord_co_o18.usc_fdrawing)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     m_put_le2( ADSL_OA1->achc_w1, iml1 );
     ADSL_OA1->achc_w1 += 2;
     D_ADSL_RCO1->dsc_ord_co_o18.usc_fdrawing = iml1;
     *(achl_flags + 0) |= 0X02;             /* set encoding byte       */
   }
   if (   (adsp_sc_order_drawstring->umc_backcolor != D_ADSL_RCO1->dsc_ord_co_o18.umc_backcolor)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_drawstring->umc_backcolor );  /* background color */
     ADSL_OA1->achc_w1 += 3;
     D_ADSL_RCO1->dsc_ord_co_o18.umc_backcolor = adsp_sc_order_drawstring->umc_backcolor;
     *(achl_flags + 0) |= 0X04;             /* set encoding byte       */
   }
   if (   (adsp_sc_order_drawstring->umc_forecolor != D_ADSL_RCO1->dsc_ord_co_o18.umc_forecolor)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_drawstring->umc_forecolor );  /* foreground color */
     ADSL_OA1->achc_w1 += 3;
     D_ADSL_RCO1->dsc_ord_co_o18.umc_forecolor = adsp_sc_order_drawstring->umc_forecolor;
     *(achl_flags + 0) |= 0X08;             /* set encoding byte       */
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     if (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE) break;
     iml1 = dsl_backrect_1.isc_left - D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X10;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_top - D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X20;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_right - D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_right;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X40;           /* right set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_bottom - D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_bottom;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X80;           /* bottom set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_left - D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X01;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_top - D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X02;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_right - D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_right;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X04;           /* right set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_bottom - D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_bottom;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X08;           /* bottom set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = isl_glyph_x_2 - D_ADSL_RCO1->dsc_ord_co_o18.isc_start_x;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X10;           /* x set                   */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = isl_glyph_y_1 - D_ADSL_RCO1->dsc_ord_co_o18.isc_start_y;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X20;           /* y set                   */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_left = dsl_backrect_1.isc_left;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_top = dsl_backrect_1.isc_top;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_right = dsl_backrect_1.isc_right;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_bottom = dsl_backrect_1.isc_bottom;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_left = dsl_opaqrect_1.isc_left;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_top = dsl_opaqrect_1.isc_top;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_right = dsl_opaqrect_1.isc_right;
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_bottom = dsl_opaqrect_1.isc_bottom;
     D_ADSL_RCO1->dsc_ord_co_o18.isc_start_x = isl_glyph_x_2;
     D_ADSL_RCO1->dsc_ord_co_o18.isc_start_y = isl_glyph_y_1;
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_left != dsl_backrect_1.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_left = dsl_backrect_1.isc_left;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X10;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_top != dsl_backrect_1.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_top = dsl_backrect_1.isc_top;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X20;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_right != dsl_backrect_1.isc_right)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_right = dsl_backrect_1.isc_right;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_right );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X40;             /* right set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_bottom != dsl_backrect_1.isc_bottom)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_backrect.isc_bottom = dsl_backrect_1.isc_bottom;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_bottom );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X80;             /* bottom set              */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_left != dsl_opaqrect_1.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_left = dsl_opaqrect_1.isc_left;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X01;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_top != dsl_opaqrect_1.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_top = dsl_opaqrect_1.isc_top;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X02;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_right != dsl_opaqrect_1.isc_right)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_right = dsl_opaqrect_1.isc_right;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_right );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X04;             /* right set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_bottom != dsl_opaqrect_1.isc_bottom)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.dsc_opaqrect.isc_bottom = dsl_opaqrect_1.isc_bottom;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_bottom );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X08;             /* bottom set              */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.isc_start_x != isl_glyph_x_2)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.isc_start_x = isl_glyph_x_2;
     m_put_le2( ADSL_OA1->achc_w1, isl_glyph_x_2 );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X10;             /* x set                   */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o18.isc_start_y != isl_glyph_y_1)
       || (D_ADSL_RCO1->dsc_ord_co_o18.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o18.isc_start_y = isl_glyph_y_1;
     m_put_le2( ADSL_OA1->achc_w1, isl_glyph_y_1 );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X20;             /* y set                   */
   }
   D_ADSL_RCO1->dsc_ord_co_o18.boc_set = TRUE;

   p_out_o_40:                              /* delta parameters set    */
   ADSL_OA1->achc_w1++;                     /* leave space for length  */
   achl1 = ADSL_OA1->achc_w1;               /* save start of fields    */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsl_glyph_w1->ucc_char_inc;  /* cacheIndex */
   do {                                     /* pseudo-loop             */
     iml2 = adsl_glyph_w1->usc_x;           /* get parameter           */
     ucl1 = 0;                              /* is positive             */
     if (iml2 < 0) {                        /* is negative             */
       iml2 = 0 - iml2;
       ucl1 = 0X40;                         /* is negative             */
     }
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2 | ucl1;  /* in one byte */
     if ((iml2 >> 6) == 0) break;           /* fits in one byte      */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80 | ucl1);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   do {                                     /* pseudo-loop             */
     iml2 = adsl_glyph_w1->usc_y;           /* get parameter           */
     ucl1 = 0;                              /* is positive             */
     if (iml2 < 0) {                        /* is negative             */
       iml2 = 0 - iml2;
       ucl1 = 0X40;                         /* is negative             */
     }
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2 | ucl1;  /* in one byte */
     if ((iml2 >> 6) == 0) break;           /* fits in one byte      */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80 | ucl1);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   do {                                     /* pseudo-loop             */
     iml2 = adsl_glyph_w1->usc_cx;          /* get parameter           */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* in one byte      */
     if ((iml2 >> 7) == 0) break;           /* fits in one byte      */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   do {                                     /* pseudo-loop             */
     iml2 = adsl_glyph_w1->usc_cy;          /* get parameter           */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* in one byte      */
     if ((iml2 >> 7) == 0) break;           /* fits in one byte      */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);  /* first byte output */
     *(ADSL_OA1->achc_w1) = (unsigned char) iml2;  /* second byte output */
   } while (FALSE);
   ADSL_OA1->achc_w1++;                     /* one byte length         */
   iml1 = ((adsl_glyph_w1->usc_cx + 7) >> 3) * adsl_glyph_w1->usc_cy;
   iml2 = 4;                                /* if no pixels, just insert zeroes */
   if (iml1 > 0) {                          /* something to copy       */
     memcpy( ADSL_OA1->achc_w1, adsl_glyph_w1 + 1, iml1 ),
     ADSL_OA1->achc_w1 += iml1;
     iml2 = ((iml1 + 3) & (0 - 4)) - iml1;  /* size of padding         */
   }
   if (iml2) {                              /* needs padding           */
     memset( ADSL_OA1->achc_w1, 0, iml2 );
     ADSL_OA1->achc_w1 += iml2;
   }
   m_put_le2( ADSL_OA1->achc_w1, adsl_glyph_w1->dsc_fo_gl_avl.imc_unicode );  /* Unicode UTF-16 */
   ADSL_OA1->achc_w1 += 2;
   *(achl1 - 1) = (unsigned char) (ADSL_OA1->achc_w1 - achl1);  /* set length of fields */
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   iml1 = adsp_sc_order_drawstring->adsc_font->ucc_ulcharinc;
   if (iml1 == 0) iml1 = adsl_glyph_w1->usc_distance;
   isl_glyph_x_1 += iml1;                   /* add increment x         */
   memset( &dsl_opaqrect_1, 0, sizeof(struct dsd_rectrb) );
   iml_arr_glyph_e = -1;                    /* array glyph entry invalid */
// to-do 03.01.10 KB remove
//   goto p_out_o_20;                       /* get next character      */
   if (adsp_sc_order_drawstring->boc_update_scrbuf == FALSE) {  // Specifies whether the local screen buffer should be changed.
     goto p_out_o_20;                       /* get next character      */
   }
   D_ADSL_RSE1->achc_prot_1 = (char *) adsl_glyph_w1;  /* pass parameter */
   bol1 = dsrs_progaddr_1[ D_ADSL_RCO1->imc_bpp - 1 ].amrc_r5_ord_x[ 0X18 ]( adsp_hl_clib_1, achp_work_area );
   if (bol1) goto p_out_o_20;               /* get next character      */
   return FALSE;                            /* error occured           */

   p_index_00:                              /* output of index         */
   /* put this glyph at end of chain because last recently used        */
#define ADSL_GLYPH_G ((struct dsd_glyph *) dsl_htree1_work.adsc_found)
   if (ADSL_GLYPH_G->adsc_rem_ch_next) {    /* is not last in chain    */
     if (ADSL_GLYPH_G->adsc_rem_ch_prev == NULL) {
       D_ADSL_RCO1->adsrc_arr_glyph_e[ ADSL_GLYPH_G->ucc_arr_glyph_e ].adsc_glyph_first
         = ADSL_GLYPH_G->adsc_rem_ch_next;
     } else {
       ADSL_GLYPH_G->adsc_rem_ch_prev->adsc_rem_ch_next
         = ADSL_GLYPH_G->adsc_rem_ch_next;
     }
     ADSL_GLYPH_G->adsc_rem_ch_next->adsc_rem_ch_prev
       = ADSL_GLYPH_G->adsc_rem_ch_prev;
     /* put at end of chain                                            */
     ADSL_GLYPH_G->adsc_rem_ch_prev
       = D_ADSL_RCO1->adsrc_arr_glyph_e[ ADSL_GLYPH_G->ucc_arr_glyph_e ].adsc_glyph_last;
     D_ADSL_RCO1->adsrc_arr_glyph_e[ ADSL_GLYPH_G->ucc_arr_glyph_e ].adsc_glyph_last->adsc_rem_ch_next
       = ADSL_GLYPH_G;
     D_ADSL_RCO1->adsrc_arr_glyph_e[ ADSL_GLYPH_G->ucc_arr_glyph_e ].adsc_glyph_last
       = ADSL_GLYPH_G;
     ADSL_GLYPH_G->adsc_rem_ch_next = NULL;
   }
   if (iml_arr_glyph_e >= 0) {              /* array glyph entry valid */
     if (iml_arr_glyph_e != ADSL_GLYPH_G->ucc_arr_glyph_e) {  /* compare array glyph entry */
       goto p_index_20;                     /* close previous command  */
     }
   }
#undef ADSL_GLYPH_G
   if (iml_index == 0) goto p_index_40;     /* open new command        */
   iml1 = 0;
   if (adsp_sc_order_drawstring->adsc_font->ucc_ulcharinc == 0) iml1 = 3;
   if (iml_index < (256 - 1 - iml1)) goto p_index_80;  /* output of one Glyph Index */

   p_index_20:                              /* close previous command  */
   *(ADSL_OA1->achc_w1 - iml_index - 1) = (unsigned char) iml_index;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   if (adsp_sc_order_drawstring->boc_update_scrbuf) {  // Specifies whether the local screen buffer should be changed.
     D_ADSL_RSE1->imc_prot_1 = iml_index;   /* pass number of glyphs   */
     D_ADSL_RSE1->imc_prot_2 = iml_arr_glyph_e;  /* pass cache index   */
     D_ADSL_RSE1->achc_prot_1 = ADSL_OA1->achc_w1 - iml_index;  /* pass parameter */
     bol1 = dsrs_progaddr_1[ D_ADSL_RCO1->imc_bpp - 1 ].amrc_r5_ord_x[ 0X13 ]( adsp_hl_clib_1, achp_work_area );
     if (bol1 == FALSE) return FALSE;       /* error occured           */
   }
   if (dsl_get_unicode_char.boc_eof) {      /* last unicode character retrieved */
     return TRUE;                           /* all done                */
   }
   iml_index = 0;                           /* count output index      */
   if (dsl_htree1_work.adsc_found == NULL) {  /* not found in tree     */
     goto p_out_o_24;                       /* continue new Glyph      */
   }

   p_index_40:                              /* open new command        */
   /* 2.2.2.2.1.1.2.14 FastIndex (FASTINDEX_ORDER)                     */
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + (4 + 9 + 285)) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (4 + 9 + 285)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_drawstring->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X13) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X13;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X13;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   *achl_flags = 0X00;                      /* clear encoding bytes    */
   *(achl_flags + 1) = 0X40;                /* clear encoding bytes    */
   ADSL_OA1->achc_w1 += 2;                  /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
#define ADSL_GLYPH_G ((struct dsd_glyph *) dsl_htree1_work.adsc_found)
   iml_arr_glyph_e = ADSL_GLYPH_G->ucc_arr_glyph_e;  /* array glyph entry */
#undef ADSL_GLYPH_G
   if (   (iml_arr_glyph_e != D_ADSL_RCO1->dsc_ord_co_o13.ucc_cache_id)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     *(ADSL_OA1->achc_w1)++ = (unsigned char) iml_arr_glyph_e;  /* array glyph entry */
     D_ADSL_RCO1->dsc_ord_co_o13.ucc_cache_id = iml_arr_glyph_e;
     *(achl_flags + 0) |= 0X01;             /* set encoding byte       */
   }
   iml1 = adsp_sc_order_drawstring->adsc_font->ucc_ulcharinc | (adsp_sc_order_drawstring->ucc_flaccel << 8);
   if (   (iml1 != D_ADSL_RCO1->dsc_ord_co_o13.usc_fdrawing)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     m_put_le2( ADSL_OA1->achc_w1, iml1 );
     ADSL_OA1->achc_w1 += 2;
     D_ADSL_RCO1->dsc_ord_co_o13.usc_fdrawing = iml1;
     *(achl_flags + 0) |= 0X02;             /* set encoding byte       */
   }
   if (   (adsp_sc_order_drawstring->umc_backcolor != D_ADSL_RCO1->dsc_ord_co_o13.umc_backcolor)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_drawstring->umc_backcolor );  /* background color */
     ADSL_OA1->achc_w1 += 3;
     D_ADSL_RCO1->dsc_ord_co_o13.umc_backcolor = adsp_sc_order_drawstring->umc_backcolor;
     *(achl_flags + 0) |= 0X04;             /* set encoding byte       */
   }
   if (   (adsp_sc_order_drawstring->umc_forecolor != D_ADSL_RCO1->dsc_ord_co_o13.umc_forecolor)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_drawstring->umc_forecolor );  /* foreground color */
     ADSL_OA1->achc_w1 += 3;
     D_ADSL_RCO1->dsc_ord_co_o13.umc_forecolor = adsp_sc_order_drawstring->umc_forecolor;
     *(achl_flags + 0) |= 0X08;             /* set encoding byte       */
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     if (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE) break;
     iml1 = dsl_backrect_1.isc_left - D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X10;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_top - D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X20;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_right - D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_right;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X40;           /* right set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_backrect_1.isc_bottom - D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_bottom;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X80;           /* bottom set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_left - D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X01;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_top - D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X02;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_right - D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_right;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X04;           /* right set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = dsl_opaqrect_1.isc_bottom - D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_bottom;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X08;           /* bottom set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = isl_glyph_x_2 - D_ADSL_RCO1->dsc_ord_co_o13.isc_start_x;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X10;           /* x set                   */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = isl_glyph_y_1 - D_ADSL_RCO1->dsc_ord_co_o13.isc_start_y;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 1) |= 0X20;           /* y set                   */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_left = dsl_backrect_1.isc_left;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_top = dsl_backrect_1.isc_top;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_right = dsl_backrect_1.isc_right;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_bottom = dsl_backrect_1.isc_bottom;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_left = dsl_opaqrect_1.isc_left;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_top = dsl_opaqrect_1.isc_top;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_right = dsl_opaqrect_1.isc_right;
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_bottom = dsl_opaqrect_1.isc_bottom;
     D_ADSL_RCO1->dsc_ord_co_o13.isc_start_x = isl_glyph_x_2;
     D_ADSL_RCO1->dsc_ord_co_o13.isc_start_y = isl_glyph_y_1;
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_index_60;                       /* delta parameters set    */
   }
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_left != dsl_backrect_1.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_left = dsl_backrect_1.isc_left;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X10;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_top != dsl_backrect_1.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_top = dsl_backrect_1.isc_top;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X20;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_right != dsl_backrect_1.isc_right)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_right = dsl_backrect_1.isc_right;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_right );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X40;             /* right set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_bottom != dsl_backrect_1.isc_bottom)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_backrect.isc_bottom = dsl_backrect_1.isc_bottom;
     m_put_le2( ADSL_OA1->achc_w1, dsl_backrect_1.isc_bottom );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X80;             /* bottom set              */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_left != dsl_opaqrect_1.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_left = dsl_opaqrect_1.isc_left;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X01;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_top != dsl_opaqrect_1.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_top = dsl_opaqrect_1.isc_top;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X02;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_right != dsl_opaqrect_1.isc_right)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_right = dsl_opaqrect_1.isc_right;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_right );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X04;             /* right set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_bottom != dsl_opaqrect_1.isc_bottom)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.dsc_opaqrect.isc_bottom = dsl_opaqrect_1.isc_bottom;
     m_put_le2( ADSL_OA1->achc_w1, dsl_opaqrect_1.isc_bottom );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X08;             /* bottom set              */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.isc_start_x != isl_glyph_x_2)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.isc_start_x = isl_glyph_x_2;
     m_put_le2( ADSL_OA1->achc_w1, isl_glyph_x_2 );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X10;             /* x set                   */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o13.isc_start_y != isl_glyph_y_1)
       || (D_ADSL_RCO1->dsc_ord_co_o13.boc_set == FALSE)) {
     D_ADSL_RCO1->dsc_ord_co_o13.isc_start_y = isl_glyph_y_1;
     m_put_le2( ADSL_OA1->achc_w1, isl_glyph_y_1 );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 1) |= 0X20;             /* y set                   */
   }
   D_ADSL_RCO1->dsc_ord_co_o13.boc_set = TRUE;

   p_index_60:                              /* delta parameters set    */
   ADSL_OA1->achc_w1++;                     /* leave space for length  */
   iml_distance = 0;                        /* distance between characters */

   p_index_80:                              /* output of one Glyph Index */
#define ADSL_GLYPH_G ((struct dsd_glyph *) dsl_htree1_work.adsc_found)
   achl1 = ADSL_OA1->achc_w1;               /* save start output       */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) ADSL_GLYPH_G->ucc_char_inc;
   iml1 = adsp_sc_order_drawstring->adsc_font->ucc_ulcharinc;
   if (iml1 == 0) {
     do {                                   /* pseudo-loop             */
       *(ADSL_OA1->achc_w1) = (unsigned char) iml_distance;
       if ((iml_distance >> 7) == 0) break;
       *(ADSL_OA1->achc_w1) = (unsigned char) 0X80;
       m_put_le2( ADSL_OA1->achc_w1 + 1, iml_distance );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     ADSL_OA1->achc_w1++;
     iml1 = iml_distance = ADSL_GLYPH_G->usc_distance;
   }
   isl_glyph_x_1 += iml1;                   /* add increment x         */
   iml_index += ADSL_OA1->achc_w1 - achl1;  /* count output index      */
   memset( &dsl_opaqrect_1, 0, sizeof(struct dsd_rectrb) );
   goto p_out_o_20;                         /* get next character      */
#undef ADSL_GLYPH_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_drawstring()                                     */

static void m_send_mpoi_system( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                struct dsd_output_area_1 *adsp_output_area_1,
                                struct dsd_sc_mpoi_system *adsp_sc_mpoi_system,
                                char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   char       *achl_out_1;                  /* output-area             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml1 = 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0 + 26;  /* size of packet */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < iml1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     return;                                /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* here starts packet */
   achl_out_1 = ADSL_OA1->achc_w1;          /* save start of packet    */
   ADSL_OA1->achc_w1 += iml1;               /* compute end of packet   */
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* here is end of packet */
   *achl_out_1 = DEF_CONST_RDP_03;
   *(achl_out_1 + 1) = 0;                   /* second byte zero        */
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2, iml1 );
   memcpy( achl_out_1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(achl_out_1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   achl_out_1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( achl_out_1, D_USERID_SE2CL );
   achl_out_1 += 2;
   m_put_be2( achl_out_1, D_ADSL_RCO1->usc_chno_disp );
   achl_out_1 += 2;
   *achl_out_1++ = 0X30;                    /* priority / segmentation */
   *achl_out_1++ = (unsigned char) (iml1 - (4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1));  /* remaining length */
   memset( achl_out_1, 0, 4 );              /* type output, second byte output + padding */
   /* make part at end                                                 */
   achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_end - 26;  /* here starts payload */
   memset( achl_out_1, 0, 26 - 4 );  /* clear area          */
   m_put_le4( achl_out_1 + 26 - 4, adsp_sc_mpoi_system->iec_system_pointer_type );  /* set error number */
   *(achl_out_1 + 0) = (unsigned char) 26;  /* set length   */
   *(achl_out_1 + 12) = (unsigned char) 26;  /* set length  */
   *(achl_out_1 + 2) = (unsigned char) 0X17;  /* pduType PDUTYPE_DATAPDU */
   *(achl_out_1 + 11) = (unsigned char) 1;  /* streaming               */
   *(achl_out_1 + 14) = (unsigned char) 0x1b;  /* pduType2 PDUTYPE2_POINTER */
   *(achl_out_1 + 18) = (unsigned char) 0x1;  /* pduType2 PDUTYPE2_POINTER */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_cur
                    + 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0;
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_SHA1 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 26 );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_1 + D_SIZE_HASH, 0, 26 );
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_1, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_1 + D_SIZE_HASH, 0, 26, achl_out_1 + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
     *(achl_out_1 - 4) = (unsigned char) 0X08;  /* output encrypted    */
   }
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_mpoi_system()                                          */

static void m_send_mpoi_position( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  struct dsd_sc_mpoi_position *adsp_sc_mpoi_position,
                                  char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   m_check_fastpath_frame( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (1 + 2 + 4)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 8;  /* FASTPATH_UPDATETYPE_PTR_POSITION */
   m_put_le2( ADSL_OA1->achc_w1, 4 );       /* length of following data excluding length */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_position->isc_x_pos );  /* X position mouse cursor */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_position->isc_y_pos );  /* Y position mouse cursor */
   ADSL_OA1->achc_w1 += 2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_mpoi_position()                                        */

static BOOL m_send_mpoi_color( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                               struct dsd_output_area_1 *adsp_output_area_1,
                               struct dsd_sc_mpoi_color *adsp_sc_mpoi_color,
                               char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   char       *achl1, *achl2;               /* working variables       */
   char       *achl_out_1;                  /* output-area             */
   char       *achl_out_start;              /* start of output-area    */
   int        iml_out_len;                  /* length output           */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   m_check_fastpath_frame( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   if (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA) {  /* compression enabled */
     goto p_compr_00;                       /* output compressed       */
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (1 + 2 + 14)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 9;  /* FASTPATH_UPDATETYPE_PTR_COLOR */
   m_put_le2( ADSL_OA1->achc_w1, 0 + 14     /* length of following data excluding length */
                                   + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_and_mask
                                   + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_xor_mask );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_cache_index );  /* cache entry in the pointer cache in which to store the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.isc_hotspot_x );  /* X coordinate of the pointer hotspot */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.isc_hotspot_y );  /* Y coordinate of the pointer hotspot */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_width );  /* Width of the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_height );  /* Height of the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_and_mask );  /* Size of the AND mask (in bytes) */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_xor_mask );  /* Size of the XOR mask (in bytes) */
   ADSL_OA1->achc_w1 += 2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
   iml1 = 1;                                /* set index what to do    */
   achl1 = (char *) adsp_sc_mpoi_color->dsc_color_ptr_attr.ac_xor_mask_data;  /* Contains the XOR mask (bottom-up) */
   achl2 = achl1 + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_xor_mask;  /* Size of the XOR mask (in bytes) */

   p_out_mpc_00:                            /* output part of the data */
   if (ADSL_OA1->achc_w2 <= ADSL_OA1->achc_w1) {  /* get new area      */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   iml2 = ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1;
   iml3 = achl2 - achl1;                    /* length of data to copy  */
   if (iml2 > iml3) iml2 = iml3;
   memcpy( ADSL_OA1->achc_w1, achl1, iml2 );
   ADSL_OA1->achc_w1 += iml2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
   achl1 += iml2;
   if (achl1 < achl2) goto p_out_mpc_00;    /* output part of the data */
   iml1--;                                  /* decrement index what to do */
   if (iml1 < 0) return TRUE;               /* all done                */
   achl1 = (char *) adsp_sc_mpoi_color->dsc_color_ptr_attr.ac_and_mask_data;  /* Contains the 1 bpp AND mask (bottom-up, 2 byte boundary) */
   achl2 = achl1 + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_and_mask;  /* Size of the AND mask (in bytes) */
   goto p_out_mpc_00;                       /* output part of the data */

   p_compr_00:                              /* output compressed       */
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
   m_put_le2( chrp_work + 0, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_cache_index );  /* cache entry in the pointer cache in which to store the pointer */
   m_put_le2( chrp_work + 2, adsp_sc_mpoi_color->dsc_color_ptr_attr.isc_hotspot_x );  /* X coordinate of the pointer hotspot */
   m_put_le2( chrp_work + 4, adsp_sc_mpoi_color->dsc_color_ptr_attr.isc_hotspot_y );  /* Y coordinate of the pointer hotspot */
   m_put_le2( chrp_work + 6, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_width );  /* Width of the pointer */
   m_put_le2( chrp_work + 8, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_height );  /* Height of the pointer */
   m_put_le2( chrp_work + 10, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_and_mask );  /* Size of the AND mask (in bytes) */
   m_put_le2( chrp_work + 12, adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_xor_mask );  /* Size of the XOR mask (in bytes) */
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 16) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   /* do compression now                                               */
   iml1 = 2;                                /* index of input          */
   iml_out_len = 0;                         /* clear length output     */
   achl_out_start = ADSL_OA1->achc_w1;      /* start of output-area    */
   achl_out_1 = ADSL_OA1->achc_w1 + 4;      /* output-area             */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = chrp_work;
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = chrp_work + 14;
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = FALSE;  /* not yet end-of-record input */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1 - 1;  /* address act output-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   while (TRUE) {                           /* loop over input data    */
     if (D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa >= D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe) {
       iml1--;                              /* next input              */
       if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break; /* end of input reached */
       if (iml1 > 0) {                      /* first part              */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
           = (char *) adsp_sc_mpoi_color->dsc_color_ptr_attr.ac_xor_mask_data;  /* Contains the XOR mask (bottom-up) */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe
           = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
               + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_xor_mask;  /* Size of the XOR mask (in bytes) */
       } else if (iml1 == 0) {              /* second part             */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
           = (char *) adsp_sc_mpoi_color->dsc_color_ptr_attr.ac_and_mask_data;  /* Contains the 1 bpp AND mask (bottom-up, 2 byte boundary) */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe
           = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
               + adsp_sc_mpoi_color->dsc_color_ptr_attr.usc_length_and_mask;  /* Size of the AND mask (in bytes) */
         D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
       }
     }
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 39681,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     iml_out_len += D_ADSL_RCO1->dsc_cdrf_enc.achc_outa - achl_out_1;
     achl_out_1 = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     ADSL_OA1->achc_w1 = achl_out_1;
//   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
//   ADSL_GAI1_OUT_G->achc_ginp_end = achl_out_1;  /* set end of output */
     if (achl_out_1 < ADSL_OA1->achc_w2) continue;  /* still space in output-area */
//   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     /* get new block for more output                                  */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* nothing more to do      */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
#undef ADSL_GAI1_OUT_G
     achl_out_1 = ADSL_OA1->achc_w1;        /* here is next output     */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1;  /* address act output-data */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   }
   *(achl_out_start + 0) = (unsigned char) (9 | 0X80);  /* FASTPATH_UPDATETYPE_PTR_COLOR */
   *(achl_out_start + 1) = *(achl_out_start + 4 - 1);  /* compression header */
   m_put_le2( achl_out_start + 2, iml_out_len );  /* length of following data excluding length */
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_mpoi_color()                                           */

/* 2.2.9.1.2.1.8 FASTPATH_UPDATETYPE_POINTER                           */
static BOOL m_send_mpoi_pointer( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                 struct dsd_output_area_1 *adsp_output_area_1,
                                 struct dsd_sc_mpoi_pointer *adsp_sc_mpoi_pointer,
                                 char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   char       *achl1, *achl2;               /* working variables       */
   char       *achl_out_1;                  /* output-area             */
   char       *achl_out_start;              /* start of output-area    */
   int        iml_out_len;                  /* length output           */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   m_check_fastpath_frame( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   if (D_ADSL_RCO1->umc_loinf_options & D_LOINFO_COMPR_ENA) {  /* compression enabled */
     goto p_compr_00;                       /* output compressed       */
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (1 + 2 + 16)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 11;  /* FASTPATH_UPDATETYPE_POINTER */
   m_put_le2( ADSL_OA1->achc_w1, 0 + 16     /* length of following data excluding length */
                                   + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_and_mask
                                   + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_xor_mask );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->usc_xor_bpp );  /* Colordepth in bpp of the XOR mask */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_cache_index );  /* cache entry in the pointer cache in which to store the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.isc_hotspot_x );  /* X coordinate of the pointer hotspot */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.isc_hotspot_y );  /* Y coordinate of the pointer hotspot */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_width );  /* Width of the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_height );  /* Height of the pointer */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_and_mask );  /* Size of the AND mask (in bytes) */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_xor_mask );  /* Size of the XOR mask (in bytes) */
   ADSL_OA1->achc_w1 += 2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
   iml1 = 1;                                /* set index what to do    */
   achl1 = (char *) adsp_sc_mpoi_pointer->dsc_color_ptr_attr.ac_xor_mask_data;  /* Contains the XOR mask (bottom-up) */
   achl2 = achl1 + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_xor_mask;  /* Size of the XOR mask (in bytes) */

   p_out_mpc_00:                            /* output part of the data */
   if (ADSL_OA1->achc_w2 <= ADSL_OA1->achc_w1) {  /* get new area      */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   iml2 = ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1;
   iml3 = achl2 - achl1;                    /* length of data to copy  */
   if (iml2 > iml3) iml2 = iml3;
   memcpy( ADSL_OA1->achc_w1, achl1, iml2 );
   ADSL_OA1->achc_w1 += iml2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
   achl1 += iml2;
   if (achl1 < achl2) goto p_out_mpc_00;    /* output part of the data */
   iml1--;                                  /* decrement index what to do */
   if (iml1 < 0) return TRUE;               /* all done                */
   achl1 = (char *) adsp_sc_mpoi_pointer->dsc_color_ptr_attr.ac_and_mask_data;  /* Contains the 1 bpp AND mask (bottom-up, 2 byte boundary) */
   achl2 = achl1 + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_and_mask;  /* Size of the AND mask (in bytes) */
   goto p_out_mpc_00;                       /* output part of the data */

   p_compr_00:                              /* output compressed       */
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
   m_put_le2( chrp_work + 0, adsp_sc_mpoi_pointer->usc_xor_bpp );  /* Colordepth in bpp of the XOR mask */
   m_put_le2( chrp_work + 2, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_cache_index );  /* cache entry in the pointer cache in which to store the pointer */
   m_put_le2( chrp_work + 4, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.isc_hotspot_x );  /* X coordinate of the pointer hotspot */
   m_put_le2( chrp_work + 6, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.isc_hotspot_y );  /* Y coordinate of the pointer hotspot */
   m_put_le2( chrp_work + 8, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_width );  /* Width of the pointer */
   m_put_le2( chrp_work + 10, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_height );  /* Height of the pointer */
   m_put_le2( chrp_work + 12, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_and_mask );  /* Size of the AND mask (in bytes) */
   m_put_le2( chrp_work + 14, adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_xor_mask );  /* Size of the XOR mask (in bytes) */
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 16) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   /* do compression now                                               */
   iml1 = 2;                                /* index of input          */
   iml_out_len = 0;                         /* clear length output     */
   achl_out_start = ADSL_OA1->achc_w1;      /* start of output-area    */
   achl_out_1 = ADSL_OA1->achc_w1 + 4;      /* output-area             */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = chrp_work;
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = chrp_work + 16;
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = FALSE;  /* not yet end-of-record input */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1 - 1;  /* address act output-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   while (TRUE) {                           /* loop over input data    */
     if (D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa >= D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe) {
       iml1--;                              /* next input              */
       if (D_ADSL_RCO1->dsc_cdrf_enc.boc_sr_flush) break; /* end of input reached */
       if (iml1 > 0) {                      /* first part              */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
           = (char *) adsp_sc_mpoi_pointer->dsc_color_ptr_attr.ac_xor_mask_data;  /* Contains the XOR mask (bottom-up) */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe
           = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
               + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_xor_mask;  /* Size of the XOR mask (in bytes) */
       } else if(iml1 == 0) {               /* second part             */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
           = (char *) adsp_sc_mpoi_pointer->dsc_color_ptr_attr.ac_and_mask_data;  /* Contains the 1 bpp AND mask (bottom-up, 2 byte boundary) */
         D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe
           = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa
               + adsp_sc_mpoi_pointer->dsc_color_ptr_attr.usc_length_and_mask;  /* Size of the AND mask (in bytes) */
         D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
       }
     }
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 39877,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     iml_out_len += D_ADSL_RCO1->dsc_cdrf_enc.achc_outa - achl_out_1;
     achl_out_1 = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
     ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     ADSL_OA1->achc_w1 = achl_out_1;
//   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
//   ADSL_GAI1_OUT_G->achc_ginp_end = achl_out_1;  /* set end of output */
     if (achl_out_1 < ADSL_OA1->achc_w2) continue;  /* still space in output-area */
//   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     /* get new block for more output                                  */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* nothing more to do      */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
#undef ADSL_GAI1_OUT_G
     achl_out_1 = ADSL_OA1->achc_w1;        /* here is next output     */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1;  /* address act output-data */
     D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   }
   *(achl_out_start + 0) = (unsigned char) (11 | 0X80);  /* FASTPATH_UPDATETYPE_POINTER */
   *(achl_out_start + 1) = *(achl_out_start + 4 - 1);  /* compression header */
   m_put_le2( achl_out_start + 2, iml_out_len );  /* length of following data excluding length */
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_mpoi_pointer()                                         */

/* 2.2.9.1.2.1.9 FASTPATH_UPDATETYPE_CACHED                            */
static void m_send_mpoi_cached( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                struct dsd_output_area_1 *adsp_output_area_1,
                                struct dsd_sc_mpoi_cached *adsp_sc_mpoi_cached,
                                char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   m_check_fastpath_frame( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < (1 + 2 + 16)) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 10;  /* FASTPATH_UPDATETYPE_CACHED */
   m_put_le2( ADSL_OA1->achc_w1, 0 + 2 );   /* length of following data excluding length */
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_mpoi_cached->usc_cache_index );  /* cache entry in the pointer cache */
   ADSL_OA1->achc_w1 += 2;
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_mpoi_cached()                                          */

/* [MS-RDPBCGR] 2.2.5.1.1 Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU) */
static void m_send_error_info( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                               struct dsd_output_area_1 *adsp_output_area_1,
                               struct dsd_sc_error_info *adsp_sc_error_info,
                               char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   char       *achl_out_1;                  /* output-area             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml1 = 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0 + 22;  /* size of packet */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < iml1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     return;                                /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* here starts packet */
   achl_out_1 = ADSL_OA1->achc_w1;          /* save start of packet    */
   ADSL_OA1->achc_w1 += iml1;               /* compute end of packet   */
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* here is end of packet */
   *achl_out_1 = DEF_CONST_RDP_03;
   *(achl_out_1 + 1) = 0;                   /* second byte zero        */
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2, iml1 );
   memcpy( achl_out_1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(achl_out_1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   achl_out_1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( achl_out_1, D_USERID_SE2CL );
   achl_out_1 += 2;
   m_put_be2( achl_out_1, D_ADSL_RCO1->usc_chno_disp );
   achl_out_1 += 2;
   *achl_out_1++ = 0X30;                    /* priority / segmentation */
   *achl_out_1++ = (unsigned char) (iml1 - (4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1));  /* remaining length */
   memset( achl_out_1, 0, 4 );              /* type output, second byte output + padding */
   /* make part at end                                                 */
   achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_end - 22;  /* here starts payload */
   memset( achl_out_1, 0, 22 - 4 );  /* clear area          */
   m_put_le4( achl_out_1 + 22 - 4, adsp_sc_error_info->umc_error_info );  /* set error number */
   *(achl_out_1 + 0) = (unsigned char) 22;  /* set length   */
   *(achl_out_1 + 12) = (unsigned char) 22;  /* set length  */
   *(achl_out_1 + 2) = (unsigned char) 0X17;  /* pduType PDUTYPE_DATAPDU */
   *(achl_out_1 + 11) = (unsigned char) 1;  /* streaming               */
   *(achl_out_1 + 14) = (unsigned char) 47;  /* pduType2 PDUTYPE2_SET_ERROR_INFO_PDU */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_cur
                    + 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0;
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 22 );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_1 + D_SIZE_HASH, 0, 22 );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_1, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_1 + D_SIZE_HASH, 0, 22, achl_out_1 + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
     *(achl_out_1 - 4) = (unsigned char) 0X08;  /* output encrypted    */
   }
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_error_info()                                           */

/* [MS-RDPBCGR] 2.2.2.3.1 Shutdown Request Denied PDU Data (TS_SHUTDOWN_DENIED_PDU) */
static void m_send_shutdown_deny( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   char       *achl_out_1;                  /* output-area             */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   iml1 = 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0 + 18;  /* size of packet */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     iml1 += D_SIZE_HASH;                   /* add length hash         */
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < iml1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     return;                                /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* here starts packet */
   achl_out_1 = ADSL_OA1->achc_w1;          /* save start of packet    */
   ADSL_OA1->achc_w1 += iml1;               /* compute end of packet   */
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* here is end of packet */
   *achl_out_1 = DEF_CONST_RDP_03;
   *(achl_out_1 + 1) = 0;                   /* second byte zero        */
   m_put_be2( ADSL_GAI1_OUT_G->achc_ginp_cur + 2, iml1 );
   memcpy( achl_out_1 + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(achl_out_1 + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   achl_out_1 += 4 + sizeof(ucrs_x224_p01) + 1;
   m_put_be2( achl_out_1, D_USERID_SE2CL );
   achl_out_1 += 2;
   m_put_be2( achl_out_1, D_ADSL_RCO1->usc_chno_disp );
   achl_out_1 += 2;
   *achl_out_1++ = 0X30;                    /* priority / segmentation */
   *achl_out_1++ = (unsigned char) (iml1 - (4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1));  /* remaining length */
   memset( achl_out_1, 0, 4 );              /* type output, second byte output + padding */
   /* make part at end                                                 */
   achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_end - 18;  /* here starts payload */
   memset( achl_out_1, 0, 18 );  /* clear area              */
   *(achl_out_1 + 0) = (unsigned char) 18;  /* set length   */
   *(achl_out_1 + 12) = (unsigned char) 18;  /* set length  */
   *(achl_out_1 + 2) = (unsigned char) 0X17;  /* pduType PDUTYPE_DATAPDU */
   *(achl_out_1 + 11) = (unsigned char) 1;  /* streaming               */
   *(achl_out_1 + 14) = (unsigned char) 37;  /* pduType2 PDUTYPE2_SHUTDOWN_DENIED */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     achl_out_1 = ADSL_GAI1_OUT_G->achc_ginp_cur
                    + 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1 + 4 + 0;
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, 18 );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     SHA1_Update( ACHL_WORK_SHA1, achl_out_1 + D_SIZE_HASH, 0, 18 );
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
//     m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->imc_count_server_sent );
//     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( achl_out_1, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     RC4( achl_out_1 + D_SIZE_HASH, 0, 18, achl_out_1 + D_SIZE_HASH, 0,
          D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
     *(achl_out_1 - 4) = (unsigned char) 0X08;  /* output encrypted    */
   }
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_shutdown_deny()                                        */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.3 PatBlt (PATBLT_ORDER)                  */
static BOOL m_send_order_patblt( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                 struct dsd_output_area_1 *adsp_output_area_1,
                                 struct dsd_sc_order_patblt *adsp_sc_order_patblt,
                                 char *achp_work_area ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (4 + 26)
   if ((adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_patblt->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X01) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X01;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   memset( achl_flags, 0, 2 );              /* clear encoding bytes    */
   ADSL_OA1->achc_w1 += 2;                  /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check bounds */
     if (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE) break;  /* variables have not been set */
     iml1 = adsp_sc_order_patblt->dsc_rectangle.isc_left - D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X01;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_patblt->dsc_rectangle.isc_top - D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X02;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_patblt->dsc_rectangle.isc_width - D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_width;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X04;           /* width set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_patblt->dsc_rectangle.isc_height - D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_height;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X08;           /* height set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_left = adsp_sc_order_patblt->dsc_rectangle.isc_left;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_top = adsp_sc_order_patblt->dsc_rectangle.isc_top;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_width = adsp_sc_order_patblt->dsc_rectangle.isc_width;  /* coordinate */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_height = adsp_sc_order_patblt->dsc_rectangle.isc_height;  /* coordinate */
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
// *achl_flags = 0;                         /* clear encoding bytes    */
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_left != adsp_sc_order_patblt->dsc_rectangle.isc_left)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_left = adsp_sc_order_patblt->dsc_rectangle.isc_left;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_rectangle.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X01;             /* left set                */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_top != adsp_sc_order_patblt->dsc_rectangle.isc_top)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_top = adsp_sc_order_patblt->dsc_rectangle.isc_top;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_rectangle.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X02;             /* top set                 */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_width != adsp_sc_order_patblt->dsc_rectangle.isc_width)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_width = adsp_sc_order_patblt->dsc_rectangle.isc_width;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_rectangle.isc_width );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X04;             /* width set               */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_height != adsp_sc_order_patblt->dsc_rectangle.isc_height)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_rect.isc_height = adsp_sc_order_patblt->dsc_rectangle.isc_height;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_rectangle.isc_height );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X08;             /* height set              */
   }

   p_out_o_40:                              /* delta parameters set    */
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.ucc_brop3 != adsp_sc_order_patblt->ucc_brop3)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.ucc_brop3 = adsp_sc_order_patblt->ucc_brop3;
     *(ADSL_OA1->achc_w1)++ = adsp_sc_order_patblt->ucc_brop3;
     *(achl_flags + 0) |= 0X10;             /* ternary raster operation set */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.umc_backcolor
             != adsp_sc_order_patblt->dsc_brush.umc_backcolor)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.umc_backcolor = adsp_sc_order_patblt->dsc_brush.umc_backcolor;
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_brush.umc_backcolor );
     ADSL_OA1->achc_w1 += 3;
     *(achl_flags + 0) |= 0X20;             /* background color set    */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.umc_forecolor != adsp_sc_order_patblt->dsc_brush.umc_forecolor)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.umc_forecolor = adsp_sc_order_patblt->dsc_brush.umc_forecolor;
     m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_patblt->dsc_brush.umc_forecolor );
     ADSL_OA1->achc_w1 += 3;
     *(achl_flags + 0) |= 0X40;             /* foreground color set    */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.scc_brushorgx
             != adsp_sc_order_patblt->dsc_brush.scc_brushorgx)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.scc_brushorgx
       = adsp_sc_order_patblt->dsc_brush.scc_brushorgx;
     *(ADSL_OA1->achc_w1)++ = adsp_sc_order_patblt->dsc_brush.scc_brushorgx;
     *(achl_flags + 0) |= 0X80;             /* brush org x set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.scc_brushorgy
             != adsp_sc_order_patblt->dsc_brush.scc_brushorgy)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.scc_brushorgy
       = adsp_sc_order_patblt->dsc_brush.scc_brushorgy;
     *(ADSL_OA1->achc_w1)++ = adsp_sc_order_patblt->dsc_brush.scc_brushorgy;
     *(achl_flags + 1) |= 0X01;             /* brush org y set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.ucc_brushstyle
             != adsp_sc_order_patblt->dsc_brush.ucc_brushstyle)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.ucc_brushstyle
       = adsp_sc_order_patblt->dsc_brush.ucc_brushstyle;
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_patblt->dsc_brush.ucc_brushstyle;
     *(achl_flags + 1) |= 0X02;             /* brush style set         */
   }
   if (   (D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.ucc_brushhatch
             != adsp_sc_order_patblt->dsc_brush.ucc_brushhatch)
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.ucc_brushhatch
       = adsp_sc_order_patblt->dsc_brush.ucc_brushhatch;
     *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_patblt->dsc_brush.ucc_brushhatch;
     *(achl_flags + 1) |= 0X04;             /* brush hatch set         */
   }
   if (   (memcmp( D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra,
                   adsp_sc_order_patblt->dsc_brush.chrc_brushextra,
                   sizeof(D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra) ))
       || (D_ADSL_RCO1->dsc_ord_co_o01.boc_set == FALSE)) {  /* variables have not been set */
     memcpy( D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra,
             adsp_sc_order_patblt->dsc_brush.chrc_brushextra,
             sizeof(D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra) );
     memcpy( ADSL_OA1->achc_w1,
             adsp_sc_order_patblt->dsc_brush.chrc_brushextra,
             sizeof(D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra) );
     ADSL_OA1->achc_w1 += sizeof(D_ADSL_RCO1->dsc_ord_co_o01.dsc_brush.chrc_brushextra);
     *(achl_flags + 1) |= 0X08;             /* brush extra data set    */
   }
   D_ADSL_RCO1->dsc_ord_co_o01.boc_set = TRUE;  /* variables have been set */
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   if (adsp_sc_order_patblt->boc_update_scrbuf == FALSE) return TRUE;  /* Specifies whether the local screen buffer should be changed */
// bol1 = dsrs_progaddr_1[ 1 ].amrc_r5_ord_x[ 1 ]( adsp_hl_clib_1 );
// bol1 = dsrs_progaddr_1[ 1 ].amrc_r5_ord_x[ 1 ]( adsp_hl_clib_1, achp_work_area );
   bol1 = dsrs_progaddr_1[ D_ADSL_RCO1->imc_bpp - 1 ].amrc_r5_ord_x[ 1 ]( adsp_hl_clib_1, achp_work_area );
   return bol1;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_patblt()                                         */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.5 OpaqueRect (OPAQUERECT_ORDER)          */
static void m_send_order_opaquerect( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                     struct dsd_output_area_1 *adsp_output_area_1,
                                     struct dsd_sc_order_opaquerect *adsp_sc_order_opaquerect,
                                     char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   char       *achl_coord;                  /* address start of coordinates */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (3 + 9 + 8 + adsp_sc_order_opaquerect->imc_no_color_bytes)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_opaquerect->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X0A) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X0A;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X0A;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
   achl_flags = ADSL_OA1->achc_w1;          /* address start of flags  */
   *achl_flags = 0;                         /* clear encoding bytes    */
   ADSL_OA1->achc_w1++;                     /* add length encoding bytes */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   achl_coord = ADSL_OA1->achc_w1;          /* address start of coordinates */
   while (TRUE) {                           /* pseudo-loop check coordinates */
     iml1 = adsp_sc_order_opaquerect->dsc_rectangle.isc_left - D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_left;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X01;           /* left set                */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_opaquerect->dsc_rectangle.isc_top - D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_top;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X02;           /* top set                 */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_opaquerect->dsc_rectangle.isc_width - D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_x_2;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X04;           /* width set               */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     iml1 = adsp_sc_order_opaquerect->dsc_rectangle.isc_height - D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_y_2;
     if (iml1) {                            /* is not zero             */
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml1;  /* output delta */
       *(achl_flags + 0) |= 0X08;           /* height set              */
     }
     iml1 >>= 7;                            /* remove bits of value    */
     if ((iml1 != 0) && (iml1 != -1)) break;  /* more than 7 bits value */
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_left = adsp_sc_order_opaquerect->dsc_rectangle.isc_left;  /* coordinate */
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_top = adsp_sc_order_opaquerect->dsc_rectangle.isc_top;  /* coordinate */
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_x_2 = adsp_sc_order_opaquerect->dsc_rectangle.isc_width;  /* coordinate right or width */
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_y_2 = adsp_sc_order_opaquerect->dsc_rectangle.isc_height;  /* coordinate bottom or height */
     *achl_start |= 0X10;                   /* delta coordinates       */
     goto p_out_o_40;                       /* delta parameters set    */
   }
// *achl_flags = 0;                         /* clear encoding bytes    */
   ADSL_OA1->achc_w1 = achl_coord;          /* after encoding bytes    */
   if (D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_left != adsp_sc_order_opaquerect->dsc_rectangle.isc_left) {
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_left = adsp_sc_order_opaquerect->dsc_rectangle.isc_left;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_opaquerect->dsc_rectangle.isc_left );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X01;             /* left set                */
   }
   if (D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_top != adsp_sc_order_opaquerect->dsc_rectangle.isc_top) {
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_top = adsp_sc_order_opaquerect->dsc_rectangle.isc_top;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_opaquerect->dsc_rectangle.isc_top );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X02;             /* top set                 */
   }
   if (D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_x_2 != adsp_sc_order_opaquerect->dsc_rectangle.isc_width) {
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_x_2 = adsp_sc_order_opaquerect->dsc_rectangle.isc_width;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_opaquerect->dsc_rectangle.isc_width );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X04;             /* width set               */
   }
   if (D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_y_2 != adsp_sc_order_opaquerect->dsc_rectangle.isc_height) {
     D_ADSL_RCO1->dsrc_ord_co_1[ 0X0A ].imc_dim_y_2 = adsp_sc_order_opaquerect->dsc_rectangle.isc_height;  /* coordinate */
     m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_opaquerect->dsc_rectangle.isc_height );
     ADSL_OA1->achc_w1 += 2;
     *(achl_flags + 0) |= 0X08;             /* height set              */
   }

   p_out_o_40:                              /* delta parameters set    */
   m_put_le4( chrp_work, adsp_sc_order_opaquerect->umc_color );
   memcpy( ADSL_OA1->achc_w1, chrp_work, adsp_sc_order_opaquerect->imc_no_color_bytes );
   ADSL_OA1->achc_w1 += adsp_sc_order_opaquerect->imc_no_color_bytes;
   *(achl_flags + 0) |= imrs_colour_r_tab[ adsp_sc_order_opaquerect->imc_no_color_bytes ];
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_opaquerect()                                     */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.11 LineTo (LINETO_ORDER)                 */
static BOOL m_send_order_lineto( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                 struct dsd_output_area_1 *adsp_output_area_1,
                                 struct dsd_sc_order_lineto *adsp_sc_order_lineto,
                                 char *achp_work_area ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if (   (adsp_sc_order_lineto->iec_backmode != ied_scc_transparent)
       && (adsp_sc_order_lineto->iec_backmode != ied_scc_opaque)) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_lineto - adsp_sc_order_lineto->iec_backmode=0X%04X invalid",
                   40864,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   (unsigned short int) adsp_sc_order_lineto->iec_backmode );
     return FALSE;
   }
   if (   (adsp_sc_order_lineto->iec_brop2 == 0)
       || (((unsigned char) adsp_sc_order_lineto->iec_brop2) > 0X10)) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_lineto - adsp_sc_order_lineto->iec_brop2=0X%02X invalid",
                   40872,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   (unsigned char) adsp_sc_order_lineto->iec_brop2 );
     return FALSE;
   }
#define D_OUT_LEN_1 (4 + 9 + 19)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_lineto->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X09) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X09;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X09;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 25.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0XDF;  /* first byte encoding flags */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X03;  /* second byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_lineto->iec_backmode );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_lineto->isc_nxstart );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_lineto->isc_nystart );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_lineto->isc_nxend );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_lineto->isc_nyend );
   ADSL_OA1->achc_w1 += 2;
   //memset( ADSL_OA1->achc_w1, 0, 3 );       /* BackColor               */
   //ADSL_OA1->achc_w1 += 3;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_lineto->iec_brop2;
   *(ADSL_OA1->achc_w1)++ = 0X00;           /* PenStyle                */
   *(ADSL_OA1->achc_w1)++ = 0X01;           /* PenWidth                */
   m_put_le4( achp_work_area, adsp_sc_order_lineto->imc_pencolor );
   memcpy( ADSL_OA1->achc_w1, achp_work_area, 3 );
   ADSL_OA1->achc_w1 += 3;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   if (adsp_sc_order_lineto->boc_update_scrbuf == FALSE) return TRUE;  /* Specifies whether the local screen buffer should be changed */
   D_ADSL_RCO1->dsc_ord_co_o09.boc_set = TRUE;  /* variables have been set */
   D_ADSL_RCO1->dsc_ord_co_o09.iec_backmode = adsp_sc_order_lineto->iec_backmode;  // mode of background: transparent or opaque
   D_ADSL_RCO1->dsc_ord_co_o09.isc_nxstart = adsp_sc_order_lineto->isc_nxstart;  // starting point of the line, x-coordinate
   D_ADSL_RCO1->dsc_ord_co_o09.isc_nystart = adsp_sc_order_lineto->isc_nystart;  // starting point of the line, y-coordinate
   D_ADSL_RCO1->dsc_ord_co_o09.isc_nxend = adsp_sc_order_lineto->isc_nxend;  // end point of the line, x-coordinate
   D_ADSL_RCO1->dsc_ord_co_o09.isc_nyend = adsp_sc_order_lineto->isc_nyend;  // end point of the line, y-coordinate
   //unsigned int imc_back_color;               // background color-> field must be zeroed out -> sense?
   D_ADSL_RCO1->dsc_ord_co_o09.ucc_brop2 = (unsigned char) adsp_sc_order_lineto->iec_brop2;  // binary raster operation
   //unsigned char ucc_penstyle;                // PenStyle must be PS_SOLID(0x00)
   //unsigned char ucc_penwith;                 // PenWidth must be 0x01.
   D_ADSL_RCO1->dsc_ord_co_o09.umc_pencolor = adsp_sc_order_lineto->imc_pencolor;  // color of the drawn line
   bol1 = dsrs_progaddr_1[ 1 ].amrc_r5_ord_x[ 9 ]( adsp_hl_clib_1, achp_work_area );
   return bol1;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_lineto()                                         */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.18 Polyline (POLYLINE_ORDER)             */
static BOOL m_send_order_polyline( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                   struct dsd_output_area_1 *adsp_output_area_1,
                                   struct dsd_sc_order_polyline *adsp_sc_order_polyline,
                                   char *achp_work_area ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
   unsigned char ucl_zerobit;               /* bit for zeroBits        */
   char       *achl_a_len;                  /* address of length field */
   char       *achl_a_zerobit;              /* address current zeroBits */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if (adsp_sc_order_polyline->ucc_numpoints == 0) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polyline - adsp_sc_order_polyline->ucc_numpoints=zero invalid",
                   41005,          /* source line no for errors */
                   __LINE__ );              /* line number for errors  */
     return FALSE;
   }
   if (adsp_sc_order_polyline->ucc_numpoints > 32) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polyline - adsp_sc_order_polyline->ucc_numpoints=%d invalid",
                   41011,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   adsp_sc_order_polyline->ucc_numpoints );
     return FALSE;
   }
#define D_OUT_LEN_1 (3 + 9 + 148)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, achp_work_area );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return NULL;                         /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return NULL;                         /* do cleanup now          */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_polyline->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X16) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X16;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X16;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 25.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X7F;  /* byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polyline->adsc_points[ 0 ].isc_x );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polyline->adsc_points[ 0 ].isc_y );
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polyline->iec_brop2;
   /* empty BrushCashEntry                                             */
   memset( ADSL_OA1->achc_w1, 0, 2 );
   ADSL_OA1->achc_w1 += 2;
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_polyline->umc_pencolor );
   ADSL_OA1->achc_w1 += 3;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polyline->ucc_numpoints;
   achl_a_len = ADSL_OA1->achc_w1;          /* address of length field */
// *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polyline->ucc_numpoints * 2 * sizeof(short int);
   ADSL_OA1->achc_w1++;                     /* after length field      */
   achl_a_zerobit = ADSL_OA1->achc_w1;      /* address current zeroBits */
   iml1 = (adsp_sc_order_polyline->ucc_numpoints + 4 - 1) / 4;  /* number of zeroBits */
// *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polyline->ucc_numpoints * 2 * sizeof(short int) + iml1;
   memset( ADSL_OA1->achc_w1, 0, iml1 );    /* clear zeroBits          */
   ADSL_OA1->achc_w1 += iml1;               /* after zeroBits          */
   ucl_zerobit = 0X80;                      /* bit for zeroBits        */
   iml1 = 1;
   do {
     if (ucl_zerobit == 0) {                /* bit for zeroBits        */
       achl_a_zerobit++;                    /* address current zeroBits */
       ucl_zerobit = 0X80;                  /* bit for zeroBits        */
     }
     iml2 = adsp_sc_order_polyline->adsc_points[ iml1 ].isc_x
             - adsp_sc_order_polyline->adsc_points[ iml1 - 1 ].isc_x;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit;    /* set current zeroBits    */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml2 = adsp_sc_order_polyline->adsc_points[ iml1 ].isc_y
             - adsp_sc_order_polyline->adsc_points[ iml1 - 1 ].isc_y;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit >> 1;  /* set current zeroBits */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml1++;
     ucl_zerobit >>= 2;                     /* bit for zeroBits        */
   } while (iml1 < (adsp_sc_order_polyline->ucc_numpoints + 1));
   *achl_a_len = (unsigned char) (ADSL_OA1->achc_w1 - (achl_a_len + 1));
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   if (adsp_sc_order_polyline->boc_update_scrbuf == FALSE) return TRUE;  /* Specifies whether the local screen buffer should be changed */
   D_ADSL_RCO1->dsc_ord_co_o16.boc_set = TRUE;  /* variables have been set */
   D_ADSL_RCO1->dsc_ord_co_o16.isc_xstart = adsp_sc_order_polyline->adsc_points[ 0 ].isc_x;  // starting point of the line, x-coordinate
   D_ADSL_RCO1->dsc_ord_co_o16.isc_ystart = adsp_sc_order_polyline->adsc_points[ 0 ].isc_y;  // starting point of the line, y-coordinate
   D_ADSL_RCO1->dsc_ord_co_o16.ucc_brop2 = (unsigned char) adsp_sc_order_polyline->iec_brop2;  // binary raster operation
   D_ADSL_RCO1->dsc_ord_co_o16.umc_pencolor = adsp_sc_order_polyline->umc_pencolor;  // color of the drawn line
   D_ADSL_RCO1->dsc_ord_co_o16.ucc_num_delta_entries = adsp_sc_order_polyline->ucc_numpoints;  /* number of points along the polyline path */
   D_ADSL_RSE1->achc_prot_1 = (char *) &adsp_sc_order_polyline->adsc_points[ 1 ];
   bol1 = dsrs_progaddr_1[ 1 ].amrc_r5_ord_x[ 0X16 ]( adsp_hl_clib_1, achp_work_area );
   return bol1;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_polyline()                                       */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.16 PolygonSC (POLYGON_SC_ORDER)          */
static void m_send_order_polygonsc( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_order_polygonsc *adsp_sc_order_polygonsc,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
   unsigned char ucl_zerobit;               /* bit for zeroBits        */
   char       *achl_a_len;                  /* address of length field */
   char       *achl_a_zerobit;              /* address current zeroBits */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if (adsp_sc_order_polygonsc->ucc_numpoints < 2) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polygonsc - adsp_sc_order_polygonsc->ucc_numpoints<2 invalid",
                   41164,          /* source line no for errors */
                   __LINE__ );              /* line number for errors  */
     return;
   }
   if (adsp_sc_order_polygonsc->ucc_numpoints > 32) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polygonsc - adsp_sc_order_polygonsc->ucc_numpoints=%d invalid",
                   41170,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   adsp_sc_order_polygonsc->ucc_numpoints );
     return;
   }

#define D_OUT_LEN_1 (4 + 9 + 249)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_polygonsc->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X14) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X14;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X14;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 25.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X7F;  /* byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polygonsc->adsc_points[ 0 ].isc_x );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polygonsc->adsc_points[ 0 ].isc_y );
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polygonsc->iec_brop2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polygonsc->iec_fillmode;
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_polygonsc->umc_brushcolor );
   ADSL_OA1->achc_w1 += 3;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygonsc->ucc_numpoints;
   achl_a_len = ADSL_OA1->achc_w1;          /* address of length field */
// *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygonsc->ucc_numpoints * 2 * sizeof(short int);
   ADSL_OA1->achc_w1++;                     /* after length field      */
   achl_a_zerobit = ADSL_OA1->achc_w1;      /* address current zeroBits */
   iml1 = (adsp_sc_order_polygonsc->ucc_numpoints + 4 - 1) / 4;  /* number of zeroBits */
   memset( ADSL_OA1->achc_w1, 0, iml1 );    /* clear zeroBits          */
   ADSL_OA1->achc_w1 += iml1;               /* after zeroBits          */
   ucl_zerobit = 0X80;                      /* bit for zeroBits        */
   iml1 = 1;
   do {
     if (ucl_zerobit == 0) {                /* bit for zeroBits        */
       achl_a_zerobit++;                    /* address current zeroBits */
       ucl_zerobit = 0X80;                  /* bit for zeroBits        */
     }
     iml2 = adsp_sc_order_polygonsc->adsc_points[ iml1 ].isc_x
             - adsp_sc_order_polygonsc->adsc_points[ iml1 - 1 ].isc_x;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit;    /* set current zeroBits    */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml2 = adsp_sc_order_polygonsc->adsc_points[ iml1 ].isc_y
             - adsp_sc_order_polygonsc->adsc_points[ iml1 - 1 ].isc_y;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit >> 1;  /* set current zeroBits */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml1++;
     ucl_zerobit >>= 2;                     /* bit for zeroBits        */
   } while (iml1 < (adsp_sc_order_polygonsc->ucc_numpoints + 1));
   *achl_a_len = (unsigned char) (ADSL_OA1->achc_w1 - (achl_a_len + 1));
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_polygonsc()                                      */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.17 PolygonCB (POLYGON_CB_ORDER)          */
static void m_send_order_polygoncb( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_order_polygoncb *adsp_sc_order_polygoncb,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
   unsigned char ucl_zerobit;               /* bit for zeroBits        */
   char       *achl_a_len;                  /* address of length field */
   char       *achl_a_zerobit;              /* address current zeroBits */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if (adsp_sc_order_polygoncb->ucc_numpoints < 2) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polygoncb - adsp_sc_order_polygoncb->ucc_numpoints<2 invalid",
                   41313,          /* source line no for errors */
                   __LINE__ );              /* line number for errors  */
     return;
   }
   if (adsp_sc_order_polygoncb->ucc_numpoints > 32) {
     m_sdh_printf( adsp_hl_clib_1, "s%05d l%05d m_send_order_polygoncb - adsp_sc_order_polygoncb->ucc_numpoints=%d invalid",
                   41319,          /* source line no for errors */
                   __LINE__,                /* line number for errors  */
                   adsp_sc_order_polygoncb->ucc_numpoints );
     return;
   }
#define D_OUT_LEN_1 (4 + 9 + 263)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_polygoncb->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X15) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X15;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X15;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 25.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0XFF;  /* first byte encoding flags */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X1F;  /* second byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polygoncb->adsc_points[ 0 ].isc_x );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_polygoncb->adsc_points[ 0 ].isc_y );
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polygoncb->iec_brop2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polygoncb->iec_fillmode;
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_polygoncb->dsc_brush.umc_backcolor );
   ADSL_OA1->achc_w1 += 3;
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_polygoncb->dsc_brush.umc_forecolor );
   ADSL_OA1->achc_w1 += 3;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygoncb->dsc_brush.scc_brushorgx;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygoncb->dsc_brush.scc_brushorgy;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_polygoncb->dsc_brush.ucc_brushstyle;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygoncb->dsc_brush.ucc_brushhatch;
   memcpy( ADSL_OA1->achc_w1,
           adsp_sc_order_polygoncb->dsc_brush.chrc_brushextra,
           sizeof(adsp_sc_order_polygoncb->dsc_brush.chrc_brushextra) );
   ADSL_OA1->achc_w1 += sizeof(adsp_sc_order_polygoncb->dsc_brush.chrc_brushextra);
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polygoncb->ucc_numpoints;
   achl_a_len = ADSL_OA1->achc_w1;          /* address of length field */
// *(ADSL_OA1->achc_w1)++ = adsp_sc_order_polyline->ucc_numpoints * 2 * sizeof(short int);
   ADSL_OA1->achc_w1++;                     /* after length field      */
   achl_a_zerobit = ADSL_OA1->achc_w1;      /* address current zeroBits */
   iml1 = (adsp_sc_order_polygoncb->ucc_numpoints + 4 - 1) / 4;  /* number of zeroBits */
   memset( ADSL_OA1->achc_w1, 0, iml1 );    /* clear zeroBits          */
   ADSL_OA1->achc_w1 += iml1;               /* after zeroBits          */
   ucl_zerobit = 0X80;                      /* bit for zeroBits        */
   iml1 = 1;
   do {
     if (ucl_zerobit == 0) {                /* bit for zeroBits        */
       achl_a_zerobit++;                    /* address current zeroBits */
       ucl_zerobit = 0X80;                  /* bit for zeroBits        */
     }
     iml2 = adsp_sc_order_polygoncb->adsc_points[ iml1 ].isc_x
             - adsp_sc_order_polygoncb->adsc_points[ iml1 - 1 ].isc_x;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit;    /* set current zeroBits    */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml2 = adsp_sc_order_polygoncb->adsc_points[ iml1 ].isc_y
             - adsp_sc_order_polygoncb->adsc_points[ iml1 - 1 ].isc_y;
     do {                                   /* pseudo-loop             */
       if (iml2 == 0) {                     /* did not change          */
         *achl_a_zerobit |= ucl_zerobit >> 1;  /* set current zeroBits */
         break;
       }
       iml3 = iml2 >> 6;                    /* remove bits of value    */
       if ((iml3 == 0) || (iml3 == -1)) {   /* not more than 6 bits value */
         *(ADSL_OA1->achc_w1)++ = (unsigned char) (iml2 & 0X7F);
         break;
       }
       *(ADSL_OA1->achc_w1)++ = (unsigned char) ((iml2 >> 8) | 0X80);
       *(ADSL_OA1->achc_w1)++ = (unsigned char) iml2;
     } while (FALSE);
     iml1++;
     ucl_zerobit >>= 2;                     /* bit for zeroBits        */
   } while (iml1 < (adsp_sc_order_polygoncb->ucc_numpoints + 1));
   *achl_a_len = (unsigned char) (ADSL_OA1->achc_w1 - (achl_a_len + 1));
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_polygoncb()                                      */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.19 EllipseSC (ELLIPSE_SC_ORDER)          */
static void m_send_order_ellipsesc( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_order_ellipsesc *adsp_sc_order_ellipsesc,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   char       *achl_bounds;                 /* address start of bounds */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (4 + 9 + 13)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_ellipsesc->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X19) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X19;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X19;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 26.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X7F;  /* byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsesc->dsc_increct.isc_left );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsesc->dsc_increct.isc_top );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsesc->dsc_increct.isc_right );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsesc->dsc_increct.isc_bottom );
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_ellipsesc->iec_brop2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_ellipsesc->iec_fillmode;
   m_put_le4( chrp_work, adsp_sc_order_ellipsesc->umc_pencolor );
   memcpy( ADSL_OA1->achc_w1, chrp_work, 3 );
   ADSL_OA1->achc_w1 += 3;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_ellipsesc()                                      */

/* [MS-RDPEGDI] 2.2.2.2.1.1.2.20 EllipseCB (ELLIPSE_CB_ORDER)          */
static void m_send_order_ellipsecb( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                    struct dsd_output_area_1 *adsp_output_area_1,
                                    struct dsd_sc_order_ellipsecb *adsp_sc_order_ellipsecb,
                                    char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
   int        iml_bounds;                   /* flag set bounds         */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
   char       *achl_bounds;                 /* address start of bounds */
// char       *achl_flags;                  /* address start of flags  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

// to-do 27.01.09 KB 9 + 27 is correct???
#define D_OUT_LEN_1 (4 + 9 + 27)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   iml_bounds = 0;                          /* clear flag set bounds   */
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
// *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X01;  /* Flags standard + no type change, no delta */
   *achl_start = D_ADSL_RSE1->ucc_order_flags_1;  /* Flags standard + no type change, no delta */
   if (adsp_sc_order_ellipsecb->boc_has_bounds == FALSE) {  /* do not set bounds */
     *achl_start &= -1 - 0X04 - 0X20;       /* no TS_BOUNDS and no TS_ZERO_BOUNDS_DELTAS */
   } else {                                 /* apply bounds            */
     if ((D_ADSL_RSE1->ucc_order_flags_1 & 0X20) == 0) {  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       D_ADSL_RSE1->ucc_order_flags_1 |= 0X20;  /* send order flags TS_ZERO_BOUNDS_DELTAS */
       iml_bounds = 1;                      /* set flag set bounds     */
     }
   }
   ADSL_OA1->achc_w1++;                     /* after Order Flags       */
   if (D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim != 0X1A) {  /* check primary order number */
     D_ADSL_RCO1->ucc_prot_r5_pdu_ord_prim = 0X1A;  /* set primary order number */
     *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X1A;  /* output primary order number */
     *achl_start |= 0X08;                   /* set typechange flag     */
   }
// to-do 27.12.08 KB - optimze, compare with buffered values
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0XFF;  /* first byte encoding flags */
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 0X1F;  /* second byte encoding flags */
   if (iml_bounds) {                        /* set flag set bounds     */
     achl_bounds = ADSL_OA1->achc_w1;       /* address start of bounds */
     *(ADSL_OA1->achc_w1)++ = 0;            /* clear flags             */
     /* check if bounds not yet set                                    */
     if (   (*((unsigned char *) &D_ADSL_RSE1->dsc_old_bounds) == 0XFF)
         && (!memcmp( &D_ADSL_RSE1->dsc_old_bounds, (char *) &D_ADSL_RSE1->dsc_old_bounds + 1, sizeof(D_ADSL_RSE1->dsc_old_bounds) - 1))) {
       iml_bounds = -1;                     /* do not apply deltas     */
     }
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_left
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_left;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X10;            /* TS_BOUND_DELTA_LEFT     */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X01;                /* TS_BOUND_LEFT           */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_left );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_top
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_top;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X20;            /* TS_BOUND_DELTA_TOP      */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X02;                /* TS_BOUND_TOP            */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_top );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_right
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_right;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X40;            /* TS_BOUND_DELTA_RIGHT    */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X04;                /* TS_BOUND_RIGHT          */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_right );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
     do {                                   /* pseudo-loop             */
       if (iml_bounds > 0) {                /* check for delta         */
         iml1 = D_ADSL_RCO1->imc_bounds_bottom
                  - D_ADSL_RSE1->dsc_old_bounds.imc_bounds_old_bottom;
         if (iml1 == 0) break;              /* nothing changed         */
         iml2 = iml1 >> 7;                  /* remove significant bits */
         if ((iml2 == 0) || (iml2 == -1)) {  /* apply delta            */
           *achl_bounds |= 0X80;            /* TS_BOUND_DELTA_BOTTOM   */
           *(ADSL_OA1->achc_w1)++ = (signed char) iml1;
           break;
         }
       }
       *achl_bounds |= 0X08;                /* TS_BOUND_BOTTOM         */
       m_put_le2( ADSL_OA1->achc_w1, D_ADSL_RCO1->imc_bounds_bottom );
       ADSL_OA1->achc_w1 += 2;
     } while (FALSE);
   }
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_increct.isc_left );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_increct.isc_top );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_increct.isc_right );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_increct.isc_bottom );
   ADSL_OA1->achc_w1 += 2;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_ellipsecb->iec_brop2;
// *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_ellipsecb->iec_fillmode;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) 1;  /* fillmode always 1   */
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_brush.umc_backcolor );
   ADSL_OA1->achc_w1 += 3;
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_ellipsecb->dsc_brush.umc_forecolor );
   ADSL_OA1->achc_w1 += 3;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_ellipsecb->dsc_brush.scc_brushorgx;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_ellipsecb->dsc_brush.scc_brushorgy;
   *(ADSL_OA1->achc_w1)++ = (unsigned char) adsp_sc_order_ellipsecb->dsc_brush.ucc_brushstyle;
   *(ADSL_OA1->achc_w1)++ = adsp_sc_order_ellipsecb->dsc_brush.ucc_brushhatch;
   memcpy( ADSL_OA1->achc_w1,
           adsp_sc_order_ellipsecb->dsc_brush.chrc_brushextra,
           sizeof(adsp_sc_order_ellipsecb->dsc_brush.chrc_brushextra) );
   ADSL_OA1->achc_w1 += sizeof(adsp_sc_order_ellipsecb->dsc_brush.chrc_brushextra);
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_order_ellipsecb()                                      */

/* [MS-RDPEGDI] 2.2.2.2.1.3.2 Create Offscreen Bitmap (CREATE_OFFSCR_BITMAP_CB_ORDER) */
static void m_send_order_createoffbitmap( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                          struct dsd_output_area_1 *adsp_output_area_1,
                                          struct dsd_sc_order_createoffbitmap *adsp_sc_order_createoffbitmap,
                                          char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   unsigned short int *ausl_w1;             /* working variable        */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   iml1 = 0;
   if (adsp_sc_order_createoffbitmap->usc_numdelindices) {
     iml1 = (1 + adsp_sc_order_createoffbitmap->usc_numdelindices) * sizeof(short int);
   }

#define D_OUT_LEN_1 (1 + 6 + iml1)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   *(ADSL_OA1->achc_w1)++ = 0X06;           /* Order Flags TS_ALTSEC_CREATE_OFFSCR_BITMAP */
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_createoffbitmap->usc_offscreenbitmapid );
   if (adsp_sc_order_createoffbitmap->usc_numdelindices) {
     *(ADSL_OA1->achc_w1 + 1) |= 0X80;
   }
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_createoffbitmap->usc_cx );
   ADSL_OA1->achc_w1 += 2;
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_createoffbitmap->usc_cy );
   ADSL_OA1->achc_w1 += 2;
   if (adsp_sc_order_createoffbitmap->usc_numdelindices) {
     iml1 = adsp_sc_order_createoffbitmap->usc_numdelindices;
     m_put_le2( ADSL_OA1->achc_w1, iml1 );
     ADSL_OA1->achc_w1 += 2;
     ausl_w1 = (unsigned short int *) (adsp_sc_order_createoffbitmap + 1);
     do {
       m_put_le2( ADSL_OA1->achc_w1, *ausl_w1++ );
       ADSL_OA1->achc_w1 += 2;
       iml1--;                              /* decrement index         */
     } while (iml1 > 0);
   }
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* m_send_order_createoffbitmap()                                    */

/* [MS-RDPEGDI] 2.2.2.2.1.3.3 Switch Surface (SWITCH_SURFACE_ORDER)    */
static void m_send_order_switchsurface( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                        struct dsd_output_area_1 *adsp_output_area_1,
                                        struct dsd_sc_order_switchsurface *adsp_sc_order_switchsurface,
                                        char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (1 + 2)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   *(ADSL_OA1->achc_w1)++ = 0X02;           /* Order Flags TS_ALTSEC_SWITCH_SURFACE */
   m_put_le2( ADSL_OA1->achc_w1, adsp_sc_order_switchsurface->usc_bitmapid );
   ADSL_OA1->achc_w1 += 2;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* m_send_order_switchsurface()                                      */
/* [MS-RDPEGDI] 2.2.2.2.1.3.7 Frame Marker    */
static void m_send_order_framemarker( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                      struct dsd_output_area_1 *adsp_output_area_1,
                                      struct dsd_sc_order_framemarker *adsp_sc_order_framemarker,
                                      char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
// int        iml_bpp;                      /* number of bytes per pixel */
// char       *achl_s1;                     /* address source          */
// char       *achl_t1;                     /* address target          */
   char       *achl_start;                  /* address start of order  */
// char       *achl_flags;                  /* address start of flags  */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

#define D_OUT_LEN_1 (1 + 4)
   if ( (adsp_output_area_1->achc_start_order != NULL)
       && ((ADSL_OA1->imc_pdu_len + D_OUT_LEN_1) > D_ADSL_RCO1->imc_max_ts_fp_update_size))
   {  /* start of current frame set */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (   (ADSL_OA1->adsc_gai1_sf == NULL)  /* start of current frame  */
       || (ADSL_OA1->achc_start_order == NULL)) {  /* not in update orders */
     m_send_frame_order_o( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < D_OUT_LEN_1) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                              /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
       adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
       adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif

     } else {
       ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     }
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
     ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
     if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
       ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
     }
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
     ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   }
#undef D_OUT_LEN_1
   achl_start = ADSL_OA1->achc_w1;          /* address start of order  */
   *(ADSL_OA1->achc_w1)++ = 0X36;           /* Order Flags TS_ALTSEC_FRAME_MARKER */
   m_put_le4( ADSL_OA1->achc_w1, adsp_sc_order_framemarker->iec_action );
   ADSL_OA1->achc_w1 += 4;
#define ADSL_GAI1_OUT_G ADSL_OA1->adsc_gai1_o1
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
#undef ADSL_GAI1_OUT_G
   ADSL_OA1->imc_pdu_len += ADSL_OA1->achc_w1 - achl_start;  /* length of PDU */
   ADSL_OA1->imc_no_order++;                /* increment number of orders */
   return;
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* m_send_order_framemarker()                                      */
static void m_send_frame_open( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                               struct dsd_output_area_1 *adsp_output_area_1,
                               char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     return;                                /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   ADSL_OA1->adsc_gai1_sf = ADSL_GAI1_OUT_G;  /* start of current frame */
   ADSL_OA1->achc_w1 += 3;                  /* add length header needed */
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     ADSL_OA1->achc_w1 += D_SIZE_HASH;      /* add length hash         */
   }
   ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
   ADSL_GAI1_OUT_G->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end */
   ADSL_OA1->achc_start_order = NULL;       /* not in update orders    */
#undef ADSL_GAI1_OUT_G
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_frame_open()                                           */

static void m_send_frame_close( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                struct dsd_output_area_1 *adsp_output_area_1,
                                char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* chain of data           */
   char       chrl_work_1[ 512 ];           /* work area               */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   if (adsp_output_area_1->adsc_gai1_sf == NULL) {  /* start of current frame */
     return;
   }
   if (ADSL_OA1->achc_start_order) {        /* is in update orders     */
     m_send_frame_order_c( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   /* count the length of the data                                     */
   iml1 = 0;                                /* clear counter           */
   adsl_gai1_w1 = ADSL_OA1->adsc_gai1_sf;   /* start of current frame  */
   do {                                     /* loop over all gather input */
     iml1 += adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
   } while (adsl_gai1_w1);
// to-do 21.03.09 KB compression - or not as already compressed before
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     if ((D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
       if (D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent) {
         m_update_keys( D_ADSL_RCO1, &D_ADSL_RCO1->dsc_encry_se2cl, NULL );
       }
     }
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrl_work_1)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             D_ADSL_RCO1->imrc_sha1_state,
             sizeof(D_ADSL_RCO1->imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             D_ADSL_RCO1->imrc_md5_state,
             sizeof(D_ADSL_RCO1->imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, iml1 );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     adsl_gai1_w1 = ADSL_OA1->adsc_gai1_sf;   /* start of current frame */
     do {                                     /* loop over all gather input */
       SHA1_Update( ACHL_WORK_SHA1,
                    adsl_gai1_w1->achc_ginp_cur,
                    0,
                    adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain   */
     } while (adsl_gai1_w1);
//   if (*(ACHL_BUFFER_C + 0) & 0X40) {     /* flag for block count    */
       m_put_le4( ACHL_WORK_UTIL_01, D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     memcpy( ADSL_OA1->adsc_gai1_sf->achc_ginp_cur - D_SIZE_HASH, ACHL_WORK_UTIL_01, D_SIZE_HASH );
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     adsl_gai1_w1 = ADSL_OA1->adsc_gai1_sf;   /* start of current frame */
     do {                                     /* loop over all gather input */
       RC4( adsl_gai1_w1->achc_ginp_cur, 0,
            adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur,
            adsl_gai1_w1->achc_ginp_cur, 0,
            D_ADSL_RCO1->dsc_encry_se2cl.chrc_rc4_state );
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
     } while (adsl_gai1_w1);
     D_ADSL_RCO1->dsc_encry_se2cl.imc_count_sent++;  /* count block received from server */
     ADSL_OA1->adsc_gai1_sf->achc_ginp_cur -= D_SIZE_HASH;
     iml1 += D_SIZE_HASH;
   }
   if (iml1 < (128 - 2)) {                  /* length in one byte      */
     iml1 += 2;
     ADSL_OA1->adsc_gai1_sf->achc_ginp_cur -= 2;
     *(ADSL_OA1->adsc_gai1_sf->achc_ginp_cur + 1) = (unsigned char) iml1;
   } else {                                 /* length in two bytes     */
     iml1 += 3;
     ADSL_OA1->adsc_gai1_sf->achc_ginp_cur -= 3;
     m_put_be2( ADSL_OA1->adsc_gai1_sf->achc_ginp_cur + 1, iml1 );
     *(ADSL_OA1->adsc_gai1_sf->achc_ginp_cur + 1) |= 0X80;  /* length in two bytes */
   }
#ifdef _DEBUG
   static int iml1_max = 0;
   if(iml1_max < iml1 || iml1 < (8+3)) {
      iml1_max = iml1;
      printf("m_send_frame_close iml1: %d\n", iml1);
   }
#endif  
   *(ADSL_OA1->adsc_gai1_sf->achc_ginp_cur + 0) = 0;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(ADSL_OA1->adsc_gai1_sf->achc_ginp_cur + 0) = (unsigned char) 0XC0;  /* flag with encryption */
   }
   adsp_output_area_1->adsc_gai1_sf = NULL;  /* not in open frame any more */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_frame_close()                                          */

/* in frame start with order commands                                  */
static void m_send_frame_order_o( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif

   // JB 28.10.2011: Close frame, as we don't know if there are eventually
   // other fast-path-commands in it and we don't know the length
   m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   m_send_frame_open( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
 
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return;                              /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return;                                /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;  /* append to chain */
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* last gather in chain */
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;  /* start output here */
#undef ADSL_GAI1_OUT_G
   }
   /* length without compression                                       */
   ADSL_OA1->achc_w1 += 1 + 2 + 2;
   ADSL_OA1->achc_start_order = ADSL_OA1->achc_w1;  /* start of current orders */
   ADSL_OA1->imc_no_order = 0;              /* number of orders        */
   ADSL_OA1->imc_pdu_len = 2;               /* length of PDU           */
   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = ADSL_OA1->achc_w1;  /* set current end, [by SM/JB] */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_frame_order_o()                                        */

/* in frame close order commands                                       */
static void m_send_frame_order_c( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  char *chrp_work ) {
   BOOL       bol1;                         /* working variable        */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
/* to-do 19.06.08 KB - compression */
   ADSL_OA1->achc_start_order -= 1 + 2 + 2;
   m_put_le2( ADSL_OA1->achc_start_order + 3, ADSL_OA1->imc_no_order );  /* number of orders */
   m_put_le2( ADSL_OA1->achc_start_order + 1, ADSL_OA1->imc_pdu_len );  /* length of PDU */
   *ADSL_OA1->achc_start_order = 0;         /* update orders           */
   ADSL_OA1->achc_start_order = NULL;       /* no more in order commands */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_frame_order_c()                                        */

// JB 28.10.2011: The length of the 2.2.9.1.2 Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
// can only be 32767 bytes (7 bit!). For update orders this is checked by the update orders
// length, but it's nowhere checked for other updateCodes.
static void m_check_fastpath_frame( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                                  struct dsd_output_area_1 *adsp_output_area_1,
                                  char *chrp_work ) {

   int        iml1;                         /* working variable        */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* chain of data           */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if ((ADSL_OA1->adsc_gai1_sf != NULL) &&
       (ADSL_OA1->achc_start_order != NULL)) {  /* is in update orders    */
     m_send_frame_order_c( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   if (ADSL_OA1->adsc_gai1_sf == NULL) {    /* start of current frame  */
     m_send_frame_open( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
     return;
   } 
   
   // check, how much data is alread in frame
   iml1 = 0;                                /* clear counter           */
   adsl_gai1_w1 = ADSL_OA1->adsc_gai1_sf;   /* start of current frame  */
   do {                                     /* loop over all gather input */
     iml1 += adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
     adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain     */
   } while (adsl_gai1_w1);

   if(iml1 + 4 + 9 + 2 + 16 + 32 * 32 * 4 + 32 * 32 / 8 > 0x7FFF){
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
     m_send_frame_open( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_check_fastpath_frame()                                        */

static BOOL m_send_vch_out( struct dsd_call_rdpserv_1 *adsp_hl_clib_1,
                            struct dsd_output_area_1 *adsp_output_area_1,
                            struct dsd_sc_vch_out *adsp_sc_vch_out,
                            char *chrp_work ) {
   int        iml1, iml2;                   /* working-variables       */
   BOOL       bol1;                         /* working variable        */
// char       *achl1;                       /* working variable        */
   struct dsd_gather_i_1 *adsl_gai1_w1;     /* working-variable        */
   BOOL       bol_compressed;               /* compress output         */
   char       *achl_out_1;                  /* output-area             */
   char       *achl_out_start;              /* start of output-area    */
   int        iml_out_len;                  /* length output           */
   struct dsd_gather_i_1 *adsl_gai1_out_save;  /* output data          */
   struct dsd_aux_get_workarea dsl_aux_get_workarea;  /* acquire additional work area */
#ifdef HL_RDPACC_HELP_DEBUG
   struct dsd_rdpa_f *ADSL_RDPA_F;
   struct dsd_rdp_server_1 *D_ADSL_RSE1;
   struct dsd_rdp_co *D_ADSL_RCO1;          /* rdp communication server */
   struct dsd_output_area_1 *ADSL_OA1;
#endif

#ifndef HL_RDPACC_HELP_DEBUG
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext)
#define D_ADSL_RSE1 (&ADSL_RDPA_F->dsc_rdp_se_1)
#define D_ADSL_RCO1 (&D_ADSL_RSE1->dsc_rdp_co_1)
#define ADSL_OA1 adsp_output_area_1
#else
   ADSL_RDPA_F = (struct dsd_rdpa_f *) adsp_hl_clib_1->ac_ext;
   D_ADSL_RSE1 = &ADSL_RDPA_F->dsc_rdp_se_1;
   D_ADSL_RCO1 = &D_ADSL_RSE1->dsc_rdp_co_1;
   ADSL_OA1 = adsp_output_area_1;
#endif
   if (adsp_output_area_1->adsc_gai1_sf) {  /* start of current frame  */
     m_send_frame_close( adsp_hl_clib_1, adsp_output_area_1, chrp_work );
   }
   bol_compressed = FALSE;                  /* compress output         */
   if ((ADSL_OA1->achc_w2 - ADSL_OA1->achc_w1) < 128) {  /* get new area */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
   }
   ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
   if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
     return FALSE;                          /* program illogic         */
   }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
   ADSL_GAI1_OUT_G->adsc_next = NULL;
   if (ADSL_OA1->adsc_gai1_o1 == NULL) {
#ifndef NEW_WSP_1102
     adsp_hl_clib_1->adsc_gather_i_1_out = ADSL_GAI1_OUT_G;
#else
     adsp_hl_clib_1->adsc_gai1_out_to_client = ADSL_GAI1_OUT_G;  /* output data to client */
#endif
   } else {
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
   }
   ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one      */
   adsl_gai1_out_save = ADSL_GAI1_OUT_G;    /* save start output data  */
   /* compute where to start output                                    */
   achl_out_1 = ADSL_OA1->achc_w1 + 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 2 + 4 + D_SIZE_HASH + 4 + 2 + 2;
#undef ADSL_GAI1_OUT_G
   achl_out_start = achl_out_1;             /* save position start output */
   adsl_gai1_w1 = adsp_sc_vch_out->adsc_gai1_out;  /* output data      */
   iml_out_len = 0;                         /* clear length output     */
   if (bol_compressed) goto psend_vch_08;   /* send virtual channel data compressed */
   memset( achl_out_1 - 2, 0, 2 );          /* clear compression flags */
   while (TRUE) {
     iml1 = adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
     if (iml1 > (ADSL_OA1->achc_w2 - achl_out_1)) iml1 = ADSL_OA1->achc_w2 - achl_out_1;
     memcpy( achl_out_1, adsl_gai1_w1->achc_ginp_cur, iml1 );
     adsl_gai1_w1->achc_ginp_cur += iml1;
     achl_out_1 += iml1;
     iml_out_len += iml1;                   /* increment length output */
     if (adsl_gai1_w1->achc_ginp_cur >= adsl_gai1_w1->achc_ginp_end) {
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;
       if (adsl_gai1_w1 == NULL) {          /* already end of chain    */
         break;                             /* all data copied         */
       }
     }
     if (achl_out_1 < ADSL_OA1->achc_w2) continue;  /* still space in output-area */
     ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     /* get new block for more output                                  */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error        */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
#undef ADSL_GAI1_OUT_G
     achl_out_1 = ADSL_OA1->achc_w1;        /* here is next output     */
   }
   goto psend_vch_20;                       /* output finished         */

   psend_vch_08:                            /* send virtual channel data compressed */
   D_ADSL_RCO1->dsc_cdrf_enc.vpc_userfld = adsp_hl_clib_1->vpc_userfld;
   D_ADSL_RCO1->dsc_cdrf_enc.amc_aux = adsp_hl_clib_1->amc_aux;
   D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = NULL;
   D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = FALSE;  /* not yet end-of-record input */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_outa = achl_out_1 - 1;  /* address act output-data */
   D_ADSL_RCO1->dsc_cdrf_enc.achc_oute = ADSL_OA1->achc_w2;  /* end of this buffer */
   while (TRUE) {                           /* loop over gather input  */
     if (D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa >= D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe) {
       if (adsl_gai1_w1 == NULL) {          /* input exhausted         */
         break;                             /* end of input reached    */
       }
       D_ADSL_RCO1->dsc_cdrf_enc.achc_inpa = adsl_gai1_w1->achc_ginp_cur;
       iml1 = adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
       if (iml1 > (ADSL_OA1->achc_w2 - achl_out_1)) iml1 = ADSL_OA1->achc_w2 - achl_out_1;
       adsl_gai1_w1->achc_ginp_cur += iml1;
       D_ADSL_RCO1->dsc_cdrf_enc.achc_inpe = adsl_gai1_w1->achc_ginp_cur;
       if (adsl_gai1_w1->achc_ginp_cur >= adsl_gai1_w1->achc_ginp_end) {
         adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next in chain */
       }
     }
     if (adsl_gai1_w1 == NULL) {            /* end of input reached    */
       D_ADSL_RCO1->dsc_cdrf_enc.boc_mp_flush = TRUE;  /* end-of-record input */
     }
     m_cdr_enc( &D_ADSL_RCO1->dsc_cdrf_enc );
     if (D_ADSL_RCO1->dsc_cdrf_enc.imc_return != DEF_IRET_NORMAL) {
       m_sdh_printf( adsp_hl_clib_1, "xlrdpac1 l%05d s%05d compression error %d.",
                     __LINE__, 42459,  /* line number for errors */
                     D_ADSL_RCO1->dsc_cdrf_enc.imc_return );
       return FALSE;                        /* do cleanup now          */
     }
     iml_out_len += D_ADSL_RCO1->dsc_cdrf_enc.achc_outa - achl_out_1;
     achl_out_1 = D_ADSL_RCO1->dsc_cdrf_enc.achc_outa;  /* set end of output */
//   ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
//   ADSL_GAI1_OUT_G->achc_ginp_end = achl_out_1;  /* set end of output */
     if (achl_out_1 < ADSL_OA1->achc_w2) continue;  /* still space in output-area */
     ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;
     /* get new block for more output                                  */
     memset( &dsl_aux_get_workarea, 0, sizeof(struct dsd_aux_get_workarea) );  /* acquire additional work area */
     bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                        DEF_AUX_GET_WORKAREA,  /* get additional work area */
                                        &dsl_aux_get_workarea,
                                        sizeof(struct dsd_aux_get_workarea) );
     if (bol1 == FALSE) {                   /* aux returned error      */
       adsp_hl_clib_1->inc_return = DEF_IRET_ERRAU;  /* fatal error occured */
       return FALSE;                        /* do cleanup now          */
     }
     ADSL_OA1->achc_w1 = dsl_aux_get_workarea.achc_work_area;
     ADSL_OA1->achc_w2 = dsl_aux_get_workarea.achc_work_area + dsl_aux_get_workarea.imc_len_work_area;
     ADSL_OA1->achc_w2 -= sizeof(struct dsd_gather_i_1);
     if (ADSL_OA1->achc_w2 < ADSL_OA1->achc_w1) {
       return FALSE;                        /* program illogic         */
     }
#define ADSL_GAI1_OUT_G ((struct dsd_gather_i_1 *) ADSL_OA1->achc_w2)
     ADSL_GAI1_OUT_G->adsc_next = NULL;
     ADSL_GAI1_OUT_G->achc_ginp_cur = ADSL_OA1->achc_w1;
     ADSL_OA1->adsc_gai1_o1->adsc_next = ADSL_GAI1_OUT_G;
     ADSL_OA1->adsc_gai1_o1 = ADSL_GAI1_OUT_G;  /* this is last one    */
#undef ADSL_GAI1_OUT_G
     achl_out_1 = ADSL_OA1->achc_w1;        /* here is next output     */
   }
   /* output length compressed data                                    */
   *(achl_out_start - 2) = *(achl_out_start - 1);  /* copy compression header */
   *(achl_out_start - 1) = 0;               /* second byte compression header */
// iml_out_len -= 1;                        /* remove length compression header */

   psend_vch_20:                            /* output finished         */
   ADSL_OA1->achc_w1 = ADSL_OA1->adsc_gai1_o1->achc_ginp_end = achl_out_1;  /* set end of block */
   /* make header of output                                            */
   achl_out_start -= 4 + 2 + 2;             /* length uncompressed, segmentation flags and compression flags */
   m_put_le4( achl_out_start, adsp_sc_vch_out->umc_vch_ulen );
   memcpy( achl_out_start + 4, adsp_sc_vch_out->chrc_vch_segfl, sizeof(adsp_sc_vch_out->chrc_vch_segfl) );
   iml_out_len += 4 + 2 + 2;                /* add length output       */
   if ((ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl.imc_count_sent & (4096 - 1)) == 0){
     if (ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl.imc_count_sent) {
       m_update_keys( &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1, &ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl, NULL );
     }
   }
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     /* generate random                                                */
#define ACHL_WORK_SHA1 ((int *) chrp_work)
#define ACHL_WORK_MD5 ((int *) ((char *) ((char *) ACHL_WORK_SHA1 + SHA_ARRAY_SIZE * sizeof(int))))
#define ACHL_WORK_UTIL_01 ((char *) ACHL_WORK_MD5 + MD5_ARRAY_SIZE * sizeof(int))
     memcpy( ACHL_WORK_SHA1,
             ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imrc_sha1_state,
             sizeof(ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imrc_sha1_state) );
     memcpy( ACHL_WORK_MD5,
             ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imrc_md5_state,
             sizeof(ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imrc_md5_state) );
     m_put_le4( ACHL_WORK_UTIL_01, iml_out_len );
     SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
     adsl_gai1_out_save->achc_ginp_cur = achl_out_start;
     adsl_gai1_w1 = adsl_gai1_out_save;
     iml2 = iml_out_len;                    /* get length output       */
     while (TRUE) {                         /* loop over all gather structures input */
       iml1 = adsl_gai1_w1->achc_ginp_end - adsl_gai1_w1->achc_ginp_cur;
       if (iml1 > iml2) {
         iml1 = iml2;                       /* only data in this frame */
       }
       SHA1_Update( ACHL_WORK_SHA1,
                    adsl_gai1_w1->achc_ginp_cur,
                    0, iml1 );
       RC4( adsl_gai1_w1->achc_ginp_cur, 0, iml1,
            adsl_gai1_w1->achc_ginp_cur, 0,
            ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl.chrc_rc4_state );
       iml2 -= iml1;                        /* subtract data processed */
       if (iml2 <= 0) break;                /* all data processed      */
       adsl_gai1_w1 = adsl_gai1_w1->adsc_next;  /* get next gather     */
       if (adsl_gai1_w1 == NULL) {          /* already end of chain    */
         return FALSE;                      /* program illogic         */
       }
     }
//   if (D_ADSL_RCL1->chc_prot_rt03 & 0X08) {  /* flag for block count */
       m_put_le4( ACHL_WORK_UTIL_01, ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl.imc_count_sent );
       SHA1_Update( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0, 4 );
//   }
     SHA1_Final( ACHL_WORK_SHA1, ACHL_WORK_UTIL_01, 0 );
     MD5_Update( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0, 20 );
     MD5_Final( ACHL_WORK_MD5, ACHL_WORK_UTIL_01, 0 );
     achl_out_start -= D_SIZE_HASH;         /* subtract length hash    */
     memcpy( achl_out_start, ACHL_WORK_UTIL_01, D_SIZE_HASH );
     iml_out_len += D_SIZE_HASH;            /* add length hash         */
#undef ACHL_WORK_SHA1
#undef ACHL_WORK_MD5
#undef ACHL_WORK_UTIL_01
     ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.dsc_encry_se2cl.imc_count_sent++;  /* count block sent */
   }
   achl_out_start -= 1 + 2 + 2;             /* length length, fl2, fl3, padding */
// *(achl_out_start + 1 + 0) = D_ADSL_RCL1->chc_prot_rt02;
// *(achl_out_start + 1 + 1) = D_ADSL_RCL1->chc_prot_rt03;
   *(achl_out_start + 1 + 0) = 0;
   *(achl_out_start + 1 + 1) = 0;
   if (D_ADSL_RCO1->imc_sec_level > 1) {    /* with encryption         */
     *(achl_out_start + 1 + 0) = 0X08;
     *(achl_out_start + 1 + 1) = 0X08;
   }
   /* two bytes padding zero                                           */
   *(achl_out_start + 1 + 2 + 0) = 0;
   *(achl_out_start + 1 + 2 + 1) = 0;
   iml_out_len += 4;                        /* add length header       */
   *achl_out_start = (unsigned char) iml_out_len;  /* one byte length  */
   if (iml_out_len >= 0X0080) {             /* length in two bytes     */
     achl_out_start--;                      /* space for second byte   */
     m_put_be2( achl_out_start, iml_out_len );
     *achl_out_start |= 0X80;               /* flag length two bytes   */
     iml_out_len += 1;                      /* increment length        */
   }
   achl_out_start -= 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1;
   iml_out_len += 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2 + 1 + 1;
   adsl_gai1_out_save->achc_ginp_cur = achl_out_start;
   *achl_out_start = DEF_CONST_RDP_03;
   *(achl_out_start + 1) = 0;               /* second byte zero        */
   m_put_be2( achl_out_start + 2, iml_out_len );
   memcpy( achl_out_start + 4,
           ucrs_x224_p01,
           sizeof(ucrs_x224_p01) );
   *(achl_out_start + 4 + sizeof(ucrs_x224_p01)) = 0X68;  /* Send Data Indication */
   m_put_be2( achl_out_start + 4 + sizeof(ucrs_x224_p01) + 1, D_USERID_SE2CL );
   m_put_be2( achl_out_start + 4 + sizeof(ucrs_x224_p01) + 1 + 2, adsp_sc_vch_out->adsc_rdp_vc_1->usc_vch_no );
   *(achl_out_start + 4 + sizeof(ucrs_x224_p01) + 1 + 2 + 2) = (unsigned char) 0XF0;  /* priority / segmentation */
   return TRUE;                             /* all done                */
#ifndef HL_RDPACC_HELP_DEBUG
#undef D_ADSL_RSE1
#undef D_ADSL_RCO1
#undef ADSL_OA1
#undef ADSL_RDPA_F
#endif
} /* end m_send_vch_out()                                              */


static unsigned short int m_rop2_0_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return 0;                                /* R2_BLACK 0              */
}
static unsigned short int m_rop2_1_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return ~ (xxp_dest | xxp_pen);           /* R2_NOTMERGEPEN DPon     */
}
static unsigned short int m_rop2_2_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest & (~ xxp_pen);           /* R2_MASKNOTPEN DPna      */
}
static unsigned short int m_rop2_3_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return ~ xxp_pen;                        /* R2_NOTCOPYPEN Pn        */
}
static unsigned short int m_rop2_4_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return (~ xxp_dest) & xxp_pen;           /* R2_MASKPENNOT PDna      */
}
static unsigned short int m_rop2_5_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return ~ xxp_dest;                       /* R2_NOT Dn               */
}
static unsigned short int m_rop2_6_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest ^ xxp_pen;               /* R2_XORPEN DPx           */
}
static unsigned short int m_rop2_7_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return ~ (xxp_dest & xxp_pen);           /* R2_NOTMASKPEN DPan      */
}
static unsigned short int m_rop2_8_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest & xxp_pen;               /* R2_MASKPEN DPa          */
}
static unsigned short int m_rop2_9_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return ~ (xxp_dest ^ xxp_pen);           /* R2_NOTXORPEN DPxn       */
}
static unsigned short int m_rop2_a_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest;                         /* R2_NOP D                */
}
static unsigned short int m_rop2_b_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest | (~ xxp_pen);           /* R2_MERGENOTPEN DPno     */
}
static unsigned short int m_rop2_c_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_pen;                          /* R2_COPYPEN P            */
}
static unsigned short int m_rop2_d_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return (~ xxp_dest) | xxp_pen;           /* R2_MERGEPENNOT PDno     */
}
static unsigned short int m_rop2_e_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return xxp_dest | xxp_pen;               /* R2_MERGEPEN PDo         */
}
static unsigned short int m_rop2_f_s( unsigned short int xxp_dest, unsigned short int xxp_pen ) {
   return 0XFFFFFFFF;                       /* R2_WHITE 1              */
}
static unsigned int m_rop2_0_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return 0;                                /* R2_BLACK 0              */
}
static unsigned int m_rop2_1_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return ~ (xxp_dest | xxp_pen);           /* R2_NOTMERGEPEN DPon     */
}
static unsigned int m_rop2_2_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest & (~ xxp_pen);           /* R2_MASKNOTPEN DPna      */
}
static unsigned int m_rop2_3_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return ~ xxp_pen;                        /* R2_NOTCOPYPEN Pn        */
}
static unsigned int m_rop2_4_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return (~ xxp_dest) & xxp_pen;           /* R2_MASKPENNOT PDna      */
}
static unsigned int m_rop2_5_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return ~ xxp_dest;                       /* R2_NOT Dn               */
}
static unsigned int m_rop2_6_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest ^ xxp_pen;               /* R2_XORPEN DPx           */
}
static unsigned int m_rop2_7_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return ~ (xxp_dest & xxp_pen);           /* R2_NOTMASKPEN DPan      */
}
static unsigned int m_rop2_8_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest & xxp_pen;               /* R2_MASKPEN DPa          */
}
static unsigned int m_rop2_9_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return ~ (xxp_dest ^ xxp_pen);           /* R2_NOTXORPEN DPxn       */
}
static unsigned int m_rop2_a_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest;                         /* R2_NOP D                */
}
static unsigned int m_rop2_b_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest | (~ xxp_pen);           /* R2_MERGENOTPEN DPno     */
}
static unsigned int m_rop2_c_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_pen;                          /* R2_COPYPEN P            */
}
static unsigned int m_rop2_d_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return (~ xxp_dest) | xxp_pen;           /* R2_MERGEPENNOT PDno     */
}
static unsigned int m_rop2_e_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return xxp_dest | xxp_pen;               /* R2_MERGEPEN PDo         */
}
static unsigned int m_rop2_f_24oi( unsigned int xxp_dest, unsigned int xxp_pen ) {
   return 0XFFFFFFFF;                       /* R2_WHITE 1              */
}

/* input two bytes little endian                                       */
static inline short int m_get_le2( char *achp_source ) {
   return *((unsigned char *) achp_source)
            | (*((unsigned char *) achp_source + 1) << 8);
}

/* input four bytes little endian                                      */
static inline int m_get_le4( char *achp_source ) {
   return *((unsigned char *) achp_source)
            | (*((unsigned char *) achp_source + 1) << 8)
            | (*((unsigned char *) achp_source + 2) << 16)
            | (*((unsigned char *) achp_source + 3) << 24);
}

/* output two bytes little endian                                      */
static inline void m_put_le2( char *achp_target, int imp1 ) {
   *((unsigned char *) achp_target) = (unsigned char) imp1;
   *((unsigned char *) achp_target + 1) = (unsigned char) (imp1 >> 8);
}

/* output four bytes little endian                                     */
static inline void m_put_le4( char *achp_target, int imp1 ) {
   *((unsigned char *) achp_target) = (unsigned char) imp1;
   *((unsigned char *) achp_target + 1) = (unsigned char) (imp1 >> 8);
   *((unsigned char *) achp_target + 2) = (unsigned char) (imp1 >> 16);
   *((unsigned char *) achp_target + 3) = (unsigned char) (imp1 >> 24);
}

/* output two bytes big endian                                         */
static inline void m_put_be2( char *achp_target, int imp1 ) {
   *((unsigned char *) achp_target) = (unsigned char) (imp1 >> 8);
   *((unsigned char *) achp_target + 1) = (unsigned char) imp1;
}
static inline BOOL m_gather_skip( dsd_gather_i_1** aads_gather, int im_skip, int* aim_counter ){
   if(*aim_counter < im_skip)
      return FALSE;
   *aim_counter -= im_skip;

   while(im_skip > 0){
     int im1 = (*aads_gather)->achc_ginp_end - (*aads_gather)->achc_ginp_cur;
     if(im1 <= 0){
       *aads_gather = (*aads_gather)->adsc_next;
       if(*aads_gather != NULL)
         continue;
       /* not enough data available */
       return FALSE;
     }
     if(im1 > im_skip)
       im1 = im_skip;
     (*aads_gather)->achc_ginp_cur += im1;
     im_skip -= im1;
   }
   return TRUE;
}
static inline BOOL m_gather_get_byte( dsd_gather_i_1** aads_gather, int* aim_counter, char* ach_retval){
   if(*aim_counter < 1)
     return FALSE;
   (*aim_counter)--;
   while(TRUE){
     if(*aads_gather == NULL)
       return FALSE;
     if((*aads_gather)->achc_ginp_cur < (*aads_gather)->achc_ginp_end)
       break;
     *aads_gather = (*aads_gather)->adsc_next;
   }
   *ach_retval = *(*aads_gather)->achc_ginp_cur++;
   return TRUE;
}

static inline BOOL m_gather_get_le( dsd_gather_i_1** aads_gather, int im_bytes, int* aim_counter, int* aim_retval ){
   if(*aim_counter < im_bytes)
      return FALSE;

   *aim_retval = 0;
   int im_shift = 0;
   while(im_bytes > 0){
     char ch_byte;
     if(m_gather_get_byte(aads_gather, aim_counter, &ch_byte) == FALSE)
       return FALSE;

     *aim_retval |= ((unsigned char) ch_byte) << im_shift;
     im_bytes--;
     im_shift += 8;

   }
   return TRUE;
}
static inline BOOL m_gather_get_hasn( dsd_gather_i_1** aads_gather, int* aim_counter, int* aim_retval ){
   *aim_retval = 0;
   while(*aim_counter > 0){
     char ch_byte;
     if(m_gather_get_byte(aads_gather, aim_counter, &ch_byte) == FALSE)
       return FALSE;
     *aim_retval |= ch_byte & 0x7f;
     if((ch_byte & 0X80) == 0)
       return TRUE;
     *aim_retval <<= 7;
   }
   return FALSE;
}

#ifdef D_CONSOLE_OUT
static void m_console_out( char *achp_buff, int implength ) {
   int        iml1, iml2, iml3, iml4, iml5, iml6;  /* working variable */
   char       byl1;                         /* working-variable        */
   char       chrlwork1[ 76 ];              /* buffer to print         */

   iml1 = 0;
   while (iml1 < implength) {
     iml2 = iml1 + 16;
     if (iml2 > implength) iml2 = implength;
     for ( iml3 = 4; iml3 < 75; iml3++ ) {
       chrlwork1[iml3] = ' ';
     }
     chrlwork1[58] = '*';
     chrlwork1[75] = '*';
     iml3 = 4;
     do {
       iml3--;
       chrlwork1[ iml3 ] = chrstrans[ (iml1 >> ((4 - 1 - iml3) << 2)) & 0X0F ];
     } while (iml3 > 0);
     iml4 = 6;                              /* start hexa digits here  */
     iml5 = 59;                             /* start ASCII here        */
     iml6 = 4;                              /* times normal            */
     do {
       byl1 = achp_buff[ iml1++ ];
       chrlwork1[ iml4++ ] = chrstrans[ (byl1 >> 4) & 0X0F ];
       chrlwork1[ iml4++ ] = chrstrans[ byl1 & 0X0F ];
       iml4++;
       if (byl1 > 0X20) {
         chrlwork1[ iml5 ] = byl1;
       }
       iml5++;
       iml6--;
       if (iml6 == 0) {
         iml4++;
         iml6 = 4;
       }
     } while (iml1 < iml2);
     printf( "%.*s\n", sizeof(chrlwork1), chrlwork1 );
   }
   fflush( stdout );
} /* end m_console_out()                                            */
#endif

/* compare entries in AVL tree of Glyphs                               */
static int m_avl_cmp_unicode_char( void *,
                                   struct dsd_htree1_avl_entry *adsp_entry_1,
                                   struct dsd_htree1_avl_entry *adsp_entry_2 ) {
#define ADSL_FO_GL_AVL_P1 ((struct dsd_fo_gl_avl *) ((char *) adsp_entry_1 - offsetof( struct dsd_fo_gl_avl, dsc_avl_e )))
#define ADSL_FO_GL_AVL_P2 ((struct dsd_fo_gl_avl *) ((char *) adsp_entry_2 - offsetof( struct dsd_fo_gl_avl, dsc_avl_e )))
   return ADSL_FO_GL_AVL_P1->imc_unicode - ADSL_FO_GL_AVL_P2->imc_unicode;
#undef ADSL_FO_GL_AVL_P1
#undef ADSL_FO_GL_AVL_P2
} /* end m_avl_cmp_unicode_char()                                      */

/* get storage for a glyph                                             */
static struct dsd_glyph * m_cr_getstorglyph( void *vpp_userfld, int imp_need_bytes ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1, iml2, iml3;             /* working variables       */
// struct dsd_arr_glyph_e *adsl_arr_glyph_e_w1;  /* array of glyph entries */
   struct dsd_glyph *adsl_glyph_w1;
   struct dsd_fo_gl_avl dsl_fo_gl_avl;      /* for AVL tree            */
   struct dsd_htree1_avl_work dsl_htree1_work;  /* work-area for AVL-Tree */

#define ADSL_CR_GETSTORGLYPH ((struct dsd_cr_getstorglyph *) vpp_userfld)  /* pass parameters get storage glyph */
#define ADSL_RDPA_F ((struct dsd_rdpa_f *) ADSL_CR_GETSTORGLYPH->adsc_hl_clib_1->ac_ext)  /* rdp accelerator frame */
#define ADSRL_ARR_GLYPH_E ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e
// adsl_arr_glyph_e_w1 = ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.adsrc_arr_glyph_e;
   iml1 = 0;                                /* clear index             */
   while (TRUE) {
     if (iml1 >= ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_no_arr_glyph_e) {  /* number of arrays of glyph entries */
       return NULL;                         /* needs more bytes than biggest cache entry */
     }
     if (imp_need_bytes <= ADSRL_ARR_GLYPH_E[ iml1 ].usc_len_store) {  /* length of storage in bytes */
       break;                               /* cache entry found       */
     }
     iml1++;                                /* increment index         */
   }
   if (ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_deleted > 0) {  /* number of deleted */
     goto p_reuse_00;                       /* reuse deleted entry     */
   }
   if (ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_filled < ADSRL_ARR_GLYPH_E[ iml1 ].usc_no_entries) {  /* number of entries */
     goto p_new_entry;                      /* make new entry          */
   }
   iml2 = iml1 + 1;                         /* get index               */
   while (   (iml2 < ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.imc_no_arr_glyph_e)  /* number of arrays of glyph entries */
          && (ADSRL_ARR_GLYPH_E[ iml2 ].usc_len_store == ADSRL_ARR_GLYPH_E[ iml1 ].usc_len_store)) {
     if (ADSRL_ARR_GLYPH_E[ iml2 ].usc_entries_deleted > 0) {  /* number of deleted */
       iml1 = iml2;                         /* take this entry         */
       goto p_reuse_00;                     /* reuse deleted entry     */
     }
     if (ADSRL_ARR_GLYPH_E[ iml2 ].usc_entries_filled < ADSRL_ARR_GLYPH_E[ iml2 ].usc_no_entries) {  /* number of entries */
       iml1 = iml2;                         /* take this entry         */
       goto p_new_entry;                    /* make new entry          */
     }
     iml2++;                                /* increment index         */
   }
   /* an old entry must be reused                                      */
   iml3 = iml1 + 1;                         /* get index               */
   while (iml3 < iml2) {                    /* for all array with same length */
     if (ADSRL_ARR_GLYPH_E[ iml3 ].adsc_glyph_first->umc_count_glyph_alloc
           < ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first->umc_count_glyph_alloc) {
       iml1 = iml3;                         /* entry is older          */
     }
     iml3++;                                /* increment index         */
   }
   adsl_glyph_w1 = ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first;  /* reuse this glyph */
   ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first = adsl_glyph_w1->adsc_rem_ch_next;  /* first glyph in chain */
   if (ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first) {  /* is not last entry */
     adsl_glyph_w1->adsc_rem_ch_next->adsc_rem_ch_prev = NULL;  /* first glyph in chain */
   }
   memset( &dsl_fo_gl_avl, 0, sizeof(struct dsd_fo_gl_avl) );  /* for AVL tree */
   dsl_fo_gl_avl.imc_unicode = adsl_glyph_w1->dsc_fo_gl_avl.imc_unicode;  /* UTF-32 of character */
   bol1 = m_htree1_avl_search( NULL, &adsl_glyph_w1->adsc_font->dsc_htree1_avl_fo_gl,
                               &dsl_htree1_work, &dsl_fo_gl_avl.dsc_avl_e );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( ADSL_CR_GETSTORGLYPH->adsc_hl_clib_1, "xlrdpac1 l%05d s%05d m_cr_getstorglyph() m_htree1_avl_search() failed",
                   __LINE__, 43324);  /* line number for errors */
     return NULL;
   }
   if (dsl_htree1_work.adsc_found == NULL) return NULL;  /* program illogic */
   bol1 = m_htree1_avl_delete( NULL, &adsl_glyph_w1->adsc_font->dsc_htree1_avl_fo_gl,
                               &dsl_htree1_work );
   if (bol1 == FALSE) {                     /* error occured           */
     m_sdh_printf( ADSL_CR_GETSTORGLYPH->adsc_hl_clib_1, "xlrdpac1 l%05d s%05d m_cr_getstorglyph() m_htree1_avl_delete() failed",
                   __LINE__, 43332);  /* line number for errors */
     return NULL;
   }
   if (adsl_glyph_w1->adsc_font == ADSL_CR_GETSTORGLYPH->adsc_font) {  /* compare font */
     ADSL_CR_GETSTORGLYPH->boc_sort = TRUE;  /* sort sequence destroyed */
   }
   adsl_glyph_w1->adsc_rem_ch_next = NULL;  /* is last entry now       */
   goto p_final_00;                         /* do final things         */

   p_reuse_00:                              /* reuse deleted entry     */
   adsl_glyph_w1 = ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first;  /* first glyph in chain */
   while (TRUE) {
     if (adsl_glyph_w1 == NULL) return NULL;  /* did not find deleted entry, program illogic */
     if (adsl_glyph_w1->adsc_font == NULL) break;  /* entry found      */
     adsl_glyph_w1 = adsl_glyph_w1->adsc_rem_ch_next;  /* next in remove chain */
   }
   if (adsl_glyph_w1->adsc_rem_ch_prev == NULL) {
     ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first = adsl_glyph_w1->adsc_rem_ch_next;  /* first glyph in chain */
   } else {
     adsl_glyph_w1->adsc_rem_ch_prev->adsc_rem_ch_next = adsl_glyph_w1->adsc_rem_ch_next;
   }
   if (adsl_glyph_w1->adsc_rem_ch_next == NULL) {
     ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_last = adsl_glyph_w1->adsc_rem_ch_prev;  /* last glyph in chain */
   } else {
     adsl_glyph_w1->adsc_rem_ch_next->adsc_rem_ch_prev = adsl_glyph_w1->adsc_rem_ch_prev;
   }
   ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_deleted--;  /* number of filled deleted */
   adsl_glyph_w1->adsc_rem_ch_next = NULL;  /* is last entry now       */
   goto p_final_00;                         /* do final things         */

   p_new_entry:                             /* make new entry          */
   adsl_glyph_w1 = (struct dsd_glyph *) m_aux_stor_alloc( &ADSL_RDPA_F->dsc_stor_sdh_1,
                                                          sizeof(struct dsd_glyph)
                                                            + ADSRL_ARR_GLYPH_E[ iml1 ].usc_len_store );
   memset( adsl_glyph_w1, 0, sizeof(struct dsd_glyph) );
   adsl_glyph_w1->ucc_arr_glyph_e = iml1;   /* array glyph entry       */
   adsl_glyph_w1->ucc_char_inc = ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_filled;  /* character index */
   ADSRL_ARR_GLYPH_E[ iml1 ].usc_entries_filled++;  /* number of filled entries */

   p_final_00:                              /* do final things         */
   adsl_glyph_w1->adsc_font = ADSL_CR_GETSTORGLYPH->adsc_font;  /* set font */
   adsl_glyph_w1->umc_count_glyph_alloc = ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.umc_count_glyph_alloc;  /* count glyph allocs */
   ADSL_RDPA_F->dsc_rdp_se_1.dsc_rdp_co_1.umc_count_glyph_alloc++;  /* count glyph allocs */
   adsl_glyph_w1->adsc_rem_ch_prev = ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_last;  /* last glyph in chain */
   if (ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first == NULL) {  /* first glyph in chain */
     ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_first = adsl_glyph_w1;  /* set first glyph in chain */
   } else {
     ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_last->adsc_rem_ch_next = adsl_glyph_w1;  /* append to chain */
   }
   ADSRL_ARR_GLYPH_E[ iml1 ].adsc_glyph_last = adsl_glyph_w1;  /* last glyph in chain */
   return adsl_glyph_w1;
#undef ADSL_CR_GETSTORGLYPH
#undef ADSL_RDPA_F
#undef ADSRL_ARR_GLYPH_E
} /* end m_cr_getstorglyph()                                           */

/* subroutine for output to console                                    */
static int m_sdh_printf( struct dsd_call_rdpserv_1 *adsp_hl_clib_1, char *achptext, ... ) {
   BOOL       bol1;                         /* working variable        */
   int        iml1;                         /* working variable        */
   va_list    dsl_argptr;
   char       chrl_out1[512];

   va_start( dsl_argptr, achptext );
   iml1 = vsnprintf( chrl_out1, sizeof(chrl_out1), achptext, dsl_argptr );
   va_end( dsl_argptr );
   bol1 = (*adsp_hl_clib_1->amc_aux)( adsp_hl_clib_1->vpc_userfld,
                                      DEF_AUX_CONSOLE_OUT,  /* output to console */
                                      chrl_out1, iml1 );
   return iml1;
} /* end m_sdh_printf()                                                */



static char * m_ret_t_ied_fcfp_bl( ied_fcfp_bl iel_fcfp_bl ) {
   switch (iel_fcfp_bl) {
     case ied_fcfp_invalid:                 /* invalid data received   */
       return "ied_fcfp_invalid";
     case ied_fcfp_constant:                /* is in constant          */
       return "ied_fcfp_constant";
     case ied_fcfp_x224_p01:                /* is in x224 header       */
       return "ied_fcfp_x224_p01";
     case ied_fcfp_ignore:                  /* ignore data             */
       return "ied_fcfp_ignore";
     case ied_fcfp_copy_normal:             /* copy data normal        */
       return "ied_fcfp_copy_normal";
     case ied_fcfp_copy_invers:             /* copy data invers        */
       return "ied_fcfp_copy_invers";
     case ied_fcfp_rdp5_rc4:                /* input RC4 encrypted     */
       return "ied_fcfp_rdp5_rc4";
     case ied_fcfp_rec_type:                /* receive record type     */
       return "ied_fcfp_rec_type";
     case ied_fcfp_byte01:                  /* receive byte 01         */
       return "ied_fcfp_byte01";
     case ied_fcfp_lencons_2:               /* two bytes length remain */
       return "ied_fcfp_lencons_2";
     case ied_fcfp_lencons_1:               /* one byte length remains */
       return "ied_fcfp_lencons_1";
     case ied_fcfp_rdp5_len1:               /* RDP5 input length 1     */
       return "ied_fcfp_rdp5_len1";
     case ied_fcfp_rdp5_len2:               /* RDP5 input length 2     */
       return "ied_fcfp_rdp5_len2";
     case ied_fcfp_mcs_c1:                  /* x224 MCS command 1      */
       return "ied_fcfp_mcs_c1";
     case ied_fcfp_userid:                  /* userid communication    */
       return "ied_fcfp_userid";
     case ied_fcfp_chno:                    /* receive channel no      */
       return "ied_fcfp_chno";
     case ied_fcfp_prio_seg:                /* Priority / Segmentation */
       return "ied_fcfp_prio_seg";
     case ied_fcfp_rt02:                    /* record type 2           */
       return "ied_fcfp_rt02";
     case ied_fcfp_rt03:                    /* record type 3           */
       return "ied_fcfp_rt03";
     case ied_fcfp_padd_1:                  /* padding                 */
       return "ied_fcfp_padd_1";
     case ied_fcfp_data_pdu_1:              /* RDP4 data PDU follows   */
       return "ied_fcfp_data_pdu_1";
     case ied_fcfp_asn1_tag:                /* ASN.1 tag follows       */
       return "ied_fcfp_asn1_tag";
     case ied_fcfp_asn1_l1_fi:              /* ASN.1 length field      */
       return "ied_fcfp_asn1_l1_fi";
     case ied_fcfp_asn1_l1_p2:              /* ASN.1 length part two   */
       return "ied_fcfp_asn1_l1_p2";
     case ied_fcfp_mu_len_1:                /* multi length 1          */
       return "ied_fcfp_mu_len_1";
     case ied_fcfp_mu_len_2:                /* multi length 2          */
       return "ied_fcfp_mu_len_2";
     case ied_fcfp_int_lit_e:               /* int little endian       */
       return "ied_fcfp_int_lit_e";
     case ied_fcfp_int_big_e:               /* int big endian          */
       return "ied_fcfp_int_big_e";
     case ied_fcfp_end_com:                 /* end of communication    */
       return "ied_fcfp_end_com";
     case ied_fcfp_no_session:              /* no more session         */
       return "ied_fcfp_no_session";
   }
   return "-undef-";
}  /* end m_ret_t_ied_fcfp_bl()                                        */


static char * m_ret_t_ied_frcl_bl( ied_frcl_bl iel_frcl_bl ) {
   switch (iel_frcl_bl) {
     case ied_frcl_start:                   /* start of communication  */
       return "ied_frcl_start";
     case ied_frcl_rec_02:                  /* receive block 2         */
       return "ied_frcl_rec_02";
     case ied_frcl_r02_x224mcs:             /* proc bl 2 X.224 MCS     */
       return "ied_frcl_r02_x224mcs";
     case ied_frcl_r02_mcscoen:             /* b2 MCS connect encoding */
       return "ied_frcl_r02_mcscoen";
     case ied_frcl_r02_mc_cids:             /* b2 MC Calling Domain Selector */
       return "ied_frcl_r02_mc_cids";
     case ied_frcl_r02_mc_ceds:             /* b2 MC Called Domain Selector */
       return "ied_frcl_r02_mc_ceds";
     case ied_frcl_r02_mc_upwf:             /* b2 MC Upward Flag       */
       return "ied_frcl_r02_mc_upwf";
     case ied_frcl_r02_mc_tdop:             /* b2 MC Target Domain Parameters */
       return "ied_frcl_r02_mc_tdop";
     case ied_frcl_r02_mc_midp:             /* b2 MC Minimum Domain Parameters */
       return "ied_frcl_r02_mc_midp";
     case ied_frcl_r02_mc_madp:             /* b2 MC Maximum Domain Parameters */
       return "ied_frcl_r02_mc_madp";
     case ied_frcl_r02_mc_usd1:             /* b2 MC User Data Start   */
       return "ied_frcl_r02_mc_usd1";
     case ied_frcl_r02_mcud_l1:             /* b2 MC Us-Da length 1    */
       return "ied_frcl_r02_mcud_l1";
     case ied_frcl_r02_fietype:             /* b2 MC Field Type        */
       return "ied_frcl_r02_fietype";
     case ied_frcl_r02_fielen:              /* b2 MC Field Length      */
       return "ied_frcl_r02_fielen";
     case ied_frcl_r02_mcud_c01:            /* b2 MC Us-Da const 01    */
       return "ied_frcl_r02_mcud_c01";
     case ied_frcl_r02_mcud_scw:            /* b2 MC Us-Da scr width   */
       return "ied_frcl_r02_mcud_scw";
     case ied_frcl_r02_mcud_sch:            /* b2 MC Us-Da scr height  */
       return "ied_frcl_r02_mcud_sch";
     case ied_frcl_r02_mcud_c02:            /* b2 MC Us-Da const 02    */
       return "ied_frcl_r02_mcud_c02";
     case ied_frcl_r02_mcud_kbl:            /* b2 MC Us-Da Keyboard La */
       return "ied_frcl_r02_mcud_kbl";
     case ied_frcl_r02_mcud_bun:            /* b2 MC Us-Da Build Numb  */
       return "ied_frcl_r02_mcud_bun";
     case ied_frcl_r02_mcud_con:            /* b2 MC Us-Da Computer Na */
       return "ied_frcl_r02_mcud_con";
     case ied_frcl_r02_mcud_kbt:            /* b2 MC Us-Da Keyboard Ty */
       return "ied_frcl_r02_mcud_kbt";
     case ied_frcl_r02_mcud_kbs:            /* b2 MC Us-Da Keyboard ST */
       return "ied_frcl_r02_mcud_kbs";
     case ied_frcl_r02_mcud_nfk:            /* b2 MC Us-Da No Func Key */
       return "ied_frcl_r02_mcud_nfk";
     case ied_frcl_r02_mcud_ime:            /* b2 MC Us-Da IME Keyb ma */
       return "ied_frcl_r02_mcud_ime";
     case ied_frcl_r02_mcud_c03:            /* b2 MC Us-Da const 03    */
       return "ied_frcl_r02_mcud_c03";
     case ied_frcl_r02_mcud_pv1:            /* b2 MC Us-Da protocol ve */
       return "ied_frcl_r02_mcud_pv1";
     case ied_frcl_r02_mcud_cod:            /* b2 MC Us-Da Color Depth */
       return "ied_frcl_r02_mcud_cod";
     case ied_frcl_r02_mcud_nvc:            /* b2 MC Us-Da no virt ch  */
       return "ied_frcl_r02_mcud_nvc";
     case ied_frcl_r02_mcud_vcn:            /* b2 MC Us-Da virt ch nam */
       return "ied_frcl_r02_mcud_vcn";
     case ied_frcl_r02_mcud_vcf:            /* b2 MC Us-Da virt ch fla */
       return "ied_frcl_r02_mcud_vcf";
     case ied_frcl_rdp5_inp:                /* RDP5-style input data   */
       return "ied_frcl_rdp5_inp";
     case ied_frcl_pdu_type_1_l:            /* get RDP4 PDU type       */
       return "ied_frcl_pdu_type_1_l";
     case ied_frcl_pdu_type_1_t:            /* get RDP4 PDU type       */
       return "ied_frcl_pdu_type_1_t";
     case ied_frcl_data_pdu_1:              /* RDP4 data PDU follows   */
       return "ied_frcl_data_pdu_1";
     case ied_frcl_data_pdu_end:            /* RDP4 data PDU end       */
       return "ied_frcl_data_pdu_end";
     case ied_frcl_rec_05:                  /* receive block 5         */
       return "ied_frcl_rec_05";
     case ied_frcl_rec_06:                  /* receive block 6         */
       return "ied_frcl_rec_06";
     case ied_frcl_cjreq_rec:               /* receive block channel join request */
       return "ied_frcl_cjreq_rec";
     case ied_frcl_clrand_rec:   /* ??? */  /* receive client random   */
       return "ied_frcl_clrand_rec";
     case ied_frcl_client_rand:             /* receive client random   */
       return "ied_frcl_client_rand";
     case ied_frcl_c_logon_info_1:          /* logon information 1     */
       return "ied_frcl_c_logon_info_1";
     case ied_frcl_c_loinf_options:         /* Options                 */
       return "ied_frcl_c_loinf_options";
     case ied_frcl_c_loinf_domna_len:       /* Domain Name Length      */
       return "ied_frcl_c_loinf_domna_len";
     case ied_frcl_c_loinf_userna_len:      /* User Name Length        */
       return "ied_frcl_c_loinf_userna_len";
     case ied_frcl_c_loinf_pwd_len:         /* Password Length         */
       return "ied_frcl_c_loinf_pwd_len";
     case ied_frcl_c_loinf_altsh_len:       /* Alt Shell Length        */
       return "ied_frcl_c_loinf_altsh_len";
     case ied_frcl_c_loinf_wodir_len:       /* Working Directory Length */
       return "ied_frcl_c_loinf_wodir_len";
     case ied_frcl_c_loinf_domna_val:       /* Domain Name String      */
       return "ied_frcl_c_loinf_domna_val";
     case ied_frcl_c_loinf_userna_val:      /* User Name String        */
       return "ied_frcl_c_loinf_userna_val";
     case ied_frcl_c_loinf_pwd_val:         /* Password String         */
       return "ied_frcl_c_loinf_pwd_val";
     case ied_frcl_c_loinf_altsh_val:        /* Alt Shell String        */
       return "ied_frcl_c_loinf_altsh_val";
     case ied_frcl_c_loinf_wodir_val:       /* Working Directory String */
       return "ied_frcl_c_loinf_wodir_val";
     case ied_frcl_c_loinf_no_a_par:        /* number of additional parameters */
       return "ied_frcl_c_loinf_no_a_par";
     case ied_frcl_c_loinf_ineta:           /* INETA                   */
       return "ied_frcl_c_loinf_ineta";
     case ied_frcl_c_loinf_path:            /* Client Path             */
       return "ied_frcl_c_loinf_path";
     case ied_frcl_c_loinf_extra:           /* Extra Parameters        */
       return "ied_frcl_c_loinf_extra";
     case ied_frcl_resp_act_pdu_rec:        /* response block active PDU */
       return "ied_frcl_resp_act_pdu_rec";
     case ied_frcl_rdp4_vch_ulen:           /* virtual channel uncompressed data length */
       return "ied_frcl_rdp4_vch_ulen";
     case ied_frcl_rec_xyz_01:              /* ?????nse block active PDU */
       return "ied_frcl_rec_xyz_01";
   }
   return "-undef-";
}  /* end m_ret_t_ied_frcl_bl()                                        */

//cend;
